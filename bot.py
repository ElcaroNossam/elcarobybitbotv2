import os
import re
import time
import datetime
import hmac
import json
import hashlib
import asyncio 
import logging
import db  
import math
import feedparser
from pathlib import Path
from urllib.parse import quote
import aiohttp
import html
import importlib
import functools
import contextlib
from dotenv import load_dotenv
load_dotenv()
from zoneinfo import ZoneInfo
from math import floor

# Unified models and functions (NEW ARCHITECTURE)
try:
    from models import Position, Order, Balance, OrderSide, OrderType, normalize_symbol
    from bot_unified import (
        get_balance_unified, get_positions_unified, 
        place_order_unified, close_position_unified, set_leverage_unified
    )
    from exchange_router import get_user_targets, Target, normalize_env
    UNIFIED_AVAILABLE = True
except ImportError as e:
    # logger not available yet at import time
    print(f"[WARNING] Unified models not available: {e}")
    UNIFIED_AVAILABLE = False
    # Fallback empty implementations
    def get_user_targets(uid): return []
    Target = None
    normalize_env = lambda x: x

from telegram.error import TimedOut as TgTimedOut, NetworkError, BadRequest
from telegram.request import HTTPXRequest
from urllib.parse import urlencode
from html import unescape
from functools import wraps

from aiohttp import ClientSession, ClientTimeout, TCPConnector
from telegram import Update, ReplyKeyboardMarkup, InlineKeyboardMarkup, InlineKeyboardButton, InputFile, WebAppInfo, MenuButtonWebApp, MenuButtonDefault, MenuButtonCommands, BotCommand
from keyboard_helpers import (
    btn_back, btn_close, btn_cancel, btn_confirm, btn_refresh, btn_settings,
    btn_yes, btn_no, btn_toggle, btn_section, btn_divider,
    btn_prev, btn_next, btn_page_info,
    build_keyboard, build_paginated_keyboard, build_confirm_dialog,
    chunk_buttons, make_url_button, make_webapp_button
)
from user_guide import get_user_guide_pdf
from hl_adapter import HLAdapter
from services.notification_service import init_notification_service
from services.notification_service import init_notification_service
from db import (
    get_subscribed_users,
    get_user_config,
    get_user_field,  # Added for API settings
    # HyperLiquid functions
    get_hl_credentials,
    set_hl_credentials,
    clear_hl_credentials,
    set_hl_enabled,
    is_hl_enabled,
    # Bybit enable/disable
    is_bybit_enabled,
    set_bybit_enabled,
    get_exchange_mode,
    set_exchange_mode,
    get_exchange_type,
    set_exchange_type,
    get_exchange_status,
    set_user_field,
    reset_pyramid,
    get_all_pyramided_symbols,
    add_active_position,
    remove_active_position,
    get_user_credentials,
    set_user_credentials,
    get_all_user_credentials,
    set_trading_mode,
    get_trading_mode,
    get_effective_trading_mode,
    get_active_account_types,
    get_strategy_account_types,
    get_user_trading_context,
    normalize_account_type,
    delete_user_credentials,
    get_active_positions,
    get_execution_targets,
    get_live_enabled,
    set_live_enabled,
    get_routing_policy,
    set_routing_policy,
    RoutingPolicy,
    add_trade_log,
    inc_pyramid,
    get_pyramid,
    get_prev_btc_dom,
    store_prev_btc_dom,
    save_market_snapshot,
    store_news,
    get_all_users,
    get_active_trading_users,
    get_last_signal_id,
    get_last_signal_by_symbol_in_raw,
    fetch_signal_by_id,
    add_pending_limit_order,
    get_pending_limit_orders,
    remove_pending_limit_order,
    set_dca_flag,
    get_dca_flag,
    set_ptp_flag,
    get_ptp_flag,
    get_trade_stats,
    get_stats_by_strategy,
    was_position_recently_closed,
    get_rolling_24h_pnl,
    # License functions
    get_user_license,
    set_user_license,
    extend_license,
    revoke_license,
    check_license_access,
    can_trade_strategy,
    get_allowed_strategies,
    create_promo_code,
    use_promo_code,
    get_promo_codes,
    deactivate_promo_code,
    get_user_payments,
    get_license_history,
    get_all_active_licenses,
    get_expiring_licenses,
    LICENSE_TYPES,
    LICENSE_PERIODS,
    # License request functions (admin approval)
    create_license_request,
    get_pending_license_requests,
    get_license_request,
    approve_license_request,
    reject_license_request,
    get_user_license_requests,
    get_license_request_stats,
    # Admin functions
    get_user_full_info,
    get_users_paginated,
    search_user_by_id,
    ban_user,
    allow_user,
    delete_user,
    update_position_strategy,
    update_position_sltp,  # Save SL/TP prices to DB after exchange update
    # Admin reports
    get_global_trade_stats,
    get_global_stats_by_strategy,
    get_all_payments,
    get_payment_stats,
    get_top_traders,
    get_user_usage_report,
)

# ENLIKO Token functions
from db_elcaro import (
    get_elc_balance,
    check_elc_balance,
    subtract_elc_balance,
    add_elc_balance,
    get_user_transactions as get_elc_transactions,
)

# License Blockchain Service
from services.license_blockchain_service import (
    purchase_license_with_elc,
    get_user_blockchain_licenses,
    get_user_license_nfts,
    verify_license_on_blockchain,
    get_blockchain_license_stats,
    calculate_final_price,
    admin_mint_license_nft,
    admin_revoke_nft,
    get_all_license_nfts,
    sync_database_to_blockchain,
    LicenseNFTTier,
)

from telegram.ext import (
    Application,
    ApplicationBuilder,
    ConversationHandler,
    CommandHandler,
    CallbackQueryHandler,
    MessageHandler,
    PreCheckoutQueryHandler,
    filters,
    ContextTypes,
)

from coin_params import (
    COIN_PARAMS,
    DEFAULT_SL_PCT,
    DEFAULT_TP_PCT,
    POSITIVE_KEYWORDS,
    NEGATIVE_KEYWORDS,
    SYMBOL_FILTER,
    ADMIN_ID,
    GLOBAL_PAUSED,
    TIMEFRAME_PARAMS,
    DEFAULT_LANG,
    MAX_OPEN_POSITIONS,
    MAX_LIMIT_ORDERS,
    BLACKLIST,
    ORDER_TYPE, 
    ORDER_PARAMS,
    CHECK_INTERVAL
)

# Configure root logger to catch all module logs (exchanges, core, etc.)
logging.basicConfig(
    level=logging.INFO,
    format="%(asctime)s [%(levelname)s] %(message)s",
    handlers=[]  # We'll add handlers below
)

logger = logging.getLogger(__name__)
logger.setLevel(logging.INFO)

# Also configure exchanges module logger
exchanges_logger = logging.getLogger("exchanges")
exchanges_logger.setLevel(logging.INFO)

# Also configure bot_unified module logger
bot_unified_logger = logging.getLogger("bot_unified")
bot_unified_logger.setLevel(logging.INFO)

if not logger.handlers: 
    console_h = logging.StreamHandler()
    console_h.setLevel(logging.INFO)
    console_h.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(message)s"))
    logger.addHandler(console_h)
    # Add same handler to exchanges logger for proper formatting
    exchanges_logger.addHandler(console_h)
    # Add same handler to bot_unified logger
    bot_unified_logger.addHandler(console_h)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# UNIFIED ARCHITECTURE - Feature Flag
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
USE_UNIFIED_ARCHITECTURE = os.getenv("USE_UNIFIED", "true").lower() == "true"

if USE_UNIFIED_ARCHITECTURE and UNIFIED_AVAILABLE:
    logger.info("‚úÖ Unified Architecture ENABLED - using new models and exchange client")
else:
    logger.info("‚ö†Ô∏è  Unified Architecture DISABLED - using legacy functions")
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

    file_h = logging.FileHandler("bot_debug.log", mode="a", encoding="utf-8")
    file_h.setLevel(logging.INFO)
    file_h.setFormatter(logging.Formatter("%(asctime)s [%(levelname)s] %(message)s"))
    logger.addHandler(file_h)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ERROR MONITORING SYSTEM
# Collects errors and sends detailed reports to admin
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
from collections import deque
from dataclasses import dataclass, field
from datetime import datetime as dt

@dataclass
class ErrorRecord:
    """Record of a single error occurrence"""
    timestamp: dt
    user_id: int | None
    username: str | None
    error_type: str
    error_message: str
    function_name: str
    symbol: str | None = None
    account_type: str | None = None
    exchange: str | None = None
    extra_context: dict = field(default_factory=dict)

class ErrorMonitor:
    """
    Centralized error monitoring system.
    - Collects errors with full context
    - Sends detailed reports to admin
    - Sends user-friendly messages to affected users
    - Rate-limits certain error types (e.g., API_KEY_EXPIRED once per day per user)
    """
    
    # Error types that should only be reported once per day per user
    DAILY_LIMIT_ERRORS = {"API_KEY_EXPIRED", "API_KEY_MISSING", "INSUFFICIENT_BALANCE", "EQUITY_ZERO"}
    
    def __init__(self, admin_id: int = ADMIN_ID, report_interval: int = 300):
        self.admin_id = admin_id
        self.report_interval = report_interval  # seconds between admin reports
        self.errors: deque[ErrorRecord] = deque(maxlen=1000)
        self.last_admin_report = 0
        self.bot = None
        self._lock = asyncio.Lock()
        
        # Track daily-limited errors: {(user_id, error_type): last_notified_date}
        self._daily_notified: dict[tuple[int, str], str] = {}
        
        # Error type to translation key mapping
        self.error_keys = {
            "INSUFFICIENT_BALANCE": "error_insufficient_balance",
            "ORDER_TOO_SMALL": "error_order_too_small",
            "API_KEY_EXPIRED": "error_api_key_expired",
            "API_KEY_MISSING": "error_api_key_missing",
            "RATE_LIMIT": "error_rate_limit",
            "POSITION_NOT_FOUND": "error_position_not_found",
            "LEVERAGE_ERROR": "error_leverage_error",
            "NETWORK_ERROR": "error_network_error",
            "SL_TP_INVALID": "error_sl_tp_invalid",
            "EQUITY_ZERO": "error_equity_zero",
        }
    
    def set_bot(self, bot):
        """Set bot instance for sending messages"""
        self.bot = bot
    
    def _get_user_message(self, error_type: str, user_id: int) -> str | None:
        """Get localized error message for user"""
        key = self.error_keys.get(error_type)
        if not key:
            return None
        try:
            lang = db.get_user_lang(user_id) or "en"
            texts = LANGS.get(lang, LANGS.get("en", {}))
            return texts.get(key)
        except Exception:
            # Fallback to English
            try:
                return LANGS.get("en", {}).get(key)
            except Exception:
                return None
    
    async def record_error(
        self,
        user_id: int | None,
        error_type: str,
        error_message: str,
        function_name: str,
        username: str | None = None,
        symbol: str | None = None,
        account_type: str | None = None,
        exchange: str | None = None,
        notify_user: bool = True,
        **extra_context
    ):
        """Record an error and optionally notify user"""
        async with self._lock:
            today = dt.now().strftime("%Y-%m-%d")
            
            # Check if this is a daily-limited error type
            if error_type in self.DAILY_LIMIT_ERRORS and user_id:
                key = (user_id, error_type)
                last_notified = self._daily_notified.get(key)
                if last_notified == today:
                    # Already notified today, skip recording and notifications
                    logger.debug(f"Skipping daily-limited error {error_type} for user {user_id} (already notified today)")
                    return
                # Mark as notified today
                self._daily_notified[key] = today
            
            error = ErrorRecord(
                timestamp=dt.now(),
                user_id=user_id,
                username=username,
                error_type=error_type,
                error_message=error_message,
                function_name=function_name,
                symbol=symbol,
                account_type=account_type,
                exchange=exchange,
                extra_context=extra_context
            )
            self.errors.append(error)
            
            # Save to database for admin management
            try:
                error_code = None
                # Extract error code from message (e.g., "110007" from Bybit)
                import re
                code_match = re.search(r"'retCode':\s*(\d+)", error_message)
                if code_match:
                    error_code = code_match.group(1)
                
                context = {
                    "function": function_name,
                    "symbol": symbol,
                    **extra_context
                }
                db.log_admin_error(
                    user_id=user_id or 0,
                    error_type=error_type,
                    error_message=error_message[:1000],  # Truncate long messages
                    error_code=error_code,
                    context=context,
                    exchange=exchange or "bybit",
                    account_type=account_type or "demo"
                )
            except Exception as e:
                logger.debug(f"Could not save error to admin log: {e}")
            
            # Notify user with friendly message
            if notify_user and user_id and self.bot and error_type in self.error_keys:
                try:
                    user_msg = self._get_user_message(error_type, user_id)
                    if user_msg:
                        if symbol:
                            user_msg = f"üìä *{symbol}*\n\n{user_msg}"
                        await self.bot.send_message(
                            user_id,
                            user_msg,
                            parse_mode="Markdown"
                        )
                except Exception as e:
                    logger.debug(f"Could not send user notification: {e}")
            
            # Check if we should send admin report
            now = time.time()
            if now - self.last_admin_report >= self.report_interval:
                asyncio.create_task(self._send_admin_report())
    
    async def _send_admin_report(self):
        """Send detailed error report to admin with inline action buttons"""
        if not self.bot:
            return
            
        async with self._lock:
            self.last_admin_report = time.time()
            
            # Get errors from last report interval
            from datetime import timedelta
            cutoff = dt.now() - timedelta(seconds=self.report_interval)
            recent_errors = [e for e in self.errors if e.timestamp >= cutoff]
            
            if not recent_errors:
                return
            
            # Group by user for actionable report
            by_user: dict[int, list[ErrorRecord]] = {}
            for err in recent_errors:
                uid = err.user_id or 0
                if uid not in by_user:
                    by_user[uid] = []
                by_user[uid].append(err)
            
            # Build detailed report with user context
            lines = [
                f"üö® <b>Error Report</b> ({len(recent_errors)} errors in {self.report_interval//60}min)",
                f"‚è∞ {dt.now().strftime('%Y-%m-%d %H:%M:%S')}",
                f"üë• <b>{len(by_user)} users affected</b>",
                ""
            ]
            
            # Collect error IDs for buttons (max 8 buttons per report)
            button_data = []
            
            for user_id, errors in sorted(by_user.items(), key=lambda x: -len(x[1])):
                # Get user info
                user_info = "unknown"
                if user_id:
                    err = errors[0]
                    user_info = f"@{err.username}" if err.username else f"uid:{user_id}"
                
                lines.append(f"<b>‚îÅ‚îÅ‚îÅ {user_info} ({len(errors)}x) ‚îÅ‚îÅ‚îÅ</b>")
                
                # Group by error type for this user
                by_type: dict[str, list[ErrorRecord]] = {}
                for err in errors:
                    if err.error_type not in by_type:
                        by_type[err.error_type] = []
                    by_type[err.error_type].append(err)
                
                for error_type, type_errors in sorted(by_type.items(), key=lambda x: -len(x[1])):
                    err = type_errors[0]
                    symbol_info = f" | {err.symbol}" if err.symbol else ""
                    acc_info = f" | {err.account_type}" if err.account_type else ""
                    exc_info = f" | {err.exchange}" if err.exchange else ""
                    
                    lines.append(f"‚îú‚îÄ <b>{error_type}</b> ({len(type_errors)}x){symbol_info}{acc_info}{exc_info}")
                    
                    # Truncate long error messages and escape HTML entities
                    msg = err.error_message[:120] + "..." if len(err.error_message) > 120 else err.error_message
                    msg = msg.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
                    lines.append(f"‚îÇ  üí¨ <code>{msg}</code>")
                    
                    # Extra context
                    if err.extra_context:
                        ctx_str = ", ".join(f"{k}={v}" for k, v in list(err.extra_context.items())[:3])
                        ctx_str = ctx_str.replace("&", "&amp;").replace("<", "&lt;").replace(">", "&gt;")
                        lines.append(f"‚îÇ  üìé {ctx_str}")
                
                # Store user_id for button (max 8 users)
                if len(button_data) < 8 and user_id:
                    button_data.append((user_id, user_info, len(errors)))
                
                lines.append("")
            
            report = "\n".join(lines)
            
            # Build inline keyboard with quick actions
            from telegram import InlineKeyboardButton, InlineKeyboardMarkup
            keyboard = []
            
            # User action buttons (2 per row)
            row = []
            for user_id, user_info, count in button_data:
                short_name = user_info[:10] if len(user_info) > 10 else user_info
                row.append(InlineKeyboardButton(
                    f"‚úÖ {short_name} ({count})",
                    callback_data=f"admin:approve_user:{user_id}"
                ))
                if len(row) == 2:
                    keyboard.append(row)
                    row = []
            if row:
                keyboard.append(row)
            
            # Bottom action buttons
            keyboard.append([
                InlineKeyboardButton("‚úÖ Approve All", callback_data="admin:errors_approve_all"),
                InlineKeyboardButton("üìã Details", callback_data="admin:errors_list:0"),
            ])
            keyboard.append([
                InlineKeyboardButton("üë• By User", callback_data="admin:errors_by_user"),
                InlineKeyboardButton("üîÑ Refresh", callback_data="admin:errors_menu"),
            ])
            
            reply_markup = InlineKeyboardMarkup(keyboard)
            
            # Send to admin
            try:
                if len(report) > 4000:
                    # For long reports, send without buttons first, then buttons
                    for i in range(0, len(report), 4000):
                        is_last = i + 4000 >= len(report)
                        await self.bot.send_message(
                            self.admin_id,
                            report[i:i+4000],
                            parse_mode="HTML",
                            reply_markup=reply_markup if is_last else None
                        )
                else:
                    await self.bot.send_message(
                        self.admin_id,
                        report,
                        parse_mode="HTML",
                        reply_markup=reply_markup
                    )
            except Exception as e:
                # Fallback: try sending without HTML parse_mode
                logger.warning(f"Admin error report HTML parse failed: {e}, retrying as plain text")
                try:
                    import re as _re
                    plain_report = _re.sub(r'<[^>]+>', '', report)
                    await self.bot.send_message(
                        self.admin_id,
                        plain_report[:4000],
                        reply_markup=reply_markup
                    )
                except Exception as e2:
                    logger.error(f"Failed to send admin error report (even plain text): {e2}")

# Global error monitor instance
error_monitor = ErrorMonitor(admin_id=ADMIN_ID, report_interval=300)  # Report every 5 minutes
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

BOT_TOKEN   = os.getenv("TELEGRAM_TOKEN")
WEBAPP_URL  = os.getenv("WEBAPP_URL", "https://enliko.com")  # WebApp URL (production domain)
BYBIT_DEMO_URL = "https://api-demo.bybit.com"
BYBIT_REAL_URL = "https://api.bybit.com"
BYBIT_BASE  = BYBIT_DEMO_URL  # Default for backward compatibility
PRICE_RANGE = float(os.getenv("PRICE_RANGE", "50.0"))
EPSILON = 1e-8
ATR_INTERVAL = "5" 
ATR_TRIGGER_PCT = 1

# Global notification service instance
notification_service = None


def _safe_float(val, default=0.0):
    """Safely convert value to float, handling None and empty strings."""
    if val is None or val == '':
        return default
    try:
        return float(val)
    except (ValueError, TypeError):
        return default

# Spot DCA Settings
SPOT_DCA_COINS = os.getenv("SPOT_DCA_COINS", "BTC,ETH").split(",")  # Coins for Spot DCA
SPOT_DCA_DEFAULT_AMOUNT = float(os.getenv("SPOT_DCA_DEFAULT_AMOUNT", "10.0"))  # Default USDT per buy

# Professional Spot Portfolio Presets
SPOT_PORTFOLIOS = {
    "blue_chip": {
        "name": "Blue Chips",
        "emoji": "üíé",
        "coins": {"BTC": 50, "ETH": 30, "BNB": 10, "SOL": 10},  # % allocation
        "description": "Top market cap, lower risk",
        "risk_level": "low",
    },
    "defi": {
        "name": "DeFi",
        "emoji": "üè¶",
        "coins": {"UNI": 25, "AAVE": 25, "MKR": 20, "LINK": 15, "SNX": 15},
        "description": "Decentralized finance protocols",
        "risk_level": "medium",
    },
    "layer2": {
        "name": "Layer 2",
        "emoji": "‚ö°",
        "coins": {"MATIC": 30, "ARB": 25, "OP": 25, "IMX": 20},
        "description": "Ethereum scaling solutions",
        "risk_level": "medium",
    },
    "ai_narrative": {
        "name": "AI & Data",
        "emoji": "ü§ñ",
        "coins": {"FET": 25, "RNDR": 25, "TAO": 20, "NEAR": 15, "GRT": 15},
        "description": "AI and data tokens",
        "risk_level": "high",
    },
    "gaming": {
        "name": "Gaming",
        "emoji": "üéÆ",
        "coins": {"AXS": 25, "SAND": 20, "MANA": 20, "GALA": 20, "ENJ": 15},
        "description": "Gaming and Metaverse",
        "risk_level": "high",
    },
    "meme": {
        "name": "Memecoins",
        "emoji": "üêï",
        "coins": {"DOGE": 35, "SHIB": 25, "PEPE": 20, "FLOKI": 10, "WIF": 10},
        "description": "High risk meme tokens",
        "risk_level": "very_high",
    },
    "l1_killers": {
        "name": "L1 Killers",
        "emoji": "‚öîÔ∏è",
        "coins": {"SOL": 30, "AVAX": 25, "NEAR": 20, "SUI": 15, "APT": 10},
        "description": "Alternative Layer 1 blockchains",
        "risk_level": "medium",
    },
    "rwa": {
        "name": "RWA",
        "emoji": "üèõÔ∏è",
        "coins": {"ONDO": 30, "MKR": 25, "SNX": 20, "LINK": 15, "GRT": 10},
        "description": "Real World Assets tokens",
        "risk_level": "medium",
    },
    "infrastructure": {
        "name": "Infra",
        "emoji": "üîß",
        "coins": {"LINK": 30, "GRT": 25, "FIL": 20, "AR": 15, "ATOM": 10},
        "description": "Web3 infrastructure",
        "risk_level": "medium",
    },
    "btc_only": {
        "name": "BTC Only",
        "emoji": "‚Çø",
        "coins": {"BTC": 100},
        "description": "100% Bitcoin - maximum simplicity",
        "risk_level": "low",
    },
    "eth_btc": {
        "name": "ETH+BTC",
        "emoji": "üí∞",
        "coins": {"BTC": 60, "ETH": 40},
        "description": "Classic 60/40 split",
        "risk_level": "low",
    },
    "custom": {
        "name": "Custom",
        "emoji": "‚öôÔ∏è",
        "coins": {},
        "description": "Your custom allocation",
        "risk_level": "custom",
    },
}

# Smart DCA Strategies
SMART_DCA_STRATEGIES = {
    "fixed": {
        "name": "Fixed DCA",
        "emoji": "üìä",
        "description": "Same amount at regular intervals",
    },
    "value_avg": {
        "name": "Value Averaging",
        "emoji": "üìà",
        "description": "Buy more when price drops, less when rises",
    },
    "fear_greed": {
        "name": "Fear & Greed",
        "emoji": "üò±",
        "description": "Buy more during extreme fear",
    },
    "dip_buy": {
        "name": "Dip Buying",
        "emoji": "üìâ",
        "description": "Only buy on significant dips",
    },
    "crash_boost": {
        "name": "Crash Boost",
        "emoji": "üö®",
        "description": "3x buy when price drops >15% in 24h",
    },
    "momentum": {
        "name": "Momentum",
        "emoji": "üöÄ",
        "description": "Buy more in uptrends, less in downtrends",
    },
    "rsi_based": {
        "name": "RSI Smart",
        "emoji": "üìê",
        "description": "Buy more when RSI < 30 (oversold)",
    },
}

# Spot Take Profit Levels (% gain -> % to sell)
DEFAULT_SPOT_TP_LEVELS = [
    {"gain_pct": 15, "sell_pct": 20},   # At 15% gain, sell 20%
    {"gain_pct": 30, "sell_pct": 20},   # At 30% gain, sell 20%
    {"gain_pct": 50, "sell_pct": 20},   # At 50% gain, sell 20%
    {"gain_pct": 100, "sell_pct": 20},  # At 100% gain, sell 20%
    {"gain_pct": 200, "sell_pct": 20},  # At 200% gain, sell remaining 20%
]

# Preset TP Profiles
SPOT_TP_PROFILES = {
    "conservative": {
        "name": "Conservative",
        "emoji": "üê¢",
        "levels": [
            {"gain_pct": 10, "sell_pct": 25},
            {"gain_pct": 20, "sell_pct": 25},
            {"gain_pct": 35, "sell_pct": 25},
            {"gain_pct": 50, "sell_pct": 25},
        ],
    },
    "balanced": {
        "name": "Balanced",
        "emoji": "‚öñÔ∏è",
        "levels": [
            {"gain_pct": 20, "sell_pct": 20},
            {"gain_pct": 50, "sell_pct": 25},
            {"gain_pct": 100, "sell_pct": 30},
            {"gain_pct": 200, "sell_pct": 25},
        ],
    },
    "aggressive": {
        "name": "Aggressive",
        "emoji": "ü¶Å",
        "levels": [
            {"gain_pct": 50, "sell_pct": 15},
            {"gain_pct": 100, "sell_pct": 20},
            {"gain_pct": 200, "sell_pct": 25},
            {"gain_pct": 500, "sell_pct": 40},
        ],
    },
    "moonbag": {
        "name": "Moonbag",
        "emoji": "üåô",
        "levels": [
            {"gain_pct": 100, "sell_pct": 50},  # Sell 50% at 2x to recover initial
            {"gain_pct": 500, "sell_pct": 25},  # Sell 25% at 5x
            # Keep 25% as "moonbag" forever
        ],
    },
}

# Trailing TP settings for Spot
SPOT_TRAILING_TP_DEFAULTS = {
    "enabled": False,
    "activation_pct": 15.0,    # Activate trailing at +15% profit
    "trail_pct": 5.0,          # Trail by 5% from peak
    "min_profit_pct": 10.0,    # Minimum profit to lock (activation - trail)
}

# Advanced Spot Trading Features
SPOT_ADVANCED_FEATURES = {
    "profit_lock": {
        "enabled": False,
        "trigger_pct": 30.0,    # Lock profit when gain >= 30%
        "lock_pct": 50.0,       # Sell 50% to lock profit
    },
    "dcs": {  # Dollar Cost Sell
        "enabled": False,
        "trigger_pct": 20.0,    # Start selling at +20%
        "sell_amount": 10.0,    # Sell $10 worth each interval
        "interval": "weekly",   # Sell interval
    },
    "crash_boost": {
        "enabled": True,
        "threshold_24h": -15.0,  # If 24h change < -15%
        "multiplier": 3.0,       # Buy 3x normal amount
    },
    "limit_dca": {
        "enabled": False,
        "offset_pct": 0.5,       # Place limit order 0.5% below market
        "timeout_hours": 24,     # Cancel if not filled in 24h
    },
    "smart_rebalance": {
        "enabled": False,
        "threshold_pct": 10.0,   # Rebalance if deviation > 10%
        "frequency": "weekly",   # Rebalance frequency
        "last_rebalance_ts": 0,
    },
}

# Spot Grid Bot defaults
SPOT_GRID_DEFAULTS = {
    "enabled": False,
    "price_low": 0.0,          # Grid lower bound
    "price_high": 0.0,         # Grid upper bound
    "grid_count": 10,          # Number of grid levels
    "total_investment": 100.0, # Total USDT to invest
    "take_profit_pct": None,   # Optional overall TP
    "stop_loss_pct": None,     # Optional overall SL
}

# Spot DCA intervals in seconds
SPOT_DCA_INTERVALS = {
    "hourly": 3600,
    "daily": 86400,
    "weekly": 604800,
    "biweekly": 1209600,
    "monthly": 2592000,
}

# Multi-timeframe DCA plan structure
SPOT_DCA_PLAN_TEMPLATE = {
    "name": "Plan 1",
    "coins": [],
    "amount": 10.0,
    "frequency": "weekly",
    "strategy": "fixed",
    "enabled": True,
    "last_exec_ts": 0,
}

_session: ClientSession | None = None

TRANSLATIONS_DIR = os.path.join(os.path.dirname(__file__), "translations")
# SECURITY: Whitelist valid language codes to prevent arbitrary module imports
VALID_LANG_PATTERN = re.compile(r'^[a-z]{2}$')  # Only 2-letter lowercase codes like 'en', 'ru', etc.

SUPPORTED_LANGS = [
    fname[:-3]
    for fname in os.listdir(TRANSLATIONS_DIR)
    if fname.endswith(".py") and fname != "__init__.py" and VALID_LANG_PATTERN.match(fname[:-3])
]

LANGS: dict[str, dict] = {
    lang: importlib.import_module(f"translations.{lang}").TEXTS
    for lang in SUPPORTED_LANGS
}

NOTICE_WINDOW = 360000   
MUTE_TTL      = 3600   
SPLIT_MARKET_PART = 0.5   
SPLIT_ADDON_PCT   = 1.0   
PAGE_SIZE = 10
DCA_LEGS = [0.25, 0.25, 0.50]               
DCA_ATR_MULTS = [0.3, 0.9]                   
DCA_LEG_TIMEOUT_SEC = int(os.getenv("DCA_LEG_TIMEOUT_SEC", "72000"))
DCA_POLL_SEC = float(os.getenv("DCA_POLL_SEC", "1.0"))          
DCA_LAST_LEG_EXTRA_PCT = float(os.getenv("DCA_LAST_LEG_EXTRA_PCT", "0.8")) 

PRIVACY_PATH = os.path.join(os.path.dirname(__file__), "privacy.txt")

_last_notice: dict[tuple[int, str, str], int] = {}  
_skip_until:  dict[tuple[int, str], int] = {} 

# ============================================================================
# CACHES WITH SIZE LIMITS (prevent memory leaks)
# Using cachetools.TTLCache for automatic expiration and size limits
# ============================================================================
try:
    from cachetools import TTLCache
    _USE_TTLCACHE = True
except ImportError:
    _USE_TTLCACHE = False
    logger.warning("cachetools not installed, using dict caches (install with: pip install cachetools)")

# Cache for leverage per user+symbol to avoid redundant API calls
# Key: (user_id, symbol, account_type), Value: current leverage
# Max 10k entries (10k users * 1 symbol avg), TTL 1 hour
if _USE_TTLCACHE:
    _leverage_cache: TTLCache = TTLCache(maxsize=10000, ttl=3600)
else:
    _leverage_cache: dict[tuple[int, str], int] = {}

# Cache for symbol filters (tick_size, min_qty, etc) - shared across all users
# Key: symbol, Value: (timestamp, filter_dict)
# Max 500 symbols, TTL 1 hour
if _USE_TTLCACHE:
    _symbol_filters_cache: TTLCache = TTLCache(maxsize=500, ttl=3600)
else:
    _symbol_filters_cache: dict[str, tuple[float, dict]] = {}
SYMBOL_FILTERS_CACHE_TTL = 3600  # 1 hour - filters rarely change

# Cache for "no API keys" message - only show once per day per user
# Key: user_id, Value: timestamp of last notification
# Max 1k users
if _USE_TTLCACHE:
    _last_api_keys_notice: TTLCache = TTLCache(maxsize=1000, ttl=86400)
else:
    _last_api_keys_notice: dict[int, float] = {}
API_KEYS_NOTICE_INTERVAL = 86400  # 24 hours in seconds

# Cache for expired/invalid API keys - skip monitoring for these users
# Key: (user_id, account_type), Value: timestamp when error occurred
# Max 1k entries
if _USE_TTLCACHE:
    _expired_api_keys_cache: TTLCache = TTLCache(maxsize=1000, ttl=3600)
else:
    _expired_api_keys_cache: dict[tuple[int, str], float] = {}
EXPIRED_API_KEYS_CACHE_TTL = 3600  # 1 hour - don't retry for 1 hour after auth error

# Cache for position mode per user (one-way vs hedge)
# Max 1k users, TTL 1 hour
if _USE_TTLCACHE:
    _position_mode_cache: TTLCache = TTLCache(maxsize=1000, ttl=3600)
else:
    _position_mode_cache: dict[tuple[int, str], str] = {}


def clear_expired_api_cache(user_id: int, account_type: str = None):
    """Clear expired API keys cache for a user when they update their credentials."""
    keys_to_remove = [k for k in _expired_api_keys_cache if k[0] == user_id and (account_type is None or k[1] == account_type)]
    for k in keys_to_remove:
        _expired_api_keys_cache.pop(k, None)
    
    # Also clear unified exchange client auth cache
    try:
        from core import clear_auth_error_cache
        clear_auth_error_cache(user_id, exchange_type="bybit", account_type=account_type)
    except Exception:
        pass


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# DAILY ERROR NOTIFICATIONS SYSTEM
# Send user-friendly error messages once per day per error type (no spam!)
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Error types for daily notifications
class DailyErrorType:
    ZERO_BALANCE = "zero_balance"
    API_KEYS_INVALID = "api_keys_invalid"
    CONNECTION_ERROR = "connection_error"
    MARGIN_EXHAUSTED = "margin_exhausted"

# Cache: (user_id, error_type, account_type) -> {"last_sent": timestamp, "missed_count": int}
if _USE_TTLCACHE:
    _daily_error_cache: TTLCache = TTLCache(maxsize=5000, ttl=86400)  # 24h TTL
else:
    _daily_error_cache: dict = {}

DAILY_ERROR_INTERVAL = 86400  # 24 hours


def _get_daily_error_key(user_id: int, error_type: str, account_type: str) -> tuple:
    """Generate cache key for daily error notification."""
    return (user_id, error_type, account_type)


def _should_send_daily_error(user_id: int, error_type: str, account_type: str) -> tuple[bool, int]:
    """
    Check if we should send error notification.
    Returns (should_send, missed_count).
    Increments missed_count for tracking.
    """
    key = _get_daily_error_key(user_id, error_type, account_type)
    now = time.time()
    today_start = now - (now % 86400)  # Start of today (UTC)
    
    entry = _daily_error_cache.get(key)
    
    if entry is None:
        # First error of this type today - will be sent
        _daily_error_cache[key] = {"last_sent": now, "missed_count": 1, "day_start": today_start}
        return True, 1
    
    # Check if it's a new day
    if entry.get("day_start", 0) < today_start:
        # New day - reset counter and send
        _daily_error_cache[key] = {"last_sent": now, "missed_count": 1, "day_start": today_start}
        return True, 1
    
    # Same day - increment counter
    entry["missed_count"] = entry.get("missed_count", 0) + 1
    
    # Check if already sent today (last_sent is set to now when first sent)
    if entry.get("last_sent", 0) >= today_start:
        # Already sent today - don't send again
        return False, entry["missed_count"]
    
    # Not sent today yet (shouldn't happen now, but just in case)
    entry["last_sent"] = now
    return True, entry["missed_count"]


def get_account_label_for_display(target_key: str, exchange: str = None) -> str:
    """
    Get proper account label for display.
    For Bybit: Demo/Real
    For HyperLiquid: Testnet/Mainnet
    
    target_key format: "bybit:paper", "hyperliquid:testnet", etc.
    """
    is_hl = exchange == "hyperliquid" or "hyperliquid" in target_key
    is_paper = "paper" in target_key or "testnet" in target_key or "demo" in target_key
    
    if is_hl:
        return "Testnet" if is_paper else "Mainnet"
    else:
        return "Demo" if is_paper else "Real"


async def notify_user_daily_error(
    bot,
    user_id: int,
    error_type: str,
    account_type: str,
    t: dict,
    extra_data: dict = None
) -> bool:
    """
    Send daily error notification to user.
    Returns True if message was sent, False if skipped (already sent today).
    """
    should_send, missed_count = _should_send_daily_error(user_id, error_type, account_type)
    
    if not should_send:
        logger.debug(f"[DailyError] Skipping {error_type} for uid={user_id} (already sent today, missed={missed_count})")
        return False
    
    # Build message based on error type
    extra = extra_data or {}
    extra["account_type"] = account_type.upper()
    extra["missed_count"] = missed_count
    # Provide defaults for new fields so old callers don't break
    extra.setdefault("symbol", "‚Äî")
    extra.setdefault("strategy", "‚Äî")
    extra.setdefault("equity", "‚Äî")
    
    try:
        if error_type == DailyErrorType.ZERO_BALANCE:
            msg = t.get('daily_zero_balance', 
                "üí∞ Insufficient Balance\n\nüö´ Your {account_type} account has $0.\nüìå Signal skipped: {symbol} ({strategy})\n\nDeposit funds to resume trading."
            ).format(**extra)
        
        elif error_type == DailyErrorType.API_KEYS_INVALID:
            msg = t.get('daily_api_keys_invalid',
                "üîë Your {account_type} API keys are invalid. Missed signals: {missed_count}. Update keys in /api_settings."
            ).format(**extra)
        
        elif error_type == DailyErrorType.CONNECTION_ERROR:
            extra.setdefault("exchange", "Bybit")
            msg = t.get('daily_connection_error',
                "üåê Cannot connect to {exchange} ({account_type}). Missed signals: {missed_count}."
            ).format(**extra)
        
        elif error_type == DailyErrorType.MARGIN_EXHAUSTED:
            extra.setdefault("open_count", "?")
            msg = t.get('daily_margin_exhausted',
                "üìä Insufficient Margin\n\nüö´ Not enough free margin on {account_type}.\nüìå Signal skipped: {symbol} ({strategy})\nüí∞ Equity: {equity}\nüìÇ Open positions: {open_count}"
            ).format(**extra)
        
        else:
            logger.warning(f"[DailyError] Unknown error type: {error_type}")
            return False
        
        await bot.send_message(user_id, msg, parse_mode="HTML")
        logger.info(f"[DailyError] Sent {error_type} notification to uid={user_id} (missed={missed_count})")
        return True
        
    except Exception as e:
        logger.warning(f"[DailyError] Failed to send {error_type} to uid={user_id}: {e}")
        return False


def clear_daily_error_cache(user_id: int, error_type: str = None, account_type: str = None):
    """Clear daily error cache when user fixes the issue (e.g., deposits funds, updates API keys)."""
    keys_to_remove = []
    for key in _daily_error_cache:
        uid, err_type, acc_type = key
        if uid != user_id:
            continue
        if error_type and err_type != error_type:
            continue
        if account_type and acc_type != account_type:
            continue
        keys_to_remove.append(key)
    
    for key in keys_to_remove:
        _daily_error_cache.pop(key, None)
    
    if keys_to_remove:
        logger.debug(f"[DailyError] Cleared {len(keys_to_remove)} error cache entries for uid={user_id}")


def _parse_chat_ids(*keys: str) -> list[int]:
    import re
    raw_parts = []
    for k in keys:
        v = os.getenv(k, "")
        if v:
            raw_parts.append(v)
    if not raw_parts:
        return []
    raw = ",".join(raw_parts)
    return [int(x) for x in re.split(r"[,\s]+", raw) if x]

SIGNAL_CHANNEL_IDS = _parse_chat_ids("SIGNAL_CHANNEL_IDS", "SIGNAL_CHANNEL_ID", "SIGNAL_CHANNEL_ID_2")
SIGNAL_CHANNEL_IDS = list(dict.fromkeys(SIGNAL_CHANNEL_IDS))

# =====================================================
# COMMUNITY MEMBERSHIP - VOLUNTARY CONTRIBUTIONS
# All amounts are suggested donations (1 ELC = 1 USDT)
# Patron: suggested $100/mo, Supporter: suggested $50/mo
# =====================================================

# Import blockchain module (Sovereign Monetary System)
from core.blockchain import (
    # Core
    blockchain, get_elc_balance, get_elc_wallet, pay_with_elc,
    deposit_elc, reward_elc, get_license_price_elc, pay_license,
    LICENSE_PRICES_ELC, ELC_SYMBOL, ELC_NAME,
    # ELC payments (ENLIKO Super Token)
    pay_license_elc, get_license_price, get_subscription_options,
    LICENSE_PRICES_ELC,
    # Sovereign owner operations
    is_sovereign_owner, emit_tokens, burn_tokens, set_monetary_policy,
    freeze_wallet, unfreeze_wallet, distribute_staking_rewards,
    get_treasury_stats, transfer_from_treasury, get_global_stats,
    get_owner_dashboard,
    # Constants
    SOVEREIGN_OWNER_ID, SOVEREIGN_OWNER_NAME, CHAIN_ID, CHAIN_NAME
)

# Suggested contribution amounts (1 ELC = 1 USDT)
PREMIUM_ELC_1M = 100.0    # Patron tier - suggested monthly
PREMIUM_ELC_3M = 270.0    # Patron 3mo (-10%)
PREMIUM_ELC_6M = 480.0    # Patron 6mo (-20%)
PREMIUM_ELC_12M = 840.0   # Patron 12mo (-30%)

# Supporter tier (50% of patron)
BASIC_ELC_1M = 50.0       # Supporter monthly
BASIC_ELC_3M = 135.0      # Supporter 3mo
BASIC_ELC_6M = 240.0      # Supporter 6mo
BASIC_ELC_12M = 420.0     # Supporter 12mo

TRIAL_PRICE = 0  # Free explorer access
TRIAL_DAYS = 7   # Explorer access duration

# ELC Payment wallet (platform master wallet)
ELC_MASTER_WALLET = "0xELC000000000000000000000000000000001"

# ELC/ENLIKO Token - Our super token (1:1 with USD)
# ELC will eventually deprecated as the primary payment token
ELC_PRICE_USD = 1.0  # 1 ELC = 1 USD

# Enterprise tier (5x Patron)
ENTERPRISE_ELC_1M = 500.0     # Enterprise monthly
ENTERPRISE_ELC_3M = 1350.0    # Enterprise 3mo
ENTERPRISE_ELC_6M = 2400.0    # Enterprise 6mo
ENTERPRISE_ELC_12M = 4200.0   # Enterprise 12mo

# Membership contribution mapping (ELC token, 1 ELC = 1 USD)
LICENSE_PRICES = {
    "premium": {  # Patron tier
        "elc": {1: PREMIUM_ELC_1M, 3: PREMIUM_ELC_3M, 6: PREMIUM_ELC_6M, 12: PREMIUM_ELC_12M},
    },
    "basic": {  # Supporter tier
        "elc": {1: BASIC_ELC_1M, 3: BASIC_ELC_3M, 6: BASIC_ELC_6M, 12: BASIC_ELC_12M},
    },
    "enterprise": {  # Enterprise tier
        "elc": {1: ENTERPRISE_ELC_1M, 3: ENTERPRISE_ELC_3M, 6: ENTERPRISE_ELC_6M, 12: ENTERPRISE_ELC_12M},
    },
    "trial": {  # Explorer access
        "elc": {1: 0},
    },
}

# Discount labels
DISCOUNT_LABELS = {
    1: "",
    3: " (-10%)",
    6: " (-20%)",
    12: " (-30%)",
}

_session_lock = asyncio.Lock()

# Per-user trading locks to prevent race conditions on concurrent signals
# Key: (user_id, symbol, account_type) -> Lock
_trading_locks: dict[tuple[int, str, str], asyncio.Lock] = {}
_trading_locks_lock = asyncio.Lock()

async def get_trading_lock(user_id: int, symbol: str, account_type: str = "auto") -> asyncio.Lock:
    """Get or create a lock for trading operations on a specific user/symbol/account."""
    key = (user_id, symbol, account_type)
    async with _trading_locks_lock:
        if key not in _trading_locks:
            _trading_locks[key] = asyncio.Lock()
        return _trading_locks[key]

async def init_session():
    """Initialize aiohttp session with optimized connection pooling."""
    global _session
    if _session is not None:
        return
    async with _session_lock:
        if _session is not None:
            return
        db.init_db()
        # PERFORMANCE: Optimized timeouts and connection limits
        timeout   = ClientTimeout(total=30, connect=8, sock_read=20)
        connector = TCPConnector(
            limit=100,           # Total connections (was 20)
            limit_per_host=30,   # Per host (was 5) - Bybit needs more
            ttl_dns_cache=300,   # DNS cache 5 min
            keepalive_timeout=30,  # Keep connections alive
            enable_cleanup_closed=True
        )
        _session  = ClientSession(timeout=timeout, connector=connector)

def log_calls(func):
    """Minimal decorator - only logs exceptions, no entry/exit spam"""
    @functools.wraps(func)
    async def wrapper(*args, **kwargs):
        try:
            return await func(*args, **kwargs)
        except MissingAPICredentials as e:
            # Don't spam logs with MissingAPICredentials - just log once as warning
            uid = None
            if args:
                if isinstance(args[0], int):
                    uid = args[0]
                elif hasattr(args[0], 'effective_user'):
                    try:
                        uid = args[0].effective_user.id
                    except Exception:
                        pass
            # Log as debug to reduce spam
            logger.debug(f"‚ö†Ô∏è {func.__name__} [uid={uid}]: API keys not configured")
            # Record for admin report
            if uid:
                error_type = "API_KEY_EXPIRED" if "expired" in str(e).lower() else "API_KEY_MISSING"
                asyncio.create_task(error_monitor.record_error(
                    user_id=uid,
                    error_type=error_type,
                    error_message=str(e),
                    function_name=func.__name__,
                    notify_user=True
                ))
            raise
        except Exception as e:
            uid = None
            if args:
                if isinstance(args[0], int):
                    uid = args[0]
                elif hasattr(args[0], 'effective_user'):
                    try:
                        uid = args[0].effective_user.id
                    except Exception:
                        pass
            # Skip logging for expected SL/TP validation errors
            err_str = str(e).lower()
            if "should lower than" in err_str or "should higher than" in err_str:
                # Expected error for positions in deep loss - don't spam logs
                pass
            elif "should greater" in err_str or "should less" in err_str:
                # Another format of SL/TP validation error
                pass
            elif "order_too_small" in err_str:
                # Expected error for small orders - already logged as warning
                pass
            elif "notional" in err_str and "minimum" in err_str:
                # Expected error for positions too small (low equity) - already logged as warning
                pass
            elif "leverage invalid" in err_str:
                # Expected error when leverage already set or position open
                pass
            else:
                logger.exception(
                    f"‚úñ {func.__name__}"
                    + (f" [uid={uid}]" if uid else "")
                    + f": {e}"
                )
            raise
    return wrapper

def once_per(key: tuple[int, str, str], seconds: int) -> bool:
    now = int(time.time())
    if len(_last_notice) > 5000:
        cutoff = now - max(NOTICE_WINDOW, 3600)
        for k, ts in list(_last_notice.items()):
            if ts < cutoff:
                _last_notice.pop(k, None)
    t = _last_notice.get(key, 0)
    if now - t < seconds:
        return False
    _last_notice[key] = now
    return True

def is_db_full_error(e: Exception) -> bool:
    return "database or disk is full" in str(e).lower()

async def set_fixed_sl_tp_percent(uid: int, symbol: str, side: str, *, sl_pct: float = 1.0, tp_pct: float = 3.0, account_type: str | None = None, exchange: str | None = None):
    positions = await fetch_open_positions(uid, account_type=account_type)
    pos_candidates = [p for p in positions if p.get("symbol") == symbol]
    if not pos_candidates:
        raise RuntimeError(f"No open position for {symbol} to set SL/TP")
    pos = max(pos_candidates, key=lambda p: abs(float(p.get("size") or 0.0)))
    entry_val = pos.get("avgPrice") or pos.get("entry_price") or 0
    entry = float(entry_val) if entry_val else 0.0
    if entry == 0:
        raise RuntimeError(f"Could not get entry price for {symbol}")
    sl_price = round(entry * (1 - sl_pct/100) if side == "Buy" else entry * (1 + sl_pct/100), 6)
    tp_price = round(entry * (1 + tp_pct/100) if side == "Buy" else entry * (1 - tp_pct/100), 6)
    await set_trading_stop(uid, symbol, sl_price=sl_price, tp_price=tp_price, side_hint=side, account_type=account_type, exchange=exchange)

def with_texts(func):
    @functools.wraps(func)
    async def wrapper(update, ctx, *args, **kwargs):
        # Guard against None user_data (e.g., channel posts without user context)
        user = update.effective_user
        if ctx.user_data is not None:
            if 'lang' not in ctx.user_data:
                if user:
                    cfg = get_user_config(user.id)
                    ctx.user_data['lang'] = cfg.get('lang', DEFAULT_LANG)
                else:
                    ctx.user_data['lang'] = DEFAULT_LANG
            ctx.t = get_texts(ctx)
        else:
            # No user_data available - get lang from DB or use default
            if user:
                cfg = get_user_config(user.id)
                lang = cfg.get('lang', DEFAULT_LANG)
            else:
                lang = DEFAULT_LANG
            ctx.t = LANGS.get(lang, LANGS[DEFAULT_LANG])
        return await func(update, ctx, *args, **kwargs)
    return wrapper

def _load_privacy_text(t: dict) -> str:
    try:
        with open(PRIVACY_PATH, "r", encoding="utf-8") as f:
            txt = f.read().strip()
        return txt
    except Exception:
        return t.get("terms_unavailable", "Terms of Service are unavailable. Please contact the admin.")

def terms_keyboard(t: dict) -> InlineKeyboardMarkup:
    return InlineKeyboardMarkup([[
        InlineKeyboardButton(t["terms_btn_accept"], callback_data="terms:accept"),
        InlineKeyboardButton(t["terms_btn_decline"], callback_data="terms:decline"),
    ]])


# ‚Äî‚Äî‚Äî Legal Disclaimer Flow (CRITICAL for compliance) ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
def disclaimer_keyboard(t: dict) -> InlineKeyboardMarkup:
    """Keyboard for disclaimer acceptance - required for legal compliance."""
    return InlineKeyboardMarkup([[
        InlineKeyboardButton(
            t.get("disclaimer_accept_btn", "‚úÖ I Understand & Accept"), 
            callback_data="disclaimer:accept"
        ),
    ], [
        InlineKeyboardButton(
            t.get("disclaimer_decline_btn", "‚ùå I Decline"), 
            callback_data="disclaimer:decline"
        ),
    ]])


async def show_disclaimer(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show the legal disclaimer that must be accepted before using trading features."""
    t = get_texts(ctx)
    chat_id = update.effective_chat.id
    
    disclaimer_text = t.get("disclaimer_trading", (
        "‚ö†Ô∏è *IMPORTANT DISCLAIMER*\n\n"
        "This platform provides educational tools for learning about cryptocurrency markets.\n\n"
        "‚Ä¢ This is NOT financial advice\n"
        "‚Ä¢ Past performance does not guarantee future results\n"
        "‚Ä¢ Trading involves substantial risk of loss\n"
        "‚Ä¢ You are solely responsible for all decisions\n\n"
        "By using Enliko, you agree to our Terms of Service."
    ))
    
    await ctx.bot.send_message(
        chat_id=chat_id,
        text=disclaimer_text,
        parse_mode="Markdown",
        reply_markup=disclaimer_keyboard(t)
    )


def has_accepted_disclaimer(uid: int) -> bool:
    """Check if user has accepted the legal disclaimer."""
    cfg = get_user_config(uid) or {}
    return bool(cfg.get("disclaimer_accepted", 0))


# ‚Äî‚Äî‚Äî Access control ‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî‚Äî
def _is_banned(uid: int) -> bool:
    cfg = get_user_config(uid) or {}
    return bool(cfg.get("is_banned", 0))

def _is_allowed_user(uid: int) -> bool:
    if uid == ADMIN_ID:       
        return True
    if _is_banned(uid):
        return False
    cfg = get_user_config(uid) or {}
    return bool(cfg.get("is_allowed", 0))

def require_access(func):
    @wraps(func)
    @with_texts
    async def _wrap(update, ctx, *args, **kw):
        uid = getattr(getattr(update, "effective_user", None), "id", None)
        if uid is None:
            return await func(update, ctx, *args, **kw)

        t = ctx.t
        
        # Update user info (username, first_name) on every interaction
        try:
            user = update.effective_user
            if user:
                username = user.username
                first_name = user.first_name
                db.update_user_info(uid, username=username, first_name=first_name)
        except Exception as e:
            logger.warning(f"Failed to update user info for {uid}: {e}")

        if uid == ADMIN_ID:
            return await func(update, ctx, *args, **kw)

        if _is_banned(uid):
            try:
                await ctx.bot.send_message(uid, t.get("banned", "You are blocked."))
            except Exception:
                pass
            return

        if not _is_allowed_user(uid):
            msg = getattr(update, "message", None)
            if msg and getattr(msg, "text", "") and msg.text.startswith("/start"):
                return await func(update, ctx, *args, **kw)
            try:
                await ctx.bot.send_message(uid, t.get("invite_only", "Access by invitation. Wait for the admin's decision."))
            except Exception:
                pass
            return

        cfg = get_user_config(uid) or {}
        if not cfg.get("terms_accepted", 0):
            msg = getattr(update, "message", None)
            data = getattr(getattr(update, "callback_query", None), "data", "")
            text = (msg.text if msg and msg.text else "") if msg else ""
            allowed = (
                text.startswith("/start")
                or text.startswith("/terms")
                or (isinstance(data, str) and data.startswith("terms:"))
            )
            if not allowed:
                try:
                    await ctx.bot.send_message(
                        uid,
                        t.get("need_terms", "First, accept the rules: /terms"),
                        reply_markup=terms_keyboard(ctx.t),
                    )
                except Exception:
                    pass
                return

        return await func(update, ctx, *args, **kw)
    return _wrap


def require_license(license_types: list[str] | None = None):
    """
    Decorator that requires user to have an active license.
    
    Args:
        license_types: List of allowed license types, e.g. ['premium', 'basic']
                      None = any active license is OK
    """
    def decorator(func):
        @wraps(func)
        @with_texts
        async def _wrap(update, ctx, *args, **kw):
            uid = getattr(getattr(update, "effective_user", None), "id", None)
            if uid is None:
                return await func(update, ctx, *args, **kw)

            t = ctx.t

            # Admin always has access
            if uid == ADMIN_ID:
                return await func(update, ctx, *args, **kw)

            license_info = get_user_license(uid)
            
            if not license_info["is_active"]:
                # No active license
                msg = t.get("no_license", "‚ö†Ô∏è You need an active subscription to use this feature.\n\nUse /subscribe to purchase a license.")
                try:
                    if update.callback_query:
                        await update.callback_query.answer(msg[:200], show_alert=True)
                    else:
                        await ctx.bot.send_message(uid, msg)
                except Exception:
                    pass
                return
            
            # Check specific license type requirement
            if license_types and license_info["license_type"] not in license_types:
                required = ", ".join(license_types)
                msg = t.get("license_required", f"‚ö†Ô∏è This feature requires a {required} subscription.\n\nUse /subscribe to upgrade.")
                try:
                    if update.callback_query:
                        await update.callback_query.answer(msg[:200], show_alert=True)
                    else:
                        await ctx.bot.send_message(uid, msg)
                except Exception:
                    pass
                return
            
            # Store license info in context for use in handler
            ctx.user_data["license_info"] = license_info
            return await func(update, ctx, *args, **kw)
        return _wrap
    return decorator



def get_texts(ctx_or_uid) -> dict:
    """Get translations for user. Accepts ctx or user_id (int)."""
    if isinstance(ctx_or_uid, int):
        # user_id passed directly - load lang from DB
        lang = db.get_user_lang(ctx_or_uid) or DEFAULT_LANG
    else:
        # ctx passed - get from user_data
        lang = ctx_or_uid.user_data.get('lang', DEFAULT_LANG)
    return LANGS.get(lang, LANGS[DEFAULT_LANG])

def _stricter_sl(side_: str, new_sl: float, cur_sl):
    if cur_sl in (None, "", 0, "0", 0.0):
        return new_sl
    cur = float(cur_sl)
    if side_ == "Buy":   
        return new_sl if new_sl > cur else None
    else:    
        return new_sl if new_sl < cur else None

@with_texts
async def cmd_lang(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    buttons = []
    for lang in SUPPORTED_LANGS:
        label = LANGS[lang].get(f"lang_{lang}", lang.upper())
        buttons.append(
            InlineKeyboardButton(label, callback_data=f"setlang:{lang}")
        )
    keyboard = [buttons[i:i+2] for i in range(0, len(buttons), 2)]
    await update.message.reply_text(
        ctx.t['select_language'],
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

@with_texts
async def on_setlang_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    try:
        asyncio.create_task(q.answer(cache_time=1))  
    except TgTimedOut:
        logger.warning("q.answer() timeout ‚Äî ignore")

    _, lang = q.data.split(":", 1)
    ctx.user_data['lang'] = lang
    set_user_field(q.from_user.id, 'lang', lang)

    ctx.t = get_texts(ctx)

    lang_label = LANGS[lang].get(f"lang_{lang}", lang.upper())
    await q.edit_message_text(f"{ctx.t['language_set']} {lang_label}")

    await ctx.bot.send_message(
        chat_id=q.from_user.id,
        text=ctx.t['welcome'],
        reply_markup=main_menu_keyboard(ctx, update=update)
    )
    
@log_calls
async def cmd_terms(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    t = get_texts(ctx)
    text = _load_privacy_text(t)
    chat_id = update.effective_chat.id

    MAX_LEN = 3500
    for i in range(0, len(text), MAX_LEN):
        chunk = text[i:i+MAX_LEN]
        await ctx.bot.send_message(chat_id, chunk)
    await ctx.bot.send_message(chat_id, t.get("terms_confirm_prompt", "Please confirm:"), reply_markup=terms_keyboard(t))

@with_texts
@log_calls
async def on_terms_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    await q.answer()
    uid = update.effective_user.id
    data = q.data or ""
    action = data.split(":", 1)[1] if ":" in data else ""

    if action == "accept":
        set_user_field(uid, "terms_accepted", True)  # Use True for boolean column
        await q.edit_message_text(ctx.t["terms_ok"])
        
        # Send privacy policy document after accepting terms
        try:
            if os.path.exists(PRIVACY_PATH):
                with open(PRIVACY_PATH, "r", encoding="utf-8") as f:
                    privacy_text = f.read()
                # Send as document for better readability
                from io import BytesIO
                privacy_buffer = BytesIO(privacy_text.encode("utf-8"))
                privacy_buffer.name = "Privacy_Policy_Terms.txt"
                await ctx.bot.send_document(
                    chat_id=uid,
                    document=InputFile(privacy_buffer, filename="Privacy_Policy_Terms.txt"),
                    caption=ctx.t.get('privacy_caption', 'üìú Privacy Policy & Terms of Use\n\nPlease read this document carefully.')
                )
        except Exception as e:
            logger.warning(f"Failed to send privacy document to {uid}: {e}")
        
        # Send user guide PDF after accepting terms
        cfg = get_user_config(uid) or {}
        if not cfg.get("guide_sent", 0):
            try:
                lang = cfg.get("lang", "en")
                pdf_buffer = get_user_guide_pdf(lang)
                guide_caption = ctx.t.get('guide_caption', 'üìö Trading Bot User Guide\n\nPlease read this guide to learn how to configure strategies and use the bot effectively.')
                await ctx.bot.send_document(
                    chat_id=uid,
                    document=InputFile(pdf_buffer, filename="Bybit_Trading_Bot_Guide.pdf"),
                    caption=guide_caption
                )
                set_user_field(uid, "guide_sent", 1)
            except Exception as e:
                logger.warning(f"Failed to send user guide PDF to {uid}: {e}")
        
        await ctx.bot.send_message(
            chat_id=uid,
            text=ctx.t["welcome"],
            reply_markup=main_menu_keyboard(ctx, update=update),
            parse_mode="HTML",
        )
    elif action == "decline":
        set_user_field(uid, "terms_accepted", False)  # Use False for boolean column
        await q.edit_message_text(ctx.t["terms_declined"])
    else:
        await q.answer(ctx.t.get("unknown_action", "Unknown action"), show_alert=True)


# ============================================================================
# Legal Disclaimer Handler (CRITICAL for compliance)
# ============================================================================
@with_texts
@log_calls
async def on_disclaimer_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle disclaimer acceptance/decline. Required for legal compliance."""
    q = update.callback_query
    await q.answer()
    uid = update.effective_user.id
    data = q.data or ""
    action = data.split(":", 1)[1] if ":" in data else ""

    if action == "accept":
        set_user_field(uid, "disclaimer_accepted", True)  # Use True for boolean column
        logger.info(f"[{uid}] Accepted legal disclaimer")
        
        accepted_text = ctx.t.get("disclaimer_accepted_msg", (
            "‚úÖ *Disclaimer Accepted*\n\n"
            "You have acknowledged that:\n"
            "‚Ä¢ This is an educational platform\n"
            "‚Ä¢ You are responsible for all trading decisions\n"
            "‚Ä¢ Past performance does not guarantee future results\n\n"
            "Welcome to Enliko Trading Tools!"
        ))
        await q.edit_message_text(accepted_text, parse_mode="Markdown")
        
        # Show main menu after accepting
        await ctx.bot.send_message(
            chat_id=uid,
            text=ctx.t["welcome"],
            reply_markup=main_menu_keyboard(ctx, update=update),
            parse_mode="HTML",
        )
        
    elif action == "decline":
        logger.info(f"[{uid}] Declined legal disclaimer")
        declined_text = ctx.t.get("disclaimer_declined_msg", (
            "‚ùå *Disclaimer Declined*\n\n"
            "You must accept the disclaimer to use Enliko Trading Tools.\n\n"
            "If you change your mind, use /start to begin again."
        ))
        await q.edit_message_text(declined_text, parse_mode="Markdown")
    else:
        await q.answer(ctx.t.get("unknown_action", "Unknown action"), show_alert=True)


# ============================================================================
# 2FA Login Confirmation Handler
# ============================================================================
@log_calls
async def on_twofa_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle 2FA approval/denial from bot buttons."""
    q = update.callback_query
    await q.answer()
    uid = update.effective_user.id
    data = q.data or ""
    
    logger.info(f"[2FA] on_twofa_cb triggered! uid={uid} data={data}")
    
    # Parse: twofa_approve:xxx or twofa_deny:xxx
    parts = data.split(":")
    if len(parts) != 2:
        logger.warning(f"[2FA] Invalid parts count: {len(parts)}, expected 2")
        return
    
    action = parts[0].replace("twofa_", "")  # approve or deny
    confirmation_id = parts[1]
    
    logger.info(f"[2FA] action={action} confirmation_id={confirmation_id}")
    
    try:
        from webapp.services import telegram_auth
        
        # Get user translations - use ctx.user_data or fallback to DB lang
        if not ctx.user_data.get('lang'):
            # Load language from DB if not in user_data
            db_lang = db.get_user_field(uid, "lang")
            if db_lang:
                ctx.user_data['lang'] = db_lang
        t = get_texts(ctx)
        
        if action == "approve":
            logger.info(f"[2FA] Calling confirm_2fa with approved=True for {confirmation_id}")
            success = telegram_auth.confirm_2fa(confirmation_id, approved=True)
            logger.info(f"[2FA] confirm_2fa result: {success}")
            if success:
                await q.edit_message_text(t.get("login_approved", "‚úÖ Login approved!\n\nYou can now continue in your browser."))
            else:
                await q.edit_message_text(t.get("login_expired", "‚è∞ Confirmation expired. Please try again."))
        else:  # deny
            logger.info(f"[2FA] Calling confirm_2fa with approved=False for {confirmation_id}")
            success = telegram_auth.confirm_2fa(confirmation_id, approved=False)
            logger.info(f"[2FA] confirm_2fa result: {success}")
            if success:
                await q.edit_message_text(t.get("login_denied", "‚ùå Login denied.\n\nIf this wasn't you, we recommend reviewing your security settings."))
            else:
                await q.edit_message_text(t.get("login_expired", "‚è∞ Confirmation expired. Please try again."))
                
    except Exception as e:
        logger.error(f"2FA callback error: {e}", exc_info=True)
        # Use ctx for translations (already loaded lang above)
        t = get_texts(ctx)
        await q.edit_message_text(t.get("login_error", "‚ö†Ô∏è Processing error. Please try again later."))


async def on_2fa_app_login_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """
    Handle 2FA confirmation for iOS/Android/Web app login.
    
    Called when user clicks "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—Ö–æ–¥" or "–û—Ç–∫–ª–æ–Ω–∏—Ç—å" buttons
    sent by /auth/telegram/request-2fa endpoint.
    
    Callback data format: 2fa_confirm:{request_id} or 2fa_reject:{request_id}
    """
    logger.info(f"[2FA] on_2fa_app_login_cb triggered! data={update.callback_query.data if update.callback_query else 'None'}")
    
    q = update.callback_query
    await q.answer()
    uid = update.effective_user.id
    data = q.data or ""
    
    logger.info(f"[2FA] User {uid} clicked 2FA button, data: {data}")
    
    # Parse: 2fa_confirm:xxx or 2fa_reject:xxx
    parts = data.split(":")
    if len(parts) != 2:
        logger.warning(f"[2FA] Invalid parts count: {len(parts)}, expected 2")
        return
    
    action = parts[0]  # 2fa_confirm or 2fa_reject
    request_id = parts[1]
    
    logger.info(f"[2FA] Parsed: action={action}, request_id={request_id}")
    
    t = get_texts(ctx)
    
    # Determine status
    if action == "2fa_confirm":
        status = "approved"
    else:
        status = "rejected"
    
    # Update status via API
    try:
        import aiohttp
        webapp_url = os.getenv("WEBAPP_URL", "https://enliko.com")
        
        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"{webapp_url}/api/auth/telegram/update-2fa-status",
                params={"request_id": request_id, "status": status},
                timeout=aiohttp.ClientTimeout(total=10)
            ) as resp:
                result = await resp.json()
                
                if resp.status == 200 and result.get("success"):
                    if status == "approved":
                        await q.edit_message_text(
                            t.get("app_login_approved", "‚úÖ <b>–í—Ö–æ–¥ –ø–æ–¥—Ç–≤–µ—Ä–∂–¥—ë–Ω!</b>\n\n–í—ã –º–æ–∂–µ—Ç–µ –ø—Ä–æ–¥–æ–ª–∂–∏—Ç—å –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏."),
                            parse_mode="HTML"
                        )
                    else:
                        await q.edit_message_text(
                            t.get("app_login_rejected", "‚ùå <b>–í—Ö–æ–¥ –æ—Ç–∫–ª–æ–Ω—ë–Ω</b>\n\n–ï—Å–ª–∏ —ç—Ç–æ –Ω–µ –≤—ã –ø—ã—Ç–∞–ª–∏—Å—å –≤–æ–π—Ç–∏, —Ä–µ–∫–æ–º–µ–Ω–¥—É–µ–º –ø—Ä–æ–≤–µ—Ä–∏—Ç—å –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏."),
                            parse_mode="HTML"
                        )
                else:
                    error_detail = result.get("detail", "Unknown error")
                    logger.error(f"2FA update failed: {error_detail}")
                    await q.edit_message_text(
                        t.get("app_login_expired", "‚è∞ –ó–∞–ø—Ä–æ—Å –Ω–∞ –≤—Ö–æ–¥ –∏—Å—Ç—ë–∫. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞."),
                        parse_mode="HTML"
                    )
                    
    except Exception as e:
        logger.error(f"2FA app login callback error: {e}")
        await q.edit_message_text(
            t.get("app_login_error", "‚ö†Ô∏è –û—à–∏–±–∫–∞ –æ–±—Ä–∞–±–æ—Ç–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ."),
            parse_mode="HTML"
        )


# ------------------------------------------------------------------------------------
# API Settings Menu - Block Structure (Bybit + HyperLiquid)
# ------------------------------------------------------------------------------------
def _mask_key(key: str | None) -> str:
    """Mask API key for display, showing only last 4 chars."""
    if not key:
        return ""
    if len(key) <= 4:
        return "‚Ä¢‚Ä¢‚Ä¢‚Ä¢"
    return f"‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢‚Ä¢{key[-4:]}"

def _mask_wallet(wallet: str | None) -> str:
    """Mask wallet address for display."""
    if not wallet:
        return "Not set"
    if len(wallet) <= 14:
        return wallet
    return f"{wallet[:6]}...{wallet[-4:]}"

def get_api_settings_keyboard(t: dict, creds: dict, uid: int = None) -> InlineKeyboardMarkup:
    """Build API settings keyboard with BLOCK structure.
    
    Structure:
    ‚ïê‚ïê‚ïê üü† BYBIT ‚ïê‚ïê‚ïê
    [Demo: ‚úÖ/‚ùå] [Real: ‚úÖ/‚ùå]
    [Test Demo] [Test Real]  
    [Clear Demo] [Clear Real]
    [Margin: CROSS/ISOLATED]
    [Trading: üü¢ ON / üî¥ OFF]
    
    ‚ïê‚ïê‚ïê üî∑ HYPERLIQUID ‚ïê‚ïê‚ïê
    [Testnet: ‚úÖ/‚ùå] [Mainnet: ‚úÖ/‚ùå]
    [Setup Testnet] [Setup Mainnet]
    [Test Connection]
    [Clear Testnet] [Clear Mainnet]
    [Margin: CROSS/ISOLATED]
    [Trading: üü¢ ON / üî¥ OFF]
    
    ‚ïê‚ïê‚ïê ‚öôÔ∏è GLOBAL ‚ïê‚ïê‚ïê
    [Trade Both: ON/OFF]
    """
    demo_key = creds.get("demo_api_key")
    demo_secret = creds.get("demo_api_secret")
    real_key = creds.get("real_api_key")
    real_secret = creds.get("real_api_secret")
    
    # Check which exchanges have keys configured
    bybit_demo_ok = bool(demo_key and demo_secret)
    bybit_real_ok = bool(real_key and real_secret)
    bybit_any = bybit_demo_ok or bybit_real_ok
    
    # Get exchange enabled status
    bybit_enabled = db.is_bybit_enabled(uid) if uid else True
    hl_enabled = db.is_hl_enabled(uid) if uid else False
    
    # Get HL configuration status (check both testnet and mainnet keys)
    hl_testnet_configured = False
    hl_mainnet_configured = False
    hl_testnet_wallet = ""
    hl_mainnet_wallet = ""
    
    if uid:
        hl_creds = db.get_hl_credentials(uid)
        hl_testnet_configured = bool(hl_creds.get("hl_testnet_private_key"))
        hl_mainnet_configured = bool(hl_creds.get("hl_mainnet_private_key"))
        hl_testnet_wallet = hl_creds.get("hl_testnet_wallet_address", "")
        hl_mainnet_wallet = hl_creds.get("hl_mainnet_wallet_address", "")
        
        # Fallback to legacy key
        if not hl_testnet_configured and not hl_mainnet_configured:
            legacy_key = hl_creds.get("hl_private_key")
            if legacy_key:
                if hl_creds.get("hl_testnet"):
                    hl_testnet_configured = True
                    hl_testnet_wallet = hl_creds.get("hl_wallet_address", "")
                else:
                    hl_mainnet_configured = True
                    hl_mainnet_wallet = hl_creds.get("hl_wallet_address", "")
    
    hl_any_configured = hl_testnet_configured or hl_mainnet_configured
    
    # Get multi-exchange mode (routing_policy)
    multi_exchange = False
    if uid:
        routing_policy = db.get_routing_policy(uid)
        multi_exchange = routing_policy == db.RoutingPolicy.ALL_ENABLED
    
    # Get margin mode settings
    bybit_margin = "cross"
    hl_margin = "cross"
    bybit_leverage = 10
    bybit_order_type = "market"
    bybit_coins = "ALL"
    hl_leverage = 10
    hl_order_type = "market"
    hl_coins = "ALL"
    
    if uid:
        bybit_margin = db.get_user_field(uid, "bybit_margin_mode") or "cross"
        hl_margin = db.get_user_field(uid, "hl_margin_mode") or "cross"
        bybit_leverage = db.get_user_field(uid, "bybit_leverage") or 10
        bybit_order_type = db.get_user_field(uid, "bybit_order_type") or "market"
        bybit_coins = db.get_user_field(uid, "bybit_coins_filter") or "ALL"
        hl_leverage = db.get_user_field(uid, "hl_leverage") or 10
        hl_order_type = db.get_user_field(uid, "hl_order_type") or "market"
        hl_coins = db.get_user_field(uid, "hl_coins_filter") or "ALL"
    
    # Status indicators
    demo_status = "‚úÖ" if bybit_demo_ok else "‚ùå"
    real_status = "‚úÖ" if bybit_real_ok else "‚ùå"
    testnet_status = "‚úÖ" if hl_testnet_configured else "‚ùå"
    mainnet_status = "‚úÖ" if hl_mainnet_configured else "‚ùå"
    
    bybit_trade_status = "üü¢ ON" if bybit_enabled else "üî¥ OFF"
    hl_trade_status = "üü¢ ON" if hl_enabled else "üî¥ OFF"
    multi_status = "üü¢ ON" if multi_exchange else "üî¥ OFF"
    
    bybit_margin_icon = "üîÑ" if bybit_margin == "cross" else "üì¶"
    hl_margin_icon = "üîÑ" if hl_margin == "cross" else "üì¶"
    
    buttons = []
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  BYBIT BLOCK  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    buttons.append([InlineKeyboardButton("‚ïê‚ïê‚ïê üü† BYBIT ‚ïê‚ïê‚ïê", callback_data="api:noop")])
    
    # Demo & Real status row
    buttons.append([
        InlineKeyboardButton(f"üß™ Demo: {demo_status}", callback_data="api:bybit_demo_setup"),
        InlineKeyboardButton(f"üíº Real: {real_status}", callback_data="api:bybit_real_setup"),
    ])
    
    # Test connections
    buttons.append([
        InlineKeyboardButton("üîÑ Test Demo", callback_data="api:test_demo"),
        InlineKeyboardButton("üîÑ Test Real", callback_data="api:test_real"),
    ])
    
    # Clear buttons
    if bybit_demo_ok or bybit_real_ok:
        clear_row = []
        if bybit_demo_ok:
            clear_row.append(InlineKeyboardButton("üóë Clear Demo", callback_data="api:delete_demo"))
        if bybit_real_ok:
            clear_row.append(InlineKeyboardButton("üóë Clear Real", callback_data="api:delete_real"))
        if clear_row:
            buttons.append(clear_row)
    
    # Bybit margin mode + coins group
    buttons.append([
        InlineKeyboardButton(f"{bybit_margin_icon} Margin: {bybit_margin.upper()}", callback_data="api:bybit_margin"),
        InlineKeyboardButton(f"ü™ô Coins: {bybit_coins}", callback_data="api:bybit_coins"),
    ])
    # Bybit leverage + order type
    order_icon = "üìä" if bybit_order_type == "market" else "üìù"
    buttons.append([
        InlineKeyboardButton(f"‚ö° Leverage: {bybit_leverage}x", callback_data="api:bybit_leverage"),
        InlineKeyboardButton(f"{order_icon} Order: {bybit_order_type.title()}", callback_data="api:bybit_order_type"),
    ])
    buttons.append([
        InlineKeyboardButton(f"Trading: {bybit_trade_status}", callback_data="api:toggle_bybit"),
    ])
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  HYPERLIQUID BLOCK  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    buttons.append([InlineKeyboardButton("‚ïê‚ïê‚ïê üî∑ HYPERLIQUID ‚ïê‚ïê‚ïê", callback_data="api:noop")])
    
    # Testnet & Mainnet status row  
    buttons.append([
        InlineKeyboardButton(f"üß™ Testnet: {testnet_status}", callback_data="api:hl_setup_testnet"),
        InlineKeyboardButton(f"üåê Mainnet: {mainnet_status}", callback_data="api:hl_setup_mainnet"),
    ])
    
    # Test connection (tests both configured networks)
    if hl_any_configured:
        buttons.append([InlineKeyboardButton("üîÑ Test Connection", callback_data="api:test_hl")])
    
    # Clear buttons
    if hl_testnet_configured or hl_mainnet_configured:
        clear_row = []
        if hl_testnet_configured:
            clear_row.append(InlineKeyboardButton("üóë Clear Testnet", callback_data="api:hl_clear_testnet"))
        if hl_mainnet_configured:
            clear_row.append(InlineKeyboardButton("üóë Clear Mainnet", callback_data="api:hl_clear_mainnet"))
        if clear_row:
            buttons.append(clear_row)
    
    # HL margin mode + coins group & trading toggle
    buttons.append([
        InlineKeyboardButton(f"{hl_margin_icon} Margin: {hl_margin.upper()}", callback_data="api:hl_margin"),
        InlineKeyboardButton(f"ü™ô Coins: {hl_coins}", callback_data="api:hl_coins"),
    ])
    # HL leverage + order type
    hl_order_icon = "üìä" if hl_order_type == "market" else "üìù"
    buttons.append([
        InlineKeyboardButton(f"‚ö° Leverage: {hl_leverage}x", callback_data="api:hl_leverage"),
        InlineKeyboardButton(f"{hl_order_icon} Order: {hl_order_type.title()}", callback_data="api:hl_order_type"),
    ])
    buttons.append([
        InlineKeyboardButton(f"Trading: {hl_trade_status}", callback_data="api:toggle_hl"),
    ])
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  GLOBAL SETTINGS  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    buttons.append([InlineKeyboardButton("‚ïê‚ïê‚ïê ‚öôÔ∏è GLOBAL ‚ïê‚ïê‚ïê", callback_data="api:noop")])
    
    # Multi-exchange trading (trade on both exchanges at once)
    buttons.append([
        InlineKeyboardButton(f"üîÄ Trade Both Exchanges: {multi_status}", callback_data="api:toggle_multi_exchange"),
    ])
    
    # Close button
    buttons.append([InlineKeyboardButton(t.get('btn_close', '‚ùå Close'), callback_data="api:close")])
    
    return InlineKeyboardMarkup(buttons)

def format_api_settings_message(t: dict, creds: dict, uid: int = None) -> str:
    """Format API settings message with BLOCK structure matching keyboard."""
    demo_key = creds.get("demo_api_key")
    demo_secret = creds.get("demo_api_secret")
    real_key = creds.get("real_api_key")
    real_secret = creds.get("real_api_secret")
    
    # Check connected exchanges
    bybit_demo_ok = bool(demo_key and demo_secret)
    bybit_real_ok = bool(real_key and real_secret)
    
    # HL credentials check
    hl_testnet_configured = False
    hl_mainnet_configured = False
    hl_testnet_wallet = ""
    hl_mainnet_wallet = ""
    bybit_enabled = True
    hl_enabled = False
    
    if uid:
        bybit_enabled = db.is_bybit_enabled(uid)
        hl_enabled = db.is_hl_enabled(uid)
        
        hl_creds = db.get_hl_credentials(uid)
        hl_testnet_configured = bool(hl_creds.get("hl_testnet_private_key"))
        hl_mainnet_configured = bool(hl_creds.get("hl_mainnet_private_key"))
        hl_testnet_wallet = hl_creds.get("hl_testnet_wallet_address", "")
        hl_mainnet_wallet = hl_creds.get("hl_mainnet_wallet_address", "")
        
        # Fallback to legacy key
        if not hl_testnet_configured and not hl_mainnet_configured:
            legacy_key = hl_creds.get("hl_private_key")
            if legacy_key:
                if hl_creds.get("hl_testnet"):
                    hl_testnet_configured = True
                    hl_testnet_wallet = hl_creds.get("hl_wallet_address", "")
                else:
                    hl_mainnet_configured = True
                    hl_mainnet_wallet = hl_creds.get("hl_wallet_address", "")
    
    # Status displays
    bybit_status = "üü¢ Trading" if bybit_enabled and (bybit_demo_ok or bybit_real_ok) else "üî¥ Off"
    hl_status = "üü¢ Trading" if hl_enabled and (hl_testnet_configured or hl_mainnet_configured) else "üî¥ Off"
    
    # Format displays
    demo_key_display = _mask_key(demo_key) if demo_key else "‚ùå Not set"
    demo_secret_display = _mask_key(demo_secret) if demo_secret else "‚ùå Not set"
    real_key_display = _mask_key(real_key) if real_key else "‚ùå Not set"
    real_secret_display = _mask_key(real_secret) if real_secret else "‚ùå Not set"
    
    testnet_wallet_display = _mask_wallet(hl_testnet_wallet) if hl_testnet_configured else "‚ùå Not set"
    mainnet_wallet_display = _mask_wallet(hl_mainnet_wallet) if hl_mainnet_configured else "‚ùå Not set"
    
    msg = f"""üîë <b>API Keys & Exchanges</b>

‚ïê‚ïê‚ïê üü† <b>BYBIT</b> ‚ïê‚ïê‚ïê  {bybit_status}

üß™ <b>Demo Account:</b>
‚îú API Key: <code>{demo_key_display}</code>
‚îî Secret: <code>{demo_secret_display}</code>

üíº <b>Real Account:</b>
‚îú API Key: <code>{real_key_display}</code>
‚îî Secret: <code>{real_secret_display}</code>

‚ïê‚ïê‚ïê üî∑ <b>HYPERLIQUID</b> ‚ïê‚ïê‚ïê  {hl_status}

üß™ <b>Testnet:</b>
‚îî Wallet: <code>{testnet_wallet_display}</code>

üåê <b>Mainnet:</b>
‚îî Wallet: <code>{mainnet_wallet_display}</code>

<i>üí° Tap buttons below to setup/test/clear credentials</i>"""
    
    return msg

@with_texts
@log_calls
async def cmd_api_settings(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show API settings menu."""
    uid = update.effective_user.id
    creds = get_all_user_credentials(uid)
    
    msg = format_api_settings_message(ctx.t, creds, uid)
    keyboard = get_api_settings_keyboard(ctx.t, creds, uid)
    
    await update.message.reply_text(
        msg,
        reply_markup=keyboard,
        parse_mode="HTML"
    )

@with_texts
@log_calls
async def on_api_settings_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle API settings callbacks."""
    q = update.callback_query
    uid = update.effective_user.id
    t = ctx.t
    
    action = q.data.split(":", 1)[1] if ":" in q.data else ""
    
    if action == "noop":
        await q.answer()
        return
    
    if action == "close":
        await q.answer()
        try:
            await q.message.delete()
        except Exception:
            pass
        return
    
    # Helper to safely edit message (ignores "not modified" error)
    async def safe_edit(text, reply_markup=None, parse_mode="HTML"):
        try:
            await q.edit_message_text(text, reply_markup=reply_markup, parse_mode=parse_mode)
        except BadRequest as e:
            if "not modified" not in str(e).lower():
                raise
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # BYBIT SETUP HANDLERS
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    
    if action == "bybit_demo_setup":
        await q.answer()
        ctx.user_data["mode"] = "enter_bybit_demo"
        ctx.user_data["api_step"] = "key"
        await safe_edit(
            "üß™ <b>Bybit Demo API Setup</b>\n\n"
            "Step 1/2: Enter your <b>Demo API Key</b>:\n\n"
            "<i>Get it from: bybit.com ‚Üí Account ‚Üí API Management</i>",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="api:back")]
            ])
        )
        return
    
    if action == "bybit_real_setup":
        await q.answer()
        ctx.user_data["mode"] = "enter_bybit_real"
        ctx.user_data["api_step"] = "key"
        await safe_edit(
            "üíº <b>Bybit Real API Setup</b>\n\n"
            "Step 1/2: Enter your <b>Real API Key</b>:\n\n"
            "‚ö†Ô∏è <b>Warning:</b> This connects to your REAL trading account!\n\n"
            "<i>Get it from: bybit.com ‚Üí Account ‚Üí API Management</i>",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="api:back")]
            ])
        )
        return
    
    if action == "bybit_clear_demo":
        delete_user_credentials(uid, "demo")
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await q.answer("üóë Demo credentials cleared", show_alert=True)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    if action == "bybit_clear_real":
        delete_user_credentials(uid, "real")
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await q.answer("üóë Real credentials cleared", show_alert=True)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # HYPERLIQUID SETUP HANDLERS
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    
    if action == "hl_setup_testnet":
        await q.answer()
        ctx.user_data["mode"] = "enter_hl_testnet"
        await safe_edit(
            "üß™ <b>HyperLiquid Testnet Setup</b>\n\n"
            "Enter your <b>Private Key</b> (API Wallet):\n\n"
            "üìñ <b>How to get API Wallet:</b>\n"
            "1. Go to <a href='https://testnet.hyperliquid.xyz/'>testnet.hyperliquid.xyz</a>\n"
            "2. Connect your main wallet\n"
            "3. Click profile icon ‚Üí Generate API Wallet\n"
            "4. Save and copy the Private Key\n\n"
            "‚ö†Ô∏è Never share your private key!",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="api:back")]
            ])
        )
        return
    
    if action == "hl_setup_mainnet":
        await q.answer()
        ctx.user_data["mode"] = "enter_hl_mainnet"
        await safe_edit(
            "üåê <b>HyperLiquid Mainnet Setup</b>\n\n"
            "Enter your <b>Private Key</b> (API Wallet):\n\n"
            "üìñ <b>How to get API Wallet:</b>\n"
            "1. Go to <a href='https://app.hyperliquid.xyz/'>app.hyperliquid.xyz</a>\n"
            "2. Connect your main wallet\n"
            "3. Click profile icon ‚Üí Generate API Wallet\n"
            "4. Save and copy the Private Key\n\n"
            "‚ö†Ô∏è <b>Warning:</b> This connects to REAL funds!\n"
            "‚ö†Ô∏è Never share your private key!",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="api:back")]
            ])
        )
        return
    
    if action == "hl_clear_testnet":
        db.set_user_field(uid, "hl_testnet_private_key", None)
        db.set_user_field(uid, "hl_testnet_wallet_address", None)
        db.invalidate_user_cache(uid)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await q.answer("üóë Testnet credentials cleared", show_alert=True)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    if action == "hl_clear_mainnet":
        db.set_user_field(uid, "hl_mainnet_private_key", None)
        db.set_user_field(uid, "hl_mainnet_wallet_address", None)
        db.invalidate_user_cache(uid)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await q.answer("üóë Mainnet credentials cleared", show_alert=True)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    if action == "test_hl":
        await q.answer("üîÑ Testing HyperLiquid...")
        
        hl_creds = db.get_hl_credentials(uid)
        testnet_key = hl_creds.get("hl_testnet_private_key")
        mainnet_key = hl_creds.get("hl_mainnet_private_key")
        
        results = []
        
        # Test Testnet
        if testnet_key:
            try:
                adapter = HLAdapter(private_key=testnet_key, testnet=True)
                await adapter.initialize()
                balance = await adapter.get_balance()
                equity = balance.get("equity", 0)
                results.append(f"üß™ <b>Testnet:</b> ‚úÖ ${equity:.2f}")
            except Exception as e:
                results.append(f"üß™ <b>Testnet:</b> ‚ùå {str(e)[:50]}")
        else:
            results.append("üß™ <b>Testnet:</b> ‚ö™ Not configured")
        
        # Test Mainnet
        if mainnet_key:
            try:
                adapter = HLAdapter(private_key=mainnet_key, testnet=False)
                await adapter.initialize()
                balance = await adapter.get_balance()
                equity = balance.get("equity", 0)
                results.append(f"üåê <b>Mainnet:</b> ‚úÖ ${equity:.2f}")
            except Exception as e:
                results.append(f"üåê <b>Mainnet:</b> ‚ùå {str(e)[:50]}")
        else:
            results.append("üåê <b>Mainnet:</b> ‚ö™ Not configured")
        
        test_msg = "üî∑ <b>HyperLiquid Connection Test</b>\n\n" + "\n".join(results)
        
        creds = get_all_user_credentials(uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(test_msg, reply_markup=keyboard)
        return
    
    # ‚îÄ‚îÄ‚îÄ Show main API Settings menu ‚îÄ‚îÄ‚îÄ
    if action == "settings":
        await q.answer()
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    # ‚îÄ‚îÄ‚îÄ HyperLiquid Settings ‚îÄ‚îÄ‚îÄ
    if action == "hl_settings":
        await q.answer()
        # Redirect to HL settings
        from db import get_hl_credentials
        hl_creds = get_hl_credentials(uid)
        
        # Build HL settings message and keyboard
        is_testnet = hl_creds.get("hl_testnet", False)
        network = "üß™ Testnet" if is_testnet else "üåê Mainnet"
        wallet = hl_creds.get("hl_testnet_wallet_address" if is_testnet else "hl_mainnet_wallet_address", "")
        wallet_display = f"{wallet[:8]}...{wallet[-6:]}" if wallet and len(wallet) > 14 else (wallet or "Not set")
        
        hl_msg = f"""üî∑ <b>HyperLiquid Settings</b>

<b>Network:</b> {network}
<b>Wallet:</b> <code>{wallet_display}</code>

Use the buttons below to configure:"""
        
        hl_buttons = [
            [
                InlineKeyboardButton("üß™ Testnet" if not is_testnet else "‚úÖ Testnet", callback_data="hl_api:testnet"),
                InlineKeyboardButton("üåê Mainnet" if is_testnet else "‚úÖ Mainnet", callback_data="hl_api:mainnet"),
            ],
            [InlineKeyboardButton("üîë Set Private Key", callback_data="hl_api:set_key")],
            [InlineKeyboardButton("üîÑ Test Connection", callback_data="hl_api:test")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="api:back")],
        ]
        
        await safe_edit(hl_msg, reply_markup=InlineKeyboardMarkup(hl_buttons))
        return
    
    # ‚îÄ‚îÄ‚îÄ Back to main API menu ‚îÄ‚îÄ‚îÄ
    if action == "back":
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await q.answer()
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    # Enter API key/secret
    if action in ("demo_key", "demo_secret", "real_key", "real_secret"):
        await q.answer()
        prompts = {
            "demo_key": t.get("api_enter_demo_key", "Enter Demo API Key:"),
            "demo_secret": t.get("api_enter_demo_secret", "Enter Demo API Secret:"),
            "real_key": t.get("api_enter_real_key", "Enter Real API Key:"),
            "real_secret": t.get("api_enter_real_secret", "Enter Real API Secret:"),
        }
        ctx.user_data["mode"] = f"enter_api_{action}"
        await safe_edit(prompts[action])
        return
    
    # Delete credentials
    if action == "delete_demo":
        delete_user_credentials(uid, "demo")
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds)
        keyboard = get_api_settings_keyboard(t, creds)
        await q.answer(t.get("api_deleted", "API deleted for {account}").format(account="Demo"), show_alert=True)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    if action == "delete_real":
        delete_user_credentials(uid, "real")
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds)
        keyboard = get_api_settings_keyboard(t, creds)
        await q.answer(t.get("api_deleted", "API deleted for {account}").format(account="Real"), show_alert=True)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    # ‚îÄ‚îÄ‚îÄ Toggle Exchange Trading ‚îÄ‚îÄ‚îÄ
    if action == "toggle_bybit":
        current = db.is_bybit_enabled(uid)
        new_val = not current
        db.set_bybit_enabled(uid, new_val)
        
        status = "üü¢ ON" if new_val else "üî¥ OFF"
        await q.answer(f"Bybit Trading: {status}", show_alert=False)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    if action == "toggle_hl":
        current = db.is_hl_enabled(uid)
        new_val = not current
        db.set_hl_enabled(uid, new_val)
        
        status = "üü¢ ON" if new_val else "üî¥ OFF"
        await q.answer(f"HyperLiquid Trading: {status}", show_alert=False)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    # ‚îÄ‚îÄ‚îÄ Toggle Multi-Exchange Trading ‚îÄ‚îÄ‚îÄ
    if action == "toggle_multi_exchange":
        current_policy = db.get_routing_policy(uid)
        is_multi = current_policy == db.RoutingPolicy.ALL_ENABLED
        
        if is_multi:
            # Disable multi-exchange ‚Üí use current exchange only
            new_policy = db.RoutingPolicy.SAME_EXCHANGE_ALL_ENVS
        else:
            # Enable multi-exchange ‚Üí trade on ALL enabled exchanges
            new_policy = db.RoutingPolicy.ALL_ENABLED
        
        db.set_routing_policy(uid, new_policy)
        
        if new_policy == db.RoutingPolicy.ALL_ENABLED:
            status = "üü¢ ON"
            msg_text = "‚ö†Ô∏è Multi-Exchange Trading ENABLED!\n\nSignals will open positions on BOTH Bybit AND HyperLiquid simultaneously."
        else:
            status = "üî¥ OFF"
            msg_text = "Multi-Exchange Trading disabled. Signals will only trade on your active exchange."
        
        await q.answer(f"Trade Both Exchanges: {status}", show_alert=False)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    # ‚îÄ‚îÄ‚îÄ Margin Mode Toggle ‚îÄ‚îÄ‚îÄ
    if action == "bybit_margin":
        current = db.get_user_field(uid, "bybit_margin_mode") or "cross"
        new_mode = "isolated" if current == "cross" else "cross"
        db.set_user_field(uid, "bybit_margin_mode", new_mode)
        
        mode_emoji = "üì¶ ISOLATED" if new_mode == "isolated" else "üîÑ CROSS"
        await q.answer(f"Bybit Margin Mode: {mode_emoji}", show_alert=True)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    if action == "hl_margin":
        current = db.get_user_field(uid, "hl_margin_mode") or "cross"
        new_mode = "isolated" if current == "cross" else "cross"
        db.set_user_field(uid, "hl_margin_mode", new_mode)
        
        mode_emoji = "üì¶ ISOLATED" if new_mode == "isolated" else "üîÑ CROSS"
        await q.answer(f"HyperLiquid Margin Mode: {mode_emoji}", show_alert=True)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    # ‚îÄ‚îÄ‚îÄ Coins Group Selection ‚îÄ‚îÄ‚îÄ
    if action == "bybit_coins":
        current = db.get_user_field(uid, "bybit_coins_group") or "ALL"
        
        buttons = [
            [InlineKeyboardButton(("‚úì " if current == "ALL" else "") + "üåê ALL", callback_data="api:bybit_coins_set:ALL")],
            [InlineKeyboardButton(("‚úì " if current == "TOP" else "") + "üíé TOP", callback_data="api:bybit_coins_set:TOP")],
            [InlineKeyboardButton(("‚úì " if current == "VOLATILE" else "") + "üî• VOLATILE", callback_data="api:bybit_coins_set:VOLATILE")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="api:back")],
        ]
        
        await q.answer()
        await safe_edit(
            "üü† <b>Bybit Coins Filter</b>\n\n"
            "Select which coins to trade:\n\n"
            "üåê <b>ALL</b> - All available coins\n"
            "üíé <b>TOP</b> - Top liquid coins only\n"
            "üî• <b>VOLATILE</b> - High volatility coins",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
        return
    
    if action.startswith("bybit_coins_set:"):
        group = action.split(":")[1]  # ALL, TOP, VOLATILE
        db.set_user_field(uid, "bybit_coins_group", group)
        
        await q.answer(f"Bybit Coins: {group}", show_alert=False)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    if action == "hl_coins":
        current = db.get_user_field(uid, "hl_coins_group") or "ALL"
        
        buttons = [
            [InlineKeyboardButton(("‚úì " if current == "ALL" else "") + "üåê ALL", callback_data="api:hl_coins_set:ALL")],
            [InlineKeyboardButton(("‚úì " if current == "TOP" else "") + "üíé TOP", callback_data="api:hl_coins_set:TOP")],
            [InlineKeyboardButton(("‚úì " if current == "VOLATILE" else "") + "üî• VOLATILE", callback_data="api:hl_coins_set:VOLATILE")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="api:back")],
        ]
        
        await q.answer()
        await safe_edit(
            "üî∑ <b>HyperLiquid Coins Filter</b>\n\n"
            "Select which coins to trade:\n\n"
            "üåê <b>ALL</b> - All available coins\n"
            "üíé <b>TOP</b> - Top liquid coins only\n"
            "üî• <b>VOLATILE</b> - High volatility coins",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
        return
    
    if action.startswith("hl_coins_set:"):
        group = action.split(":")[1]  # ALL, TOP, VOLATILE
        db.set_user_field(uid, "hl_coins_group", group)
        
        await q.answer(f"HyperLiquid Coins: {group}", show_alert=False)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    # ‚îÄ‚îÄ‚îÄ Leverage Settings ‚îÄ‚îÄ‚îÄ
    LEVERAGE_OPTIONS = [1, 2, 3, 5, 10, 20, 25, 50, 100]
    
    if action == "bybit_leverage":
        current = db.get_user_field(uid, "bybit_leverage") or 10
        # Cycle to next leverage
        try:
            idx = LEVERAGE_OPTIONS.index(int(current))
            new_lev = LEVERAGE_OPTIONS[(idx + 1) % len(LEVERAGE_OPTIONS)]
        except ValueError:
            new_lev = 10
        
        db.set_user_field(uid, "bybit_leverage", new_lev)
        await q.answer(f"Bybit Leverage: {new_lev}x", show_alert=False)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    if action == "hl_leverage":
        current = db.get_user_field(uid, "hl_leverage") or 10
        # Cycle to next leverage
        try:
            idx = LEVERAGE_OPTIONS.index(int(current))
            new_lev = LEVERAGE_OPTIONS[(idx + 1) % len(LEVERAGE_OPTIONS)]
        except ValueError:
            new_lev = 10
        
        db.set_user_field(uid, "hl_leverage", new_lev)
        await q.answer(f"HyperLiquid Leverage: {new_lev}x", show_alert=False)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    # ‚îÄ‚îÄ‚îÄ Order Type Settings ‚îÄ‚îÄ‚îÄ
    if action == "bybit_order_type":
        current = db.get_user_field(uid, "bybit_order_type") or "market"
        new_type = "limit" if current == "market" else "market"
        db.set_user_field(uid, "bybit_order_type", new_type)
        
        type_emoji = "üìä Market" if new_type == "market" else "üìù Limit"
        await q.answer(f"Bybit Order: {type_emoji}", show_alert=True)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    if action == "hl_order_type":
        current = db.get_user_field(uid, "hl_order_type") or "market"
        new_type = "limit" if current == "market" else "market"
        db.set_user_field(uid, "hl_order_type", new_type)
        
        type_emoji = "üìä Market" if new_type == "market" else "üìù Limit"
        await q.answer(f"HyperLiquid Order: {type_emoji}", show_alert=True)
        
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        await safe_edit(msg, reply_markup=keyboard)
        return
    
    # Test connection
    if action in ("test_demo", "test_real"):
        account_type = "demo" if action == "test_demo" else "real"
        account_emoji = "üß™" if account_type == "demo" else "üíº"
        account_name = t.get("api_mode_demo", "Demo") if account_type == "demo" else t.get("api_mode_real", "Real")
        
        try:
            result = await _bybit_request(
                uid, "GET", "/v5/account/wallet-balance",
                params={"accountType": "UNIFIED", "coin": "USDT"},
                account_type=account_type
            )
            coins = result.get("list", [{}])[0].get("coin", [])
            usdt = next((c for c in coins if c.get("coin") == "USDT"), {})
            
            balance = _safe_float(usdt.get("walletBalance"))
            equity = _safe_float(usdt.get("equity"))
            available = _safe_float(usdt.get("availableToWithdraw"))
            
            test_msg = f"""‚úÖ <b>{t.get('api_test_success', 'Connection Successful!')}</b>

{account_emoji} <b>{account_name}</b>

üí∞ {t.get('balance_wallet', 'Wallet Balance')}: <b>{balance:.2f}</b> USDT
üíé {t.get('balance_equity', 'Equity')}: <b>{equity:.2f}</b> USDT
‚ú® {t.get('balance_available', 'Available')}: <b>{available:.2f}</b> USDT

üîó {t.get('api_test_status', 'Status')}: üü¢ {t.get('api_test_connected', 'Connected')}"""
            
            await q.answer("‚úÖ")
            creds = get_all_user_credentials(uid)
            keyboard = get_api_settings_keyboard(t, creds)
            try:
                await q.edit_message_text(test_msg, reply_markup=keyboard, parse_mode="HTML")
            except BadRequest:
                pass
        except MissingAPICredentials:
            test_msg = f"""{account_emoji} <b>{account_name}</b>

‚ùå <b>{t.get('api_test_no_keys', 'API Keys Not Set')}</b>

{t.get('api_test_set_keys', 'Please set API Key and Secret first.')}"""
            
            await q.answer("‚ùå")
            creds = get_all_user_credentials(uid)
            keyboard = get_api_settings_keyboard(t, creds)
            try:
                await q.edit_message_text(test_msg, reply_markup=keyboard, parse_mode="HTML")
            except BadRequest:
                pass
        except Exception as e:
            test_msg = f"""{account_emoji} <b>{account_name}</b>

‚ùå <b>{t.get('api_test_failed', 'Connection Failed')}</b>

{t.get('api_test_error', 'Error')}: <code>{str(e)[:100]}</code>

{t.get('api_test_check_keys', 'Please check your API credentials.')}"""
            
            await q.answer("‚ùå")
            creds = get_all_user_credentials(uid)
            keyboard = get_api_settings_keyboard(t, creds)
            try:
                await q.edit_message_text(test_msg, reply_markup=keyboard, parse_mode="HTML")
            except BadRequest:
                pass
        return
    
    # Unknown action - just answer to dismiss loading
    await q.answer()


# ==============================================================================
# SPOT SETTINGS HANDLERS
# ==============================================================================

def get_spot_settings_keyboard(t: dict, cfg: dict, spot_settings: dict) -> InlineKeyboardMarkup:
    """Build keyboard for Spot DCA settings - Compact & User-Friendly."""
    # Get settings
    spot_enabled = cfg.get("spot_enabled", 0)
    trading_mode = spot_settings.get("trading_mode", "demo")
    strategy = spot_settings.get("strategy", "fixed")
    amount = spot_settings.get("dca_amount", SPOT_DCA_DEFAULT_AMOUNT)
    auto_dca = spot_settings.get("auto_dca", False)
    tp_enabled = spot_settings.get("tp_enabled", False)
    
    # Strategy info
    strategy_info = SMART_DCA_STRATEGIES.get(strategy, SMART_DCA_STRATEGIES["fixed"])
    strategy_label = f"{strategy_info['emoji']} {strategy_info['name']}"
    
    # Status emojis
    enabled_emoji = "‚úÖ" if spot_enabled else "‚ùå"
    mode_emoji = "üß™" if trading_mode == "demo" else "üí∞"
    auto_emoji = "‚úÖ" if auto_dca else "‚ùå"
    tp_emoji = "‚úÖ" if tp_enabled else "‚ùå"
    
    buttons = []
    
    # Row 1: Enable/Disable + Mode
    buttons.append([
        InlineKeyboardButton(f"{enabled_emoji} Spot", callback_data="spot:enable_toggle"),
        InlineKeyboardButton(f"{mode_emoji} {trading_mode.title()}", callback_data="spot:mode"),
    ])
    
    # Row 2: Strategy + Amount
    buttons.append([
        InlineKeyboardButton(f"üéØ {strategy_label}", callback_data="spot:strategy"),
        InlineKeyboardButton(f"üíµ {amount}$", callback_data="spot:amount"),
    ])
    
    # Row 3: Auto DCA + Auto TP (only if enabled)
    if spot_enabled:
        buttons.append([
            InlineKeyboardButton(f"üîÑ Auto: {auto_emoji}", callback_data="spot:auto_toggle"),
            InlineKeyboardButton(f"üìà TP: {tp_emoji}", callback_data="spot:tp_toggle"),
        ])
    
    # Strategy-specific settings
    if strategy == "dip_buy":
        dip_threshold = spot_settings.get("dip_threshold", 5.0)
        buttons.append([
            InlineKeyboardButton(f"üìâ Dip: -{dip_threshold}%", callback_data="spot:dip_threshold"),
        ])
    elif strategy == "fear_greed":
        fear_threshold = spot_settings.get("fear_threshold", 25)
        buttons.append([
            InlineKeyboardButton(f"üò± Fear Index: <{fear_threshold}", callback_data="spot:fear_threshold"),
        ])
    
    # Row 4: Coins selection
    portfolio = spot_settings.get("portfolio", "custom")
    coins = spot_settings.get("coins", SPOT_DCA_COINS)
    if portfolio != "custom":
        portfolio_info = SPOT_PORTFOLIOS.get(portfolio, {})
        coins_label = f"{portfolio_info.get('emoji', 'üìÅ')} {portfolio_info.get('name', portfolio)}"
    else:
        coins_label = ", ".join(coins[:2]) + (f"+{len(coins)-2}" if len(coins) > 2 else "")
    buttons.append([
        InlineKeyboardButton(f"ü™ô {coins_label}", callback_data="spot:coins"),
    ])
    
    # Action buttons (only if enabled)
    if spot_enabled:
        buttons.append([
            InlineKeyboardButton(t.get("spot_btn_buy", "üí∞ Buy Now"), callback_data="spot:buy_now"),
            InlineKeyboardButton(t.get("spot_btn_holdings", "üíé Holdings"), callback_data="spot:holdings"),
        ])
        buttons.append([
            InlineKeyboardButton(t.get("spot_btn_rebalance", "‚öñÔ∏è Rebalance"), callback_data="spot:rebalance_now"),
        ])
    
    # Back button
    buttons.append([
        InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="spot:back_to_strategies"),
    ])
    
    return InlineKeyboardMarkup(buttons)


def format_spot_settings_message(t: dict, cfg: dict, spot_settings: dict) -> str:
    """Format Spot DCA settings message - Compact version."""
    spot_enabled = cfg.get("spot_enabled", 0)
    coins = spot_settings.get("coins", SPOT_DCA_COINS)
    amount = spot_settings.get("dca_amount", SPOT_DCA_DEFAULT_AMOUNT)
    total_invested = spot_settings.get("total_invested", 0.0)
    trading_mode = spot_settings.get("trading_mode", "demo")
    strategy = spot_settings.get("strategy", "fixed")
    portfolio = spot_settings.get("portfolio", "custom")
    
    # Get strategy info
    strategy_info = SMART_DCA_STRATEGIES.get(strategy, SMART_DCA_STRATEGIES["fixed"])
    strategy_label = f"{strategy_info['emoji']} {strategy_info['name']}"
    
    # Get portfolio info
    portfolio_info = SPOT_PORTFOLIOS.get(portfolio, SPOT_PORTFOLIOS.get("custom", {}))
    
    # Status
    enabled_label = t.get('toggle_on', '‚úÖ Enabled') if spot_enabled else t.get('toggle_off', '‚ùå Disabled')
    mode_label = t.get('mode_demo', 'üß™ Demo') if trading_mode == "demo" else t.get('mode_real', 'üí∞ Real')
    
    # Coins display
    if portfolio != "custom" and portfolio_info.get("coins"):
        coins_list = [f"{c}: {p}%" for c, p in portfolio_info["coins"].items()]
        coins_display = ", ".join(coins_list)
    else:
        coins_display = ", ".join(coins) if isinstance(coins, list) else str(coins)
    
    lines = [
        "üíπ <b>Spot DCA Settings</b>",
        "",
        f"<b>Status:</b> {enabled_label}",
        f"<b>Mode:</b> {mode_label}",
        f"<b>Strategy:</b> {strategy_label}",
        f"<b>Amount:</b> {amount} USDT",
        f"<b>Coins:</b> {coins_display}",
    ]
    
    if total_invested > 0:
        lines.append(f"<b>Total Invested:</b> ${total_invested:.2f}")
    
    # Strategy description
    lines.append("")
    lines.append(f"<i>{strategy_info.get('description', '')}</i>")
    
    return "\n".join(lines)


@with_texts
@log_calls
async def cmd_spot_portfolio(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handler for Spot button in main menu - shows portfolio directly."""
    uid = update.effective_user.id
    t = ctx.t
    
    cfg = db.get_user_config(uid)
    spot_settings = cfg.get("spot_settings") or {}
    account_type = spot_settings.get("trading_mode", "demo")
    
    # Show loading message
    loading_msg = await update.message.reply_text(
        "üíπ Loading Spot Portfolio...",
        parse_mode="HTML"
    )
    
    try:
        balances = await fetch_spot_balance(uid, account_type=account_type)
        
        if not balances:
            await loading_msg.edit_text(
                "üíπ <b>Spot Portfolio</b>\n\n"
                "‚ùå No spot balance found.\n\n"
                "To start using Spot trading:\n"
                "1. Add funds to your Bybit account\n"
                "2. Transfer to UNIFIED account\n"
                "3. Use üí∞ Buy Now to purchase coins",
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚öôÔ∏è Spot Settings", callback_data="spot:back_to_main")],
                ])
            )
            return
        
        # Get prices for all coins in parallel
        total_usd_value = 0.0
        holdings_data = []
        
        # Filter coins with balance
        filtered_balances = {c: amt for c, amt in balances.items() if amt > 0.00001}
        
        # Fetch prices in parallel
        price_tasks = {}
        for coin in filtered_balances:
            if coin != "USDT":
                symbol = f"{coin}USDT"
                price_tasks[coin] = asyncio.create_task(get_spot_ticker(uid, symbol, account_type))
        
        # Wait for all prices
        for coin, task in price_tasks.items():
            try:
                ticker = await task
                price = float(ticker.get("lastPrice", 0)) if ticker else 0
                price_change_24h = float(ticker.get("price24hPcnt", 0)) * 100 if ticker else 0
                amount = filtered_balances[coin]
                usd_value = amount * price
                total_usd_value += usd_value
                holdings_data.append({
                    "coin": coin,
                    "amount": amount,
                    "price": price,
                    "usd_value": usd_value,
                    "change_24h": price_change_24h,
                })
            except Exception as e:
                logger.warning(f"Failed to get price for {coin}: {e}")
                holdings_data.append({
                    "coin": coin,
                    "amount": filtered_balances[coin],
                    "price": 0,
                    "usd_value": 0,
                    "change_24h": 0,
                })
        
        # Add USDT if present
        if "USDT" in filtered_balances:
            usdt_amt = filtered_balances["USDT"]
            total_usd_value += usdt_amt
            holdings_data.append({
                "coin": "USDT",
                "amount": usdt_amt,
                "price": 1.0,
                "usd_value": usdt_amt,
                "change_24h": 0,
            })
        
        # Sort by USD value descending
        holdings_data.sort(key=lambda x: x["usd_value"], reverse=True)
        
        # Format message
        mode_label = "üß™ Demo" if account_type == "demo" else "üí∞ Real"
        lines = [
            f"üíπ <b>Spot Portfolio</b> {mode_label}",
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            f"üíµ <b>Total Value:</b> ${total_usd_value:,.2f}",
            "",
        ]
        
        for h in holdings_data:
            coin = h["coin"]
            amount = h["amount"]
            usd_value = h["usd_value"]
            change = h["change_24h"]
            
            # Format change with emoji
            if change > 0:
                change_str = f"üü¢ +{change:.2f}%"
            elif change < 0:
                change_str = f"üî¥ {change:.2f}%"
            else:
                change_str = "‚ö™ 0.00%"
            
            # Format amount (shorter for readability)
            if amount >= 1:
                amt_str = f"{amount:,.4f}"
            else:
                amt_str = f"{amount:.8f}"
            
            if coin == "USDT":
                lines.append(f"üíµ <b>USDT:</b> ${usd_value:,.2f}")
            else:
                lines.append(f"ü™ô <b>{coin}:</b> {amt_str}")
                lines.append(f"   ‚îî ${usd_value:,.2f} | {change_str}")
        
        holdings_msg = "\n".join(lines)
        
        # Build keyboard with action buttons
        buttons = []
        
        # Quick sell buttons for non-USDT coins
        sellable = [h for h in holdings_data if h["coin"] != "USDT" and h["usd_value"] > 1]
        if sellable:
            buttons.append([InlineKeyboardButton(t.get("spot_btn_sell", "üí∏ Sell Menu"), callback_data="spot:sell_menu")])
        
        # Action buttons
        buttons.append([
            InlineKeyboardButton(t.get("btn_refresh", "üîÑ Refresh"), callback_data="spot:holdings"),
            InlineKeyboardButton(t.get("spot_btn_rebalance", "‚öñÔ∏è Rebalance"), callback_data="spot:rebalance_now"),
        ])
        
        buttons.append([
            InlineKeyboardButton(t.get("spot_btn_settings", "‚öôÔ∏è Settings"), callback_data="spot:back_to_main"),
        ])
        
        await loading_msg.edit_text(
            holdings_msg,
            reply_markup=InlineKeyboardMarkup(buttons),
            parse_mode="HTML"
        )
        
    except Exception as e:
        logger.error(f"Error in cmd_spot_portfolio: {e}")
        await loading_msg.edit_text(
            f"‚ùå Error loading portfolio: {str(e)}",
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚öôÔ∏è Spot Settings", callback_data="spot:back_to_main")],
            ])
        )


@with_texts
@log_calls
async def cmd_spot_settings(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handler for Spot Settings button in main menu."""
    uid = update.effective_user.id
    t = ctx.t
    
    cfg = db.get_user_config(uid)
    
    # Check if spot is enabled
    if not cfg.get("spot_enabled", 0):
        await update.message.reply_text(
            t.get("spot_not_enabled", "‚ùå Spot trading is not enabled. Enable it in API Settings first."),
            parse_mode="HTML"
        )
        return
    
    spot_settings = cfg.get("spot_settings") or {}
    if not spot_settings:
        # Initialize default spot settings
        spot_settings = {
            "coins": SPOT_DCA_COINS.copy() if isinstance(SPOT_DCA_COINS, list) else SPOT_DCA_COINS.split(","),
            "dca_amount": SPOT_DCA_DEFAULT_AMOUNT,
            "frequency": "manual",
            "auto_dca": False,
            "total_invested": 0.0,
        }
    
    msg = format_spot_settings_message(t, cfg, spot_settings)
    keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
    
    await update.message.reply_text(msg, reply_markup=keyboard, parse_mode="HTML")


@with_texts
@log_calls
async def on_spot_settings_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Callback handler for Spot settings inline buttons."""
    q = update.callback_query
    await q.answer()
    
    uid = q.from_user.id
    t = ctx.t
    data = q.data  # "spot:action"
    
    if not data.startswith("spot:"):
        return
    
    action = data.split(":", 1)[1]
    cfg = db.get_user_config(uid)
    spot_settings = cfg.get("spot_settings") or {}
    
    if not spot_settings:
        spot_settings = {
            "coins": SPOT_DCA_COINS.copy() if isinstance(SPOT_DCA_COINS, list) else SPOT_DCA_COINS.split(","),
            "dca_amount": SPOT_DCA_DEFAULT_AMOUNT,
            "frequency": "manual",
            "auto_dca": False,
            "total_invested": 0.0,
            "trailing_tp": SPOT_TRAILING_TP_DEFAULTS.copy(),
            "trailing_state": {},
            "grids": {},
            "purchase_history": {},
        }
    
    # Handle enable/disable toggle
    if action == "enable_toggle":
        current = cfg.get("spot_enabled", 0)
        new_value = 0 if current else 1
        db.set_user_field(uid, "spot_enabled", new_value)
        
        status = "‚úÖ Spot enabled" if new_value else "‚ùå Spot disabled"
        await q.answer(status)
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    # Handle actions
    if action == "coins":
        # Show coin selection
        available_coins = SPOT_DCA_COINS if isinstance(SPOT_DCA_COINS, list) else SPOT_DCA_COINS.split(",")
        current_coins = spot_settings.get("coins", available_coins)
        
        buttons = []
        for coin in available_coins:
            is_selected = coin in current_coins
            emoji = "‚úÖ" if is_selected else "‚¨ú"
            buttons.append([InlineKeyboardButton(
                f"{emoji} {coin}",
                callback_data=f"spot:coin_toggle:{coin}"
            )])
        buttons.append([InlineKeyboardButton(
            t.get("spot_btn_back", "‚¨ÖÔ∏è Back"),
            callback_data="spot:back_to_main"
        )])
        
        try:
            await q.edit_message_text(
                t.get("spot_select_coins", "Select coins for Spot DCA:"),
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action.startswith("coin_toggle:"):
        coin = action.split(":")[1]
        current_coins = list(spot_settings.get("coins", []))
        
        if coin in current_coins:
            if len(current_coins) > 1:  # Don't allow empty selection
                current_coins.remove(coin)
        else:
            current_coins.append(coin)
        
        spot_settings["coins"] = current_coins
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        
        # Refresh coin selection
        available_coins = SPOT_DCA_COINS if isinstance(SPOT_DCA_COINS, list) else SPOT_DCA_COINS.split(",")
        buttons = []
        for c in available_coins:
            is_selected = c in current_coins
            emoji = "‚úÖ" if is_selected else "‚¨ú"
            buttons.append([InlineKeyboardButton(
                f"{emoji} {c}",
                callback_data=f"spot:coin_toggle:{c}"
            )])
        buttons.append([InlineKeyboardButton(
            t.get("spot_btn_back", "‚¨ÖÔ∏è Back"),
            callback_data="spot:back_to_main"
        )])
        
        try:
            await q.edit_message_reply_markup(reply_markup=InlineKeyboardMarkup(buttons))
        except BadRequest:
            pass
        return
    
    if action == "amount":
        ctx.user_data["spot_awaiting"] = "amount"
        try:
            await q.edit_message_text(
                t.get("spot_enter_amount", "Enter DCA amount in USDT:"),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action == "frequency":
        # Cycle through frequencies (includes hourly and biweekly)
        freqs = ["manual", "hourly", "daily", "weekly", "biweekly", "monthly"]
        current = spot_settings.get("frequency", "manual")
        idx = freqs.index(current) if current in freqs else 0
        new_freq = freqs[(idx + 1) % len(freqs)]
        
        spot_settings["frequency"] = new_freq
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        
        freq_labels = {
            "manual": "‚è∏Ô∏è Manual",
            "hourly": t.get("spot_freq_hourly", "‚è∞ Hourly"),
            "daily": t.get("spot_freq_daily", "Daily"),
            "weekly": t.get("spot_freq_weekly", "Weekly"),
            "biweekly": t.get("spot_freq_biweekly", "Bi-Weekly"),
            "monthly": t.get("spot_freq_monthly", "Monthly"),
        }
        await q.answer(t.get("spot_frequency_saved", "‚úÖ Frequency set to {freq}").format(freq=freq_labels[new_freq]))
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "auto_toggle":
        current = spot_settings.get("auto_dca", False)
        spot_settings["auto_dca"] = not current
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        
        status_msg = t.get("spot_auto_enabled", "‚úÖ Auto DCA enabled") if not current else t.get("spot_auto_disabled", "‚ùå Auto DCA disabled")
        await q.answer(status_msg, show_alert=True)
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "buy_now":
        # Check if spot trading is enabled in strategy settings
        if not cfg.get("spot_enabled", 0):
            await q.answer(t.get("spot_not_enabled", "‚ùå Spot trading is disabled in settings"), show_alert=True)
            return
        
        # Detect user's exchange
        user_exchange = db.get_exchange_type(uid) or "bybit"
        
        # Execute Smart DCA buy for all selected coins
        coins = spot_settings.get("coins", SPOT_DCA_COINS)
        base_amount = spot_settings.get("dca_amount", SPOT_DCA_DEFAULT_AMOUNT)
        strategy = spot_settings.get("strategy", "fixed")
        portfolio = spot_settings.get("portfolio", "custom")
        allocation = spot_settings.get("allocation", {})
        
        # Use trading mode from spot settings
        account_type = spot_settings.get("trading_mode", "demo")
        
        # Normalize account_type for HyperLiquid
        if user_exchange == "hyperliquid":
            if account_type in ("demo", "real"):
                account_type = "testnet" if account_type == "demo" else "mainnet"
        
        results = []
        total_spent = 0.0
        skipped = []
        
        # Get portfolio allocation if using preset
        if portfolio != "custom" and portfolio in SPOT_PORTFOLIOS:
            portfolio_info = SPOT_PORTFOLIOS[portfolio]
            allocation = portfolio_info.get("coins", {})
        
        for coin in coins:
            # Calculate amount based on allocation
            if allocation and coin in allocation:
                coin_pct = allocation[coin] / 100.0
                coin_base_amount = base_amount * coin_pct
            else:
                coin_base_amount = base_amount / len(coins) if coins else base_amount
            
            # Apply smart DCA strategy multiplier
            adjusted_amount = await calculate_smart_dca_amount(
                base_amount=coin_base_amount,
                strategy=strategy,
                coin=coin,
                spot_settings=spot_settings,
                user_id=uid,
                account_type=account_type,
                exchange=user_exchange,
            )
            
            if adjusted_amount <= 0:
                skipped.append(coin)
                continue
            
            result = await execute_spot_dca_buy(uid, coin, adjusted_amount, account_type=account_type, exchange=user_exchange)
            if result.get("success"):
                spent = result.get("usdt_spent", adjusted_amount)
                results.append(f"‚úÖ {result.get('qty', 0):.6f} {coin} (${spent:.2f})")
                total_spent += spent
            elif result.get("error") == "SKIP":
                # Silently skip - don't show error to user
                reason = result.get("reason", "unknown")
                if reason == "order_too_small":
                    skipped.append(f"{coin} (min)")
                elif reason == "insufficient_balance":
                    skipped.append(f"{coin} (bal)")
                else:
                    skipped.append(coin)
            else:
                # Only show real errors
                results.append(f"‚ùå {coin}: {result.get('error', 'Error')}")
        
        # Update total invested
        spot_settings["total_invested"] = spot_settings.get("total_invested", 0.0) + total_spent
        
        # Record last DCA timestamp
        spot_settings["last_dca_ts"] = int(time.time())
        
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        
        # Build result message
        result_lines = results.copy()
        if skipped:
            result_lines.append(f"‚è≠Ô∏è Skipped (no dip): {', '.join(skipped)}")
        
        strategy_info = SMART_DCA_STRATEGIES.get(strategy, {})
        strategy_label = f"{strategy_info.get('emoji', 'üìä')} {strategy_info.get('name', 'Fixed')}"
        
        result_msg = "\n".join(result_lines)
        await q.answer(f"DCA executed! Spent: ${total_spent:.2f}", show_alert=True)
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            extra_info = f"\n\n<b>üéØ Strategy:</b> {strategy_label}\n<b>Last Buy:</b>\n{result_msg}"
            await q.edit_message_text(msg + extra_info, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "holdings":
        # Show detailed spot portfolio - use trading mode from settings
        account_type = spot_settings.get("trading_mode", "demo")
        
        balances = await fetch_spot_balance(uid, account_type=account_type)
        
        if not balances:
            await q.answer(t.get("spot_no_balance", "‚ùå No spot balance found"), show_alert=True)
            return
        
        await q.answer("Loading portfolio...")
        
        # Get prices for all coins in parallel
        total_usd_value = 0.0
        holdings_data = []
        
        # Filter coins with balance
        filtered_balances = {c: amt for c, amt in balances.items() if amt > 0.00001}
        
        # Fetch prices in parallel
        price_tasks = {}
        for coin in filtered_balances:
            if coin != "USDT":
                symbol = f"{coin}USDT"
                price_tasks[coin] = asyncio.create_task(get_spot_ticker(uid, symbol, account_type))
        
        # Wait for all prices
        for coin, task in price_tasks.items():
            try:
                ticker = await task
                price = float(ticker.get("lastPrice", 0)) if ticker else 0
                price_change_24h = float(ticker.get("price24hPcnt", 0)) * 100 if ticker else 0
                amount = filtered_balances[coin]
                usd_value = amount * price
                total_usd_value += usd_value
                holdings_data.append({
                    "coin": coin,
                    "amount": amount,
                    "price": price,
                    "usd_value": usd_value,
                    "change_24h": price_change_24h,
                })
            except Exception as e:
                logger.warning(f"Failed to get price for {coin}: {e}")
                holdings_data.append({
                    "coin": coin,
                    "amount": filtered_balances[coin],
                    "price": 0,
                    "usd_value": 0,
                    "change_24h": 0,
                })
        
        # Add USDT if present
        if "USDT" in filtered_balances:
            usdt_amt = filtered_balances["USDT"]
            total_usd_value += usdt_amt
            holdings_data.append({
                "coin": "USDT",
                "amount": usdt_amt,
                "price": 1.0,
                "usd_value": usdt_amt,
                "change_24h": 0,
            })
        
        # Sort by USD value descending
        holdings_data.sort(key=lambda x: x["usd_value"], reverse=True)
        
        # Format message
        mode_label = "üß™ Demo" if account_type == "demo" else "üí∞ Real"
        lines = [
            f"üíé <b>Spot Portfolio</b> {mode_label}",
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            f"üíµ <b>Total Value:</b> ${total_usd_value:,.2f}",
            "",
        ]
        
        for h in holdings_data:
            coin = h["coin"]
            amount = h["amount"]
            usd_value = h["usd_value"]
            change = h["change_24h"]
            
            # Format change with emoji
            if change > 0:
                change_str = f"üü¢ +{change:.2f}%"
            elif change < 0:
                change_str = f"üî¥ {change:.2f}%"
            else:
                change_str = "‚ö™ 0.00%"
            
            # Format amount (shorter for readability)
            if amount >= 1:
                amt_str = f"{amount:,.4f}"
            else:
                amt_str = f"{amount:.8f}"
            
            if coin == "USDT":
                lines.append(f"üíµ <b>USDT:</b> ${usd_value:,.2f}")
            else:
                lines.append(f"ü™ô <b>{coin}:</b> {amt_str}")
                lines.append(f"   ‚îî ${usd_value:,.2f} | {change_str}")
        
        holdings_msg = "\n".join(lines)
        
        # Build keyboard with sell buttons
        buttons = []
        
        # Quick sell buttons for non-USDT coins
        sellable = [h for h in holdings_data if h["coin"] != "USDT" and h["usd_value"] > 1]
        if sellable:
            buttons.append([InlineKeyboardButton(t.get("spot_btn_sell", "üí∏ Sell Menu"), callback_data="spot:sell_menu")])
        
        # Action buttons
        buttons.append([
            InlineKeyboardButton(t.get("btn_refresh", "üîÑ Refresh"), callback_data="spot:holdings"),
            InlineKeyboardButton(t.get("spot_btn_rebalance", "‚öñÔ∏è Rebalance"), callback_data="spot:rebalance_now"),
        ])
        
        buttons.append([InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="spot:back_to_main")])
        
        try:
            await q.edit_message_text(
                holdings_msg,
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action == "back_to_main":
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "mode":
        # Toggle trading mode (demo/real)
        current_mode = spot_settings.get("trading_mode", "demo")
        new_mode = "real" if current_mode == "demo" else "demo"
        spot_settings["trading_mode"] = new_mode
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        
        mode_labels = {"demo": "üß™ Demo", "real": "üí∞ Real"}
        await q.answer(f"Spot: {mode_labels.get(new_mode, new_mode)}")
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "back_to_strategies":
        # Return to strategies menu
        cfg = get_user_config(uid)
        active_exchange = db.get_exchange_type(uid) or "bybit"
        context = db.get_user_trading_context(uid)
        account_type = context.get("account_type", "demo")
        global_use_atr = bool(cfg.get("use_atr", 1))
        lines = [t.get('strategy_settings_header', '‚öôÔ∏è *Strategy Settings*')]
        lines.append("")
        for strat_key, strat_nm in STRATEGY_NAMES_MAP.items():
            strat_settings_data = db.get_strategy_settings(uid, strat_key, active_exchange, account_type)
            status_parts = _build_strategy_status_parts(strat_key, strat_settings_data, active_exchange, global_use_atr, global_cfg=cfg)
            if status_parts:
                lines.append(f"*{strat_nm}*: {', '.join(status_parts)}")
            else:
                lines.append(f"*{strat_nm}*: {t.get('using_global', 'Using global settings')}")
        lines.append("")
        dca_status = '‚úÖ' if cfg.get('dca_enabled', 0) else '‚ùå'
        lines.append(f"*DCA*: {dca_status} Leg1={cfg.get('dca_pct_1', 10.0)}%, Leg2={cfg.get('dca_pct_2', 25.0)}%")
        
        try:
            await q.edit_message_text(
                "\n".join(lines),
                parse_mode="Markdown",
                reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
            )
        except BadRequest:
            pass
        return
    
    # === NEW PROFESSIONAL SPOT FEATURES ===
    
    if action == "portfolio":
        # Show portfolio selection menu
        buttons = []
        current_portfolio = spot_settings.get("portfolio", "custom")
        for key, info in SPOT_PORTFOLIOS.items():
            selected = "‚úÖ " if key == current_portfolio else ""
            coins_preview = ", ".join(list(info["coins"].keys())[:3]) if info["coins"] else "Custom"
            buttons.append([InlineKeyboardButton(
                f"{selected}{info['emoji']} {info['name']} ({coins_preview})",
                callback_data=f"spot:set_portfolio:{key}"
            )])
        buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:back_to_main")])
        
        try:
            await q.edit_message_text(
                "üìÅ <b>Select Portfolio Preset</b>\n\n"
                "Choose a predefined portfolio or create your own custom allocation:",
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action.startswith("set_portfolio:"):
        portfolio_key = action.split(":")[1]
        if portfolio_key in SPOT_PORTFOLIOS:
            portfolio_info = SPOT_PORTFOLIOS[portfolio_key]
            spot_settings["portfolio"] = portfolio_key
            
            # If not custom, set coins from portfolio
            if portfolio_key != "custom" and portfolio_info.get("coins"):
                spot_settings["coins"] = list(portfolio_info["coins"].keys())
                spot_settings["allocation"] = portfolio_info["coins"].copy()
            
            db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
            await q.answer(f"Portfolio: {portfolio_info['name']}")
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "strategy":
        # Show DCA strategy selection
        buttons = []
        current_strategy = spot_settings.get("strategy", "fixed")
        for key, info in SMART_DCA_STRATEGIES.items():
            selected = "‚úÖ " if key == current_strategy else ""
            buttons.append([InlineKeyboardButton(
                f"{selected}{info['emoji']} {info['name']}",
                callback_data=f"spot:set_strategy:{key}"
            )])
        buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:back_to_main")])
        
        strategies_help = (
            "üéØ <b>Select DCA Strategy</b>\n\n"
            "<b>üìä Fixed DCA:</b> Buy same amount at regular intervals\n\n"
            "<b>üìà Value Averaging:</b> Buy MORE when price is down, LESS when up. "
            "Automatically adjusts to maintain target growth.\n\n"
            "<b>üò± Fear & Greed:</b> Increases buy amount during extreme market fear "
            "(F&G Index < 25). Great for buying blood in the streets.\n\n"
            "<b>üìâ Dip Buying:</b> Only triggers when price drops by X% from recent high. "
            "Waits for dips instead of buying at any price."
        )
        
        try:
            await q.edit_message_text(
                strategies_help,
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action.startswith("set_strategy:"):
        strategy_key = action.split(":")[1]
        if strategy_key in SMART_DCA_STRATEGIES:
            strategy_info = SMART_DCA_STRATEGIES[strategy_key]
            spot_settings["strategy"] = strategy_key
            db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
            await q.answer(f"Strategy: {strategy_info['name']}")
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "dip_threshold":
        # Cycle through dip thresholds: 3%, 5%, 7%, 10%, 15%
        thresholds = [3.0, 5.0, 7.0, 10.0, 15.0]
        current = spot_settings.get("dip_threshold", 5.0)
        idx = thresholds.index(current) if current in thresholds else 1
        new_threshold = thresholds[(idx + 1) % len(thresholds)]
        
        spot_settings["dip_threshold"] = new_threshold
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        await q.answer(f"Dip threshold: -{new_threshold}%")
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "fear_threshold":
        # Cycle through fear thresholds: 15, 20, 25, 30, 35
        thresholds = [15, 20, 25, 30, 35]
        current = spot_settings.get("fear_threshold", 25)
        idx = thresholds.index(current) if current in thresholds else 2
        new_threshold = thresholds[(idx + 1) % len(thresholds)]
        
        spot_settings["fear_threshold"] = new_threshold
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        await q.answer(f"Fear Index threshold: <{new_threshold}")
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "tp_toggle":
        current = spot_settings.get("tp_enabled", False)
        spot_settings["tp_enabled"] = not current
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        
        status = "‚úÖ Auto TP enabled" if not current else "‚ùå Auto TP disabled"
        await q.answer(status)
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "rebalance_toggle":
        current = spot_settings.get("rebalance_enabled", False)
        spot_settings["rebalance_enabled"] = not current
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        
        status = "‚úÖ Auto Rebalance enabled" if not current else "‚ùå Auto Rebalance disabled"
        await q.answer(status)
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "tp_settings":
        # Show TP levels configuration
        tp_levels = spot_settings.get("tp_levels", DEFAULT_SPOT_TP_LEVELS)
        
        lines = [
            "üéØ <b>Take Profit Levels</b>",
            "",
            "Configure automatic sell targets:",
            "",
        ]
        for i, level in enumerate(tp_levels):
            lines.append(f"üìç At +{level['gain_pct']}% gain ‚Üí Sell {level['sell_pct']}%")
        
        lines.extend([
            "",
            "<i>When coin reaches target gain, bot will automatically "
            "sell the specified percentage of holdings.</i>",
        ])
        
        buttons = [
            [
                InlineKeyboardButton("üìù Edit Level 1", callback_data="spot:edit_tp:0"),
                InlineKeyboardButton("üìù Edit Level 2", callback_data="spot:edit_tp:1"),
            ],
            [
                InlineKeyboardButton("üìù Edit Level 3", callback_data="spot:edit_tp:2"),
                InlineKeyboardButton("üìù Edit Level 4", callback_data="spot:edit_tp:3"),
            ],
            [InlineKeyboardButton("üîÑ Reset to Default", callback_data="spot:reset_tp")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:back_to_main")],
        ]
        
        try:
            await q.edit_message_text(
                "\n".join(lines),
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action == "reset_tp":
        spot_settings["tp_levels"] = DEFAULT_SPOT_TP_LEVELS.copy()
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        await q.answer("TP levels reset to default")
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action.startswith("edit_tp:"):
        # Edit specific TP level (0-3)
        level_idx = int(action.split(":")[1])
        tp_levels = spot_settings.get("tp_levels", DEFAULT_SPOT_TP_LEVELS.copy())
        
        if 0 <= level_idx < len(tp_levels):
            level = tp_levels[level_idx]
            ctx.user_data["spot_edit_tp_level"] = level_idx
            ctx.user_data["spot_awaiting"] = "tp_gain"
            
            try:
                await q.edit_message_text(
                    f"üìù <b>Edit TP Level {level_idx + 1}</b>\n\n"
                    f"Current settings:\n"
                    f"‚Ä¢ Gain trigger: +{level['gain_pct']}%\n"
                    f"‚Ä¢ Sell amount: {level['sell_pct']}%\n\n"
                    f"Enter new <b>gain trigger %</b> (e.g. 50 for +50%):",
                    parse_mode="HTML",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("‚¨ÖÔ∏è Cancel", callback_data="spot:tp_settings")]
                    ])
                )
            except BadRequest:
                pass
        return
    
    if action.startswith("tp_sell_pct:"):
        # Set sell percentage for TP level
        level_idx = ctx.user_data.get("spot_edit_tp_level", 0)
        ctx.user_data["spot_awaiting"] = "tp_sell"
        
        tp_levels = spot_settings.get("tp_levels", DEFAULT_SPOT_TP_LEVELS.copy())
        if 0 <= level_idx < len(tp_levels):
            level = tp_levels[level_idx]
            try:
                await q.edit_message_text(
                    f"üìù <b>Edit TP Level {level_idx + 1}</b>\n\n"
                    f"Gain trigger: +{level['gain_pct']}%\n\n"
                    f"Enter <b>sell amount %</b> (e.g. 25 to sell 25% of holdings):",
                    parse_mode="HTML",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("‚¨ÖÔ∏è Cancel", callback_data="spot:tp_settings")]
                    ])
                )
            except BadRequest:
                pass
        return
    
    if action == "sell_menu":
        # Show detailed menu to select coin to sell
        account_type = spot_settings.get("trading_mode", "demo")
        
        await q.answer("Loading sell menu...")
        
        balances = await fetch_spot_balance(uid, account_type=account_type)
        
        # Filter coins with balance > 0 (excluding stables)
        sellable = {coin: qty for coin, qty in balances.items() 
                   if qty > 0.00001 and coin not in ("USDT", "USDC", "BUSD", "DAI")}
        
        if not sellable:
            await q.answer(t.get("spot_no_coins", "‚ùå No coins to sell"), show_alert=True)
            return
        
        # Get purchase history for PnL calculation
        purchase_history = spot_settings.get("purchase_history", {})
        
        # Fetch all prices in parallel
        price_tasks = {}
        for coin in sellable:
            symbol = f"{coin}USDT"
            price_tasks[coin] = asyncio.create_task(get_spot_ticker(uid, symbol, account_type))
        
        # Build detailed sell menu
        mode_label = "üß™ Demo" if account_type == "demo" else "üí∞ Real"
        lines = [
            f"üí∏ <b>Sell Assets</b> {mode_label}",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            "",
        ]
        
        buttons = []
        total_value = 0.0
        total_pnl = 0.0
        
        for coin, qty in sorted(sellable.items(), key=lambda x: x[0]):
            try:
                ticker = await price_tasks[coin]
                price = float(ticker.get("lastPrice", 0)) if ticker else 0
                price_change = float(ticker.get("price24hPcnt", 0)) * 100 if ticker else 0
                value = qty * price
                total_value += value
                
                # Calculate PnL if we have purchase history
                pnl_str = ""
                if coin in purchase_history:
                    avg_price = purchase_history[coin].get("avg_price", 0)
                    if avg_price > 0:
                        pnl_pct = ((price - avg_price) / avg_price) * 100
                        pnl_usd = value - (qty * avg_price)
                        total_pnl += pnl_usd
                        if pnl_pct >= 0:
                            pnl_str = f" | üü¢ +{pnl_pct:.1f}%"
                        else:
                            pnl_str = f" | üî¥ {pnl_pct:.1f}%"
                
                # 24h change emoji
                if price_change > 0:
                    change_str = f"‚ÜóÔ∏è+{price_change:.1f}%"
                elif price_change < 0:
                    change_str = f"‚ÜòÔ∏è{price_change:.1f}%"
                else:
                    change_str = "‚Üí 0%"
                
                lines.append(f"ü™ô <b>{coin}</b>: {qty:.6f}")
                lines.append(f"   üíµ ${value:,.2f} ({change_str}){pnl_str}")
                
                buttons.append([InlineKeyboardButton(
                    f"üí∏ Sell {coin} (${value:.2f})",
                    callback_data=f"spot:sell_coin:{coin}"
                )])
            except Exception as e:
                logger.warning(f"Failed to get price for {coin}: {e}")
                buttons.append([InlineKeyboardButton(
                    f"üí∏ Sell {coin}: {qty:.6f}",
                    callback_data=f"spot:sell_coin:{coin}"
                )])
        
        lines.append("")
        lines.append(f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        lines.append(f"üíµ <b>Total:</b> ${total_value:,.2f}")
        if abs(total_pnl) > 0.01:
            pnl_emoji = "üü¢" if total_pnl >= 0 else "üî¥"
            lines.append(f"üìä <b>Total PnL:</b> {pnl_emoji} ${total_pnl:+,.2f}")
        
        # Add Sell All button if multiple coins
        if len(sellable) > 1:
            buttons.append([InlineKeyboardButton(
                f"üî• SELL ALL ‚Üí USDT (${total_value:,.2f})",
                callback_data="spot:sell_all_to_usdt"
            )])
        
        buttons.append([
            InlineKeyboardButton("üîÑ Refresh", callback_data="spot:sell_menu"),
            InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:holdings"),
        ])
        
        try:
            await q.edit_message_text(
                "\n".join(lines),
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action.startswith("sell_coin:"):
        coin = action.split(":")[1]
        
        # Show sell percentage options
        buttons = [
            [
                InlineKeyboardButton("25%", callback_data=f"spot:exec_sell:{coin}:25"),
                InlineKeyboardButton("50%", callback_data=f"spot:exec_sell:{coin}:50"),
            ],
            [
                InlineKeyboardButton("75%", callback_data=f"spot:exec_sell:{coin}:75"),
                InlineKeyboardButton("100%", callback_data=f"spot:exec_sell:{coin}:100"),
            ],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:sell_menu")],
        ]
        
        try:
            await q.edit_message_text(
                f"üí∏ <b>Sell {coin}</b>\n\n"
                "Select percentage to sell:",
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action.startswith("exec_sell:"):
        parts = action.split(":")
        coin = parts[1]
        sell_pct = float(parts[2])
        account_type = spot_settings.get("trading_mode", "demo")
        
        await q.answer(f"Selling {sell_pct}% of {coin}...")
        
        result = await execute_spot_sell(uid, coin, sell_pct=sell_pct, account_type=account_type)
        
        if result.get("success"):
            msg_text = (
                f"‚úÖ <b>Sold {coin}</b>\n\n"
                f"Qty: {result.get('qty_sold', 0):.6f} {coin}\n"
                f"Price: ${result.get('price', 0):.4f}\n"
                f"Received: ${result.get('usdt_received', 0):.2f} USDT"
            )
        else:
            msg_text = f"‚ùå <b>Sell Failed</b>\n\n{result.get('error', 'Unknown error')}"
        
        # Return to holdings view with updated data
        buttons = [
            [InlineKeyboardButton("üíé View Holdings", callback_data="spot:holdings")],
            [InlineKeyboardButton("üí∏ Sell More", callback_data="spot:sell_menu")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:back_to_main")],
        ]
        
        try:
            await q.edit_message_text(msg_text, reply_markup=InlineKeyboardMarkup(buttons), parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "sell_all_to_usdt":
        # Confirmation before selling all
        account_type = spot_settings.get("trading_mode", "demo")
        
        # Get all sellable coins
        balances = await fetch_spot_balance(uid, account_type=account_type)
        sellable = {coin: qty for coin, qty in balances.items() 
                   if qty > 0.00001 and coin not in ("USDT", "USDC", "BUSD", "DAI")}
        
        if not sellable:
            await q.answer("No coins to sell!", show_alert=True)
            return
        
        # Calculate total value
        total_value = 0.0
        for coin, qty in sellable.items():
            symbol = f"{coin}USDT"
            try:
                ticker = await get_spot_ticker(uid, symbol, account_type)
                price = float(ticker.get("lastPrice", 0)) if ticker else 0
                total_value += qty * price
            except Exception as e:
                logger.warning(f"Failed to get price for {symbol}: {e}")
        
        coins_list = ", ".join(sellable.keys())
        
        buttons = [
            [InlineKeyboardButton(f"‚úÖ YES, Sell All (~${total_value:,.2f})", callback_data="spot:exec_sell_all")],
            [InlineKeyboardButton("‚ùå Cancel", callback_data="spot:sell_menu")],
        ]
        
        try:
            await q.edit_message_text(
                f"‚ö†Ô∏è <b>Confirm Sell All</b>\n\n"
                f"You are about to sell ALL:\n"
                f"ü™ô <b>{coins_list}</b>\n\n"
                f"üíµ Estimated: ~${total_value:,.2f} USDT\n\n"
                f"<b>This action cannot be undone!</b>",
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action == "exec_sell_all":
        # Execute sell all coins to USDT
        account_type = spot_settings.get("trading_mode", "demo")
        
        await q.answer("Selling all coins to USDT...")
        
        balances = await fetch_spot_balance(uid, account_type=account_type)
        sellable = {coin: qty for coin, qty in balances.items() 
                   if qty > 0.00001 and coin not in ("USDT", "USDC", "BUSD", "DAI")}
        
        results = []
        total_received = 0.0
        
        for coin in sellable:
            result = await execute_spot_sell(uid, coin, sell_pct=100, account_type=account_type)
            if result.get("success"):
                received = result.get("usdt_received", 0)
                total_received += received
                results.append(f"‚úÖ {coin}: +${received:,.2f}")
            else:
                results.append(f"‚ùå {coin}: {result.get('error', 'Failed')}")
        
        lines = [
            "üî• <b>Sell All Complete</b>",
            "‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ",
            "",
        ]
        lines.extend(results)
        lines.append("")
        lines.append(f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
        lines.append(f"üíµ <b>Total Received:</b> ${total_received:,.2f} USDT")
        
        buttons = [
            [InlineKeyboardButton("üíé View Holdings", callback_data="spot:holdings")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:back_to_main")],
        ]
        
        try:
            await q.edit_message_text("\n".join(lines), reply_markup=InlineKeyboardMarkup(buttons), parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "rebalance_now":
        # Check if spot trading is enabled in strategy settings
        if not cfg.get("spot_enabled", 0):
            await q.answer(t.get("spot_not_enabled", "‚ùå Spot trading is disabled in settings"), show_alert=True)
            return
        
        account_type = spot_settings.get("trading_mode", "demo")
        
        await q.answer("Rebalancing portfolio...")
        
        result = await rebalance_spot_portfolio(uid, account_type=account_type)
        
        if result.get("success"):
            sells = result.get("sells", [])
            buys = result.get("buys", [])
            total = result.get("total_rebalanced", 0)
            
            lines = ["‚öñÔ∏è <b>Portfolio Rebalanced</b>", ""]
            
            if sells:
                lines.append("<b>Sold:</b>")
                lines.extend([f"  ‚Ä¢ {s}" for s in sells])
                lines.append("")
            
            if buys:
                lines.append("<b>Bought:</b>")
                lines.extend([f"  ‚Ä¢ {b}" for b in buys])
                lines.append("")
            
            if not sells and not buys:
                lines.append("‚úÖ Portfolio already balanced!")
            else:
                lines.append(f"üí∞ Total rebalanced: ${total:.2f}")
            
            msg_text = "\n".join(lines)
        else:
            msg_text = f"‚ùå <b>Rebalance Failed</b>\n\n{result.get('error', 'Unknown error')}"
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        
        try:
            await q.edit_message_text(msg_text, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "analysis":
        # Show market analysis for selected coins
        await q.answer("Analyzing market...")
        
        coins = spot_settings.get("coins", SPOT_DCA_COINS)
        account_type = spot_settings.get("trading_mode", "demo")
        
        lines = ["üìä <b>Market Analysis</b>", ""]
        
        # Fetch Fear & Greed Index (simulated for now, can integrate real API)
        fear_greed = await get_fear_greed_index()
        fg_emoji = "üò±" if fear_greed < 25 else "üò∞" if fear_greed < 45 else "üòê" if fear_greed < 55 else "üòÄ" if fear_greed < 75 else "ü§ë"
        fg_label = "Extreme Fear" if fear_greed < 25 else "Fear" if fear_greed < 45 else "Neutral" if fear_greed < 55 else "Greed" if fear_greed < 75 else "Extreme Greed"
        
        lines.append(f"<b>Fear & Greed Index:</b> {fg_emoji} {fear_greed} ({fg_label})")
        lines.append("")
        
        # Get price data for coins
        for coin in coins[:5]:  # Limit to 5 coins
            symbol = f"{coin}USDT"
            try:
                ticker = await get_spot_ticker(uid, symbol, account_type)
                if ticker:
                    price = float(ticker.get("lastPrice", 0))
                    change_24h = float(ticker.get("price24hPcnt", 0)) * 100
                    change_emoji = "üìà" if change_24h > 0 else "üìâ"
                    lines.append(f"{change_emoji} <b>{coin}:</b> ${price:.4f} ({change_24h:+.2f}%)")
            except Exception:
                lines.append(f"‚ö†Ô∏è <b>{coin}:</b> Data unavailable")
        
        lines.extend([
            "",
            "<i>üí° Tip: Buy more during Extreme Fear!</i>",
        ])
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg_base = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        
        try:
            await q.edit_message_text(
                msg_base + "\n\n" + "\n".join(lines),
                reply_markup=keyboard,
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action == "performance":
        # Show portfolio performance
        account_type = spot_settings.get("trading_mode", "demo")
        total_invested = spot_settings.get("total_invested", 0.0)
        
        balances = await fetch_spot_balance(uid, account_type=account_type)
        
        lines = ["üìà <b>Portfolio Performance</b>", ""]
        
        total_value = 0.0
        holdings_lines = []
        
        for coin, qty in sorted(balances.items()):
            if qty > 0.00001 and coin != "USDT":
                symbol = f"{coin}USDT"
                try:
                    ticker = await get_spot_ticker(uid, symbol, account_type)
                    if ticker:
                        price = float(ticker.get("lastPrice", 0))
                        value = qty * price
                        total_value += value
                        holdings_lines.append(f"‚Ä¢ {coin}: {qty:.6f} (${value:.2f})")
                except Exception:
                    holdings_lines.append(f"‚Ä¢ {coin}: {qty:.6f}")
        
        # Add USDT balance
        usdt_balance = balances.get("USDT", 0)
        if usdt_balance > 0.01:
            total_value += usdt_balance
            holdings_lines.append(f"‚Ä¢ USDT: {usdt_balance:.2f}")
        
        for line in holdings_lines:
            lines.append(line)
        
        lines.append("")
        lines.append(f"üí∞ <b>Total Value:</b> ${total_value:.2f}")
        lines.append(f"üíµ <b>Total Invested:</b> ${total_invested:.2f}")
        
        if total_invested > 0:
            pnl = total_value - total_invested
            pnl_pct = (pnl / total_invested) * 100
            pnl_emoji = "üü¢" if pnl >= 0 else "üî¥"
            lines.append(f"{pnl_emoji} <b>P&L:</b> ${pnl:.2f} ({pnl_pct:+.2f}%)")
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg_base = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        
        try:
            await q.edit_message_text(
                msg_base + "\n\n" + "\n".join(lines),
                reply_markup=keyboard,
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    # === END NEW PROFESSIONAL SPOT FEATURES ===
    
    # ==================== TRAILING TP ====================
    if action == "trailing_toggle":
        trailing_config = spot_settings.get("trailing_tp", SPOT_TRAILING_TP_DEFAULTS.copy())
        trailing_config["enabled"] = not trailing_config.get("enabled", False)
        spot_settings["trailing_tp"] = trailing_config
        db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
        
        status = "enabled" if trailing_config["enabled"] else "disabled"
        await q.answer(f"üìà Trailing TP {status}!", show_alert=True)
        
        cfg = db.get_user_config(uid)
        spot_settings = cfg.get("spot_settings") or {}
        msg = format_spot_settings_message(t, cfg, spot_settings)
        keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    # ==================== PORTFOLIO STATS ====================
    if action == "portfolio_stats":
        await q.answer("Loading portfolio stats...")
        account_type = spot_settings.get("trading_mode", "demo")
        
        stats = await get_spot_portfolio_stats(uid, account_type=account_type)
        
        lines = ["üìä <b>Portfolio Statistics</b>", ""]
        
        # Overall stats
        lines.append(f"üí∞ <b>Total Value:</b> ${stats['total_current_value']:.2f}")
        lines.append(f"üíµ <b>Cost Basis:</b> ${stats['total_cost_basis']:.2f}")
        lines.append(f"üè¶ <b>USDT Available:</b> ${stats['usdt_balance']:.2f}")
        lines.append("")
        
        pnl = stats['overall_pnl_value']
        pnl_pct = stats['overall_pnl_pct']
        pnl_emoji = "üü¢" if pnl >= 0 else "üî¥"
        lines.append(f"{pnl_emoji} <b>Overall P&L:</b> ${pnl:.2f} ({pnl_pct:+.2f}%)")
        lines.append("")
        
        # Per-coin breakdown
        if stats['coins']:
            lines.append("<b>üìà Coins Breakdown:</b>")
            for coin_stat in stats['coins'][:8]:  # Top 8 coins
                coin = coin_stat['coin']
                value = coin_stat['current_value']
                coin_pnl = coin_stat['pnl_pct']
                emoji = "üü¢" if coin_pnl >= 0 else "üî¥"
                lines.append(f"  {emoji} {coin}: ${value:.2f} ({coin_pnl:+.1f}%)")
        
        lines.append("")
        lines.append(f"üìä <b>Total Invested:</b> ${stats.get('total_invested', 0):.2f}")
        
        buttons = [
            [InlineKeyboardButton("üîÑ Refresh", callback_data="spot:portfolio_stats")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:back_to_main")],
        ]
        
        try:
            await q.edit_message_text(
                "\n".join(lines),
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    # ==================== PERFORMANCE (DCA History) ====================
    if action == "performance":
        await q.answer("Loading performance...")
        account_type = spot_settings.get("trading_mode", "demo")
        purchase_history = spot_settings.get("purchase_history", {})
        total_invested = spot_settings.get("total_invested", 0)
        last_dca_ts = spot_settings.get("last_dca_ts", 0)
        
        lines = ["üìà <b>DCA Performance</b>", ""]
        
        # Summary
        lines.append(f"üíµ <b>Total Invested:</b> ${total_invested:.2f}")
        if last_dca_ts:
            from datetime import datetime
            last_dca_date = datetime.fromtimestamp(last_dca_ts).strftime("%Y-%m-%d %H:%M")
            lines.append(f"‚è∞ <b>Last DCA:</b> {last_dca_date}")
        lines.append("")
        
        # Per-coin history
        if purchase_history:
            lines.append("<b>ü™ô Purchase History:</b>")
            for coin, history in sorted(purchase_history.items()):
                total_qty = history.get("total_qty", 0)
                avg_price = history.get("avg_price", 0)
                total_cost = history.get("total_cost", 0)
                buy_count = len(history.get("purchases", []))
                
                if total_qty > 0:
                    lines.append(f"  ‚Ä¢ {coin}: {total_qty:.6f} @ avg ${avg_price:.4f}")
                    lines.append(f"    Cost: ${total_cost:.2f} ({buy_count} buys)")
        else:
            lines.append("<i>No DCA purchases yet. Use 'Buy Now' to start.</i>")
        
        # DCA frequency info
        lines.append("")
        freq = spot_settings.get("frequency", "manual")
        auto_dca = spot_settings.get("auto_dca", False)
        lines.append(f"‚öôÔ∏è <b>Mode:</b> {freq.title()}" + (" (Auto)" if auto_dca else " (Manual)"))
        
        buttons = [
            [InlineKeyboardButton("üìä Portfolio Stats", callback_data="spot:portfolio_stats")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:back_to_main")],
        ]
        
        try:
            await q.edit_message_text(
                "\n".join(lines),
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    # ==================== LIMIT ORDERS ====================
    if action == "limit_order":
        coins = spot_settings.get("coins", SPOT_DCA_COINS)
        
        buttons = []
        for coin in coins:
            buttons.append([InlineKeyboardButton(
                f"üìã {coin} Limit Order",
                callback_data=f"spot:limit_setup:{coin}"
            )])
        buttons.append([InlineKeyboardButton("üìã View Open Orders", callback_data="spot:limit_view")])
        buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:back_to_main")])
        
        try:
            await q.edit_message_text(
                "üìã <b>Spot Limit Orders</b>\n\n"
                "Place limit buy orders at specific prices.\n"
                "Select a coin to set up a limit order:",
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action.startswith("limit_setup:"):
        coin = action.split(":")[1]
        ctx.user_data["spot_limit_coin"] = coin
        ctx.user_data["spot_awaiting"] = "limit_price"
        
        account_type = spot_settings.get("trading_mode", "demo")
        symbol = f"{coin}USDT"
        
        # Get current price
        current_price = 0
        try:
            ticker = await get_spot_ticker(uid, symbol, account_type)
            if ticker:
                current_price = float(ticker.get("lastPrice", 0))
        except Exception:
            pass
        
        try:
            await q.edit_message_text(
                f"üìã <b>Limit Buy {coin}</b>\n\n"
                f"üí∞ Current price: ${current_price:.4f}\n\n"
                f"Enter the price at which you want to buy {coin}:",
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action == "limit_view":
        account_type = spot_settings.get("trading_mode", "demo")
        
        orders = await get_spot_open_orders(uid, account_type)
        
        if not orders:
            try:
                await q.edit_message_text(
                    "üìã <b>Open Limit Orders</b>\n\n"
                    "No open orders.",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:limit_order")]
                    ]),
                    parse_mode="HTML"
                )
            except BadRequest:
                pass
            return
        
        lines = ["üìã <b>Open Limit Orders</b>", ""]
        buttons = []
        
        for order in orders[:10]:  # Limit to 10
            symbol = order.get("symbol", "")
            side = order.get("side", "")
            price = float(order.get("price", 0))
            qty = float(order.get("qty", 0))
            order_id = order.get("orderId", "")
            
            side_emoji = "üü¢" if side == "Buy" else "üî¥"
            lines.append(f"{side_emoji} {symbol}: {qty:.6f} @ ${price:.4f}")
            
            buttons.append([InlineKeyboardButton(
                f"‚ùå Cancel {symbol[:6]}",
                callback_data=f"spot:limit_cancel:{symbol}:{order_id}"
            )])
        
        buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:limit_order")])
        
        try:
            await q.edit_message_text(
                "\n".join(lines),
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action.startswith("limit_cancel:"):
        parts = action.split(":")
        symbol = parts[1]
        order_id = parts[2]
        account_type = spot_settings.get("trading_mode", "demo")
        
        result = await cancel_spot_order(uid, symbol, order_id, account_type)
        
        if result.get("success"):
            await q.answer("‚úÖ Order cancelled!", show_alert=True)
        else:
            await q.answer(f"‚ùå Failed: {result.get('error', 'Unknown')}", show_alert=True)
        
        # Refresh order list
        orders = await get_spot_open_orders(uid, account_type)
        
        if not orders:
            try:
                await q.edit_message_text(
                    "üìã <b>Open Limit Orders</b>\n\n"
                    "No open orders.",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:limit_order")]
                    ]),
                    parse_mode="HTML"
                )
            except BadRequest:
                pass
            return
        
        lines = ["üìã <b>Open Limit Orders</b>", ""]
        buttons = []
        
        for order in orders[:10]:
            symbol = order.get("symbol", "")
            side = order.get("side", "")
            price = float(order.get("price", 0))
            qty = float(order.get("qty", 0))
            oid = order.get("orderId", "")
            
            side_emoji = "üü¢" if side == "Buy" else "üî¥"
            lines.append(f"{side_emoji} {symbol}: {qty:.6f} @ ${price:.4f}")
            buttons.append([InlineKeyboardButton(f"‚ùå Cancel {symbol[:6]}", callback_data=f"spot:limit_cancel:{symbol}:{oid}")])
        
        buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:limit_order")])
        
        try:
            await q.edit_message_text("\n".join(lines), reply_markup=InlineKeyboardMarkup(buttons), parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    # ==================== GRID BOT ====================
    if action == "grid_menu":
        coins = spot_settings.get("coins", SPOT_DCA_COINS)
        grids = spot_settings.get("grids", {})
        
        lines = ["üî≤ <b>Spot Grid Bot</b>", ""]
        
        # Show active grids
        active_grids = [c for c, g in grids.items() if g.get("active")]
        if active_grids:
            lines.append("<b>Active Grids:</b>")
            for coin in active_grids:
                grid = grids[coin]
                profit = grid.get("realized_profit", 0)
                trades = grid.get("trades_count", 0)
                lines.append(f"  ‚úÖ {coin}: ${profit:.2f} profit ({trades} trades)")
            lines.append("")
        
        lines.append("Select a coin to set up grid trading:")
        
        buttons = []
        for coin in coins:
            is_active = coin in active_grids
            emoji = "‚úÖ" if is_active else "‚ûï"
            action_text = "Stop" if is_active else "Setup"
            buttons.append([InlineKeyboardButton(
                f"{emoji} {coin} Grid ({action_text})",
                callback_data=f"spot:grid_coin:{coin}"
            )])
        
        buttons.append([InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:back_to_main")])
        
        try:
            await q.edit_message_text(
                "\n".join(lines),
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
        except BadRequest:
            pass
        return
    
    if action.startswith("grid_coin:"):
        coin = action.split(":")[1]
        grids = spot_settings.get("grids", {})
        
        if coin in grids and grids[coin].get("active"):
            # Grid is active - show stop option
            grid = grids[coin]
            profit = grid.get("realized_profit", 0)
            trades = grid.get("trades_count", 0)
            
            buttons = [
                [InlineKeyboardButton("üõë Stop Grid", callback_data=f"spot:grid_stop:{coin}")],
                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:grid_menu")],
            ]
            
            try:
                await q.edit_message_text(
                    f"üî≤ <b>{coin} Grid Active</b>\n\n"
                    f"üí∞ Profit: ${profit:.2f}\n"
                    f"üìä Trades: {trades}\n"
                    f"üìà Range: ${grid.get('price_low', 0):.2f} - ${grid.get('price_high', 0):.2f}\n"
                    f"üî¢ Levels: {grid.get('grid_count', 0)}",
                    reply_markup=InlineKeyboardMarkup(buttons),
                    parse_mode="HTML"
                )
            except BadRequest:
                pass
        else:
            # Setup new grid
            ctx.user_data["spot_grid_coin"] = coin
            ctx.user_data["spot_awaiting"] = "grid_range"
            
            account_type = spot_settings.get("trading_mode", "demo")
            symbol = f"{coin}USDT"
            
            current_price = 0
            try:
                ticker = await get_spot_ticker(uid, symbol, account_type)
                if ticker:
                    current_price = float(ticker.get("lastPrice", 0))
            except Exception:
                pass
            
            try:
                await q.edit_message_text(
                    f"üî≤ <b>Setup {coin} Grid</b>\n\n"
                    f"üí∞ Current price: ${current_price:.4f}\n\n"
                    f"Enter grid parameters:\n"
                    f"<code>low_price high_price grid_count total_usdt</code>\n\n"
                    f"Example: <code>{current_price*0.9:.2f} {current_price*1.1:.2f} 10 100</code>",
                    parse_mode="HTML"
                )
            except BadRequest:
                pass
        return
    
    if action.startswith("grid_stop:"):
        coin = action.split(":")[1]
        account_type = spot_settings.get("trading_mode", "demo")
        
        result = await stop_spot_grid(uid, coin, account_type)
        
        if result.get("success"):
            msg = (
                f"üõë <b>{coin} Grid Stopped</b>\n\n"
                f"üìä Total Trades: {result.get('total_trades', 0)}\n"
                f"üí∞ Total Profit: ${result.get('total_profit', 0):.2f}\n"
                f"‚ùå Orders Cancelled: {result.get('orders_cancelled', 0)}"
            )
            await q.answer("Grid stopped!")
        else:
            msg = f"‚ùå Failed to stop grid: {result.get('error', 'Unknown')}"
        
        buttons = [[InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:grid_menu")]]
        
        try:
            await q.edit_message_text(msg, reply_markup=InlineKeyboardMarkup(buttons), parse_mode="HTML")
        except BadRequest:
            pass
        return
    
    if action == "back":
        await q.message.delete()
        await ctx.bot.send_message(
            chat_id=uid,
            text=t["welcome"],
            reply_markup=main_menu_keyboard(ctx, update=update)
        )
        return


@with_texts
@log_calls
async def handle_spot_text_input(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> bool:
    """Handle text input for Spot settings (e.g., DCA amount).
    Returns True if handled, False otherwise.
    """
    if not ctx.user_data.get("spot_awaiting"):
        return False
    
    uid = update.effective_user.id
    t = ctx.t
    text = update.message.text.strip()
    awaiting = ctx.user_data.pop("spot_awaiting", None)
    
    if awaiting == "amount":
        try:
            amount = float(text)
            if amount < 1:
                await update.message.reply_text(t.get("min_amount_error", "‚ùå Minimum amount is 1 USDT"))
                return True
            if amount > 100000:
                await update.message.reply_text(t.get("max_amount_error", "‚ùå Maximum amount is 100,000 USDT"))
                return True
            
            cfg = db.get_user_config(uid)
            spot_settings = cfg.get("spot_settings") or {}
            spot_settings["dca_amount"] = amount
            db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
            
            await update.message.reply_text(
                t.get("spot_amount_saved", "‚úÖ DCA amount set to {amount} USDT").format(amount=amount)
            )
            
            # Show updated settings
            cfg = db.get_user_config(uid)
            spot_settings = cfg.get("spot_settings") or {}
            msg = format_spot_settings_message(t, cfg, spot_settings)
            keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
            await update.message.reply_text(msg, reply_markup=keyboard, parse_mode="HTML")
            
            return True
        except ValueError:
            await update.message.reply_text(t.get("invalid_amount", "‚ùå Invalid number. Please enter a valid amount."))
            return True
    
    if awaiting == "tp_gain":
        # Handle TP gain percentage input
        try:
            gain_pct = float(text)
            if gain_pct < 1:
                await reply_with_keyboard(update, ctx, t.get("spot_gain_min", "‚ùå Minimum gain trigger is 1%"))
                return True
            if gain_pct > 10000:
                await reply_with_keyboard(update, ctx, t.get("spot_gain_max", "‚ùå Maximum gain trigger is 10000%"))
                return True
            
            level_idx = ctx.user_data.get("spot_edit_tp_level", 0)
            cfg = db.get_user_config(uid)
            spot_settings = cfg.get("spot_settings") or {}
            tp_levels = spot_settings.get("tp_levels", DEFAULT_SPOT_TP_LEVELS.copy())
            
            if 0 <= level_idx < len(tp_levels):
                tp_levels[level_idx]["gain_pct"] = gain_pct
                spot_settings["tp_levels"] = tp_levels
                db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
            
            # Now ask for sell percentage
            ctx.user_data["spot_awaiting"] = "tp_sell"
            await update.message.reply_text(
                f"‚úÖ Gain trigger set to +{gain_pct}%\n\n"
                f"Now enter <b>sell amount %</b> (how much to sell when triggered):",
                parse_mode="HTML"
            )
            return True
        except ValueError:
            await reply_with_keyboard(update, ctx, t.get("spot_invalid_pct", "‚ùå Invalid number. Please enter a valid percentage."))
            return True
    
    if awaiting == "tp_sell":
        # Handle TP sell percentage input
        try:
            sell_pct = float(text)
            if sell_pct < 1:
                await reply_with_keyboard(update, ctx, t.get("spot_sell_min", "‚ùå Minimum sell amount is 1%"))
                return True
            if sell_pct > 100:
                await reply_with_keyboard(update, ctx, t.get("spot_sell_max", "‚ùå Maximum sell amount is 100%"))
                return True
            
            level_idx = ctx.user_data.pop("spot_edit_tp_level", 0)
            cfg = db.get_user_config(uid)
            spot_settings = cfg.get("spot_settings") or {}
            tp_levels = spot_settings.get("tp_levels", DEFAULT_SPOT_TP_LEVELS.copy())
            
            if 0 <= level_idx < len(tp_levels):
                tp_levels[level_idx]["sell_pct"] = sell_pct
                spot_settings["tp_levels"] = tp_levels
                db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
            
            # Show updated TP levels
            lines = [
                "‚úÖ <b>TP Level Updated!</b>",
                "",
                "üéØ <b>Current TP Levels:</b>",
                "",
            ]
            for i, level in enumerate(tp_levels):
                marker = "üìç" if i == level_idx else "‚Ä¢"
                lines.append(f"{marker} At +{level['gain_pct']}% ‚Üí Sell {level['sell_pct']}%")
            
            buttons = [
                [InlineKeyboardButton("‚¨ÖÔ∏è Back to TP Settings", callback_data="spot:tp_settings")],
                [InlineKeyboardButton("üè† Main Menu", callback_data="spot:back_to_main")],
            ]
            
            await update.message.reply_text(
                "\n".join(lines),
                reply_markup=InlineKeyboardMarkup(buttons),
                parse_mode="HTML"
            )
            return True
        except ValueError:
            await reply_with_keyboard(update, ctx, t.get("spot_invalid_pct", "‚ùå Invalid number. Please enter a valid percentage."))
            return True
    
    # ==================== LIMIT ORDER INPUT ====================
    if awaiting == "limit_price":
        try:
            limit_price = float(text)
            if limit_price <= 0:
                await reply_with_keyboard(update, ctx, "‚ùå Price must be positive")
                return True
            
            ctx.user_data["spot_limit_price"] = limit_price
            ctx.user_data["spot_awaiting"] = "limit_amount"
            
            coin = ctx.user_data.get("spot_limit_coin", "BTC")
            await update.message.reply_text(
                f"üìã <b>Limit Buy {coin}</b>\n\n"
                f"üí∞ Price: ${limit_price:.4f}\n\n"
                f"Enter USDT amount to invest:",
                parse_mode="HTML"
            )
            return True
        except ValueError:
            await reply_with_keyboard(update, ctx, "‚ùå Invalid price. Please enter a number.")
            return True
    
    if awaiting == "limit_amount":
        try:
            amount = float(text)
            if amount < 5:
                await reply_with_keyboard(update, ctx, "‚ùå Minimum amount is 5 USDT")
                return True
            
            coin = ctx.user_data.pop("spot_limit_coin", "BTC")
            limit_price = ctx.user_data.pop("spot_limit_price", 0)
            
            cfg = db.get_user_config(uid)
            spot_settings = cfg.get("spot_settings") or {}
            account_type = spot_settings.get("trading_mode", "demo")
            
            result = await place_spot_limit_order(
                user_id=uid,
                coin=coin,
                side="Buy",
                price=limit_price,
                usdt_amount=amount,
                account_type=account_type,
            )
            
            if result.get("success"):
                msg = (
                    f"‚úÖ <b>Limit Order Placed!</b>\n\n"
                    f"ü™ô {coin}\n"
                    f"üí∞ Price: ${limit_price:.4f}\n"
                    f"üì¶ Amount: {result.get('qty', 0):.6f}\n"
                    f"üíµ Investment: ${amount:.2f}"
                )
            else:
                msg = f"‚ùå <b>Failed to place order</b>\n\n{result.get('error', 'Unknown error')}"
            
            buttons = [
                [InlineKeyboardButton("üìã View Orders", callback_data="spot:limit_view")],
                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:limit_order")],
            ]
            
            await update.message.reply_text(msg, reply_markup=InlineKeyboardMarkup(buttons), parse_mode="HTML")
            return True
        except ValueError:
            await reply_with_keyboard(update, ctx, "‚ùå Invalid amount. Please enter a number.")
            return True
    
    # ==================== GRID BOT INPUT ====================
    if awaiting == "grid_range":
        try:
            parts = text.split()
            if len(parts) != 4:
                await update.message.reply_text(
                    "‚ùå Invalid format. Please enter:\n"
                    "<code>low_price high_price grid_count total_usdt</code>",
                    parse_mode="HTML"
                )
                return True
            
            price_low = float(parts[0])
            price_high = float(parts[1])
            grid_count = int(parts[2])
            total_investment = float(parts[3])
            
            if price_low >= price_high:
                await reply_with_keyboard(update, ctx, "‚ùå Low price must be less than high price")
                return True
            if grid_count < 3 or grid_count > 50:
                await reply_with_keyboard(update, ctx, "‚ùå Grid count must be between 3 and 50")
                return True
            if total_investment < 10:
                await reply_with_keyboard(update, ctx, t.get("grid_min_10", "‚ùå Minimum investment is 10 USDT"))
                return True
            
            coin = ctx.user_data.pop("spot_grid_coin", "BTC")
            
            cfg = db.get_user_config(uid)
            spot_settings = cfg.get("spot_settings") or {}
            account_type = spot_settings.get("trading_mode", "demo")
            
            await update.message.reply_text(t.get("grid_setup", "‚è≥ Setting up {coin} grid...").format(coin=coin))
            
            result = await setup_spot_grid(
                user_id=uid,
                coin=coin,
                price_low=price_low,
                price_high=price_high,
                grid_count=grid_count,
                total_investment=total_investment,
                account_type=account_type,
            )
            
            if result.get("success"):
                msg = (
                    f"‚úÖ <b>{coin} Grid Bot Started!</b>\n\n"
                    f"üìà Range: ${price_low:.2f} - ${price_high:.2f}\n"
                    f"üî¢ Levels: {grid_count}\n"
                    f"üíµ Investment: ${total_investment:.2f}\n"
                    f"üìä Orders placed: {result.get('orders_placed', 0)}\n"
                    f"üìç Grid step: ${result.get('grid_step', 0):.4f}"
                )
            else:
                msg = f"‚ùå <b>Failed to setup grid</b>\n\n{result.get('error', 'Unknown error')}"
            
            buttons = [
                [InlineKeyboardButton("üî≤ Grid Menu", callback_data="spot:grid_menu")],
                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="spot:back_to_main")],
            ]
            
            await update.message.reply_text(msg, reply_markup=InlineKeyboardMarkup(buttons), parse_mode="HTML")
            return True
        except ValueError:
            await update.message.reply_text(
                t.get("grid_invalid_input", "‚ùå Invalid input. Please enter numbers.") + "\n<code>low_price high_price grid_count total_usdt</code>",
                parse_mode="HTML"
            )
            return True
    
    return False


def _clean(x: float) -> float:
    return float(f"{x:.12f}")

def quantize(value: float, step: float) -> float:
    return _clean(floor(value / step) * step)

def quantize_up(value: float, step: float) -> float:
    return _clean(math.ceil(value / step) * step)

def _prices_equal(a, b, rel_tol=1e-6, abs_tol=1e-8) -> bool:
    """Compare two prices with tolerance for floating point precision.
    Returns True if prices are essentially equal.
    Used to avoid unnecessary API calls when SL/TP differs only by float precision.
    
    Args:
        a: First price
        b: Second price  
        rel_tol: Relative tolerance (0.0001% of max price)
        abs_tol: Absolute tolerance (effectively zero ‚Äî rely on rel_tol)
    
    CRITICAL: abs_tol was 0.01 before, which made ALL price differences under $0.01
    be treated as "equal". For low-price coins (MOCA=$0.015, LINEA=$0.003), this
    caused ATR trailing SL to NEVER update because diff < 0.01 ‚Üí always "equal".
    Fixed Feb 11, 2026: abs_tol=1e-8 (effectively zero).
    """
    if a is None and b is None:
        return True
    if a is None or b is None:
        return False
    # Use both relative and absolute tolerance
    return abs(a - b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)

def _decimals_from_step(step: float) -> int:
    s = f"{step:.16f}".rstrip("0")
    if "." in s:
        return len(s.split(".")[1])
    return 0

def resolve_sl_tp_pct(cfg: dict, symbol: str, strategy: str | None = None, user_id: int | None = None, side: str | None = None) -> tuple[float, float]:
    """
    Resolve SL/TP percentages for a trade.
    If strategy is provided and user has per-strategy settings, use those.
    For ALL strategies, side-specific settings (long_sl_percent, short_sl_percent) take priority if side is provided.
    Otherwise fallback to global user settings, then coin-specific defaults.
    
    Uses user's current exchange/account context for strategy settings lookup.
    """
    coin_cfg = COIN_PARAMS.get(symbol, COIN_PARAMS["DEFAULT"])

    # Try to get per-strategy settings if available
    strat_sl = None
    strat_tp = None
    if strategy and user_id:
        # Get user's current exchange/account context
        context = get_user_trading_context(user_id)
        strat_settings = db.get_strategy_settings(
            user_id, strategy, 
            context["exchange"], 
            context["account_type"]
        )
        
        # For ALL strategies, check side-specific settings first if side is provided
        if side:
            side_prefix = "long" if side in ("Buy", "LONG", "long") else "short"
            side_sl = strat_settings.get(f"{side_prefix}_sl_percent")
            side_tp = strat_settings.get(f"{side_prefix}_tp_percent")
            # DEBUG: Log side resolution
            logger.info(f"[RESOLVE-SL-TP] uid={user_id} symbol={symbol} strategy={strategy} side={side} side_prefix={side_prefix} side_sl={side_sl} side_tp={side_tp}")
            
            if side_sl is not None and side_sl > 0:
                strat_sl = side_sl
            if side_tp is not None and side_tp > 0:
                strat_tp = side_tp
        
        # Fallback to general strategy settings if side-specific not set
        if strat_sl is None:
            strat_sl = strat_settings.get("sl_percent")
        if strat_tp is None:
            strat_tp = strat_settings.get("tp_percent")

    # Priority: strategy settings > user global settings > coin defaults
    # SL
    user_sl = cfg.get("sl_percent") or 0
    if strat_sl is not None and 0 < strat_sl <= 50:
        sl_pct = float(strat_sl)
        logger.debug(f"[SL-RESOLVE] uid={user_id}, strategy={strategy}, strat_sl={strat_sl}, user_sl={user_sl}, sl_pct={sl_pct} (from strategy settings)")
    elif 0 < user_sl <= 50:
        sl_pct = float(user_sl)
        logger.debug(f"[SL-RESOLVE] uid={user_id}, strategy={strategy}, strat_sl={strat_sl}, user_sl={user_sl}, sl_pct={sl_pct} (from user global)")
    else:
        sl_pct = float(coin_cfg.get("sl_pct", DEFAULT_SL_PCT))
        logger.debug(f"[SL-RESOLVE] uid={user_id}, strategy={strategy}, strat_sl={strat_sl}, user_sl={user_sl}, sl_pct={sl_pct} (from coin defaults)")

    # TP
    if strat_tp is not None and float(strat_tp) > sl_pct:
        tp_pct = float(strat_tp)
    else:
        user_tp = cfg.get("tp_percent") or 0
        if float(user_tp) > sl_pct:
            tp_pct = float(user_tp)
        else:
            tp_pct = float(coin_cfg.get("tp_pct", DEFAULT_TP_PCT))

    return sl_pct, tp_pct


def get_strategy_trade_params(uid: int, cfg: dict, symbol: str, strategy: str, side: str = None,
                              exchange: str = None, account_type: str = None) -> dict:
    """
    Get trading parameters for a specific strategy.
    Returns dict with: percent (risk%), sl_pct, tp_pct, use_atr, be_enabled, be_trigger_pct
    Falls back to global user settings if per-strategy not set.
    
    For ALL strategies, if side is provided, uses side-specific settings (long_percent, short_sl_percent, etc.)
    
    Args:
        uid: User ID
        cfg: User config dict
        symbol: Trading symbol
        strategy: Strategy name
        side: 'Buy' or 'Sell' for side-specific settings
        exchange: 'bybit' or 'hyperliquid' (auto-detected if None)
        account_type: 'demo', 'real', 'testnet', 'mainnet' (auto-detected if None)
    """
    # Auto-detect context if not provided
    if exchange is None or account_type is None:
        context = get_user_trading_context(uid)
        exchange = exchange or context["exchange"]
        account_type = account_type or context["account_type"]
    
    strat_settings = db.get_strategy_settings(uid, strategy, exchange, account_type)
    
    # Determine use_atr: strategy-specific takes priority over global
    # NOTE: pg_get_strategy_settings returns long_use_atr/short_use_atr, NOT generic use_atr
    # When side is not provided yet, check both sides for consensus, else fall back to global
    strat_use_atr = strat_settings.get("use_atr")  # Generic key (usually None)
    if strat_use_atr is None:
        # Try to get from either side as initial default (will be overridden in side-specific block)
        long_atr = strat_settings.get("long_use_atr")
        short_atr = strat_settings.get("short_use_atr")
        if long_atr is not None or short_atr is not None:
            # Use first available side setting as initial value
            strat_use_atr = long_atr if long_atr is not None else short_atr
    if strat_use_atr is not None:
        use_atr = bool(strat_use_atr)
    else:
        use_atr = bool(cfg.get("use_atr", 1))  # Default to ATR enabled
    
    # Determine BE settings: strategy-specific takes priority over global
    strat_be_enabled = strat_settings.get("be_enabled")
    if strat_be_enabled is not None:
        be_enabled = bool(strat_be_enabled)
    else:
        be_enabled = bool(cfg.get("be_enabled", 0))  # Default to BE disabled
    
    strat_be_trigger = strat_settings.get("be_trigger_pct")
    if strat_be_trigger is not None and strat_be_trigger > 0:
        be_trigger_pct = float(strat_be_trigger)
    else:
        be_trigger_pct = float(cfg.get("be_trigger_pct", 1.0))  # Default 1%
    
    # For ALL strategies, check for side-specific settings first if side is provided
    if side:
        side_prefix = "long" if side == "Buy" else "short"
        
        # Get side-specific percent
        side_percent = strat_settings.get(f"{side_prefix}_percent")
        if side_percent is not None and side_percent > 0:
            percent = float(side_percent)
        else:
            # Fallback to general strategy percent, then global
            strat_percent = strat_settings.get("percent")
            if strat_percent is not None and strat_percent > 0:
                percent = float(strat_percent)
            else:
                percent = float(cfg.get("percent", 1))
        
        # Get side-specific SL
        side_sl = strat_settings.get(f"{side_prefix}_sl_percent")
        if side_sl is not None and side_sl > 0:
            sl_pct = float(side_sl)
        else:
            sl_pct, _ = resolve_sl_tp_pct(cfg, symbol, strategy=strategy, user_id=uid, side=side)
        
        # Get side-specific TP
        side_tp = strat_settings.get(f"{side_prefix}_tp_percent")
        if side_tp is not None and side_tp > 0:
            tp_pct = float(side_tp)
        else:
            _, tp_pct = resolve_sl_tp_pct(cfg, symbol, strategy=strategy, user_id=uid, side=side)
        
        # Get side-specific BE settings
        side_be_enabled = strat_settings.get(f"{side_prefix}_be_enabled")
        if side_be_enabled is not None:
            be_enabled = bool(side_be_enabled)
        
        side_be_trigger = strat_settings.get(f"{side_prefix}_be_trigger_pct")
        if side_be_trigger is not None and side_be_trigger > 0:
            be_trigger_pct = float(side_be_trigger)
        
        # Get side-specific use_atr (CRITICAL FIX: must override global!)
        # pg_get_strategy_settings() returns long_use_atr / short_use_atr, NOT generic use_atr
        # Without this, use_atr always falls back to global user setting from users table
        side_use_atr = strat_settings.get(f"{side_prefix}_use_atr")
        if side_use_atr is not None:
            use_atr = bool(side_use_atr)
        
        # Get side-specific leverage
        side_leverage = strat_settings.get(f"{side_prefix}_leverage")
        if side_leverage is not None and side_leverage > 0:
            leverage = int(side_leverage)
        else:
            # Fallback to global user leverage
            leverage = int(cfg.get("leverage", 10))
        
        # Get side-specific order_type and limit_offset_pct
        side_order_type = strat_settings.get(f"{side_prefix}_order_type")
        if side_order_type:
            order_type = side_order_type
        else:
            order_type = cfg.get("global_order_type", "market")
        
        side_limit_offset = strat_settings.get(f"{side_prefix}_limit_offset_pct")
        if side_limit_offset is not None and side_limit_offset > 0:
            limit_offset_pct = float(side_limit_offset)
        else:
            limit_offset_pct = float(cfg.get("limit_offset_pct", 0.1))
        
        # Get DCA settings
        side_dca_enabled = strat_settings.get(f"{side_prefix}_dca_enabled")
        if side_dca_enabled is not None:
            dca_enabled = bool(side_dca_enabled)
        else:
            dca_enabled = bool(cfg.get("dca_enabled", 0))
        
        side_dca_pct_1 = strat_settings.get(f"{side_prefix}_dca_pct_1")
        if side_dca_pct_1 is not None and side_dca_pct_1 > 0:
            dca_pct_1 = float(side_dca_pct_1)
        else:
            dca_pct_1 = float(cfg.get("dca_pct_1", 10.0))
        
        side_dca_pct_2 = strat_settings.get(f"{side_prefix}_dca_pct_2")
        if side_dca_pct_2 is not None and side_dca_pct_2 > 0:
            dca_pct_2 = float(side_dca_pct_2)
        else:
            dca_pct_2 = float(cfg.get("dca_pct_2", 25.0))
        
        # Get Partial TP settings
        side_ptp_enabled = strat_settings.get(f"{side_prefix}_partial_tp_enabled")
        if side_ptp_enabled is not None:
            partial_tp_enabled = bool(side_ptp_enabled)
        else:
            partial_tp_enabled = False
        
        side_ptp_1_trigger = strat_settings.get(f"{side_prefix}_partial_tp_1_trigger_pct")
        if side_ptp_1_trigger is not None and side_ptp_1_trigger > 0:
            partial_tp_1_trigger_pct = float(side_ptp_1_trigger)
        else:
            partial_tp_1_trigger_pct = 2.0
        
        side_ptp_1_close = strat_settings.get(f"{side_prefix}_partial_tp_1_close_pct")
        if side_ptp_1_close is not None and side_ptp_1_close > 0:
            partial_tp_1_close_pct = float(side_ptp_1_close)
        else:
            partial_tp_1_close_pct = 30.0
        
        side_ptp_2_trigger = strat_settings.get(f"{side_prefix}_partial_tp_2_trigger_pct")
        if side_ptp_2_trigger is not None and side_ptp_2_trigger > 0:
            partial_tp_2_trigger_pct = float(side_ptp_2_trigger)
        else:
            partial_tp_2_trigger_pct = 5.0
        
        side_ptp_2_close = strat_settings.get(f"{side_prefix}_partial_tp_2_close_pct")
        if side_ptp_2_close is not None and side_ptp_2_close > 0:
            partial_tp_2_close_pct = float(side_ptp_2_close)
        else:
            partial_tp_2_close_pct = 30.0
        
        return {
            "percent": percent,
            "sl_pct": sl_pct,
            "tp_pct": tp_pct,
            "use_atr": use_atr,
            "be_enabled": be_enabled,
            "be_trigger_pct": be_trigger_pct,
            "leverage": leverage,
            "order_type": order_type,
            "limit_offset_pct": limit_offset_pct,
            "dca_enabled": dca_enabled,
            "dca_pct_1": dca_pct_1,
            "dca_pct_2": dca_pct_2,
            "partial_tp_enabled": partial_tp_enabled,
            "partial_tp_1_trigger_pct": partial_tp_1_trigger_pct,
            "partial_tp_1_close_pct": partial_tp_1_close_pct,
            "partial_tp_2_trigger_pct": partial_tp_2_trigger_pct,
            "partial_tp_2_close_pct": partial_tp_2_close_pct,
        }
    
    # Default behavior when side is not provided
    # Get percent (risk)
    strat_percent = strat_settings.get("percent")
    if strat_percent is not None and strat_percent > 0:
        percent = float(strat_percent)
    else:
        percent = float(cfg.get("percent", 1))
    
    # Get SL/TP using resolve function with strategy awareness
    sl_pct, tp_pct = resolve_sl_tp_pct(cfg, symbol, strategy=strategy, user_id=uid)
    
    # Get leverage (no side-specific when side not provided)
    strat_leverage = strat_settings.get("long_leverage") or strat_settings.get("short_leverage")
    if strat_leverage is not None and strat_leverage > 0:
        leverage = int(strat_leverage)
    else:
        leverage = int(cfg.get("leverage", 10))
    
    # Order type defaults when side not provided
    order_type = cfg.get("global_order_type", "market")
    limit_offset_pct = float(cfg.get("limit_offset_pct", 0.1))
    
    return {
        "percent": percent,
        "sl_pct": sl_pct,
        "tp_pct": tp_pct,
        "use_atr": use_atr,
        "be_enabled": be_enabled,
        "be_trigger_pct": be_trigger_pct,
        "leverage": leverage,
        "order_type": order_type,
        "limit_offset_pct": limit_offset_pct,
        "dca_enabled": False,
        "dca_pct_1": 10.0,
        "dca_pct_2": 25.0,
        "partial_tp_enabled": False,
        "partial_tp_1_trigger_pct": 2.0,
        "partial_tp_1_close_pct": 30.0,
        "partial_tp_2_trigger_pct": 5.0,
        "partial_tp_2_close_pct": 30.0,
    }


def _sign_payload(ts, api_key, secret, recv_window, body_json, query):
    base = ts + api_key + recv_window
    to_sign = base + (query or "") + (body_json or "")
    return hmac.new(secret.encode(), to_sign.encode(), hashlib.sha256).hexdigest()


def classify_headline(headline: str) -> str:
    text = headline.lower()
    words = set(re.findall(r'\w+', text))
    if words & NEGATIVE_KEYWORDS:
        return 'bad'
    if words & POSITIVE_KEYWORDS:
        return 'good'
    return 'neutral'

def _to_float_num(s: str) -> float:
    return float(s.replace(",", ".").strip())

def parse_manual(parts: list[str], typ: str):
    if typ == 'Limit':
        if len(parts) != 4:
            raise ValueError("Limit: 4 arguments required (SYMBOL SIDE PRICE QTY)")
        symbol, side_str, price_s, qty_s = parts
        price = _to_float_num(price_s)
        qty   = _to_float_num(qty_s)
    else:
        if len(parts) != 3:
            raise ValueError("Market: 3 arguments required (SYMBOL SIDE QTY)")
        symbol, side_str, qty_s = parts
        price = None
        qty   = _to_float_num(qty_s)

    side_str = side_str.strip().upper()
    if side_str not in ("LONG", "SHORT"):
        raise ValueError("SIDE must be LONG or SHORT")
    side = "Buy" if side_str == "LONG" else "Sell"
    return symbol.upper(), side, price, qty


def human_format(num: float) -> str:
    if abs(num) >= 1_000_000:
        return f"{num/1_000_000:.1f}M"
    if abs(num) >= 1_000:
        return f"{num/1_000:.1f}K"
    return f"{num:.2f}"

def _parse_sqlite_ts_to_utc(s: str) -> float:
    try:
        dt = datetime.datetime.fromisoformat(s.replace(" ", "T"))
    except Exception:
        try:
            return float(s)
        except Exception:
            return 0.0
    if dt.tzinfo is None:
        dt = dt.replace(tzinfo=datetime.timezone.utc)
    return dt.timestamp()


async def reply_with_keyboard(update: Update, ctx: ContextTypes.DEFAULT_TYPE, text: str, parse_mode: str = "HTML"):
    """
    Send reply with main menu keyboard. Use this instead of update.message.reply_text() 
    to ensure keyboard never disappears.
    """
    keyboard = main_menu_keyboard(ctx, update=update)
    await update.message.reply_text(text, reply_markup=keyboard, parse_mode=parse_mode)


def main_menu_keyboard(ctx: ContextTypes.DEFAULT_TYPE, user_id: int = None, update: Update = None):
    """Generate main menu keyboard. Modern, clean and compact design."""
    # Get translations - fallback to English if ctx.t not available
    t = getattr(ctx, 't', None)
    if t is None:
        # Load translations for this user
        lang = db.get_user_lang(user_id) if user_id else 'en'
        t = LANGS.get(lang, LANGS[DEFAULT_LANG])
    
    # Try to get user_id from update if not provided
    if user_id is None and update is not None:
        try:
            user_id = update.effective_user.id
        except Exception:
            pass
    
    # Get active exchange and trading mode
    active_exchange = get_exchange_type(user_id) if user_id else "bybit"
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  UNIFIED MODERN COMPACT MENU  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # Exchange status button (shows current active exchange + account mode)
    if active_exchange == "hyperliquid":
        trading_mode_hl = get_trading_mode(user_id) if user_id else "demo"
        is_testnet_display = trading_mode_hl in ("demo", "testnet")
        if is_testnet_display:
            exchange_btn = t.get('exchange_hl_testnet', 'üî∑ HL Testnet üß™')
        else:
            exchange_btn = t.get('exchange_hl_mainnet', 'üî∑ HL Mainnet üåê')
    else:
        creds = get_all_user_credentials(user_id) if user_id else {}
        trading_mode = creds.get("trading_mode", "demo")
        if trading_mode == "demo":
            exchange_btn = t.get('exchange_bybit_demo', 'üü† Bybit Demo üéÆ')
        elif trading_mode == "real":
            exchange_btn = t.get('exchange_bybit_real', 'üü† Bybit Real üíµ')
        else:  # both
            exchange_btn = t.get('exchange_bybit_both', 'üü† Bybit Demo+Real üîÄ')
    
    # Build webapp URL with user_id for auto-login
    webapp_url = WEBAPP_URL
    
    import time
    cache_bust = int(time.time())
    webapp_url_with_user = f"{webapp_url}/dashboard?start={user_id}&_t={cache_bust}" if user_id else f"{webapp_url}/dashboard?_t={cache_bust}"
    
    keyboard = [
        # ‚îÄ‚îÄ‚îÄ Row 1: Core Trading ‚îÄ‚îÄ‚îÄ
        [ t.get('button_balance', 'üíé Portfolio'), t.get('button_positions', 'üéØ Positions'), t.get('button_orders', 'üìä Orders') ],
        # ‚îÄ‚îÄ‚îÄ Row 2: AI & Market ‚îÄ‚îÄ‚îÄ
        [ t.get('button_strategies', 'ü§ñ AI Bots'), t.get('button_market', 'üìà Market'), t.get('button_history', 'üìú History') ],
        # ‚îÄ‚îÄ‚îÄ Row 3: Premium & Settings ‚îÄ‚îÄ‚îÄ
        [ t.get('button_lang', 'üåç Lang'), t.get('button_api_keys', 'üîó API Keys'), exchange_btn ],
        # ‚îÄ‚îÄ‚îÄ Row 4: Terminal & Exchange ‚îÄ‚îÄ‚îÄ
        [ t.get('button_terminal', 'üíª Terminal'), t.get('button_subscribe', 'üëë PREMIUM') ],
    ]
    
    # Add admin row if user is admin
    if user_id == ADMIN_ID:
        keyboard.append([ t.get('button_licenses', 'üé´ Licenses'), t.get('button_admin', 'üõ°Ô∏è Admin') ])
    
    return ReplyKeyboardMarkup(
        keyboard=keyboard,
        resize_keyboard=True
    )

def extract_image_from_summary(summary_html: str) -> str | None:
    m = re.search(r'<img[^>]+src="([^"]+)"', summary_html)
    return unescape(m.group(1)) if m else None

_position_mode_cache: dict[tuple[int, str], str] = {} 
_atr_triggered: dict[tuple[int, str, str], bool] = {}  # (uid, symbol, account_type)
_atr_was_enabled: dict[tuple[int, str, str], bool] = {}  # Track if ATR was enabled for (uid, symbol, account_type) - for detecting when ATR gets disabled
_atr_tp_removal_done: dict[tuple[int, str, str], float] = {}  # (uid, symbol, account_type) -> timestamp of last successful TP removal (inc. retCode 34040)
_be_triggered: dict[tuple[int, str, str], bool] = {}  # Track if BE (break-even) was applied for (uid, symbol, account_type)
_close_all_cooldown: dict[int, float] = {}  # uid -> timestamp when cooldown ends
_notification_retry_after: dict[int, float] = {}  # uid -> timestamp when Telegram rate limit expires
_telegram_id_cache: dict[int, int | None] = {}  # uid -> telegram_id (None = no telegram linked)
# HyperLiquid SL cache - HL API doesn't return stopLoss field, so we track what we set
# Key: (uid, symbol), Value: sl_price that was last set
# This prevents repeated API calls when SL is already set
_hl_sl_cache: dict[tuple[int, str], float] = {}

# HyperLiquid SL/TP fail cooldown - prevents retrying set_tp_sl every 20s when it fails
# Key: (uid, symbol), Value: timestamp of last failure
# Cooldown: 5 minutes between retry attempts for the same symbol
_hl_sl_fail_cooldown: dict[tuple[int, str], float] = {}
_HL_SL_FAIL_COOLDOWN_SEC = 300  # 5 minutes


def get_telegram_id_for_notifications(uid: int) -> int | None:
    """
    Get Telegram ID for sending notifications.
    
    For email-only users (negative uid), telegram_id may be NULL.
    For Telegram users (positive uid), user_id == telegram_id.
    
    Returns:
        telegram_id if available, None if user has no Telegram linked
    """
    # Check cache first
    if uid in _telegram_id_cache:
        return _telegram_id_cache[uid]
    
    # For positive user_id, it's a Telegram user - their ID is the telegram_id
    if uid > 0:
        _telegram_id_cache[uid] = uid
        return uid
    
    # For negative user_id (email users), check if they have telegram_id linked
    try:
        from core.db_postgres import get_conn
        with get_conn() as conn:
            cur = conn.cursor()
            cur.execute("SELECT telegram_id FROM users WHERE user_id = %s", (uid,))
            row = cur.fetchone()
            if row and row[0]:
                telegram_id = int(row[0])
                _telegram_id_cache[uid] = telegram_id
                return telegram_id
            else:
                _telegram_id_cache[uid] = None
                return None
    except Exception as e:
        logger.warning(f"[{uid}] Could not get telegram_id: {e}")
        _telegram_id_cache[uid] = None
        return None


async def safe_send_notification(bot, uid: int, text: str, **kwargs) -> bool:
    """
    Send message with Telegram rate limit handling.
    Returns True if sent, False if rate limited or user has no Telegram.
    """
    from telegram.error import RetryAfter
    
    # Get the actual Telegram ID to send to
    telegram_id = get_telegram_id_for_notifications(uid)
    if telegram_id is None:
        # User has no Telegram linked - skip silently (no error log spam)
        logger.debug(f"[{uid}] Skipping notification - no Telegram ID linked")
        return False
    
    # Check if user is rate limited
    retry_until = _notification_retry_after.get(telegram_id, 0)
    if time.time() < retry_until:
        logger.debug(f"[{telegram_id}] Skipping notification - rate limited until {retry_until}")
        return False
    
    try:
        await bot.send_message(telegram_id, text, **kwargs)
        return True
    except RetryAfter as e:
        # Store retry_after time and skip this notification
        _notification_retry_after[telegram_id] = time.time() + e.retry_after
        logger.warning(f"[{telegram_id}] Telegram rate limit hit, retry after {e.retry_after}s")
        return False
    except Exception as e:
        logger.error(f"[{telegram_id}] Failed to send notification: {e}")
        return False


@log_calls
async def get_position_mode(user_id: int, symbol: str, account_type: str = None) -> str:
    key = (user_id, symbol, account_type or "auto")
    mode = _position_mode_cache.get(key)
    if mode:
        return mode

    res = await _bybit_request(
        user_id, "GET", "/v5/position/list",
        params={"category": "linear", "symbol": symbol},
        account_type=account_type
    )
    items = res.get("list", []) or []
    idxs = {int(it.get("positionIdx", 0)) for it in items if it is not None}

    mode = "hedge" if (1 in idxs or 2 in idxs) else "one_way"
    _position_mode_cache[key] = mode
    return mode

def position_idx_for(side: str, mode: str) -> int:
    if mode == "hedge":
        return 1 if side == "Buy" else 2
    return 0

@with_texts
@log_calls
async def cmd_approve(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return
    try:
        target_uid = int((ctx.args or [None])[0])
        if not target_uid:
            raise ValueError
    except Exception:
        await reply_with_keyboard(update, ctx, ctx.t["usage_approve"])
        return

    set_user_field(target_uid, "is_allowed", 1)
    set_user_field(target_uid, "is_banned", 0)

    await reply_with_keyboard(update, ctx, ctx.t["moderation_approved"].format(target=target_uid))
    try:
        await ctx.bot.send_message(target_uid, ctx.t["approved_user_dm"])
    except Exception:
        pass

@with_texts
@log_calls
async def whoami(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await reply_with_keyboard(update, ctx, ctx.t.get("your_id", "Your ID: {uid}").format(uid=update.effective_user.id))

@with_texts
@log_calls
async def cmd_ban(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return
    try:
        target_uid = int((ctx.args or [None])[0])
        if not target_uid:
            raise ValueError
    except Exception:
        await reply_with_keyboard(update, ctx, ctx.t["usage_ban"])
        return

    set_user_field(target_uid, "is_banned", 1)
    set_user_field(target_uid, "is_allowed", 0)

    await reply_with_keyboard(update, ctx, ctx.t["moderation_banned"].format(target=target_uid))
    try:
        await ctx.bot.send_message(target_uid, ctx.t["banned_user_dm"])
    except Exception:
        pass

@log_calls
async def set_leverage(
    user_id: int,
    symbol: str,
    leverage: int = 10,
    account_type: str = None
) -> int:
    """
    Set leverage for a symbol. Uses cache to avoid redundant API calls.
    Returns the actual leverage that was set (may differ from requested due to fallback).
    Returns 0 if failed to set any leverage.
    """
    # Clamp leverage to reasonable bounds (Bybit max is typically 100-500 depending on symbol)
    leverage = max(1, min(leverage, 200))
    
    cache_key = (user_id, symbol, account_type or "auto")
    current_lev = _leverage_cache.get(cache_key)
    
    if current_lev == leverage:
        logger.debug(f"[{user_id}] Leverage for {symbol} already {leverage}x, skipping API call")
        return leverage  # Already set, return current
    
    body = {
        "category":    "linear",
        "symbol":      symbol,
        "buyLeverage":  str(leverage),
        "sellLeverage": str(leverage),
    }
    try:
        await _bybit_request(user_id, "POST", "/v5/position/set-leverage", body=body, account_type=account_type)
        _leverage_cache[cache_key] = leverage
        logger.info(f"[{user_id}] Leverage for {symbol} set to {leverage}x [{account_type or 'auto'}]")
        return leverage  # Success, return requested
    except Exception as e:
        err_str = str(e).lower()
        # If error contains "leverage not modified" - it's already set
        if "not modified" in err_str or "110043" in str(e):
            _leverage_cache[cache_key] = leverage
            logger.debug(f"[{user_id}] Leverage for {symbol} already {leverage}x (from API)")
            return leverage  # Already set
        # If error is "leverage invalid" (10001) - fallback through decreasing values
        if "10001" in str(e) or "leverage invalid" in err_str:
            logger.warning(f"[{user_id}] Leverage {leverage}x not supported for {symbol}, trying fallbacks")
            # Try decreasing leverage values until one works
            # Include values <= leverage to handle cases where requested leverage itself fails
            for fallback_lev in [100, 75, 50, 25, 20, 15, 10, 5, 3, 2, 1]:
                if fallback_lev <= leverage:
                    try:
                        body["buyLeverage"] = str(fallback_lev)
                        body["sellLeverage"] = str(fallback_lev)
                        await _bybit_request(user_id, "POST", "/v5/position/set-leverage", body=body, account_type=account_type)
                        _leverage_cache[cache_key] = fallback_lev
                        logger.info(f"[{user_id}] Leverage for {symbol} set to fallback {fallback_lev}x [{account_type or 'auto'}]")
                        return fallback_lev  # Return actual fallback leverage
                    except Exception:
                        continue
            logger.warning(f"[{user_id}] Could not set any leverage for {symbol}")
            return 0  # Failed to set any leverage
        # 110013: leverage exceeds maxLeverage by risk limit - try to extract and use max
        if "110013" in str(e) or "cannot set leverage" in err_str or "maxleverage" in err_str:
            # Try to extract maxLeverage from error message: "gt maxLeverage [500]"
            import re
            match = re.search(r'maxLeverage\s*\[(\d+)\]', str(e))
            if match:
                max_lev = int(match.group(1))
                logger.warning(f"[{user_id}] Leverage {leverage}x exceeds max {max_lev}x for {symbol}, using max")
                if max_lev != leverage:
                    # Retry with max leverage
                    body["buyLeverage"] = str(max_lev)
                    body["sellLeverage"] = str(max_lev)
                    try:
                        await _bybit_request(user_id, "POST", "/v5/position/set-leverage", body=body, account_type=account_type)
                        _leverage_cache[cache_key] = max_lev
                        logger.info(f"[{user_id}] Leverage for {symbol} set to max {max_lev}x [{account_type or 'auto'}]")
                        return max_lev  # Return actual max leverage
                    except Exception as e2:
                        logger.warning(f"[{user_id}] Failed to set max leverage for {symbol}: {e2}")
                        return 0
            else:
                # Can't extract max, try common values: 100, 50, 25, 10
                for fallback_lev in [100, 75, 50, 25, 20, 15, 10, 5, 3, 2, 1]:
                    if fallback_lev <= leverage:
                        try:
                            body["buyLeverage"] = str(fallback_lev)
                            body["sellLeverage"] = str(fallback_lev)
                            await _bybit_request(user_id, "POST", "/v5/position/set-leverage", body=body, account_type=account_type)
                            _leverage_cache[cache_key] = fallback_lev
                            logger.info(f"[{user_id}] Leverage for {symbol} set to fallback {fallback_lev}x [{account_type or 'auto'}]")
                            return fallback_lev  # Return actual fallback leverage
                        except Exception:
                            continue
                logger.warning(f"[{user_id}] Could not set any leverage for {symbol}")
                return 0  # Failed
        raise

def _calc_pnl(entry: float, exit_: float, side: str, size: float) -> tuple[float, float]:
    if entry <= 0:
        return 0.0, 0.0
    direction = 1.0 if side == "Buy" else -1.0
    pnl_abs = (exit_ - entry) * size * direction
    pct = (exit_ / entry - 1.0) * (100.0 if side == "Buy" else -100.0)
    return pnl_abs, pct


@log_calls
async def detect_exit_reason(
    user_id: int, 
    symbol: str, 
    entry_price: float = None, 
    exit_price: float = None, 
    side: str = None,
    sl_pct: float = None,
    tp_pct: float = None,
    atr_activated: bool = False,
    account_type: str = "demo"
) -> tuple[str, str]:
    """
    Detect exit reason by checking execution list and order history.
    If Bybit API doesn't provide clear reason, uses price comparison as fallback.
    Returns tuple of (reason, order_type) where reason is one of:
    - "TP" - Take Profit triggered
    - "SL" - Stop Loss triggered (fixed %)
    - "ATR_SL" - ATR Trailing Stop triggered
    - "TRAILING" - Trailing Stop triggered (native Bybit)
    - "LIQ" - Liquidation
    - "ADL" - Auto-Deleveraging
    - "MANUAL" - Manual close by user
    - "UNKNOWN" - Could not determine
    
    Args:
        atr_activated: If True and SL detected, will return "ATR_SL" instead of "SL"
        account_type: For logging purposes
    """
    reason = "UNKNOWN"
    order_type = ""
    
    # Step 1: Check execution list for position closes (closedSize > 0)
    # Note: /v5/execution/list returns createType and stopOrderType which tell us WHY position was closed
    try:
        exec_data = await _bybit_request(
            user_id,
            "GET",
            "/v5/execution/list",
            params={
                "category": "linear",
                "symbol":   symbol,
                "limit":    20
            }
        )
        trades = exec_data.get("list", [])
        
        # Filter for position closes: execType="Trade" and closedSize > 0
        closes = [
            t for t in trades
            if t.get("execType") == "Trade"
            and float(t.get("closedSize") or 0) > 0
        ]
        
        if closes:
            last = max(closes, key=lambda t: int(t.get("execTime", 0)))
            order_type = last.get("orderType", "")
            
            # Check createType FIRST - most reliable indicator from Bybit API
            # Values: CreateByStopLoss, CreateByTakeProfit, CreateByTrailingStop, CreateByUser, etc.
            ctp = (last.get("createType") or "").lower()
            if "takeprofit" in ctp:
                return "TP", order_type
            elif "stoploss" in ctp:
                return "SL", order_type
            elif "trailing" in ctp:
                return "TRAILING", order_type
            elif "liq" in ctp or "takeover" in ctp:
                return "LIQ", order_type
            elif "adl" in ctp:
                return "ADL", order_type
            
            # Check stopOrderType as secondary indicator
            sop = (last.get("stopOrderType") or "").lower()
            if "takeprofit" in sop or "partialtakeprofit" in sop:
                return "TP", order_type
            elif "stoploss" in sop or "partialstoploss" in sop:
                return "SL", order_type
            elif "trailingstop" in sop:
                return "TRAILING", order_type
            
            # If createType is CreateByUser or CreateByClosing - it's manual
            if "user" in ctp or "closing" in ctp:
                return "MANUAL", order_type
                
            # If we have orderId, check order history for more details (fallback)
            order_id = last.get("orderId")
            if order_id:
                # Step 2: Check order history for more details
                try:
                    order_data = await _bybit_request(
                        user_id,
                        "GET",
                        "/v5/order/history",
                        params={
                            "category": "linear",
                            "symbol": symbol,
                            "orderId": order_id,
                            "limit": 1
                        }
                    )
                    orders = order_data.get("list", [])
                    if orders:
                        order = orders[0]
                        # Check createType in order (most reliable)
                        order_ctp = (order.get("createType") or "").lower()
                        if "takeprofit" in order_ctp:
                            return "TP", order_type
                        elif "stoploss" in order_ctp:
                            return "SL", order_type
                        elif "trailing" in order_ctp:
                            return "TRAILING", order_type
                        elif "liq" in order_ctp or "takeover" in order_ctp:
                            return "LIQ", order_type
                        elif "adl" in order_ctp:
                            return "ADL", order_type
                        
                        # Check stopOrderType in order
                        order_sop = (order.get("stopOrderType") or "").lower()
                        if "takeprofit" in order_sop:
                            return "TP", order_type
                        elif "stoploss" in order_sop:
                            return "SL", order_type
                        elif "trailingstop" in order_sop:
                            return "TRAILING", order_type
                        
                        # If createType is user/closing in order history
                        if "closing" in order_ctp or "user" in order_ctp:
                            return "MANUAL", order_type
                except Exception as e:
                    logger.debug(f"Could not fetch order history for {symbol}: {e}")
            
            # Step 3: If we have a close execution but couldn't determine reason from API,
            # we still shouldn't default to MANUAL - let's use price-based fallback below
            # (This is reached only if createType was empty/unknown)
                    
    except Exception as e:
        logger.warning(f"Error in detect_exit_reason for {symbol}: {e}")
    
    # Step 4: If no closes found in execution list, check closed-pnl API
    if reason == "UNKNOWN":
        try:
            pnl_data = await _bybit_request(
                user_id,
                "GET",
                "/v5/position/closed-pnl",
                params={
                    "category": "linear",
                    "symbol": symbol,
                    "limit": 5
                }
            )
            pnl_list = pnl_data.get("list", [])
            if pnl_list:
                latest = pnl_list[0]
                # Note: closed-pnl doesn't have createType/stopOrderType
                # It only has execType (Trade, BustTrade, etc.)
                exec_type = (latest.get("execType") or "").lower()
                if "bust" in exec_type:
                    return "LIQ", latest.get("orderType", "")
                elif "adl" in exec_type:
                    return "ADL", latest.get("orderType", "")
        except Exception as e:
            logger.debug(f"Could not fetch closed-pnl for detect_exit_reason: {e}")
    
    # Step 5: Fallback - determine by comparing exit_price with entry_price and expected TP/SL levels
    if reason == "UNKNOWN" and entry_price and exit_price and side and entry_price > 0 and exit_price > 0:
        pnl_pct = ((exit_price / entry_price) - 1.0) * 100 if side == "Buy" else ((entry_price / exit_price) - 1.0) * 100
        
        # Use provided SL/TP or defaults
        sl_threshold = sl_pct or 3.0  # Default SL ~3%
        tp_threshold = tp_pct or 8.0  # Default TP ~8%
        
        if side == "Buy":
            # For LONG: profit if exit > entry
            if pnl_pct >= tp_threshold * 0.8:  # At least 80% of TP target
                return "TP", order_type or "Market"
            elif pnl_pct <= -sl_threshold * 0.8:  # At least 80% of SL target
                # Check if ATR trailing was activated - means dynamic SL was used
                sl_reason = "ATR_SL" if atr_activated else "SL"
                return sl_reason, order_type or "Market"
        else:
            # For SHORT: profit if exit < entry
            if pnl_pct >= tp_threshold * 0.8:
                return "TP", order_type or "Market"
            elif pnl_pct <= -sl_threshold * 0.8:
                sl_reason = "ATR_SL" if atr_activated else "SL"
                return sl_reason, order_type or "Market"
        
        # If small profit/loss, likely manual
        return "MANUAL", order_type or "Market"
    
    # Final step: If we detected SL from API and ATR was activated, upgrade to ATR_SL
    if reason == "SL" and atr_activated:
        reason = "ATR_SL"
    
    return reason, order_type


# Exit reason labels with emojis for user notifications
EXIT_REASON_LABELS = {
    "TP":       "üéØ Take Profit",
    "SL":       "üõ°Ô∏è Stop-Loss", 
    "ATR_SL":   "üìâ ATR Trailing Stop",
    "TRAILING": "üìà Trailing Stop",
    "LIQ":      "üíÄ Liquidation",
    "ADL":      "‚ö° Auto-Deleverage",
    "MANUAL":   "üëÜ Manual Close",
    "UNKNOWN":  "‚ùì Unknown",
}

def format_exit_reason(reason: str) -> str:
    """Format exit reason with emoji and readable label for user notifications."""
    return EXIT_REASON_LABELS.get(reason, f"‚ùì {reason}")


@log_calls
async def fetch_candles(symbol: str, interval: str, limit: int) -> list[list]:
    url = f"{BYBIT_BASE}/v5/market/kline"
    params = {
        "category": "linear",
        "symbol":   symbol,
        "interval": interval.upper(),
        "limit":    limit
    }
    if _session is None:
        await init_session()
        
    async with _session.get(url, params=params) as resp:
        data = await resp.json()
    return data.get("result", {}).get("list", [])

@log_calls
async def calc_atr(symbol: str, interval: str = "D", periods: int = 14) -> float:
    candles = await fetch_candles(symbol, interval, periods + 50)
    if len(candles) < periods + 1:
        raise RuntimeError(f"Not enough data for ATR: need {periods+1}, need {len(candles)}")

    candles.sort(key=lambda c: int(c[0]))

    closes = [float(c[4]) for c in candles]
    highs  = [float(c[2]) for c in candles]
    lows   = [float(c[3]) for c in candles]

    trs = []
    for i in range(1, len(candles)):
        tr = max(
            highs[i] - lows[i],
            abs(highs[i] - closes[i-1]),
            abs(lows[i]  - closes[i-1])
        )
        trs.append(tr)

    atr = sum(trs[:periods]) / periods
    for tr in trs[periods:]:
        atr = (atr * (periods - 1) + tr) / periods
    return atr

@with_texts
@log_calls
async def cmd_toggle_atr(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    cfg = get_user_config(uid) or {}
    new_mode = not bool(cfg.get("use_atr", 0))
    set_user_field(uid, "use_atr", int(new_mode))
    mode_text = "Wilder‚ÄëATR" if new_mode else "SL/TP %"
    await update.message.reply_text(
        ctx.t['atr_mode_changed'].format(mode_text=mode_text),
        parse_mode="Markdown",
        reply_markup=main_menu_keyboard(ctx, update=update)
    )

async def check_trading_limits_user(user_id: int, t: dict) -> tuple[bool, str]:
    """Check if user can open new positions/orders. 0 = unlimited."""
    # Check positions limit (0 = unlimited)
    if MAX_OPEN_POSITIONS > 0:
        positions = await fetch_open_positions(user_id)
        if len(positions) >= MAX_OPEN_POSITIONS:
            return False, t['limit_positions_exceeded'].format(max=MAX_OPEN_POSITIONS)

    # Check orders limit (0 = unlimited)
    if MAX_LIMIT_ORDERS > 0:
        orders = await fetch_open_orders(user_id)
        limit_orders = [o for o in orders if o.get("orderType") == "Limit"]
        if len(limit_orders) >= MAX_LIMIT_ORDERS:
            return False, t['limit_limit_orders_exceeded'].format(max=MAX_LIMIT_ORDERS)

    return True, ""


async def check_strategy_max_positions(
    user_id: int, 
    strategy: str, 
    side: str,
    exchange: str,
    account_type: str
) -> tuple[bool, int, int]:
    """
    Check if user can open new position for this strategy/side based on max_positions setting.
    
    Args:
        user_id: User ID
        strategy: Strategy name (oi, scryptomera, scalper, elcaro, fibonacci, rsi_bb)
        side: Trade side (long or short)
        exchange: Exchange type (bybit or hyperliquid)
        account_type: Account type (demo, real, testnet, mainnet)
        
    Returns:
        (can_trade, current_count, max_limit)
        - can_trade: True if user can open new position
        - current_count: Number of currently open positions for this strategy/side
        - max_limit: The max_positions limit (0 = unlimited)
    """
    # Get strategy settings with max_positions for this side
    settings = db.get_strategy_settings(user_id, strategy, exchange, account_type)
    max_positions = settings.get(f"{side}_max_positions", 0)
    
    # 0 = unlimited
    if max_positions <= 0:
        return True, 0, 0
    
    # Count open positions for this strategy and side
    # Note: side in DB is "Buy" or "Sell", convert from "long"/"short"
    db_side = "Buy" if side == "long" else "Sell"
    
    # Get all positions for user
    positions = db.get_active_positions(user_id, exchange=exchange)
    
    # Count positions matching this strategy AND side
    count = sum(
        1 for p in positions 
        if p.get("strategy") == strategy and p.get("side") == db_side
    )
    
    can_trade = count < max_positions
    
    if not can_trade:
        logger.info(
            f"[{user_id}] max_positions reached for {strategy}/{side}: "
            f"{count} >= {max_positions} - skipping signal"
        )
    
    return can_trade, count, max_positions

@with_texts
@log_calls
async def cmd_select_coin_group(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show coin filter selection with current filter highlighted."""
    uid = update.effective_user.id
    cfg = get_user_config(uid) or {}
    current_filter = (cfg.get("coins") or "ALL").upper()
    
    # Emojis for current selection
    filters = {
        "ALL": ("üåê", ctx.t.get('group_all', 'üåê All Coins')),
        "TOP": ("üèÜ", ctx.t.get('group_top', 'üèÜ TOP')),
        "VOLATILE": ("üî•", ctx.t.get('group_volatile', 'üî• Volatile Coins')),
    }
    
    # Build keyboard with check mark on current
    keyboard = []
    for key, (emoji, label) in filters.items():
        mark = " ‚úÖ" if key == current_filter else ""
        keyboard.append([InlineKeyboardButton(f"{emoji} {label}{mark}", callback_data=f"coins:{key}")])
    
    # Info text
    current_label = filters.get(current_filter, ("üåê", "All"))[1]
    text = f"ü™ô *{ctx.t.get('select_coin_group', 'Select Coin Filter')}*\n\n"
    text += f"üìç Current: *{current_label}*\n\n"
    text += f"üåê *All* ‚Äî trade any coin\n"
    text += f"üèÜ *Top* ‚Äî only major coins (BTC, ETH, SOL, etc.)\n"
    text += f"üî• *Volatile* ‚Äî altcoins with high volatility"
    
    await update.message.reply_text(
        text,
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )

def get_user_tz(user_id: int) -> str:
    cfg = get_user_config(user_id) or {}
    return cfg.get("tz", "UTC")  



@log_calls
async def fetch_today_realized_pnl(user_id: int, tz_str: str | None = None, account_type: str | None = None, exchange: str | None = None) -> float:
    """
    Fetch today's realized PnL for user using database (rolling 24h window).
    
    Changed from Bybit API to database for more accurate results:
    - Bybit API uses calendar day (resets at midnight) ‚Üí shows $0 after midnight
    - Database uses rolling 24h window ‚Üí always shows recent profits correctly
    
    Args:
        user_id: Telegram user ID
        tz_str: Timezone string (ignored, kept for API compatibility)
        account_type: 'demo' or 'real' (defaults to user's trading_mode)
        exchange: 'bybit' or 'hyperliquid' (defaults to user's active exchange)
    
    Returns:
        Total realized PnL for last 24 hours in USDT
    """
    # Determine exchange if not specified
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or 'bybit'
    
    # Use database rolling 24h PnL (more accurate than API calendar day)
    total = db.get_rolling_24h_pnl(user_id, account_type=account_type, exchange=exchange)
    
    logger.debug(f"[{user_id}] Rolling 24h PnL: {total:+.4f} USDT (from trade_logs DB)")
    return total


@log_calls
async def fetch_last_closed_pnl(user_id: int, symbol: str, account_type: str = None, exchange: str = None) -> dict | None:
    """Fetch last closed PnL record for a symbol. Returns None if no records found.
    
    Args:
        user_id: Telegram user ID
        symbol: Trading pair symbol
        account_type: 'demo', 'real', 'testnet', 'mainnet', or None (auto-detect)
        exchange: 'bybit' or 'hyperliquid', if None uses user's default
    """
    # Determine exchange
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or 'bybit'
    
    if exchange == 'hyperliquid':
        return await _fetch_last_closed_pnl_hl(user_id, symbol, account_type)
    
    # Bybit path (original)
    try:
        data = await _bybit_request(
            user_id,
            "GET",
            "/v5/position/closed-pnl",
            params={
                "category": "linear",
                "symbol":   symbol,
                "limit":    1
            },
            account_type=account_type
        )
        recs = data.get("list", [])
        if not recs:
            logger.debug(f"[{user_id}] No closed PnL records for {symbol}")
            return None
        rec = recs[0]
        # Log all fields for debugging
        logger.debug(f"[{user_id}] Bybit closed-pnl raw: {rec}")
        return rec
    except MissingAPICredentials:
        logger.debug(f"[{user_id}] fetch_last_closed_pnl: no API credentials for {symbol}")
        return None
    except Exception as e:
        # CRITICAL: Re-raise rate limit and transient errors so monitor loop
        # doesn't treat failed API call as "position has no close record"
        error_str = str(e).lower()
        if any(keyword in error_str for keyword in ("rate limit", "429", "too many", "timeout", "connection")):
            logger.warning(f"[{user_id}] fetch_last_closed_pnl transient error for {symbol}: {e}")
            raise  # Let monitor loop handle it (skip, not remove)
        logger.debug(f"[{user_id}] fetch_last_closed_pnl error: {e}")
        return None


async def _fetch_last_closed_pnl_hl(user_id: int, symbol: str, account_type: str = None) -> dict | None:
    """Fetch last closed PnL for HyperLiquid positions.
    
    Returns data in Bybit-compatible format:
    {
        "avgEntryPrice": str, "avgExitPrice": str,
        "closedPnl": str, "closedSize": str,
        "closedPnlRate": str (optional), "leverage": str (optional),
        "symbol": str
    }
    """
    try:
        is_testnet = account_type in ("testnet", "paper", "demo")
        hl_account_type = "testnet" if is_testnet else "mainnet"
        
        from core.exchange_client import get_exchange_client
        client = await get_exchange_client(user_id, exchange_type='hyperliquid', account_type=hl_account_type)
        adapter = client._client  # HLAdapter
        if not adapter:
            logger.debug(f"[{user_id}] No HL adapter available for _fetch_last_closed_pnl_hl")
            return None
        
        await adapter.initialize()
        
        # Normalize symbol: BTCUSDT ‚Üí BTC, ETHUSDC ‚Üí ETH
        coin = symbol.replace("USDT", "").replace("USDC", "").replace("USD", "")
        
        # Fetch fills for this user
        fills = await adapter._client.user_fills(address=adapter._main_wallet_address)
        
        if not fills:
            logger.debug(f"[{user_id}] No HL fills for {symbol}")
            return None
        
        # Find the most recent closing fill for this coin
        # A closing fill has dir like "Close Long" or "Close Short" or has closedPnl != "0.0"
        for fill in fills:
            fill_coin = fill.get("coin", "")
            if fill_coin != coin:
                continue
            
            closed_pnl = float(fill.get("closedPnl", "0"))
            direction = fill.get("dir", "")
            
            # Skip non-closing fills
            if closed_pnl == 0 and "Close" not in direction:
                continue
            
            exit_price = float(fill.get("px", "0"))
            size = float(fill.get("sz", "0"))
            
            # To compute entry price from PnL:
            # For Close Long: pnl = (exit - entry) * size ‚Üí entry = exit - pnl/size
            # For Close Short: pnl = (entry - exit) * size ‚Üí entry = exit + pnl/size
            is_close_long = "Long" in direction or fill.get("side") == "A"  # A = sell = close long
            if size > 0:
                if is_close_long:
                    entry_price = exit_price - (closed_pnl / size)
                else:
                    entry_price = exit_price + (closed_pnl / size)
            else:
                entry_price = exit_price
            
            # Get leverage from position (if available from active_positions DB)
            ap_list = db.get_active_positions(user_id, account_type=account_type, exchange="hyperliquid")
            leverage = "10"
            for ap in ap_list:
                if ap.get("symbol") == symbol:
                    leverage = str(ap.get("leverage", 10))
                    break
            
            # Calculate closedPnlRate (ROE) = pnl / (entry * size) * leverage
            try:
                lev_float = float(leverage)
                pnl_rate = (closed_pnl / (entry_price * size)) * lev_float if entry_price > 0 and size > 0 else 0
            except Exception:
                pnl_rate = 0
            
            logger.debug(f"[{user_id}] HL closed-pnl for {symbol}: entry={entry_price:.6f}, exit={exit_price:.6f}, pnl={closed_pnl:.4f}")
            
            # Return in Bybit-compatible format
            return {
                "avgEntryPrice": str(entry_price),
                "avgExitPrice": str(exit_price),
                "closedPnl": str(closed_pnl),
                "closedSize": str(size),
                "closedPnlRate": str(pnl_rate),
                "leverage": leverage,
                "symbol": symbol,
            }
        
        logger.debug(f"[{user_id}] No closing fills found for {coin} on HL")
        return None
        
    except Exception as e:
        error_str = str(e).lower()
        if any(keyword in error_str for keyword in ("rate limit", "429", "too many", "timeout", "connection")):
            logger.warning(f"[{user_id}] _fetch_last_closed_pnl_hl transient error for {symbol}: {e}")
            raise
        logger.debug(f"[{user_id}] _fetch_last_closed_pnl_hl error: {e}")
        return None

@log_calls
async def fetch_last_execution_price(user_id: int, symbol: str) -> float:
    result = await _bybit_request(
        user_id,
        "GET",
        "/v5/position/closed-pnl",
        params={
            "category": "linear",
            "symbol":   symbol,
            "limit":    1
        }
    )
    closes = result.get("list", [])
    if not closes:
        raise RuntimeError(f"No closed PnL records for {symbol}")
    last = closes[0]
    exit_price = float(last["avgExitPrice"])
    return exit_price

class MissingAPICredentials(RuntimeError):
    pass


def _canon_query(params: dict | None) -> str:
    if not params:
        return ""
    items = sorted((str(k), str(v)) for k, v in params.items())
    return "&".join(f"{quote(k, safe='~')}={quote(v, safe='~')}" for k, v in items)


@log_calls
async def _bybit_request(user_id: int, method: str, path: str,
                         params: dict = None, body: dict = None,
                         retries: int = 3, account_type: str = None) -> dict:
    """Make a request to Bybit API.
    
    Args:
        user_id: Telegram user ID
        method: HTTP method (GET/POST)
        path: API endpoint path
        params: Query parameters for GET requests
        body: JSON body for POST requests
        retries: Number of retry attempts
        account_type: 'demo', 'real', or None (auto-detect from trading_mode)
    """
    # CRITICAL FIX: Normalize 'both' mode to 'demo' since Bybit API doesn't support 'both'
    # 'both' is a trading config that means "trade on demo AND real", but API needs specific mode
    if account_type == 'both':
        account_type = 'demo'
    
    # Check if API key is known to be expired/invalid - skip API call
    cache_key = (user_id, account_type or "auto")
    now = time.time()
    if cache_key in _expired_api_keys_cache:
        expired_ts = _expired_api_keys_cache[cache_key]
        if now - expired_ts < EXPIRED_API_KEYS_CACHE_TTL:
            raise MissingAPICredentials(f"API key expired/invalid (cached, retry after {int(EXPIRED_API_KEYS_CACHE_TTL - (now - expired_ts))}s)")
        else:
            # TTL expired, remove from cache and retry
            del _expired_api_keys_cache[cache_key]
    
    # Get credentials for specified account type
    api_key, api_secret = get_user_credentials(user_id, account_type)
    if not api_key or not api_secret:
        raise MissingAPICredentials("API Key/Secret not set")

    # Determine base URL based on account type
    if account_type == "real":
        base_url = BYBIT_REAL_URL
    elif account_type == "demo":
        base_url = BYBIT_DEMO_URL
    else:
        # Auto-detect from trading mode
        trading_mode = get_trading_mode(user_id)
        base_url = BYBIT_REAL_URL if trading_mode == "real" else BYBIT_DEMO_URL

    if _session is None:
        await init_session()

    ts   = str(int(time.time() * 1000))
    recv = "60000"
    params    = params or {}
    body_json = json.dumps(body, separators=(",", ":")) if body else ""
    query     = _canon_query(params)

    sign      = _sign_payload(ts, api_key, api_secret, recv, body_json, query)


    headers = {
        "X-BAPI-API-KEY":     api_key,
        "X-BAPI-TIMESTAMP":   ts,
        "X-BAPI-RECV-WINDOW": recv,
        "X-BAPI-SIGN":        sign,
        "X-BAPI-SIGN-TYPE":   "2",
        "Content-Type":       "application/json",
    }
    url = base_url + path + (f"?{query}" if method == "GET" and query else "")
    
    logger.debug(f"API Request: {method} {url} [account_type={account_type}]")


    last_exc = None
    for attempt in range(1, retries + 1):
        try:
            if method == "GET":
                async with _session.get(url, headers=headers) as resp:
                    resp.raise_for_status()
                    data = await resp.json(content_type=None)
            else:
                async with _session.post(url, data=body_json, headers=headers) as resp:
                    resp.raise_for_status()
                    data = await resp.json(content_type=None)

            if path == "/v5/position/trading-stop" and data.get("retCode") == 34040:
                logger.info(f"{path}: not modified (retCode=34040) for user {user_id} ‚Äî body was: {body_json}")
                return data.get("result", {})

            # Handle "leverage not modified" - not an error, just already set
            if path == "/v5/position/set-leverage" and data.get("retCode") == 110043:
                logger.debug(f"{path}: leverage not modified (retCode=110043) ‚Äî ok")
                return data.get("result", {})
            
            # Handle "no closed PnL" - not critical, return empty
            if path == "/v5/position/closed-pnl" and data.get("retCode") == 10016:
                logger.debug(f"{path}: no closed PnL records (retCode=10016)")
                return {"list": []}

            if data.get("retCode") not in (0, None):
                ret_code = data.get("retCode")
                ret_msg = str(data.get("retMsg", "")).lower()
                
                # Handle expired/invalid API keys - cache to avoid spamming
                if ret_code in (33004, 10003, 10004, 10005):
                    # 33004 = API key expired, 10003/4/5 = invalid API key/signature
                    cache_key = (user_id, account_type or "auto")
                    _expired_api_keys_cache[cache_key] = time.time()
                    logger.warning(f"API key error for user {user_id} (cached for {EXPIRED_API_KEYS_CACHE_TTL}s): {data.get('retMsg')}")
                    raise MissingAPICredentials(f"API key error: {data.get('retMsg')}")
                
                # Leverage validation errors - log as debug only, not error (handled in set_leverage)
                elif path == "/v5/position/set-leverage" and ret_code in (10001, 110013):
                    logger.debug(f"Bybit leverage validation: {data.get('retMsg')}")
                    raise RuntimeError(f"Bybit error {path}: {data}")
                
                # SL/TP validation errors - log as warning, not error (expected for deep loss positions)
                # Bybit returns various phrasings: "should lower than", "should higher than", "should greater", "should less"
                elif ret_code == 10001 and any(x in ret_msg.lower() for x in ["should lower", "should higher", "should greater", "should less"]):
                    logger.warning(f"Bybit SL/TP validation: {path} - {data.get('retMsg')}")
                    raise RuntimeError(f"Bybit error {path}: {data}")
                
                else:
                    logger.error(f"Bybit error for user {user_id} on {path}: {data}")
                    raise RuntimeError(f"Bybit error {path}: {data}")

            return data.get("result") or data

        except (asyncio.TimeoutError, aiohttp.ClientError) as e:
            last_exc = e
            logger.warning(f"Request {path} failed ({attempt}/{retries}): {e}")
            if attempt < retries:
                await asyncio.sleep(2 ** attempt)
            else:
                logger.error(f"All {retries} retries failed for {path}")
                raise

    raise last_exc

@log_calls
async def fetch_market_status():
    """Fetch market data from CoinMarketCap (primary) and Yahoo Finance (Gold, S&P500)"""
    if _session is None:
        await init_session()

    btc_dom, eth_dom, usdt_dom = 0.0, 0.0, 0.0
    btc_price, btc_change = 0.0, 0.0
    sp500, sp500_change = 0.0, 0.0
    gold_price, gold_change = 0.0, 0.0
    total1, total2, total3 = 0.0, 0.0, 0.0
    fear_greed, fear_greed_label = 0, "N/A"
    altseason_index = 0
    top_coins = []  # List of (symbol, mcap_billions, dominance_pct)
    headers = {"User-Agent": "Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36"}

    # ===== CoinMarketCap: listing API for top coins, dominance, BTC price =====
    try:
        cmc_url = "https://api.coinmarketcap.com/data-api/v3/cryptocurrency/listing?start=1&limit=15&sortBy=market_cap&sortType=desc"
        async with _session.get(cmc_url, headers=headers, timeout=aiohttp.ClientTimeout(total=10)) as r:
            if r.status == 200:
                data = await r.json()
                for crypto in data.get("data", {}).get("cryptoCurrencyList", []):
                    symbol = crypto.get("symbol")
                    # Get USD quote (second in list typically)
                    usd_quote = None
                    for q in crypto.get("quotes", []):
                        if q.get("name") == "USD":
                            usd_quote = q
                            break
                    if not usd_quote and crypto.get("quotes"):
                        usd_quote = crypto.get("quotes", [{}])[-1]  # Last is usually USD
                    
                    if not usd_quote:
                        continue
                        
                    dom = usd_quote.get("dominance", 0)
                    mcap = usd_quote.get("marketCap", 0)
                    mcap_b = mcap / 1e9 if mcap else 0
                    price = usd_quote.get("price", 0)
                    change_24h = usd_quote.get("percentChange24h", 0)
                    
                    if symbol == "BTC":
                        btc_dom = float(dom)
                        btc_price = float(price)
                        btc_change = float(change_24h)
                    elif symbol == "ETH":
                        eth_dom = float(dom)
                    elif symbol == "USDT":
                        usdt_dom = float(dom)
                    
                    # Collect top coins (skip stablecoins and index tokens for the list)
                    if symbol not in ("BTC", "USDT", "USDC", "DAI", "BUSD", "TUSD", "FDUSD", "USDD", "CMC20", "CMC100"):
                        top_coins.append((symbol, mcap_b, float(dom)))
    except Exception as e:
        logger.debug(f"CoinMarketCap listing fetch failed: {e}")

    # ===== CoinMarketCap: global metrics for Total Market Cap =====
    try:
        cmc_global_url = "https://api.coinmarketcap.com/data-api/v3/global-metrics/quotes/latest"
        async with _session.get(cmc_global_url, headers=headers, timeout=aiohttp.ClientTimeout(total=10)) as r:
            if r.status == 200:
                data = await r.json()
                gdata = data.get("data", {})
                
                # Fallback for dominance if listing failed
                if btc_dom == 0:
                    btc_dom = float(gdata.get("btcDominance", 0))
                if eth_dom == 0:
                    eth_dom = float(gdata.get("ethDominance", 0))
                
                # Get Total Market Cap from quotes
                quotes = gdata.get("quotes", [])
                if quotes:
                    q = quotes[0]
                    total_mcap = q.get("totalMarketCap", 0)
                    altcoin_mcap = q.get("altcoinMarketCap", 0)
                    
                    total1 = total_mcap / 1e12  # Total 1: All crypto in trillions
                    total2 = altcoin_mcap / 1e12  # Total 2: Without BTC
                    # Total 3: Without BTC and ETH
                    eth_mcap = total_mcap * (eth_dom / 100) if eth_dom else 0
                    total3 = (altcoin_mcap - eth_mcap) / 1e12
    except Exception as e:
        logger.debug(f"CoinMarketCap global metrics failed: {e}")

    # ===== CoinMarketCap: Fear & Greed and Altcoin Season from charts page =====
    try:
        fg_url = "https://coinmarketcap.com/charts/fear-and-greed-index/"
        async with _session.get(fg_url, headers=headers, timeout=aiohttp.ClientTimeout(total=10)) as r:
            if r.status == 200:
                html = await r.text()
                import re
                # Parse Fear & Greed Index
                fg_match = re.search(r'"score":(\d+).*?"name":"([^"]+)"', html)
                if fg_match:
                    fear_greed = int(fg_match.group(1))
                    fear_greed_label = fg_match.group(2)
                
                # Parse Altcoin Season Index
                alt_match = re.search(r'"altcoinIndex":(\d+)', html)
                if alt_match:
                    altseason_index = int(alt_match.group(1))
    except Exception as e:
        logger.debug(f"CoinMarketCap Fear & Greed fetch failed: {e}")

    # ===== Yahoo Finance: S&P 500 =====
    try:
        sp500_url = "https://query1.finance.yahoo.com/v8/finance/chart/%5EGSPC?interval=1d&range=2d"
        async with _session.get(sp500_url, headers=headers, timeout=aiohttp.ClientTimeout(total=10)) as r:
            data = await r.json()
            result = data.get("chart", {}).get("result", [])
            if result:
                meta = result[0].get("meta", {})
                sp500 = meta.get("regularMarketPrice", 0.0)
                prev_close = meta.get("chartPreviousClose", meta.get("previousClose", sp500))
                if prev_close and prev_close > 0:
                    sp500_change = ((sp500 - prev_close) / prev_close) * 100
    except Exception as e:
        logger.warning(f"Yahoo S&P500 fetch failed: {e}")

    # ===== Yahoo Finance: Gold (XAU/USD) =====
    try:
        gold_url = "https://query1.finance.yahoo.com/v8/finance/chart/GC=F?interval=1d&range=2d"
        async with _session.get(gold_url, headers=headers, timeout=aiohttp.ClientTimeout(total=10)) as r:
            data = await r.json()
            result = data.get("chart", {}).get("result", [])
            if result:
                meta = result[0].get("meta", {})
                gold_price = meta.get("regularMarketPrice", 0.0)
                prev_close = meta.get("chartPreviousClose", meta.get("previousClose", gold_price))
                if prev_close and prev_close > 0:
                    gold_change = ((gold_price - prev_close) / prev_close) * 100
    except Exception as e:
        logger.warning(f"Yahoo Gold fetch failed: {e}")

    # Get top 5 altcoins by dominance
    top_coins = sorted(top_coins, key=lambda x: x[2], reverse=True)[:5]

    return btc_dom, usdt_dom, btc_price, btc_change, sp500, sp500_change, top_coins, gold_price, gold_change, total1, total2, total3, fear_greed, fear_greed_label, altseason_index



@log_calls
async def set_trading_stop(
    uid: int,
    symbol: str,
    tp_price: float | None = None,
    sl_price: float | None = None,
    side_hint: str | None = None,
    is_trailing: bool = False,  # Skip entry price validation for trailing SL
    is_be: bool = False,  # Skip validation for Break-Even SL (SL = entry)
    account_type: str | None = None,  # 'demo', 'real', 'testnet', 'mainnet' or None (auto-detect)
    exchange: str | None = None,  # 'bybit' or 'hyperliquid' or None (auto-detect)
) -> bool:
    """
    Set TP/SL for a position on Bybit OR HyperLiquid.
    Returns True if successful, False if position not found.
    
    Supports both exchanges with 1:1 functionality parity:
    - Bybit: uses /v5/position/trading-stop API
    - HyperLiquid: uses set_tp_sl via HLAdapter
    """
    if tp_price is None and sl_price is None:
        raise ValueError("You must specify at least one of the levels: TP or SL")
    
    # Auto-detect exchange if not specified
    if exchange is None:
        exchange = db.get_exchange_type(uid)
    
    # Route to exchange-specific implementation
    if exchange == "hyperliquid":
        return await _set_trading_stop_hyperliquid(
            uid, symbol, tp_price, sl_price, side_hint, is_trailing, is_be, account_type
        )
    else:
        return await _set_trading_stop_bybit(
            uid, symbol, tp_price, sl_price, side_hint, is_trailing, is_be, account_type
        )


async def _set_trading_stop_hyperliquid(
    uid: int,
    symbol: str,
    tp_price: float | None = None,
    sl_price: float | None = None,
    side_hint: str | None = None,
    is_trailing: bool = False,
    is_be: bool = False,
    account_type: str | None = None,
) -> bool:
    """
    Set TP/SL for a position on HyperLiquid.
    Implements same validation as Bybit for 1:1 parity.
    Uses pooled client to avoid 429 rate limits.
    """
    try:
        # Determine testnet/mainnet from account_type
        is_testnet = account_type in ("testnet", "paper", "demo")
        hl_account_type = "testnet" if is_testnet else "mainnet"
        
        # Use pooled client instead of creating new adapter every time
        # This prevents 429 rate limit errors from repeated client initialization
        from core.exchange_client import get_exchange_client
        
        try:
            client = await get_exchange_client(uid, exchange_type='hyperliquid', account_type=hl_account_type)
        except ValueError as e:
            # Auth error cached - skip silently
            if "cached" in str(e).lower():
                return False
            raise
        
        # Get the underlying HLAdapter
        adapter = client._client
        if not adapter:
            logger.warning(f"[{uid}] No HL adapter available for {hl_account_type}")
            return False
        
        # Get position to validate side - use cached positions from unified fetch
        # This avoids extra API call since monitor loop already fetched positions
        from bot_unified import _get_hl_cache
        
        cache_key = f"positions:{uid}:{hl_account_type}"
        cached_positions = _get_hl_cache(cache_key)
        
        pos = None
        if cached_positions is not None:
            # Find position for this symbol in cached data
            for p in cached_positions:
                if hasattr(p, 'symbol') and p.symbol == symbol:
                    # Convert Position object to dict format
                    # PositionSide.LONG.value = "Buy", PositionSide.SHORT.value = "Sell"
                    pos = {
                        "side": p.side.value,  # Already "Buy" or "Sell"
                        "entryPrice": p.entry_price,
                        "size": p.size,
                    }
                    break
            if pos is None:
                logger.debug(f"[{uid}] No HL position for {symbol} in cache, skipping SL/TP update")
                return False
        else:
            # Fallback to API call only if cache miss (should be rare)
            logger.debug(f"[{uid}] HL cache miss for positions, fetching from API")
            positions_result = await adapter.fetch_positions(symbol)
            positions = positions_result.get("result", {}).get("list", [])
            
            if not positions:
                logger.debug(f"[{uid}] No HL positions for {symbol}, skipping SL/TP update")
                return False
            
            pos = positions[0]  # Get first/only position for symbol
        
        effective_side = pos.get("side")
        entry_price = float(pos.get("entryPrice", 0))
        
        # Validate TP/SL prices (same logic as Bybit)
        if tp_price is not None:
            if effective_side == "Buy" and entry_price > 0 and tp_price <= entry_price:
                logger.warning(f"[{uid}] {symbol} HL: TP ({tp_price}) <= entry ({entry_price}) for LONG - skipping")
                tp_price = None
            elif effective_side == "Sell" and entry_price > 0 and tp_price >= entry_price:
                logger.warning(f"[{uid}] {symbol} HL: TP ({tp_price}) >= entry ({entry_price}) for SHORT - skipping")
                tp_price = None
        
        if sl_price is not None and not is_be and not is_trailing:
            if effective_side == "Buy" and entry_price > 0 and sl_price >= entry_price:
                logger.warning(f"[{uid}] {symbol} HL: SL ({sl_price}) >= entry ({entry_price}) for LONG - skipping")
                sl_price = None
            elif effective_side == "Sell" and entry_price > 0 and sl_price <= entry_price:
                logger.warning(f"[{uid}] {symbol} HL: SL ({sl_price}) <= entry ({entry_price}) for SHORT - skipping")
                sl_price = None
        
        if tp_price is None and sl_price is None:
            logger.debug(f"[{uid}] {symbol} HL: No valid TP/SL to set after validation")
            return True
        
        # Check if SL/TP already set to same value (using cached SL for HL)
        # This prevents unnecessary API calls that cause 429 rate limits
        def _prices_close(a, b, rel_tol=1e-6, abs_tol=0.01) -> bool:
            """Compare two prices with tolerance for floating point precision."""
            if a is None and b is None:
                return True
            if a is None or b is None:
                return False
            return abs(a - b) <= max(rel_tol * max(abs(a), abs(b)), abs_tol)
        
        cached_sl = _hl_sl_cache.get((uid, symbol))
        if sl_price is not None and cached_sl is not None and _prices_close(sl_price, cached_sl):
            logger.debug(f"[{uid}] {symbol} HL: SL already set to ~{cached_sl} (requested {sl_price}), skipping API call")
            # If only SL was requested and it's already set, we're done
            if tp_price is None:
                return True
            # Otherwise continue to set TP
            sl_price = None
        
        # Final check - if nothing to set after cache check
        if tp_price is None and sl_price is None:
            logger.debug(f"[{uid}] {symbol} HL: All TP/SL already set, skipping API call")
            return True
        
        # Check fail cooldown - don't retry set_tp_sl if it recently failed (e.g. "Too many open orders")
        fail_key = (uid, symbol)
        last_fail = _hl_sl_fail_cooldown.get(fail_key)
        if last_fail is not None:
            elapsed = time.time() - last_fail
            if elapsed < _HL_SL_FAIL_COOLDOWN_SEC:
                logger.debug(f"[{uid}] {symbol} HL: set_tp_sl in cooldown ({elapsed:.0f}s / {_HL_SL_FAIL_COOLDOWN_SEC}s), skipping")
                return False
            else:
                # Cooldown expired, remove and retry
                _hl_sl_fail_cooldown.pop(fail_key, None)
        
        # Set TP/SL via HyperLiquid API
        # Use adapter.main_wallet_address which is auto-discovered for Unified Account support
        coin = hl_symbol_to_coin(symbol)
        logger.info(f"[{uid}] {symbol} HL: Calling set_tp_sl(coin={coin}, tp={tp_price}, sl={sl_price})")
        result = await adapter._client.set_tp_sl(coin=coin, tp_price=tp_price, sl_price=sl_price, address=adapter.main_wallet_address)
        logger.info(f"[{uid}] {symbol} HL: set_tp_sl raw result: {result}")
        
        # Check results - must verify both transport status AND inner order statuses
        # HL returns status='ok' at transport level even when order has errors like "Too many open orders"
        success = False
        for r in result:
            if not isinstance(r, dict):
                continue
            r_status = r.get("result", {}).get("status")
            if r_status != "ok":
                continue
            # Check inner statuses for errors
            statuses = r.get("result", {}).get("response", {}).get("data", {}).get("statuses", [])
            has_inner_error = any(isinstance(s, dict) and "error" in s for s in statuses)
            if has_inner_error:
                inner_errors = [s.get("error") for s in statuses if isinstance(s, dict) and "error" in s]
                logger.warning(f"[{uid}] {symbol} HL: set_tp_sl order error: {inner_errors}")
                continue
            success = True
        
        if success:
            logger.info(f"[{uid}] {symbol} HL: TP/SL set successfully - tp={tp_price}, sl={sl_price}")
            
            # Update global SL cache for HL - prevents repeated API calls
            # HL API doesn't return stopLoss in position data, so we track it locally
            if sl_price is not None:
                _hl_sl_cache[(uid, symbol)] = sl_price
                logger.debug(f"[{uid}] {symbol} HL: SL cached = {sl_price}")
            
            # Save to DB
            db_account_type = "testnet" if is_testnet else "mainnet"
            try:
                update_position_sltp(
                    user_id=uid,
                    symbol=symbol,
                    account_type=db_account_type,
                    sl_price=sl_price,
                    tp_price=tp_price,
                    respect_manual_override=True,
                    exchange="hyperliquid"
                )
            except Exception as db_err:
                logger.warning(f"[{uid}] {symbol} HL: Failed to save SL/TP to DB: {db_err}")
            
            # Clear fail cooldown on success
            _hl_sl_fail_cooldown.pop(fail_key, None)
            return True
        else:
            logger.warning(f"[{uid}] {symbol} HL: TP/SL not set - result: {result}")
            # Set fail cooldown to prevent retrying every monitor cycle
            _hl_sl_fail_cooldown[fail_key] = time.time()
            return False
        
        # NOTE: Client is pooled - do NOT close it manually!
            
    except Exception as e:
        logger.error(f"[{uid}] {symbol} HL set_trading_stop error: {e}")
        # Set fail cooldown on exception too (e.g. rate limit)
        _hl_sl_fail_cooldown[(uid, symbol)] = time.time()
        return False


async def _set_trading_stop_bybit(
    uid: int,
    symbol: str,
    tp_price: float | None = None,
    sl_price: float | None = None,
    side_hint: str | None = None,
    is_trailing: bool = False,
    is_be: bool = False,
    account_type: str | None = None,
) -> bool:
    """Set TP/SL for a position on Bybit. Returns True if successful, False if position not found."""

    filt = await get_symbol_filters(uid, symbol)
    tick = float(filt["tickSize"])

    if side_hint:
        s = side_hint.strip().upper()
        if s in ("LONG", "BUY"):
            side_hint = "Buy"
        elif s in ("SHORT", "SELL"):
            side_hint = "Sell"
        else:
            side_hint = None  

    # CRITICAL: Explicitly pass exchange="bybit" to avoid using user's default exchange
    # User's default might be "hyperliquid" while we need Bybit positions here
    positions = await fetch_open_positions(uid, account_type=account_type, exchange="bybit")
    pos_candidates = [p for p in positions if p.get("symbol") == symbol]

    if not pos_candidates:
        # Position was closed - return False instead of raising
        logger.debug(f"[{uid}] No open positions for {symbol}, skipping SL/TP update")
        return False

    pos = None
    if side_hint:
        pos = next((p for p in pos_candidates if p.get("side") == side_hint), None)

    if not pos:
        pos = max(pos_candidates, key=lambda p: abs(float(p.get("size") or 0.0)))

    effective_side = pos.get("side")
    if effective_side not in ("Buy", "Sell"):
        try:
            mark = float(pos.get("markPrice"))
        except (TypeError, ValueError):
            mark = None
        if mark is not None:
            if sl_price is not None:
                effective_side = "Buy" if sl_price < mark else "Sell"
            elif tp_price is not None:
                effective_side = "Buy" if tp_price > mark else "Sell"
    if effective_side not in ("Buy", "Sell"):
        effective_side = "Buy" 

    def _to_float(x):
        try:
            return float(x) if x not in (None, "", 0, "0") else None
        except Exception:
            return None

    current_sl = _to_float(pos.get("stopLoss"))
    current_tp = _to_float(pos.get("takeProfit"))
    try:
        mark = float(pos.get("markPrice"))
    except (TypeError, ValueError):
        mark = None

    # _prices_equal is now defined at module level (line ~4912)
    
    # Bybit validates SL/TP against entry price (avgPrice), not mark price
    try:
        entry_price = float(pos.get("avgPrice") or pos.get("entry_price") or 0)
    except (TypeError, ValueError):
        entry_price = None
    
    # Debug: log validation parameters
    logger.debug(f"{symbol}: set_trading_stop validation - entry_price={entry_price}, mark={mark}, sl_price={sl_price}, tp_price={tp_price}, side={effective_side}")

    def _q(x: float) -> float:
        return quantize(x, tick)

    def _qu(x: float) -> float:
        return quantize_up(x, tick)

    if sl_price is not None:
        if effective_side == "Buy":
            sl_price = _qu(sl_price)
        else:
            sl_price = _q(sl_price)

    if tp_price is not None:
        tp_price = _q(tp_price)

    # Bybit validates SL against BOTH entry price AND mark price
    # For LONG: SL must be < entry_price AND < mark_price
    # For SHORT: SL must be > entry_price AND > mark_price
    
    if tp_price is not None:
        # TP validation - check against entry_price first, then mark
        check_prices = [p for p in [entry_price, mark] if p and p > 0]
        for check_price in check_prices:
            if effective_side == "Buy" and tp_price <= check_price:
                logger.warning(f"{symbol}: TP ({tp_price}) <= price ({check_price}) for LONG - skipping TP")
                tp_price = None
                break
            if effective_side == "Sell" and tp_price >= check_price:
                logger.warning(f"{symbol}: TP ({tp_price}) >= price ({check_price}) for SHORT - skipping TP")
                tp_price = None
                break

    if sl_price is not None:
        # SL validation - for trailing SL only check against mark price, not entry
        # For Break-Even, skip validation entirely (SL = entry is intentional)
        # For regular SL, check against both entry and mark price
        if is_be:
            # Break-Even SL: SL = entry price, skip all validation
            check_prices = []
        elif is_trailing:
            # Trailing SL: only validate against mark price (SL follows price movement)
            check_prices = [mark] if mark and mark > 0 else []
        else:
            # Regular SL: validate against both entry and mark price
            check_prices = [p for p in [entry_price, mark] if p and p > 0]
        for check_price in check_prices:
            if effective_side == "Buy" and sl_price >= check_price:
                logger.warning(f"{symbol}: SL ({sl_price}) >= price ({check_price}) for LONG - skipping SL")
                sl_price = None
                break
            if effective_side == "Sell" and sl_price <= check_price:
                logger.warning(f"{symbol}: SL ({sl_price}) <= price ({check_price}) for SHORT - skipping SL")
                sl_price = None
                break

    def _stricter(side_: str, new_sl: float, cur_sl):
        """
        Check if new SL is "stricter" (closer to entry) than current.
        This is ONLY used for ATR trailing where we want to tighten SL progressively.
        For regular SL changes, we want to allow setting any valid SL.
        
        For LONG: higher SL = stricter (closer to entry)
        For SHORT: lower SL = stricter (closer to entry)
        
        Returns new_sl if it's stricter, None if current is already stricter.
        """
        if cur_sl in (None, "", 0, "0", 0.0):
            return new_sl
        cur = float(cur_sl)
        if side_ == "Buy":
            return new_sl if new_sl > cur else None
        else:
            # FIX: For SHORT, HIGHER SL is stricter (closer to entry which is below SL)
            # OLD (wrong): return new_sl if new_sl < cur else None
            # Wait - actually the OLD logic was correct for ATR trailing:
            # When price drops (profit), we trail SL DOWN (lower = stricter = less loss if reverses)
            # But for INITIAL SL setting, we need the CORRECT SL, not "stricter"
            # So we should NOT use _stricter for initial SL at all
            return new_sl if new_sl < cur else None

    # FIX: Only apply _stricter filter for ATR trailing mode
    # For regular SL setting, allow any valid SL (don't filter by "strictness")
    if sl_price is not None and is_trailing:
        sl_candidate = _stricter(effective_side, sl_price, current_sl)
        if sl_candidate is None:
            logger.debug(f"{symbol}: ATR trailing SL ({sl_price}) not stricter than current ({current_sl}), keeping current")
            sl_price = None
        else:
            sl_price = sl_candidate

    if (tp_price is None or _prices_equal(tp_price, current_tp)) and (sl_price is None or _prices_equal(sl_price, current_sl)):
        logger.debug(f"{symbol}: trading-stop unchanged (side={effective_side}, current_sl={current_sl}, sl_price={sl_price})")
        return True  # SL/TP already correct ‚Äî this is a success, not an error

    mode = await get_position_mode(uid, symbol)
    position_idx = position_idx_for(effective_side, mode)

    body = {
        "category": "linear",
        "symbol": symbol,
        "positionIdx": position_idx,
        "tpslMode": "Full",  # Required by Bybit API v5 - entire position TP/SL
    }
    if tp_price is not None:
        body["takeProfit"] = str(tp_price)
        body["tpTriggerBy"] = "MarkPrice"  # More reliable than LastPrice
    if sl_price is not None:
        body["stopLoss"] = str(sl_price)
        body["slTriggerBy"] = "MarkPrice"  # More reliable than LastPrice

    # DEBUG: Log what we're sending vs what was already set
    logger.info(
        f"[{uid}] {symbol}: set_trading_stop CALL - current_sl={current_sl}, current_tp={current_tp}, "
        f"new_sl={sl_price}, new_tp={tp_price}, side={effective_side}, entry={entry_price}"
    )

    # Determine account_type for DB update
    db_account_type = account_type or "demo"
    
    try:
        await _bybit_request(uid, "POST", "/v5/position/trading-stop", body=body, account_type=account_type)
        
        # CRITICAL FIX: Save SL/TP prices to DB after successful exchange update
        # This ensures DB reflects actual exchange state for monitoring and display
        try:
            update_position_sltp(
                user_id=uid,
                symbol=symbol,
                account_type=db_account_type,
                sl_price=sl_price,
                tp_price=tp_price,
                respect_manual_override=True,  # Don't overwrite manual SL/TP
                exchange="bybit"
            )
            logger.debug(f"[{uid}] {symbol}: SL/TP saved to DB - sl={sl_price}, tp={tp_price}")
        except Exception as db_err:
            logger.warning(f"[{uid}] {symbol}: Failed to save SL/TP to DB: {db_err}")
        
        return True
    except RuntimeError as e:
        err_str = str(e).lower()
        if "no open positions" in err_str or "position not exists" in err_str:
            logger.debug(f"[{uid}] Position for {symbol} closed during set_trading_stop")
            return False
        # Handle invalid SL/TP price errors - position in deep loss or price moved too fast
        # Bybit returns: "should lower than", "should higher than", "should greater", "should less"
        if any(x in err_str for x in ["should lower", "should higher", "should greater", "should less"]):
            logger.warning(f"[{uid}] {symbol}: SL/TP price invalid - price moved too fast, skipping update")
            return False  # Return False instead of raising - price moved, retry next cycle
        raise


async def remove_take_profit(
    uid: int,
    symbol: str,
    side_hint: str | None = None,
    account_type: str | None = None,
    exchange: str | None = None,
) -> bool:
    """
    Remove Take Profit from a position by setting TP to 0.
    Used when switching from Fixed SL/TP to ATR trailing mode.
    Returns True if successful, False if position not found.
    
    Supports both Bybit and HyperLiquid exchanges.
    """
    # Auto-detect exchange if not specified
    if exchange is None:
        exchange = db.get_exchange_type(uid)
    
    if side_hint:
        s = side_hint.strip().upper()
        if s in ("LONG", "BUY"):
            side_hint = "Buy"
        elif s in ("SHORT", "SELL"):
            side_hint = "Sell"
        else:
            side_hint = None

    positions = await fetch_open_positions(uid, account_type=account_type, exchange=exchange)
    pos_candidates = [p for p in positions if p.get("symbol") == symbol]

    if not pos_candidates:
        logger.debug(f"[{uid}] No open positions for {symbol}, skipping TP removal")
        return False

    pos = None
    if side_hint:
        pos = next((p for p in pos_candidates if p.get("side") == side_hint), None)

    if not pos:
        pos = max(pos_candidates, key=lambda p: abs(float(p.get("size") or 0.0)))

    effective_side = pos.get("side")
    if effective_side not in ("Buy", "Sell"):
        effective_side = "Buy"

    # Route to exchange-specific implementation
    if exchange == "hyperliquid":
        return await _remove_take_profit_hyperliquid(uid, symbol, effective_side, account_type)
    else:
        return await _remove_take_profit_bybit(uid, symbol, effective_side, account_type)


async def _remove_take_profit_bybit(
    uid: int,
    symbol: str,
    effective_side: str,
    account_type: str | None = None,
) -> bool:
    """Remove Take Profit on Bybit.
    
    CRITICAL FIX (Feb 11, 2026): Bybit's /v5/position/trading-stop with takeProfit="0"
    returns retCode 34040 ("not modified") ‚Äî Bybit internally considers the TP already
    cleared, but the position endpoint still reports the old TP value (stale display).
    
    Since Bybit says the TP is already effectively "0" (not active), we accept this
    and return True. The retCode 34040 means the TP WON'T trigger on exchange even
    though position data still shows a value.
    
    Returns True if TP is cleared (including when Bybit says it's already cleared).
    """
    mode = await get_position_mode(uid, symbol)
    position_idx = position_idx_for(effective_side, mode)

    # Fetch current position data (SL + TP) to include in request
    current_sl = None
    current_tp_val = None
    try:
        positions = await fetch_open_positions(uid, account_type=account_type, exchange="bybit")
        pos = next((p for p in positions if p.get("symbol") == symbol), None)
        if pos:
            raw_sl = pos.get("stopLoss")
            if raw_sl not in (None, "", 0, "0", 0.0):
                current_sl = float(raw_sl)
            raw_tp = pos.get("takeProfit")
            if raw_tp not in (None, "", 0, "0", 0.0):
                current_tp_val = float(raw_tp)
    except Exception as e:
        logger.debug(f"{symbol}: Could not fetch position data for TP removal: {e}")

    # If TP is already 0/None on exchange, nothing to do
    if current_tp_val is None:
        logger.debug(f"[{uid}] {symbol}: TP already cleared on exchange, nothing to remove")
        return True

    body = {
        "category": "linear",
        "symbol": symbol,
        "positionIdx": position_idx,
        "tpslMode": "Full",
        "takeProfit": "0",
        "tpTriggerBy": "MarkPrice",
    }
    
    # Include current SL to preserve it
    if current_sl is not None:
        body["stopLoss"] = str(current_sl)
        body["slTriggerBy"] = "MarkPrice"

    logger.info(f"[{uid}] {symbol}: remove_take_profit_bybit side={effective_side} current_tp={current_tp_val} current_sl={current_sl}")

    try:
        result = await _bybit_request(uid, "POST", "/v5/position/trading-stop", body=body, account_type=account_type)
        # retCode 0 = TP actually cleared
        # retCode 34040 = "not modified" ‚Äî Bybit says TP is already at 0 internally
        # Both cases mean TP is effectively cleared and won't trigger
        logger.info(f"[{uid}] {symbol}: TP removal accepted by Bybit (result={result})")
        return True
    except RuntimeError as e:
        err_str = str(e).lower()
        if "no open positions" in err_str or "position not exists" in err_str:
            logger.debug(f"[{uid}] Position for {symbol} closed during remove_take_profit")
            return False
        raise


async def _remove_take_profit_hyperliquid(
    uid: int,
    symbol: str,
    effective_side: str,
    account_type: str | None = None,
) -> bool:
    """Remove Take Profit on HyperLiquid by re-setting only SL (cancels TP trigger orders)."""
    try:
        # Determine testnet/mainnet from account_type
        is_testnet = account_type in ("testnet", "paper", "demo")
        hl_account_type = "testnet" if is_testnet else "mainnet"
        
        # Use pooled client
        from core.exchange_client import get_exchange_client
        
        try:
            client = await get_exchange_client(uid, exchange_type='hyperliquid', account_type=hl_account_type)
        except ValueError as e:
            if "cached" in str(e).lower():
                return False
            raise
        
        adapter = client._client
        if not adapter:
            logger.warning(f"[{uid}] No HL adapter available for {hl_account_type}")
            return False
        
        coin = hl_symbol_to_coin(symbol)
        
        # Get current position to find SL price
        position = await adapter._client.get_position(coin)
        if not position:
            logger.debug(f"[{uid}] No HL position for {coin}, skipping TP removal")
            return False
        
        # Cancel all trigger orders (this removes both TP and SL)
        try:
            cancelled = await adapter._client.cancel_trigger_orders_for_coin(
                coin=coin, address=adapter._main_wallet_address or adapter._address
            )
            if cancelled:
                logger.info(f"[{uid}] {symbol} HL: Cancelled {cancelled} trigger orders to remove TP")
        except Exception as cancel_err:
            logger.warning(f"[{uid}] {symbol} HL: Failed to cancel trigger orders: {cancel_err}")
        
        # Re-set only SL (without TP) if DB has SL
        from db import get_active_positions
        db_positions = get_active_positions(uid, account_type=account_type, exchange="hyperliquid")
        db_pos = next((p for p in db_positions if p.get("symbol") == symbol), None)
        
        if db_pos and db_pos.get("sl_price"):
            sl_price = float(db_pos["sl_price"])
            if sl_price > 0:
                try:
                    await adapter.set_tp_sl(
                        coin=coin,
                        sl_price=sl_price,
                        tp_price=None,  # No TP ‚Äî ATR trailing handles it
                        address=adapter._main_wallet_address,
                    )
                    logger.info(f"[{uid}] {symbol} HL: TP removed, SL preserved at {sl_price}")
                except Exception as sl_err:
                    logger.warning(f"[{uid}] {symbol} HL: Could not re-set SL after TP removal: {sl_err}")
        else:
            logger.info(f"[{uid}] {symbol} HL: TP removed (no SL to preserve)")
        
        return True
        
    except Exception as e:
        logger.warning(f"[{uid}] {symbol} HL: Failed to remove TP: {e}")
        return False


async def _position_idx_for_cached(uid: int, symbol: str, side: str) -> int:
    mode = await get_position_mode(uid, symbol)
    return position_idx_for(side, mode)

@with_texts
@log_calls
async def cmd_manual_order(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [
            InlineKeyboardButton(
                ctx.t['button_order_limit'],    
                callback_data="order_type:Limit"
            ),
            InlineKeyboardButton(
                ctx.t['button_order_market'],   
                callback_data="order_type:Market"
            ),
        ]
    ]
    await update.message.reply_text(
        ctx.t['order_type_prompt'],
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    return ORDER_TYPE

async def on_error(update, context):
    err = context.error
    if err is None:
        # No actual error, probably just a cancelled callback
        return
    if isinstance(err, (TgTimedOut, NetworkError)):
        logger.warning(f"Telegram transient error: {err}")
        return
    # Log with traceback for debugging
    logger.error(f"Unhandled error: {type(err).__name__}: {err}", exc_info=err)  

@with_texts
@log_calls
async def on_order_type_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    try:
        asyncio.create_task(q.answer(cache_time=1))   
    except TgTimedOut:
        logger.warning("q.answer() timeout ‚Äî we ignore")

    _, order_type = q.data.split(":", 1)
    ctx.user_data['manual_order_type'] = order_type

    if order_type == "Limit":
        prompt = (
            ctx.t['limit_order_format']
        )
    else:
        prompt = (
            ctx.t['market_order_format']
        )

    await q.edit_message_text(prompt, parse_mode='Markdown')
    return ORDER_PARAMS

@log_calls
async def split_market_plus_one_limit(
    uid: int,
    symbol: str,
    side: str,               
    spot_price: float,
    total_qty: float,
    signal_id: int | None,
    timeframe: str,
    ctx: ContextTypes.DEFAULT_TYPE,
    t: dict,
    *,
    market_msg: str,           
    limit_msg: str,
    strategy: str | None = None,
    account_type: str = "demo",
) -> None:
    filt = await get_symbol_filters(uid, symbol)
    step_qty  = float(filt["qtyStep"])
    min_qty   = float(filt["minQty"])

    def q_qty(v: float) -> float:
        return max(min_qty, quantize(v, step_qty))

    leg1_raw = total_qty * DCA_LEGS[0]
    leg2_raw = total_qty * DCA_LEGS[1]
    leg3_raw = total_qty * DCA_LEGS[2]

    leg1 = q_qty(leg1_raw)
    leg2 = q_qty(leg2_raw)
    leg3 = q_qty(total_qty - leg1 - leg2) 
    if leg3 < min_qty:
        leg2 = q_qty(leg2 + leg3)
        leg3 = 0.0

    if leg1 < min_qty:
        leg1 = q_qty(min_qty)
    if leg2 < min_qty and leg2 > 0:
        leg2 = q_qty(min_qty)

    async def get_mark() -> float | None:
        try:
            data = await _bybit_request(uid, "GET", "/v5/market/tickers",
                                        params={"category":"linear","symbol":symbol})
            last = (data.get("list") or [{}])[0].get("lastPrice")
            if last not in (None, "", "0"):
                return float(last)
        except Exception:
            pass
        try:
            positions = await fetch_open_positions(uid)
            p = next((p for p in positions if p.get("symbol")==symbol), None)
            if p:
                return float(p.get("markPrice"))
        except Exception:
            pass
        return None

    async def strict_set_sl_tp(_side: str, _entry: float, hint_tp_pct: float, hint_sl_pct: float):
        cfg = get_user_config(uid) or {}
        global_use_atr = bool(cfg.get("use_atr", 1))  # Default to ATR enabled
        
        # Get strategy-specific use_atr if strategy is set
        if strategy:
            strat_settings = db.get_strategy_settings(uid, strategy, exchange="bybit", account_type=account_type)
            strat_use_atr = strat_settings.get("use_atr")
            use_atr = bool(strat_use_atr) if strat_use_atr is not None else global_use_atr
        else:
            use_atr = global_use_atr
        
        # P0.5: If hint_tp_pct is None, it means ATR mode - skip TP
        if hint_tp_pct is None:
            use_atr = True
        
        # Use strategy-specific SL/TP if available
        sl_pct, tp_pct = resolve_sl_tp_pct(cfg, symbol, strategy=strategy, user_id=uid, side=_side)
        sl_pct = hint_sl_pct or sl_pct
        tp_pct = hint_tp_pct or tp_pct

        sl_price = round(_entry * (1 - sl_pct/100) if _side=="Buy" else _entry*(1+sl_pct/100), 6)
        if not use_atr:
            tp_price = round(_entry * (1 + tp_pct/100) if _side=="Buy" else _entry*(1-tp_pct/100), 6)
            mark = await get_mark()
            kwargs = {"sl_price": sl_price}
            if mark is None or (_side=="Buy" and tp_price>mark) or (_side=="Sell" and tp_price<mark):
                kwargs["tp_price"] = tp_price
            await set_trading_stop(uid, symbol, **kwargs, side_hint=_side, account_type=account_type, exchange="bybit")
        else:
            await set_trading_stop(uid, symbol, sl_price=sl_price, side_hint=_side, account_type=account_type, exchange="bybit")
            logger.info(f"[{uid}] ATR enabled for {symbol}: only SL={sl_price:.6f} set, TP managed by trailing")

    await place_order(uid, symbol, side, orderType="Market", qty=leg1)
    pos = None
    for _ in range(12):
        try:
            positions = await fetch_open_positions(uid)
            pos = next((p for p in positions if p.get("symbol")==symbol), None)
            if pos:
                break
        except Exception:
            pass
        await asyncio.sleep(0.25)

    cfg = get_user_config(uid) or {}
    # Use strategy-specific settings including use_atr
    trade_params = get_strategy_trade_params(uid, cfg, symbol, strategy, side=side, account_type=account_type)
    sl_pct = trade_params["sl_pct"]
    tp_pct = trade_params["tp_pct"]
    use_atr = trade_params["use_atr"]
    
    tf = timeframe or "24h"
    periods = TIMEFRAME_PARAMS.get(tf, TIMEFRAME_PARAMS["24h"])["atr_periods"]

    if not pos:
        try:
            await ctx.bot.send_message(
                uid,
                t.get('pos_fetch_fail', "Failed to confirm open position {symbol}.").format(symbol=symbol)
            )
        finally:
            return

    entry  = float(pos.get("avgPrice") or spot_price)
    size   = float(pos.get("size") or leg1)
    side_s = pos.get("side") or side
    # Get leverage from position data (Bybit returns it) or from user config
    pos_leverage = pos.get("leverage")
    if pos_leverage:
        pos_leverage = int(float(pos_leverage))
    else:
        pos_leverage = cfg.get('leverage', 10)

    add_active_position(
        user_id=uid, symbol=symbol, side=side_s,
        entry_price=entry, size=size,
        timeframe=tf, signal_id=(signal_id or get_last_signal_id(uid, symbol, tf)),
        strategy=strategy,
        account_type=account_type,
        exchange="bybit",  # DCA is Bybit-only
        use_atr=use_atr,  # P0.5: Pass ATR setting
        leverage=pos_leverage,  # Save actual leverage used
        # Fix #2: Save SL/TP % at position open time
        applied_sl_pct=sl_pct,
        applied_tp_pct=tp_pct,
    )

    # P0.5: If ATR enabled, only set SL (no TP - will be managed by ATR trailing)
    if use_atr:
        await strict_set_sl_tp(side_s, entry, None, sl_pct)  # tp_pct=None
        logger.info(f"[{uid}] ATR enabled for {symbol}: only SL set, TP will be managed by ATR trailing")
    else:
        await strict_set_sl_tp(side_s, entry, tp_pct, sl_pct)
    
    try:
        await ctx.bot.send_message(
            uid,
            t.get('dca_leg1_done', "DCA: Leg #1 MARKET {symbol} qty={q}, entry‚âà{p}")
             .format(symbol=symbol, q=leg1, p=entry)
        )
    except Exception:
        pass
    async def _dca_task():
        try:
            try:
                atr_val = await calc_atr(symbol, interval=ATR_INTERVAL, periods=periods)
            except Exception:
                atr_val = 0.0

            if leg2 >= min_qty:
                deadline2 = time.time() + DCA_LEG_TIMEOUT_SEC
                fired2 = False
                while time.time() < deadline2:
                    mark = await get_mark()
                    if mark is not None and atr_val > 0:
                        trigger = DCA_ATR_MULTS[0] * atr_val
                        if (side_s == "Buy" and (entry - mark) >= trigger) or \
                           (side_s == "Sell" and (mark - entry) >= trigger):
                            fired2 = True
                            break
                    await asyncio.sleep(DCA_POLL_SEC)

                if fired2:
                    await place_order(uid, symbol, side_s, orderType="Market", qty=leg2)
                    for _ in range(12):
                        positions = await fetch_open_positions(uid)
                        p2 = next((p for p in positions if p.get("symbol")==symbol), None)
                        if p2:
                            break
                        await asyncio.sleep(0.25)
                    if p2:
                        entry2 = float(p2.get("avgPrice") or entry)
                        size2  = float(p2.get("size") or (size + leg2))
                        await strict_set_sl_tp(side_s, entry2, tp_pct, sl_pct)
                        try:
                            await ctx.bot.send_message(
                                uid,
                                t.get('dca_leg2_done', "DCA: Leg #2 MARKET {symbol} qty={q}, new_avg‚âà{p}")
                                 .format(symbol=symbol, q=leg2, p=entry2)
                            )
                        except Exception:
                            pass
                        entry = entry2
                        size  = size2

            if leg3 >= min_qty:
                deadline3 = time.time() + DCA_LEG_TIMEOUT_SEC
                fired3 = False
                while time.time() < deadline3:
                    mark = await get_mark()
                    if mark is not None and atr_val > 0:
                        trigger = DCA_ATR_MULTS[1] * atr_val
                        if (side_s == "Buy" and (entry - mark) >= trigger) or \
                           (side_s == "Sell" and (mark - entry) >= trigger):
                            fired3 = True
                            break
                    await asyncio.sleep(DCA_POLL_SEC)

                cur = await get_mark()
                if cur is None:
                    cur = entry
                lim_price = cur * (1.0 - DCA_LAST_LEG_EXTRA_PCT/100.0) if side_s == "Buy" \
                            else cur * (1.0 + DCA_LAST_LEG_EXTRA_PCT/100.0)

                try:
                    res = await place_limit_order(uid, symbol, side_s, price=lim_price, qty=leg3)
                    order_id = _normalize_order_id(res)
                    tif = str(res.get("timeInForce") or "GTC")
                    add_pending_limit_order(
                        user_id=uid, order_id=order_id, symbol=symbol,
                        side=side_s, qty=leg3, price=lim_price,
                        signal_id=(signal_id or 0),
                        created_ts=int(time.time()*1000),
                        time_in_force=tif,
                        account_type=account_type,
                        exchange="bybit",
                    )
                    try:
                        await ctx.bot.send_message(
                            uid,
                            t.get('dca_leg3_limit', "DCA: Leg #3 LIMIT {symbol} @ {p} qty={q} (pending)")
                             .format(symbol=symbol, p=round(lim_price,6), q=leg3)
                        )
                    except Exception:
                        pass
                except Exception:
                    await place_order(uid, symbol, side_s, orderType="Market", qty=leg3)
                    for _ in range(12):
                        positions = await fetch_open_positions(uid)
                        p3 = next((p for p in positions if p.get("symbol")==symbol), None)
                        if p3:
                            break
                        await asyncio.sleep(0.25)
                    if p3:
                        entry3 = float(p3.get("avgPrice") or entry)
                        await strict_set_sl_tp(side_s, entry3, tp_pct, sl_pct)
                        try:
                            await ctx.bot.send_message(
                                uid,
                                t.get('dca_leg3_market', "DCA: Leg #3 MARKET {symbol} qty={q}, new_avg‚âà{p}")
                                 .format(symbol=symbol, q=leg3, p=entry3)
                            )
                        except Exception:
                            pass

        except Exception as e:
            logger.error(f"DCA task error for {uid}:{symbol}: {e}", exc_info=True)

    try:
        asyncio.create_task(_dca_task(), name=f"dca_{uid}_{symbol}")
    except Exception:
        pass

@with_texts
@log_calls
async def manual_order_text(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    try:
        typ = ctx.user_data.get('manual_order_type')
        if not typ:
            await update.message.reply_text(ctx.t['order_type_prompt'], reply_markup=main_menu_keyboard(ctx, update=update))
            return ConversationHandler.END

        parts = update.message.text.strip().split()
        symbol, side, price, qty = parse_manual(parts, typ)

        filt = await get_symbol_filters(uid, symbol) 
        tick     = float(filt["tickSize"])
        min_px   = float(filt["minPrice"])
        min_qty  = float(filt["minQty"])
        qty_step = float(filt["qtyStep"])

        q_raw = qty
        q = quantize(q_raw, qty_step)
        if q < min_qty:
            q = min_qty

        inst = await _bybit_request(
            uid, "GET", "/v5/market/instruments-info",
            params={"category": "linear", "symbol": symbol}
        )
        inst_list = inst.get("list", [])
        if not inst_list:
            await update.message.reply_text(
                ctx.t.get("symbol_not_found", f"‚ùå Symbol {symbol} not found"),
                reply_markup=main_menu_keyboard(ctx, update=update)
            )
            return ConversationHandler.END
        lot      = inst_list[0]["lotSizeFilter"]
        raw_max  = lot.get("maxOrderQty") if typ == "Limit" else lot.get("maxMktOrderQty")
        max_qty  = float(raw_max) if raw_max not in (None, "", 0, "0") else float("inf")

        if q > max_qty:
            q = quantize(max_qty, qty_step)
            if q < min_qty:
                q = min_qty

        px_adj = None
        if typ == "Limit":
            if price is None:
                await update.message.reply_text(ctx.t['order_parse_error'], reply_markup=main_menu_keyboard(ctx, update=update))
                return ConversationHandler.END
            px_adj = quantize(price, tick)
            if px_adj < min_px:
                await update.message.reply_text(
                    ctx.t['price_error_min'].format(min=min_px),
                    reply_markup=main_menu_keyboard(ctx, update=update)
                )
                return ConversationHandler.END

        res = await place_order_all_accounts(
            user_id=uid,
            symbol=symbol,
            side=side,
            orderType=typ,
            qty=q,
            price=px_adj if typ == "Limit" else None,
            strategy="manual",
            add_position=(typ == "Market"),  # Only add position for Market orders
        )

        if typ == "Limit":
            await update.message.reply_text(
                ctx.t['order_success'] + f"\n{symbol} {('LONG' if side=='Buy' else 'SHORT')} @ {px_adj} qty={q}",
                reply_markup=main_menu_keyboard(ctx, update=update)
            )
        else:
            await update.message.reply_text(
                ctx.t['order_success'] + f"\n{symbol} {('LONG' if side=='Buy' else 'SHORT')} (Market) qty={q}",
                reply_markup=main_menu_keyboard(ctx, update=update)
            )

    except ValueError as ve:
        await update.message.reply_text(
            ctx.t.get("error_validation", "‚ùå {msg}").format(msg=str(ve)),
            reply_markup=main_menu_keyboard(ctx, update=update)
        )
    except Exception:
        logger.exception("Error placing order")
        await update.message.reply_text(
            ctx.t['order_create_error'].format(msg="internal error"),
            reply_markup=main_menu_keyboard(ctx, update=update)
        )
    finally:
        ctx.user_data.pop('manual_order_type', None)

    return ConversationHandler.END

@log_calls
async def fetch_coindesk_news(limit: int = 5) -> list[dict]:
    url = "https://www.coindesk.com/arc/outboundfeeds/rss/"
    if _session is None:
        await init_session()

    text = None
    for attempt in (1, 2):
        try:
            async with _session.get(url, headers={"User-Agent": "Mozilla/5.0"}) as resp:
                if resp.status == 200:
                    text = await resp.text()
                    break
        except Exception:
            pass
        if attempt == 1:
            await asyncio.sleep(1.5)
    if not text:
        return []

    d = feedparser.parse(text)
    news = []
    for entry in d.entries[:limit]:
        title = entry.title
        link  = entry.link
        desc  = re.sub(r'<[^>]+>', '', entry.summary or '').strip()
        img = None
        mc = entry.get("media_content") or []
        if mc and isinstance(mc, list):
            img = (mc[0] or {}).get("url")
        if not img:
            m = re.search(r'<img[^>]+src="([^"]+)"', entry.summary or "")
            img = m.group(1) if m else None

        news.append({"title": title, "link": link, "description": desc, "image": img})
    return news


@require_access
@with_texts
@log_calls
async def cmd_market(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    chat_id = update.effective_chat.id

    loader = await ctx.bot.send_message(chat_id, ctx.t['loader'])
    try:
        await ctx.bot.delete_message(chat_id, loader.message_id)
    except Exception:
        pass
    btc_dom, usdt_dom, btc_price, btc_change, sp500, sp500_change, top_coins, gold_price, gold_change, total1, total2, total3, fear_greed, fear_greed_label, altseason_index = await fetch_market_status()
    prev_dom = get_prev_btc_dom()
    store_prev_btc_dom(btc_dom)
    if prev_dom is None:
        dom_trend = "unknown"
    elif btc_dom > prev_dom:
        dom_trend = "rising"      
    elif btc_dom < prev_dom:
        dom_trend = "falling"     
    else:
        dom_trend = "stable"      

    if dom_trend == "falling":
        alt_signal = "LONG" if btc_change > 0 else "NEUTRAL"
    else:
        alt_signal = "SHORT"

    save_market_snapshot(
        dom=btc_dom,
        price=btc_price,
        change=btc_change,
        alt_signal=alt_signal
    )
    emoji_map = {
        "LONG":    ctx.t.get("emoji_long", "üü¢"),
        "SHORT":   ctx.t.get("emoji_short", "üî¥"),
        "NEUTRAL": ctx.t.get("emoji_neutral", "‚ö™"),
    }
    dom_emo_map = {
        "rising":  ctx.t.get('dominance_rising', 'üìà Rising'),
        "falling": ctx.t.get('dominance_falling', 'üìâ Falling'),
        "stable":  ctx.t.get('dominance_stable', '‚ûñ Stable'),
        "unknown": ctx.t.get('dominance_unknown', '‚ùì Unknown')
    }
    dom_emo = dom_emo_map.get(dom_trend, dom_emo_map['unknown'])

    # S&P 500 emoji
    sp_emoji = "üìà" if sp500_change > 0 else "üìâ" if sp500_change < 0 else "‚ûñ"
    btc_emoji = "üìà" if btc_change > 0 else "üìâ" if btc_change < 0 else "‚ûñ"
    gold_emoji = "üìà" if gold_change > 0 else "üìâ" if gold_change < 0 else "‚ûñ"

    # Fear & Greed emoji
    if fear_greed >= 75:
        fg_emoji = "üü¢"  # Extreme Greed
    elif fear_greed >= 55:
        fg_emoji = "üü°"  # Greed
    elif fear_greed >= 45:
        fg_emoji = "‚ö™"  # Neutral
    elif fear_greed >= 25:
        fg_emoji = "üü†"  # Fear
    else:
        fg_emoji = "üî¥"  # Extreme Fear

    # Altseason emoji
    if altseason_index >= 75:
        alt_emoji = "üöÄ"  # Altseason
    elif altseason_index >= 50:
        alt_emoji = "üìà"
    elif altseason_index >= 25:
        alt_emoji = "üìâ"
    else:
        alt_emoji = "‚ùÑÔ∏è"  # Bitcoin Season

    # Build top coins table
    top_coins_text = ""
    if top_coins:
        medals = ["ü•á", "ü•à", "ü•â", "4Ô∏è‚É£", "5Ô∏è‚É£"]
        top_coins_text = f"\n\nüìä *{ctx.t.get('market_dominance_header', 'Top Coins by Dominance')}:*\n"
        top_coins_text += "```\n"
        for i, (symbol, mcap_b, dom) in enumerate(top_coins[:5]):
            medal = medals[i] if i < len(medals) else f"{i+1}."
            top_coins_text += f"{medal} {symbol:<5} {dom:>5.2f}%\n"
        top_coins_text += "```"

    # Build Total Market Cap info
    total_text = ""
    if total1 > 0:
        total_text = (
            f"\n\nüí∞ *{ctx.t.get('market_total_header', 'Total Market Cap')}:*\n"
            f"‚Ä¢ Total 1: ${total1:.2f}T\n"
            f"‚Ä¢ Total 2: ${total2:.2f}T\n"
            f"‚Ä¢ Total 3: ${total3:.2f}T"
        )

    # Build indices section
    indices_text = ""
    if fear_greed > 0 or altseason_index > 0:
        indices_text = f"\n\nüé≠ *{ctx.t.get('market_indices_header', 'Market Indices')}:*\n"
        if fear_greed > 0:
            indices_text += f"‚Ä¢ Fear & Greed: {fg_emoji} {fear_greed} ({fear_greed_label})\n"
        if altseason_index > 0:
            indices_text += f"‚Ä¢ Altseason Index: {alt_emoji} {altseason_index}"

    header = (
        f"{ctx.t.get('market_status_heading', 'üìä *Market Overview*')}\n\n"
        f"‚Ä¢ BTC: ${btc_price:,.0f} {btc_emoji} {btc_change:+.2f}%\n"
        f"‚Ä¢ {ctx.t.get('btc_dominance', 'BTC Dominance')}: {btc_dom:.2f}% ({dom_emo})\n"
        f"‚Ä¢ {ctx.t.get('usdt_dominance', 'USDT Dominance')}: {usdt_dom:.2f}%\n"
        f"‚Ä¢ S&P 500: {sp500:,.0f} {sp_emoji} {sp500_change:+.2f}%\n"
        f"‚Ä¢ Gold: ${gold_price:,.0f} {gold_emoji} {gold_change:+.2f}%\n\n"
        f"‚Ä¢ {ctx.t.get('alt_signal_label', 'ALT Signal')}: {emoji_map.get(alt_signal, '‚ö™')} *{ctx.t.get(f'alt_signal_{alt_signal.lower()}', alt_signal)}*"
        f"{indices_text}"
        f"{top_coins_text}"
        f"{total_text}"
    )
    await ctx.bot.send_message(chat_id, header, parse_mode="Markdown")

async def _place_hl_market_order(
    user_id: int,
    symbol: str,
    side: str,           # "Buy" / "Sell"
    qty: float,
    account_type: str = None,
    reduce_only: bool = False,
) -> dict:
    """
    Place a market order on HyperLiquid.
    Used by DCA/PTP monitor logic for HL positions.
    Returns dict with status and result.
    """
    is_testnet = account_type in ("testnet", "paper", "demo")
    hl_account_type = "testnet" if is_testnet else "mainnet"

    from core.exchange_client import get_exchange_client
    client = await get_exchange_client(user_id, exchange_type='hyperliquid', account_type=hl_account_type)
    adapter = client._client
    if not adapter:
        raise ValueError(f"No HL adapter available for {hl_account_type}")

    coin = hl_symbol_to_coin(symbol)
    is_buy = side.lower() in ("buy", "long")

    if reduce_only:
        result = await adapter._client.market_close(
            coin=coin,
            sz=qty,
            slippage=0.02,
        )
    else:
        result = await adapter._client.market_open(
            coin=coin,
            is_buy=is_buy,
            sz=qty,
            slippage=0.01,
        )

    logger.info(f"[{user_id}] HL market order: {symbol} {side} qty={qty} reduce_only={reduce_only} ‚Üí {result}")
    return result


async def _place_exchange_order(
    user_id: int,
    symbol: str,
    side: str,
    qty: float,
    account_type: str = None,
    exchange: str = "bybit",
    reduce_only: bool = False,
) -> dict:
    """
    Exchange-aware market order placement.
    Routes to Bybit place_order() or HyperLiquid _place_hl_market_order().
    Used by DCA and Partial Take Profit in monitor_positions_loop.
    """
    if exchange == "hyperliquid":
        return await _place_hl_market_order(
            user_id, symbol, side, qty,
            account_type=account_type,
            reduce_only=reduce_only,
        )
    else:
        return await place_order(
            user_id=user_id,
            symbol=symbol,
            side=side,
            orderType="Market",
            qty=qty,
            account_type=account_type,
        )


@log_calls
async def place_order(
    user_id: int,
    symbol: str,
    side: str,                 # "Buy" / "Sell"
    orderType: str,            # "Limit" / "Market"
    qty: float,
    price: float | None = None,
    timeInForce: str = "GTC",
    account_type: str = None,
):
    """
    Place an order on Bybit. Uses per-user/symbol lock to prevent race conditions.
    """
    # Get lock for this user/symbol/account to prevent concurrent orders
    trading_lock = await get_trading_lock(user_id, symbol, account_type or "auto")
    
    async with trading_lock:
        return await _place_order_impl(
            user_id, symbol, side, orderType, qty, price, timeInForce, account_type
        )

async def _place_order_impl(
    user_id: int,
    symbol: str,
    side: str,
    orderType: str,
    qty: float,
    price: float | None = None,
    timeInForce: str = "GTC",
    account_type: str = None,
):
    # Check minimum notional value for Bybit BEFORE sending order
    # Bybit requires 5 USDT minimum, we use 5.0 here as final check
    MIN_NOTIONAL = 5.0
    # Get current price for notional calculation
    try:
        ticker = await _bybit_request(
            user_id, "GET", "/v5/market/tickers",
            params={"category": "linear", "symbol": symbol},
            account_type=account_type
        )
        current_price = float(ticker["list"][0]["lastPrice"])
        notional = qty * current_price
        
        if notional < MIN_NOTIONAL:
            logger.warning(
                f"[{user_id}] Order notional ${notional:.2f} < ${MIN_NOTIONAL} min for {symbol}. "
                f"Skipping order (qty={qty:.4f}, price={current_price:.4f})"
            )
            # Record error for admin reporting
            asyncio.create_task(error_monitor.record_error(
                user_id=user_id,
                error_type="ORDER_TOO_SMALL",
                error_message=f"notional ${notional:.2f} < ${MIN_NOTIONAL} min",
                function_name="_place_order_impl",
                symbol=symbol,
                account_type=account_type,
                notify_user=True,
                qty=qty,
                price=current_price,
                notional=notional
            ))
            raise ValueError(f"ORDER_TOO_SMALL: notional ${notional:.2f} < ${MIN_NOTIONAL} minimum")
    except ValueError:
        raise  # Re-raise our ORDER_TOO_SMALL error
    except Exception as e:
        logger.warning(f"[{user_id}] Could not check notional for {symbol}: {e}")
        # Continue anyway - Bybit will reject if too small
    
    # –ù–æ—Ä–º–∞–ª–∏–∑–∞—Ü–∏—è –∫–æ–ª–∏—á–µ—Å—Ç–≤–∞/—Ü–µ–Ω—ã –ø–æ–¥ —à–∞–≥–∏ –∏–Ω—Å—Ç—Ä—É–º–µ–Ω—Ç–∞
    qty_str, price_str, min_qty, max_qty, tick_size = await normalize_qty_price(
        user_id, symbol, orderType, qty, price, account_type=account_type
    )

    logger.debug(
        f"‚ñ∂ place_order: {symbol} {side} {orderType} "
        f"raw_qty={qty}, min_qty={min_qty}, max_qty={max_qty} ‚Üí send qty={qty_str}"
        + (f", price={price_str}" if price_str else "")
        + f" [{account_type or 'auto'}]"
    )

    import uuid
    order_link_id = f"tg_{uuid.uuid4().hex[:32]}"

    body = {
        "category":     "linear",
        "symbol":       symbol,
        "side":         side,
        "orderType":    orderType,          # "Limit" | "Market"
        "qty":          qty_str,            # –¥–ª—è Market ‚Äî —ç—Ç–æ base qty
        "orderLinkId":  order_link_id,      # –ø—Ä–∞–≤–∏–ª—å–Ω–æ–µ –∏–º—è –∫–ª—é—á–∞ –Ω–∞ Bybit v5
    }

    if orderType == "Limit":
        # –î–ª—è –ª–∏–º–∏—Ç–æ–∫ ‚Äî —Ü–µ–Ω–∞ –æ–±—è–∑–∞—Ç–µ–ª—å–Ω–∞ –∏ TIF –∏–º–µ–µ—Ç —Å–º—ã—Å–ª
        body["price"] = price_str
        body["timeInForce"] = timeInForce or "GTC"
    else:
        # –î–ª—è Market ‚Äî —Ü–µ–Ω—É –ù–ï –æ—Ç–ø—Ä–∞–≤–ª—è–µ–º; TIF –ª—É—á—à–µ —è–≤–Ω–æ –∫–∞–∫ IOC
        body.pop("price", None)
        body["timeInForce"] = "IOC"

    # –ü—Ä–æ—Å—Ç–∞–≤–ª—è–µ–º –∫–æ—Ä—Ä–µ–∫—Ç–Ω—ã–π positionIdx (hedge/one_way)
    mode = await get_position_mode(user_id, symbol, account_type=account_type)
    body["positionIdx"] = position_idx_for(side, mode)

    try:
        res = await _bybit_request(user_id, "POST", "/v5/order/create", body=body, account_type=account_type)
    except RuntimeError as e:
        msg = str(e).lower()

        # –î–µ–Ω–µ–≥ –Ω–µ—Ç ‚Äî —Å—Ä–∞–∑—É human-readable –æ—à–∏–±–∫–∞ (110007: ab not enough, insufficient balance)
        if "insufficient" in msg or "balance" in msg or "110007" in msg or "ab not enough" in msg:
            # Log full error and order params for debugging
            logger.error(f"[{user_id}] INSUFFICIENT_BALANCE error. Order body: {body}. Full error: {e}")
            # Record error for admin reporting
            asyncio.create_task(error_monitor.record_error(
                user_id=user_id,
                error_type="INSUFFICIENT_BALANCE",
                error_message=str(e),
                function_name="_place_order_impl",
                symbol=symbol,
                account_type=account_type,
                notify_user=True,
                side=side,
                qty=qty,
                order_type=orderType
            ))
            raise ValueError("INSUFFICIENT_BALANCE")

        # –ù–µ–ø—Ä–∞–≤–∏–ª—å–Ω—ã–π position mode ‚Äî –º–µ–Ω—è–µ–º –∏ —Ä–µ—Ç—Ä–∞–∏–º
        if "position idx not match position mode" in msg:
            alt_mode = "one_way" if mode == "hedge" else "hedge"
            body["positionIdx"] = position_idx_for(side, alt_mode)
            _position_mode_cache[(user_id, symbol, account_type or "auto")] = alt_mode
            logger.info(f"{symbol}: retry with alt position mode {alt_mode}")
            res = await _bybit_request(user_id, "POST", "/v5/order/create", body=body, account_type=account_type)

        # –û—à–∏–±–∫–∞ –∫—Ä–µ–¥–∏—Ç–Ω–æ–≥–æ –ø–ª–µ—á–∞ ‚Äî –ø—ã—Ç–∞–µ–º—Å—è –∏–∑–≤–ª–µ—á—å maxLeverage –∏–∑ –æ—à–∏–±–∫–∏ –∏ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å
        elif "110013" in msg or "cannot set leverage" in msg:
            # Try to extract maxLeverage from error message: "gt maxLeverage [500]"
            import re
            match = re.search(r'maxLeverage\s*\[(\d+)\]', str(e))
            target_lev = int(match.group(1)) if match else 10
            
            logger.info(f"{symbol}: leverage error ‚Üí trying to set {target_lev}x")
            lev_success = await set_leverage(user_id, symbol, leverage=target_lev, account_type=account_type)
            
            # If set_leverage failed (returned 0), try progressively lower values
            if lev_success == 0:
                for fallback in [5, 3, 2, 1]:
                    logger.info(f"{symbol}: trying fallback leverage {fallback}x")
                    if await set_leverage(user_id, symbol, leverage=fallback, account_type=account_type) > 0:
                        break
            
            res = await _bybit_request(user_id, "POST", "/v5/order/create", body=body, account_type=account_type)

        # –û—à–∏–±–∫–∞ 110090 - –ø–æ–∑–∏—Ü–∏—è –ø—Ä–µ–≤—ã—à–∞–µ—Ç –ª–∏–º–∏—Ç, –Ω—É–∂–Ω–æ —Å–Ω–∏–∑–∏—Ç—å –ø–ª–µ—á–æ –¥–æ 45 –∏–ª–∏ –Ω–∏–∂–µ
        elif "110090" in msg or "exceed the max" in msg:
            logger.info(f"{symbol}: max position limit error ‚Üí reduce leverage to 45x and retry")
            await set_leverage(user_id, symbol, leverage=45, account_type=account_type)
            try:
                res = await _bybit_request(user_id, "POST", "/v5/order/create", body=body, account_type=account_type)
            except RuntimeError as e2:
                # –ï—Å–ª–∏ –≤—Å—ë –µ—â—ë –Ω–µ —Ä–∞–±–æ—Ç–∞–µ—Ç - –ø—Ä–æ–±—É–µ–º —Å 25x
                if "110090" in str(e2).lower() or "exceed the max" in str(e2).lower():
                    logger.info(f"{symbol}: still exceeds limit ‚Üí reduce leverage to 25x and retry")
                    await set_leverage(user_id, symbol, leverage=25, account_type=account_type)
                    res = await _bybit_request(user_id, "POST", "/v5/order/create", body=body, account_type=account_type)
                else:
                    raise

        # –ù–µ–≤–µ—Ä–Ω—ã–π TIF –¥–ª—è —Ä—ã–Ω–∫–∞ ‚Äî –ø–æ–ø—Ä–∞–≤–∏–º –Ω–∞ IOC –∏ —Ä–µ—Ç—Ä–∞–∏–º
        elif "timeinforce" in msg and "market" in msg:
            if body.get("orderType") == "Market":
                body["timeInForce"] = "IOC"
                res = await _bybit_request(user_id, "POST", "/v5/order/create", body=body, account_type=account_type)
            else:
                raise

        else:
            raise

    logger.info(f"Order placed [{account_type or 'auto'}]: {res}")
    return res


@log_calls
async def place_order_all_accounts(
    user_id: int,
    symbol: str,
    side: str,
    orderType: str,
    qty: float,
    price: float | None = None,
    timeInForce: str = "GTC",
    strategy: str = None,
    leverage: int = None,
    signal_id: int | None = None,
    timeframe: str = "24h",
    add_position: bool = True,  # Whether to add position to DB
    calc_qty_per_target: bool = False,  # Calculate qty for each target separately
    entry_price: float = None,  # Required if calc_qty_per_target=True
) -> dict:
    """
    DEPRECATED: Use place_order_for_targets() for multi-exchange support.
    
    Place order on all active accounts based on strategy's trading_mode or global trading_mode.
    If trading_mode is 'both', places order on both demo and real accounts.
    Also adds active positions to DB with correct account_type for each successful order.
    Returns dict with results per account type.
    
    If calc_qty_per_target=True:
      - qty parameter becomes the FALLBACK qty
      - Each target will calculate its own qty based on its own settings (percent, sl_pct)
      - entry_price is REQUIRED for per-target qty calculation
    """
    # Forward to new function using legacy mode
    return await place_order_for_targets(
        user_id=user_id,
        symbol=symbol,
        side=side,
        orderType=orderType,
        qty=qty,
        price=price,
        timeInForce=timeInForce,
        strategy=strategy,
        leverage=leverage,
        signal_id=signal_id,
        timeframe=timeframe,
        add_position=add_position,
        use_legacy_routing=True,  # Use old account_types logic
        calc_qty_per_target=calc_qty_per_target,
        entry_price=entry_price,
    )


@log_calls
async def place_order_for_targets(
    user_id: int,
    symbol: str,
    side: str,
    orderType: str,
    qty: float = None,  # Can be None if calc_qty_per_target=True
    price: float | None = None,
    timeInForce: str = "GTC",
    strategy: str = None,
    leverage: int = None,
    signal_id: int | None = None,
    timeframe: str = "24h",
    add_position: bool = True,
    targets: list[dict] = None,  # Explicit targets list
    use_legacy_routing: bool = False,  # Use old account_types logic
    # NEW: Parameters for per-target qty calculation
    calc_qty_per_target: bool = False,  # If True, calculate qty for each target separately
    entry_price: float = None,  # Price for qty calculation (required if calc_qty_per_target=True)
) -> dict:
    """
    Place order on specified targets (supports Bybit + HyperLiquid).
    
    Target format: {"exchange": "bybit", "env": "paper", "account_type": "demo"}
    
    Features:
    - Multi-exchange support (Bybit + HyperLiquid)
    - Per-target qty calculation (when calc_qty_per_target=True)
    - Per-target leverage/SL/TP
    - Unique client_order_id per target: {signal_id}-{exchange}-{env}
    
    Returns dict with results per target key (e.g., "bybit:paper": {...})
    
    IMPORTANT: strategy parameter is REQUIRED for auto-trading.
    If strategy is None/empty, a warning will be logged and 'unknown' will be used as fallback.
    """
    from db import get_execution_targets, get_live_enabled
    
    # Validate and log strategy
    if not strategy:
        logger.warning(f"[{user_id}] place_order_for_targets called without strategy for {symbol} {side}! Using 'unknown' as fallback.")
        strategy = "unknown"
    
    # Validate strategy is one of known strategies
    KNOWN_STRATEGIES = {"oi", "scryptomera", "scalper", "elcaro", "fibonacci", "rsi_bb", "webapp", "manual", "unknown"}
    if strategy.lower() not in KNOWN_STRATEGIES:
        logger.warning(f"[{user_id}] Unknown strategy '{strategy}' for {symbol} {side}. This may cause issues with settings resolution.")
    
    # Determine targets
    if targets is None:
        if use_legacy_routing:
            # Use new get_execution_targets which respects strategy trading_mode
            # and routes to both enabled exchanges
            targets = get_execution_targets(user_id, strategy)
            
            if not targets:
                # Fallback: check if any exchange is enabled
                bybit_enabled = db.is_bybit_enabled(user_id)
                hl_enabled = db.is_hl_enabled(user_id)
                
                if not bybit_enabled and not hl_enabled:
                    raise ValueError("No exchanges enabled for trading")
                else:
                    raise ValueError("No valid credentials configured for enabled exchanges")
        else:
            # Use new routing policy system
            targets = get_execution_targets(user_id, strategy)
    
    if not targets:
        raise ValueError("No execution targets configured")
    
    # Get default leverage from user config if not specified
    if leverage is None:
        cfg = get_user_config(user_id)
        leverage = cfg.get('leverage', 10)
    
    results = {}
    errors = []
    
    logger.info(f"[{user_id}] place_order_for_targets: strategy={strategy}, targets={targets}")
    
    for target in targets:
        target_exchange = target.get("exchange", "bybit")
        target_env = target.get("env", "paper")
        target_account_type = target.get("account_type")
        target_key = f"{target_exchange}:{target_env}"
        
        logger.info(f"[{user_id}] Processing target: {target_key} account_type={target_account_type}")
        
        # Skip disabled exchanges
        if target_exchange == "bybit" and not db.is_bybit_enabled(user_id):
            logger.debug(f"[{user_id}] Skipping Bybit target - Bybit is disabled")
            continue
        if target_exchange == "hyperliquid" and not db.is_hl_enabled(user_id):
            logger.debug(f"[{user_id}] Skipping HyperLiquid target - HL is disabled")
            continue
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # Skip target if position already exists for this symbol+account_type+exchange
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        acc_for_check = target_account_type or ("demo" if target_env == "paper" else "real")
        existing_positions = get_active_positions(user_id, account_type=acc_for_check, exchange=target_exchange)
        has_existing = any(p.get("symbol") == symbol for p in existing_positions)
        
        if has_existing:
            logger.info(f"[{user_id}] Skipping {target_key} - position already exists for {symbol} on {acc_for_check}")
            results[target_key] = {"success": False, "skipped": True, "reason": f"Position already exists for {symbol}", "exchange": target_exchange}
            continue
        
        # Generate unique client_order_id for this target
        client_order_id = f"{signal_id or 'manual'}-{target_exchange[:2]}-{target_env[:1]}-{int(time.time())}"
        
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # Per-target qty calculation: get settings and calculate qty for THIS target
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        target_qty = qty  # Default to passed qty
        target_leverage = leverage
        target_order_type = orderType  # Default to passed orderType
        target_limit_offset_pct = 0.1  # Default offset for limit orders
        
        if calc_qty_per_target and entry_price:
            try:
                # Get strategy settings for THIS specific target (exchange + account_type)
                cfg = get_user_config(user_id) or {}
                target_acc = target_account_type or ("demo" if target_env == "paper" else "real")
                trade_params = get_strategy_trade_params(
                    user_id, cfg, symbol, strategy or "manual",
                    side=side, exchange=target_exchange, account_type=target_acc
                )
                
                risk_pct = trade_params.get("percent", 1.0)
                sl_pct = trade_params.get("sl_pct", 3.0)
                
                # Get leverage from trade_params (side-specific) if not explicitly passed
                if target_leverage is None:
                    target_leverage = trade_params.get("leverage") or cfg.get("leverage", 10)
                
                # Get order_type from trade_params (side-specific) - use if not explicitly passed as Market
                user_order_type = trade_params.get("order_type", "market")
                target_limit_offset_pct = trade_params.get("limit_offset_pct", 0.1)
                
                # Only override if user setting is "limit" and we're not forced to use Market
                if user_order_type.lower() == "limit" and orderType == "Market":
                    target_order_type = "Limit"
                    logger.info(f"[{user_id}] Using Limit order from user settings with offset {target_limit_offset_pct}%")
                
                # Calculate qty for THIS account's balance
                # For HyperLiquid we need different balance fetch method
                if target_exchange == "hyperliquid":
                    # HyperLiquid: get balance via exchange_router
                    from exchange_router import ExchangeRouter
                    router = ExchangeRouter()
                    hl_balance = await router._get_hl_balance(user_id)
                    equity = float(hl_balance.get("equity", 0))
                    if equity <= 0:
                        raise ValueError(f"HyperLiquid equity={equity}")
                    
                    # Manual qty calculation for HyperLiquid
                    risk_usdt = equity * (risk_pct / 100)
                    price_move = entry_price * (sl_pct / 100)
                    if price_move <= 0:
                        raise ValueError("Invalid sl_pct for price_move")
                    target_qty = risk_usdt / price_move
                    
                    logger.info(
                        f"[{user_id}] HL per-target qty for {target_key}: "
                        f"equity={equity:.2f}, risk={risk_pct}%, sl={sl_pct}%, qty={target_qty:.4f}"
                    )
                else:
                    # Bybit: use standard calc_qty
                    target_qty = await calc_qty(
                        user_id, symbol, entry_price, risk_pct, sl_pct,
                        account_type=target_acc, exchange="bybit"
                    )
                    
                    # Check minimum notional value ($5 on Bybit)
                    # If position is too small, SKIP the trade instead of increasing leverage
                    MIN_NOTIONAL_BYBIT = 5.0   # Bybit's minimum
                    notional_value = target_qty * entry_price
                    
                    if notional_value < MIN_NOTIONAL_BYBIT:
                        logger.warning(
                            f"[{user_id}] {symbol} notional ${notional_value:.2f} < ${MIN_NOTIONAL_BYBIT} minimum. "
                            f"SKIPPING trade (equity too low or risk% too small). "
                            f"qty={target_qty:.4f}, leverage={target_leverage}x, risk={risk_pct}%, sl={sl_pct}%"
                        )
                        errors.append(f"[{target_key.upper()}] Notional ${notional_value:.2f} below ${MIN_NOTIONAL_BYBIT} minimum - increase risk% or equity")
                        continue  # Skip this target, don't open position
                    
                    logger.info(
                        f"[{user_id}] Per-target qty for {target_key}: "
                        f"risk={risk_pct}%, sl={sl_pct}%, qty={target_qty:.4f}, leverage={target_leverage}, notional=${target_qty * entry_price:.2f}"
                    )
            except Exception as calc_err:
                logger.error(f"[{user_id}] Failed to calc qty for {target_key}: {calc_err}")
                errors.append(f"[{target_key.upper()}] calc_qty: {str(calc_err)}")
                continue
        
        try:
            if target_exchange == "hyperliquid":
                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                # HyperLiquid order (via HLAdapter directly)
                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                is_testnet = (target_env == "paper" or target_account_type == "testnet")
                
                # Check if coin exists on HyperLiquid BEFORE trying to trade
                from hyperliquid.constants import coin_to_asset_id
                coin = hl_symbol_to_coin(symbol)
                if coin_to_asset_id(coin) is None:
                    # Coin not supported on HyperLiquid - skip this target silently (not an error)
                    logger.info(f"[{user_id}] Skipping {target_key} - {coin} not available on HyperLiquid")
                    results[target_key] = {"success": False, "skipped": True, "reason": f"{coin} not available on HyperLiquid", "exchange": target_exchange}
                    continue
                
                # Get HL credentials
                hl_creds = db.get_hl_credentials(user_id)
                # Get correct private key and wallet_address for network (multitenancy)
                if is_testnet:
                    hl_private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
                    wallet_address = hl_creds.get("hl_testnet_wallet_address") or hl_creds.get("hl_wallet_address")
                else:
                    hl_private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
                    wallet_address = hl_creds.get("hl_mainnet_wallet_address") or hl_creds.get("hl_wallet_address")
                
                if not hl_private_key:
                    errors.append(f"[{target_key.upper()}] No HL private key for {'testnet' if is_testnet else 'mainnet'}")
                    continue
                
                # Create adapter - let it auto-discover main wallet via userRole API
                adapter = HLAdapter(
                    private_key=hl_private_key,
                    testnet=is_testnet
                    # vault_address and main_wallet_address auto-discovered
                )
                
                try:
                    # Ensure adapter is fully initialized (auto-discovery + dynamic mapping)
                    await adapter.initialize()
                    
                    # coin already extracted above for validation
                    is_buy = side.lower() in ("buy", "long")
                    hl_leverage = target_leverage or leverage or 10
                    
                    # Check if coin actually has a price on this HL network (testnet has fewer coins)
                    mid_price = await adapter._client.get_mid_price(coin)
                    if mid_price is None or mid_price <= 0:
                        logger.info(f"[{user_id}] Skipping {target_key} - {coin} has no price on HL {'testnet' if is_testnet else 'mainnet'}")
                        results[target_key] = {"success": False, "skipped": True, "reason": f"{coin} not tradeable on HL {'testnet' if is_testnet else 'mainnet'}", "exchange": target_exchange}
                        continue
                    
                    # Set leverage first
                    try:
                        await adapter._client.update_leverage(coin=coin, leverage=hl_leverage, is_cross=True)
                    except Exception as lev_err:
                        logger.warning(f"[{user_id}] Could not set HL leverage: {lev_err}")
                    
                    # Calculate limit price if using limit order
                    limit_price = price
                    if target_order_type == "Limit" and entry_price and not price:
                        if side == "Buy":
                            limit_price = entry_price * (1 - target_limit_offset_pct / 100)
                        else:
                            limit_price = entry_price * (1 + target_limit_offset_pct / 100)
                        logger.info(f"[{user_id}] Limit order price for {symbol}: {limit_price:.4f} (offset {target_limit_offset_pct}%)")
                    
                    # Place order based on order type
                    if target_order_type == "Limit" and limit_price:
                        res = await adapter._client.limit_open(
                            coin=coin,
                            is_buy=is_buy,
                            sz=target_qty,
                            px=limit_price,
                            reduce_only=False
                        )
                    else:
                        # Market order
                        res = await adapter._client.market_open(
                            coin=coin,
                            is_buy=is_buy,
                            sz=target_qty,
                            slippage=0.01
                        )
                    
                    results[target_key] = {"success": True, "result": res, "exchange": target_exchange, "qty": target_qty, "order_type": target_order_type}
                    logger.info(f"‚úÖ [{target_key.upper()}] {target_order_type} order placed: {symbol} {side} qty={target_qty}")
                    
                finally:
                    await adapter.close()
                
            else:
                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                # Bybit order
                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                acc_type = target_account_type or ("demo" if target_env == "paper" else "real")
                
                # Set leverage first with target-specific value, get actual leverage applied
                actual_leverage = target_leverage or leverage
                try:
                    actual_leverage = await set_leverage(user_id, symbol, leverage=target_leverage or leverage, account_type=acc_type) or (target_leverage or leverage)
                except Exception as lev_err:
                    logger.warning(f"[{user_id}] Failed to set Bybit leverage for {symbol}: {lev_err}")
                
                # Calculate limit price if using limit order
                limit_price = price
                if target_order_type == "Limit" and entry_price and not price:
                    # Calculate limit price with offset
                    if side == "Buy":
                        # For buy, set limit below current price
                        limit_price = entry_price * (1 - target_limit_offset_pct / 100)
                    else:
                        # For sell, set limit above current price
                        limit_price = entry_price * (1 + target_limit_offset_pct / 100)
                    logger.info(f"[{user_id}] Bybit limit price for {symbol}: {limit_price:.4f} (offset {target_limit_offset_pct}%)")
                
                # Place order with target-specific qty and order type
                res = await place_order(user_id, symbol, side, target_order_type, target_qty, limit_price, timeInForce, account_type=acc_type)
                results[target_key] = {"success": True, "result": res, "exchange": target_exchange, "qty": target_qty, "actual_leverage": actual_leverage, "order_type": target_order_type}
                logger.info(f"‚úÖ [{target_key.upper()}] {target_order_type} order placed: {symbol} {side} qty={target_qty}")
            
            # Store position in DB with correct target info
            if add_position and target_order_type == "Market":
                # FIX: Get ACTUAL entry price from position (avgPrice) instead of ticker price!
                # This is critical for correct SL/TP calculation
                pos_entry_price = 0
                try:
                    if target_exchange == "hyperliquid":
                        # Get price from HL position
                        hl_creds = db.get_hl_credentials(user_id)
                        is_testnet_for_price = (target_env == "paper")
                        # Get correct private key and wallet_address for network (multitenancy)
                        if is_testnet_for_price:
                            hl_private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
                            wallet_address_for_price = hl_creds.get("hl_testnet_wallet_address") or hl_creds.get("hl_wallet_address")
                        else:
                            hl_private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
                            wallet_address_for_price = hl_creds.get("hl_mainnet_wallet_address") or hl_creds.get("hl_wallet_address")
                        
                        if hl_private_key:
                            adapter = HLAdapter(
                                private_key=hl_private_key,
                                testnet=is_testnet_for_price
                                # main_wallet_address auto-discovered
                            )
                            try:
                                # Try to get actual position entry price
                                positions = await adapter.get_positions()
                                hl_coin = hl_symbol_to_coin(symbol)
                                for hl_pos in positions:
                                    if hl_pos.get("coin") == hl_coin and float(hl_pos.get("szi", 0)) != 0:
                                        pos_entry_price = float(hl_pos.get("entryPx", 0))
                                        break
                                # Fallback to ticker if position not found yet
                                if not pos_entry_price:
                                    price_data = await adapter.get_price(hl_coin)
                                    pos_entry_price = float(price_data) if price_data else 0
                            finally:
                                await adapter.close()
                    else:
                        # FIX: Get actual avgPrice from Bybit POSITION endpoint, not ticker!
                        # Small delay to let Bybit process the order
                        await asyncio.sleep(0.3)
                        position_data = await _bybit_request(
                            user_id, "GET", "/v5/position/list",
                            params={"category": "linear", "symbol": symbol},
                            account_type=target_account_type or "demo"
                        )
                        position_list = position_data.get("list", [])
                        for pos in position_list:
                            if float(pos.get("size", 0)) > 0:
                                pos_entry_price = float(pos.get("avgPrice", 0))
                                logger.debug(f"[{user_id}] Got actual avgPrice from position: {pos_entry_price}")
                                break
                        
                        # Fallback to ticker if position not found (shouldn't happen)
                        if not pos_entry_price:
                            logger.warning(f"[{user_id}] Position not found after order, using ticker price as fallback")
                            ticker_data = await _bybit_request(
                                user_id, "GET", "/v5/market/tickers",
                                params={"category": "linear", "symbol": symbol},
                                account_type=target_account_type or "demo"
                            )
                            ticker_list = ticker_data.get("list", [])
                            if ticker_list:
                                pos_entry_price = float(ticker_list[0].get("lastPrice", 0))
                except Exception as e:
                    logger.warning(f"[{user_id}] Failed to get entry price: {e}")
                    # Fallback to passed entry_price
                    pos_entry_price = entry_price or 0
                
                # P0.5: Get use_atr from strategy settings
                cfg = get_user_config(user_id) or {}
                trade_params = get_strategy_trade_params(user_id, cfg, symbol, strategy or "manual", 
                                                         side=side, exchange=target_exchange, 
                                                         account_type=target_account_type)
                pos_use_atr = trade_params.get("use_atr", False)
                pos_sl_pct = trade_params.get("sl_pct")
                pos_tp_pct = trade_params.get("tp_pct")
                
                # Calculate SL/TP prices from entry and percentages
                pos_sl_price = None
                pos_tp_price = None
                if pos_entry_price and pos_entry_price > 0:
                    if pos_sl_pct:
                        if side == "Buy":
                            pos_sl_price = pos_entry_price * (1 - pos_sl_pct / 100)
                        else:
                            pos_sl_price = pos_entry_price * (1 + pos_sl_pct / 100)
                    if pos_tp_pct and not pos_use_atr:  # No TP price if ATR mode (trailing)
                        if side == "Buy":
                            pos_tp_price = pos_entry_price * (1 + pos_tp_pct / 100)
                        else:
                            pos_tp_price = pos_entry_price * (1 - pos_tp_pct / 100)
                
                # Get actual leverage (may differ from requested due to fallback)
                pos_leverage = results.get(target_key, {}).get("actual_leverage", target_leverage or leverage)
                
                add_active_position(
                    user_id=user_id,
                    signal_id=signal_id,
                    symbol=symbol,
                    side=side,
                    size=target_qty,  # Use target-specific qty
                    entry_price=pos_entry_price,
                    timeframe=timeframe,
                    strategy=strategy,
                    account_type=target_account_type or ("demo" if target_env == "paper" else "real"),
                    exchange=target_exchange,
                    env=target_env,
                    client_order_id=client_order_id,
                    use_atr=pos_use_atr,  # P0.5: Pass ATR setting
                    leverage=pos_leverage,  # Save actual leverage (after fallback)
                    # Fix #2: Save SL/TP % at position open time
                    applied_sl_pct=pos_sl_pct,
                    applied_tp_pct=pos_tp_pct,
                    # Fix #3: Save calculated SL/TP prices
                    sl_price=pos_sl_price,
                    tp_price=pos_tp_price,
                )
                logger.info(f"üìä [{target_key.upper()}] Position saved to DB: {symbol} {side} @ {pos_entry_price} qty={target_qty} strategy={strategy} (use_atr={pos_use_atr}, leverage={pos_leverage}, sl={pos_sl_price}, tp={pos_tp_price})")
                
        except Exception as e:
            results[target_key] = {"success": False, "error": str(e), "exchange": target_exchange}
            errors.append(f"[{target_key.upper()}] {str(e)}")
            logger.error(f"‚ùå [{target_key.upper()}] {orderType} order failed for {symbol}: {e}")
    
    if errors and not any(r["success"] for r in results.values()):
        raise RuntimeError(f"All orders failed: {'; '.join(errors)}")
    
    return results


# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# ‚ñà‚ñà  HYPERLIQUID ORDER EXECUTION  ‚ñà‚ñà
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê

# Cache for HyperLiquid available coins
_hl_coins_cache = {"coins": set(), "timestamp": 0, "ttl": 300}  # 5 min cache

async def get_hl_available_coins() -> set:
    """Get set of available coin symbols on HyperLiquid."""
    import time
    now = time.time()
    
    if _hl_coins_cache["coins"] and (now - _hl_coins_cache["timestamp"]) < _hl_coins_cache["ttl"]:
        return _hl_coins_cache["coins"]
    
    try:
        from hyperliquid import HyperLiquidClient
        # Use read-only client just to get coin list
        client = HyperLiquidClient(testnet=False)
        await client.initialize()
        mids = await client.get_all_mids()
        await client.close()
        
        # Convert to USDT format for comparison (HL uses BTC, we compare BTCUSDT)
        coins = {f"{coin}USDT" for coin in mids.keys()}
        _hl_coins_cache["coins"] = coins
        _hl_coins_cache["timestamp"] = now
        return coins
    except Exception as e:
        logger.warning(f"Failed to get HL coins: {e}")
        return set()


def hl_symbol_to_coin(symbol: str) -> str:
    """Convert BTCUSDT to BTC for HyperLiquid."""
    if symbol.endswith("USDT"):
        return symbol[:-4]
    if symbol.endswith("USDC"):
        return symbol[:-4]
    return symbol


async def place_order_bybit_if_needed(
    user_id: int,
    symbol: str,
    side: str,
    qty: float,
    strategy: str,
    leverage: int = None,
    sl_percent: float = None,
    tp_percent: float = None,
    entry_price: float = None,
) -> dict | None:
    """
    Place order on Bybit if user's active exchange is HyperLiquid but Bybit is also configured.
    This is the symmetric counterpart to place_order_hyperliquid().
    
    Only called when:
    1. User's active exchange is HyperLiquid
    2. User has Bybit API keys configured
    3. User wants to trade on both exchanges
    4. Bybit is enabled (bybit_enabled = 1)
    
    Returns result dict or None if not executed.
    """
    try:
        # Only execute if active exchange is hyperliquid
        active_exchange = db.get_exchange_type(user_id)
        if active_exchange != "hyperliquid":
            # Bybit is already handled by place_order_all_accounts
            return None
        
        # Check if Bybit is enabled for this user
        if not db.is_bybit_enabled(user_id):
            logger.debug(f"[{user_id}] Bybit is disabled for this user")
            return None
        
        # Check if user has Bybit credentials
        trading_mode = db.get_trading_mode(user_id)
        bybit_types = db._get_bybit_account_types(user_id)
        if not bybit_types:
            logger.debug(f"[{user_id}] No Bybit credentials configured")
            return None
        
        # Check if user wants to trade on both exchanges
        # Option 1: routing_policy = ALL_ENABLED
        # Option 2: trading_mode = "both" (means user wants both demo+real, implies multi-exchange intent)
        routing_policy = db.get_routing_policy(user_id)
        wants_both_exchanges = (
            routing_policy == db.RoutingPolicy.ALL_ENABLED or
            trading_mode == "both"  # User explicitly chose to trade on demo+real
        )
        
        if not wants_both_exchanges:
            logger.debug(f"[{user_id}] User doesn't want both exchanges - routing={routing_policy}, mode={trading_mode}")
            return None
        
        # Get strategy settings for Bybit
        cfg = get_user_config(user_id) or {}
        
        results = {}
        for acc_type in bybit_types:
            try:
                # Get per-account settings
                params = get_strategy_trade_params(
                    user_id, cfg, symbol, strategy or "manual",
                    side=side, exchange="bybit", account_type=acc_type
                )
                
                risk_pct = params.get("percent", 1.0)
                sl_pct = params.get("sl_pct", sl_percent or 3.0)
                
                # Calculate qty for this account
                if entry_price:
                    target_qty = await calc_qty(user_id, symbol, entry_price, risk_pct, sl_pct, account_type=acc_type, exchange="bybit")
                else:
                    target_qty = qty
                
                # Set leverage
                target_leverage = leverage or params.get("leverage", 10)
                try:
                    await set_leverage(user_id, symbol, leverage=target_leverage, account_type=acc_type)
                except Exception as lev_err:
                    logger.warning(f"[{user_id}] Failed to set Bybit leverage: {lev_err}")
                
                # Place order
                res = await place_order(user_id, symbol, side, "Market", target_qty, account_type=acc_type)
                results[acc_type] = {"success": True, "result": res, "qty": target_qty}
                logger.info(f"‚úÖ [{user_id}] Bybit {acc_type} order placed: {symbol} {side} qty={target_qty}")
                
            except Exception as acc_err:
                logger.error(f"[{user_id}] Bybit {acc_type} order failed: {acc_err}")
                results[acc_type] = {"success": False, "error": str(acc_err)}
        
        return {"success": True, "exchange": "bybit", "results": results}
        
    except Exception as e:
        logger.error(f"[{user_id}] Bybit order failed for {symbol}: {e}")
        return {"success": False, "error": str(e), "exchange": "bybit"}


async def place_order_hyperliquid(
    user_id: int,
    symbol: str,
    side: str,
    qty: float,
    strategy: str,
    leverage: int = None,
    sl_percent: float = None,
    tp_percent: float = None,
) -> dict | None:
    """
    Place order on HyperLiquid if:
    1. User has HL credentials configured
    2. HL is enabled for this strategy
    3. The coin is available on HL
    4. User's active exchange is NOT already HyperLiquid (to avoid duplicate)
    
    Returns result dict or None if not executed.
    
    NOTE: This function is called AFTER place_order_all_accounts() which handles
    the user's active exchange. If active exchange is already 'hyperliquid',
    the order was already placed there, so we skip to avoid duplicates.
    """
    try:
        # CRITICAL: Check if user's active exchange is already HyperLiquid
        # In that case, place_order_all_accounts already handled HL order
        active_exchange = db.get_exchange_type(user_id)
        if active_exchange == "hyperliquid":
            logger.debug(f"[{user_id}] Skipping duplicate HL order - already placed via active exchange")
            return None
        
        # Check if HL is enabled for this strategy
        hl_settings = db.get_hl_effective_settings(user_id, strategy)
        if not hl_settings.get("enabled"):
            return None
        
        # Check if user has HL credentials
        hl_creds = get_hl_credentials(user_id)
        # Determine network from trading_mode, NOT from legacy hl_testnet flag
        trading_mode = get_trading_mode(user_id)
        testnet = trading_mode in ("demo", "testnet")
        
        # Get correct private key for network (multitenancy)
        from core.account_utils import get_hl_credentials_for_account
        _acc = "testnet" if testnet else "mainnet"
        hl_private_key, testnet, _ = get_hl_credentials_for_account(hl_creds, _acc)
        
        if not hl_private_key:
            logger.debug(f"[{user_id}] No HL private key configured for {'testnet' if testnet else 'mainnet'}")
            return None
        
        # Check if coin is available on HL
        available_coins = await get_hl_available_coins()
        if symbol not in available_coins:
            logger.debug(f"[{user_id}] {symbol} not available on HyperLiquid")
            return None
        
        # Get HL-specific settings
        hl_percent = hl_settings.get("percent", 1.0)
        hl_sl = hl_settings.get("sl_percent", sl_percent or 2.0)
        hl_tp = hl_settings.get("tp_percent", tp_percent or 3.0)
        hl_leverage = hl_settings.get("leverage", leverage or 10)
        
        # Create adapter - main wallet will be auto-discovered if this is an agent wallet
        # No need to pass vault_address or main_wallet_address anymore!
        adapter = HLAdapter(
            private_key=hl_private_key,
            testnet=testnet,
            # vault_address and main_wallet_address will be auto-discovered from userRole API
        )
        
        async with adapter:
            # Get current price
            coin = hl_symbol_to_coin(symbol)
            price = await adapter._client.get_mid_price(coin)
            if not price:
                logger.warning(f"[{user_id}] Could not get price for {coin} on HL")
                return None
            
            # Calculate qty based on HL percent
            # Use get_balance() which supports Unified Account
            balance_result = await adapter.get_balance(use_cache=True)
            if not balance_result.get("success"):
                logger.warning(f"[{user_id}] HL balance error: {balance_result.get('error')}")
                return None
            
            balance_data = balance_result.get("data", {})
            account_value = balance_data.get("equity", 0)
            is_unified = balance_data.get("is_unified_account", False)
            
            if account_value <= 0:
                logger.warning(f"[{user_id}] HL account value is 0 (unified={is_unified})")
                return None
            
            # Calculate position size
            position_value = account_value * (hl_percent / 100)
            hl_qty = position_value / price
            
            # Round qty to appropriate decimals
            hl_qty = round(hl_qty, 4)
            if hl_qty <= 0:
                return None
            
            logger.info(f"[{user_id}] HL qty calc: equity={account_value:.2f}, unified={is_unified}, percent={hl_percent}%, qty={hl_qty:.4f}")
            
            # Set leverage first (required before placing order)
            is_buy = side.lower() in ("buy", "long")
            try:
                await adapter._client.update_leverage(coin=coin, leverage=hl_leverage, is_cross=True)
            except Exception as lev_err:
                logger.warning(f"[{user_id}] Could not set HL leverage: {lev_err}")
            
            # Place market order
            result = await adapter._client.market_open(
                coin=coin,
                is_buy=is_buy,
                sz=hl_qty,
                slippage=0.01  # 1% slippage
            )
            
            # Set TP/SL if provided
            if result.get("status") == "ok" and (hl_tp or hl_sl):
                try:
                    tp_price = None
                    sl_price = None
                    if hl_tp and hl_tp > 0:
                        tp_price = price * (1 + hl_tp / 100) if is_buy else price * (1 - hl_tp / 100)
                    if hl_sl and hl_sl > 0:
                        sl_price = price * (1 - hl_sl / 100) if is_buy else price * (1 + hl_sl / 100)
                    # Use main_wallet_address for Unified Account support
                    await adapter._client.set_tp_sl(coin=coin, tp_price=tp_price, sl_price=sl_price, address=adapter.main_wallet_address)
                except Exception as tpsl_err:
                    logger.warning(f"[{user_id}] Could not set HL TP/SL: {tpsl_err}")
            
            logger.info(f"‚úÖ [{user_id}] HL order placed: {symbol} {side} qty={hl_qty} lev={hl_leverage}x")
            return {
                "success": True,
                "exchange": "hyperliquid",
                "testnet": testnet,
                "symbol": symbol,
                "side": side,
                "qty": hl_qty,
                "leverage": hl_leverage,
                "result": result
            }
            
    except Exception as e:
        logger.error(f"[{user_id}] HL order failed for {symbol}: {e}")
        return {"success": False, "error": str(e), "exchange": "hyperliquid"}


@require_access
@with_texts
@log_calls
async def cmd_toggle_oi(update, ctx):
    uid = update.effective_user.id
    cfg = get_user_config(uid) or {}
    new = not bool(cfg.get("trade_oi", 0))
    set_user_field(uid, "trade_oi", int(new))
    await update.message.reply_text(
        ctx.t['toggle_oi_status'].format(
            feature=ctx.t['feature_oi'],
            status=ctx.t['status_enabled'] if new else ctx.t['status_disabled']
        ),
        reply_markup=main_menu_keyboard(ctx, update=update)
    )

@require_access
@with_texts
@log_calls
async def cmd_toggle_scryptomera(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    cfg = get_user_config(uid)
    new = 0 if cfg.get("trade_scryptomera", 0) else 1
    set_user_field(uid, "trade_scryptomera", new)

    emoji = ctx.t["emoji_long"] if new else ctx.t["emoji_short"]
    status = ctx.t['status_enabled'] if new else ctx.t['status_disabled']
    feature_name = ctx.t.get('feature_scryptomera', 'Scryptomera')

    await update.message.reply_text(
        f"{emoji} {feature_name}: {status}",
        reply_markup=main_menu_keyboard(ctx, update=update)
    )

@require_access
@with_texts
@log_calls
async def cmd_toggle_scalper(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    cfg = get_user_config(uid)
    new = 0 if cfg.get("trade_scalper", 0) else 1
    set_user_field(uid, "trade_scalper", new)

    emoji = ctx.t["emoji_long"] if new else ctx.t["emoji_short"]
    status = ctx.t['status_enabled'] if new else ctx.t['status_disabled']
    feature_name = ctx.t.get('feature_scalper', 'Scalper')

    await update.message.reply_text(
        f"{emoji} {feature_name}: {status}",
        reply_markup=main_menu_keyboard(ctx, update=update)
    )


@require_access
@with_texts
@log_calls
async def cmd_toggle_elcaro(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    cfg = get_user_config(uid)
    new = 0 if cfg.get("trade_elcaro", 0) else 1
    set_user_field(uid, "trade_elcaro", new)

    emoji = ctx.t["emoji_long"] if new else ctx.t["emoji_short"]
    status = ctx.t['status_enabled'] if new else ctx.t['status_disabled']
    feature_name = ctx.t.get('feature_elcaro', 'Enliko')

    await update.message.reply_text(
        f"{emoji} {feature_name}: {status}",
        reply_markup=main_menu_keyboard(ctx, update=update)
    )


@require_access
@with_texts
@log_calls
async def cmd_toggle_fibonacci(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    cfg = get_user_config(uid)
    new = 0 if cfg.get("trade_fibonacci", 0) else 1
    set_user_field(uid, "trade_fibonacci", new)

    emoji = ctx.t["emoji_long"] if new else ctx.t["emoji_short"]
    status = ctx.t['status_enabled'] if new else ctx.t['status_disabled']
    feature_name = ctx.t.get('feature_fibonacci', 'Fibonacci')

    await update.message.reply_text(
        f"{emoji} {feature_name}: {status}",
        reply_markup=main_menu_keyboard(ctx, update=update)
    )


# ------------------------------------------------------------------------------------
# Strategy Settings with Inline Keyboard
# ------------------------------------------------------------------------------------

def _build_strategy_status_parts(strat_key: str, strat_settings: dict, active_exchange: str = "bybit", global_use_atr: bool = True, global_cfg: dict = None) -> list:
    """
    Build status parts list for a strategy based on its settings.
    Used consistently across all menus to show strategy customizations.
    
    Args:
        strat_key: Strategy name
        strat_settings: Strategy-specific settings dict
        active_exchange: Current exchange (bybit/hyperliquid)
        global_use_atr: User's global ATR setting (fallback when strategy doesn't override)
        global_cfg: User's global config dict (for fallback display values)
    """
    status_parts = []
    global_cfg = global_cfg or {}
    
    # For display, try side-specific first, then non-prefixed, then global fallback
    l_pct = strat_settings.get("long_percent")
    l_sl = strat_settings.get("long_sl_percent")
    l_tp = strat_settings.get("long_tp_percent")
    s_pct = strat_settings.get("short_percent")
    s_sl = strat_settings.get("short_sl_percent")
    s_tp = strat_settings.get("short_tp_percent")
    
    # Effective values: strategy-specific or global fallback
    pct = strat_settings.get("percent") or l_pct or global_cfg.get("percent")
    sl = strat_settings.get("sl_percent") or l_sl or global_cfg.get("sl_percent")
    tp = strat_settings.get("tp_percent") or l_tp or global_cfg.get("tp_percent")
    
    atr_per = strat_settings.get("atr_periods")
    atr_mult = strat_settings.get("atr_multiplier_sl")
    atr_trig = strat_settings.get("atr_trigger_pct")
    use_atr_strat = strat_settings.get("use_atr")  # None = global, 0 = Fixed, 1 = ATR
    mode = strat_settings.get("trading_mode", "global")
    if mode == "all":
        mode = "global"  # Normalize legacy value
    
    # Determine effective use_atr: strategy-specific overrides global
    use_atr = use_atr_strat if use_atr_strat is not None else (1 if global_use_atr else 0)
    
    # Exchange-aware mode text
    if active_exchange == "hyperliquid":
        mode_text = {"testnet": "Testnet", "mainnet": "Mainnet", "both": "Both", "global": "Global", "demo": "Testnet", "real": "Mainnet"}.get(mode, "Global")
    else:
        mode_text = {"demo": "Demo", "real": "Real", "both": "Both", "global": "Global", "testnet": "Demo", "mainnet": "Real"}.get(mode, "Global")
    
    # For scryptomera and scalper, show side-specific or direction info
    if strat_key in ("scryptomera", "scalper"):
        direction = strat_settings.get("direction", "all")
        dir_emoji = {"all": "üîÑ", "long": "üìà", "short": "üìâ"}.get(direction, "üîÑ")
        status_parts.append(f"{dir_emoji}")
        
        # Check for side-specific settings (use global fallback for display)
        eff_l_pct = l_pct or global_cfg.get("percent")
        eff_l_sl = l_sl or global_cfg.get("sl_percent")
        eff_s_pct = s_pct or global_cfg.get("percent")
        eff_s_sl = s_sl or global_cfg.get("sl_percent")
        
        has_side_specific = (l_pct is not None or l_sl is not None or 
                            s_pct is not None or s_sl is not None)
        
        if has_side_specific:
            # Show side-specific settings
            if l_pct is not None or l_sl is not None:
                status_parts.append(f"L:{l_pct or '-'}%/{l_sl or '-'}%")
            if s_pct is not None or s_sl is not None:
                status_parts.append(f"S:{s_pct or '-'}%/{s_sl or '-'}%")
        else:
            # Show effective settings (global fallback)
            if eff_l_pct is not None:
                status_parts.append(f"Entry: {eff_l_pct}%")
            if eff_l_sl is not None:
                status_parts.append(f"SL: {eff_l_sl}%")
            eff_tp = tp or global_cfg.get("tp_percent")
            if eff_tp is not None:
                status_parts.append(f"TP: {eff_tp}%")
    else:
        # General settings for other strategies
        if pct is not None:
            status_parts.append(f"Entry: {pct}%")
        if sl is not None:
            status_parts.append(f"SL: {sl}%")
        if tp is not None:
            status_parts.append(f"TP: {tp}%")
    
    # ATR status - ALWAYS show (with effective value: strategy or global fallback)
    atr_emoji = "‚ö°" if use_atr else "üìâ"
    status_parts.append(f"{atr_emoji}ATR:{'ON' if use_atr else 'OFF'}")
    
    if atr_per is not None:
        status_parts.append(f"ATR: {atr_per}p")
    if atr_mult is not None:
        status_parts.append(f"Mult: {atr_mult}")
    if atr_trig is not None:
        status_parts.append(f"Trig: {atr_trig}%")
    
    # Break-Even status
    be_enabled = strat_settings.get("be_enabled")
    be_trigger = strat_settings.get("be_trigger_pct")
    if be_enabled is not None and be_enabled:
        be_text = f"BE:{be_trigger}%" if be_trigger else "BE:ON"
        status_parts.append(f"üîí{be_text}")
    
    if mode != "global":
        status_parts.append(f"Mode: {mode_text}")
    
    return status_parts


STRATEGY_NAMES_MAP = {
    "oi": "OI",
    "rsi_bb": "RSI+BB",
    "scryptomera": "Scryptomera",
    "scalper": "Scalper",
    "elcaro": "Enliko",
    "fibonacci": "Fibonacci",
    "webapp": "WebApp",
    "manual": "Manual",
}


def build_strategy_settings_text(strategy: str, strat_settings: dict, t: dict) -> str:
    """Build strategy settings display text based on STRATEGY_FEATURES.
    
    Returns formatted markdown text showing only relevant settings for the strategy.
    """
    features = STRATEGY_FEATURES.get(strategy, {})
    display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
    global_lbl = t.get('global_default', 'Global')
    
    lines = [t.get('strategy_param_header', '‚öôÔ∏è *{name} Settings*').format(name=display_name)]
    lines.append("")
    
    # Order type
    if features.get("order_type"):
        order_type = strat_settings.get("order_type", "market")
        order_emoji = "üéØ" if order_type == "limit" else "‚ö°"
        order_label = "Limit" if order_type == "limit" else "Market"
        lines.append(f"*Order Type*: {order_emoji} {order_label}")
    
    # Direction
    if features.get("direction"):
        direction = strat_settings.get("direction", "all")
        dir_emoji = {"all": "üîÑ", "long": "üìà", "short": "üìâ"}.get(direction, "üîÑ")
        dir_label = {"all": "ALL", "long": "LONG only", "short": "SHORT only"}.get(direction, "ALL")
        lines.append(f"*Direction*: {dir_emoji} {dir_label}")
    
    # Position size (for strategies that show it on main screen)
    if features.get("percent"):
        pct = strat_settings.get("percent")
        lines.append(f"üìä Position Size: {pct if pct is not None else global_lbl}%")
    
    # Leverage
    if features.get("leverage"):
        leverage = strat_settings.get("leverage")
        lines.append(f"‚ö° Leverage: {leverage if leverage else 'Auto'}x")
    
    # ATR toggle
    if features.get("use_atr"):
        use_atr = strat_settings.get("use_atr") or 0
        atr_status = "‚úÖ Enabled" if use_atr else "‚ùå Disabled"
        lines.append(f"üìä ATR Trailing: {atr_status}")
    
    # SL/TP on main screen (for simple strategies)
    if features.get("sl_tp"):
        sl = strat_settings.get("sl_percent")
        tp = strat_settings.get("tp_percent")
        lines.append(f"üîª SL: {sl if sl is not None else global_lbl}%")
        lines.append(f"üî∫ TP: {tp if tp is not None else global_lbl}%")
    
    # Coins group
    if features.get("coins_group"):
        coins_group = strat_settings.get("coins_group")
        coins_label = coins_group if coins_group else "All"
        lines.append(f"ü™ô Coins Filter: {coins_label}")
    
    # Min quality (Fibonacci)
    if features.get("min_quality"):
        min_quality = strat_settings.get("min_quality", 50)
        lines.append(f"‚≠ê Min Quality: {min_quality}%")
    
    # Side-specific summary (THIS IS THE PRIMARY SETTINGS NOW)
    if features.get("side_settings"):
        lines.append("")
        lines.append("*‚îÅ‚îÅ‚îÅ LONG / SHORT Settings ‚îÅ‚îÅ‚îÅ*")
        l_pct = strat_settings.get("long_percent")
        l_sl = strat_settings.get("long_sl_percent")
        l_tp = strat_settings.get("long_tp_percent")
        s_pct = strat_settings.get("short_percent")
        s_sl = strat_settings.get("short_sl_percent")
        s_tp = strat_settings.get("short_tp_percent")
        
        not_set = t.get('not_set', '‚Äî')
        
        if strategy in ("elcaro", "fibonacci"):
            # Only show percent for these strategies (SL/TP from signal)
            lines.append(f"üìà *LONG*: Entry = {l_pct or not_set}%")
            lines.append(f"üìâ *SHORT*: Entry = {s_pct or not_set}%")
        else:
            # Full settings: Entry/SL/TP
            lines.append(f"üìà *LONG*:")
            lines.append(f"   Entry: {l_pct or not_set}% | SL: {l_sl or not_set}% | TP: {l_tp or not_set}%")
            lines.append(f"üìâ *SHORT*:")
            lines.append(f"   Entry: {s_pct or not_set}% | SL: {s_sl or not_set}% | TP: {s_tp or not_set}%")
    
    return "\n".join(lines)


# Define which features each strategy supports for cleaner UI
# This controls which settings are shown in the strategy settings menu
# General settings (percent, sl_tp) serve as FALLBACK for side-specific settings
STRATEGY_FEATURES = {
    "scryptomera": {
        "order_type": False,     # Order type is per-side now (in LONG/SHORT settings)
        "coins_group": False,    # MOVED to API Settings per-exchange (Feb 10, 2026)
        "leverage": True,        # Leverage setting
        "use_atr": True,         # ATR trailing toggle
        "direction": True,       # LONG/SHORT/ALL filter
        "side_settings": True,   # Separate LONG/SHORT settings (overrides general)
        "percent": True,         # General percent (fallback for side-specific)
        "sl_tp": True,           # General SL/TP (fallback for side-specific)
        "atr_params": True,      # ATR params on main screen  
        "min_quality": False,    # Scryptomera doesn't have quality filter
    },
    "scalper": {
        "order_type": False,     # Order type is per-side now
        "coins_group": False,    # MOVED to API Settings per-exchange (Feb 10, 2026)
        "leverage": True,
        "use_atr": True,
        "direction": True,
        "side_settings": True,
        "percent": True,         # General percent (fallback)
        "sl_tp": True,           # General SL/TP (fallback)
        "atr_params": True,
        "min_quality": False,
    },
    "elcaro": {
        "order_type": False,     # Order type is per-side now (in LONG/SHORT settings)
        "coins_group": False,    # MOVED to API Settings per-exchange (Feb 10, 2026)
        "leverage": True,        # User-configured leverage
        "use_atr": True,         # ATR trailing toggle
        "direction": True,
        "side_settings": True,   # LONG/SHORT separate settings
        "percent": True,         # General percent (fallback)
        "sl_tp": True,           # User-configured SL/TP (NOT from signal anymore!)
        "atr_params": True,      # ATR params from user settings
        "min_quality": False,
    },
    "fibonacci": {
        "order_type": False,     # Order type is per-side now
        "coins_group": False,    # MOVED to API Settings per-exchange (Feb 10, 2026)
        "leverage": True,
        "use_atr": True,         # ATR trailing option
        "direction": True,
        "side_settings": True,
        "percent": True,         # General percent (fallback)
        "sl_tp": True,           # General SL/TP (fallback)
        "atr_params": True,      # ATR params
        "min_quality": True,     # Fibonacci-specific quality filter
    },
    "oi": {
        "order_type": False,     # Order type is per-side now
        "coins_group": False,    # MOVED to API Settings per-exchange (Feb 10, 2026)
        "leverage": True,
        "use_atr": True,
        "direction": True,
        "side_settings": True,   # LONG/SHORT separate settings
        "percent": True,         # General percent (fallback)
        "sl_tp": True,           # General SL/TP (fallback)
        "atr_params": True,      # Full ATR control
        "min_quality": False,
    },
    "rsi_bb": {
        "order_type": False,     # Order type is per-side now (in LONG/SHORT settings)
        "coins_group": False,    # MOVED to API Settings per-exchange (Feb 10, 2026)
        "leverage": True,
        "use_atr": True,
        "direction": True,
        "side_settings": True,   # LONG/SHORT separate settings
        "percent": True,         # General percent (fallback)
        "sl_tp": True,           # General SL/TP (fallback)
        "atr_params": True,
        "min_quality": False,
    },
    "manual": {
        "order_type": False,     # Order type is per-side now
        "coins_group": False,    # Not needed for manual trades
        "leverage": True,
        "use_atr": True,
        "direction": True,
        "side_settings": True,   # LONG/SHORT separate settings
        "percent": True,
        "sl_tp": True,
        "atr_params": True,
        "min_quality": False,
    },
}

def get_strategy_settings_keyboard(t: dict, cfg: dict = None, uid: int = None) -> InlineKeyboardMarkup:
    """Build inline keyboard for strategy selection.
    
    Each strategy row has 3 buttons:
    1. ON/OFF toggle
    2. Trading mode cycle (Demo ‚Üí Real ‚Üí Both) - shows Testnet/Mainnet for HyperLiquid
    3. Settings button
    
    Trading mode is per-strategy, allowing different strategies to trade on different accounts.
    """
    cfg = cfg or {}
    
    # Check current exchange for proper labels (Testnet/Mainnet for HL)
    is_hyperliquid = False
    if uid:
        active_exchange = db.get_exchange_type(uid) or "bybit"
        is_hyperliquid = active_exchange == "hyperliquid"
    
    # Helper to get status emoji
    def status(key):
        return "‚úÖ" if cfg.get(key, 0) else "‚ùå"
    
    # Get strategy trading mode and format as button
    def get_mode_btn(strategy_name):
        if uid:
            mode = db.get_strategy_trading_mode(uid, strategy_name) or "demo"
        else:
            mode = "demo"
        
        # Use Testnet/Mainnet labels for HyperLiquid, Demo/Real for Bybit
        if is_hyperliquid:
            mode_labels = {
                "demo": "üß™ Testnet",
                "real": "üåê Mainnet", 
                "both": "üîÄ Both"
            }
        else:
            mode_labels = {
                "demo": "üéÆ Demo",
                "real": "üíµ Real", 
                "both": "üîÄ Both"
            }
        return InlineKeyboardButton(
            mode_labels.get(mode, mode_labels["demo"]),
            callback_data=f"strat_mode_cycle:{strategy_name}"
        )
    
    # Strategy definitions: (key, trade_flag, emoji, name)
    strategies = [
        ("oi", "trade_oi", "üìä", "OI"),
        ("rsi_bb", "trade_rsi_bb", "üìâ", "RSI+BB"),
        ("scryptomera", "trade_scryptomera", "üîÆ", "Scryptomera"),
        ("scalper", "trade_scalper", "üéØ", "Scalper"),
        ("elcaro", "trade_elcaro", "üî•", "Enliko"),
        ("fibonacci", "trade_fibonacci", "üìê", "Fibonacci"),
        ("manual", "trade_manual", "‚úã", "Manual"),  # Manual trading strategy
    ]
    
    buttons = []
    
    # Header
    buttons.append([InlineKeyboardButton(
        t.get('strategies_header', '‚ïê‚ïê üìà STRATEGIES ‚ïê‚ïê'),
        callback_data="noop"
    )])
    
    # Each strategy: [ON/OFF | Mode | ‚öôÔ∏è Settings]
    for strat_key, trade_flag, emoji, name in strategies:
        buttons.append([
            InlineKeyboardButton(
                f"{status(trade_flag)} {emoji} {name}",
                callback_data=f"strat_toggle:{strat_key}"
            ),
            get_mode_btn(strat_key),
            InlineKeyboardButton("‚öôÔ∏è", callback_data=f"strat_set:{strat_key}"),
        ])
    
    # Separator
    buttons.append([InlineKeyboardButton("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ", callback_data="noop")])
    
    # Spot trading
    spot_enabled = cfg.get("spot_enabled", 0)
    spot_status = "‚úÖ" if spot_enabled else "‚ùå"
    buttons.append([
        InlineKeyboardButton(f"{spot_status} üíπ Spot", callback_data="strat_toggle:spot"),
        InlineKeyboardButton("‚öôÔ∏è", callback_data="strat_set:spot"),
    ])
    
    # NOTE: Global Settings removed - use per-strategy Long/Short settings instead
    # Each strategy has its own Entry%, SL%, TP%, ATR settings
    
    # Close
    buttons.append([InlineKeyboardButton(t.get('btn_close', '‚ùå Close'), callback_data="strat_set:close")])
    
    return InlineKeyboardMarkup(buttons)


def get_strategy_param_keyboard(strategy: str, t: dict, strat_settings: dict = None) -> InlineKeyboardMarkup:
    """Build inline keyboard for strategy settings.
    
    SIMPLIFIED ARCHITECTURE:
    - Each strategy has LONG and SHORT settings independently
    - Direction is determined by which sides are enabled
    - No complex fallback logic - values come from DB or STRATEGY_DEFAULTS
    
    Shows:
    1. Current direction (based on enabled long/short)
    2. LONG button with settings summary
    3. SHORT button with settings summary
    4. Order type (if strategy supports it)
    5. Coins filter (if strategy supports it)
    6. Reset to Defaults
    7. Back
    """
    from coin_params import STRATEGY_DEFAULTS
    
    display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
    strat_settings = strat_settings or {}
    features = STRATEGY_FEATURES.get(strategy, {})
    
    buttons = []
    
    # Get enabled status for each side
    long_enabled = strat_settings.get("long_enabled", True)
    short_enabled = strat_settings.get("short_enabled", True)
    
    # Determine current direction based on enabled sides
    if long_enabled and short_enabled:
        direction = "all"
        dir_emoji = "üîÑ"
        dir_label = "ALL"
    elif long_enabled:
        direction = "long"
        dir_emoji = "üìà"
        dir_label = "LONG only"
    elif short_enabled:
        direction = "short"
        dir_emoji = "üìâ"
        dir_label = "SHORT only"
    else:
        direction = "none"
        dir_emoji = "‚õî"
        dir_label = "DISABLED"
    
    # ‚îÄ‚îÄ‚îÄ DIRECTION TOGGLE ‚îÄ‚îÄ‚îÄ
    buttons.append([InlineKeyboardButton(
        f"üéØ {t.get('direction', 'Direction')}: {dir_emoji} {dir_label}",
        callback_data=f"strat_dir_toggle:{strategy}"
    )])
    
    # ‚îÄ‚îÄ‚îÄ LONG SETTINGS ‚îÄ‚îÄ‚îÄ
    long_defaults = STRATEGY_DEFAULTS.get("long", {})
    l_pct = strat_settings.get("long_percent") or long_defaults.get("percent", 1)
    l_sl = strat_settings.get("long_sl_percent") or long_defaults.get("sl_percent", 3)
    l_tp = strat_settings.get("long_tp_percent") or long_defaults.get("tp_percent", 8)
    l_lev = strat_settings.get("long_leverage") or long_defaults.get("leverage", 10)
    l_atr = strat_settings.get("long_use_atr")
    if l_atr is None:
        l_atr = long_defaults.get("use_atr", True)
    
    long_status = "‚úÖ" if long_enabled else "‚ùå"
    if strategy == "elcaro":
        # Enliko only has entry % (SL/TP from signal)
        long_info = f"{l_pct}%"
    else:
        atr_icon = "üìä" if l_atr else "üéØ"
        long_info = f"E:{l_pct}% SL:{l_sl}% TP:{l_tp}% L:{l_lev}x {atr_icon}"
    
    buttons.append([InlineKeyboardButton(
        f"{long_status} üìà LONG [{long_info}]", 
        callback_data=f"strat_side:{strategy}:long"
    )])
    
    # ‚îÄ‚îÄ‚îÄ SHORT SETTINGS ‚îÄ‚îÄ‚îÄ
    short_defaults = STRATEGY_DEFAULTS.get("short", {})
    s_pct = strat_settings.get("short_percent") or short_defaults.get("percent", 1)
    s_sl = strat_settings.get("short_sl_percent") or short_defaults.get("sl_percent", 3)
    s_tp = strat_settings.get("short_tp_percent") or short_defaults.get("tp_percent", 8)
    s_lev = strat_settings.get("short_leverage") or short_defaults.get("leverage", 10)
    s_atr = strat_settings.get("short_use_atr")
    if s_atr is None:
        s_atr = short_defaults.get("use_atr", True)
    
    short_status = "‚úÖ" if short_enabled else "‚ùå"
    if strategy == "elcaro":
        short_info = f"{s_pct}%"
    else:
        atr_icon = "üìä" if s_atr else "üéØ"
        short_info = f"E:{s_pct}% SL:{s_sl}% TP:{s_tp}% L:{s_lev}x {atr_icon}"
    
    buttons.append([InlineKeyboardButton(
        f"{short_status} üìâ SHORT [{short_info}]", 
        callback_data=f"strat_side:{strategy}:short"
    )])
    
    # ‚îÄ‚îÄ‚îÄ COINS FILTER (if supported) ‚îÄ‚îÄ‚îÄ
    if features.get("coins_group"):
        coins_group = strat_settings.get("coins_group", "ALL")
        coins_emoji = {"ALL": "üåê", "TOP": "üíé", "TOP100": "üíé", "VOLATILE": "üî•"}.get(coins_group, "üåê")
        buttons.append([InlineKeyboardButton(
            f"ü™ô {t.get('coins_filter', 'Coins')}: {coins_emoji} {coins_group}",
            callback_data=f"strat_coins:{strategy}"
        )])
    
    # ‚îÄ‚îÄ‚îÄ MIN QUALITY (Fibonacci only) ‚îÄ‚îÄ‚îÄ
    if features.get("min_quality"):
        min_quality = strat_settings.get("min_quality", 50)
        buttons.append([InlineKeyboardButton(
            f"‚≠ê {t.get('min_quality', 'Min Quality')}: {min_quality}%",
            callback_data=f"strat_param:{strategy}:min_quality"
        )])
    
    # ‚îÄ‚îÄ‚îÄ RESET & BACK ‚îÄ‚îÄ‚îÄ
    buttons.append([InlineKeyboardButton(
        f"üîÑ {t.get('reset_to_defaults', 'Reset to Defaults')}",
        callback_data=f"strat_reset:{strategy}"
    )])
    buttons.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="strat_set:back")])
    
    return InlineKeyboardMarkup(buttons)


def _build_side_settings_header(strategy: str, side: str, strat_settings: dict) -> list:
    """Build header lines for side settings menu showing current values."""
    from coin_params import STRATEGY_DEFAULTS
    
    emoji = "üìà" if side == "long" else "üìâ"
    display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
    defaults = STRATEGY_DEFAULTS.get(side, {})
    
    def _get_val(key, default):
        val = strat_settings.get(f"{side}_{key}")
        return val if val is not None else defaults.get(key, default)
    
    entry_pct = _get_val("percent", 3.0)
    sl_pct = _get_val("sl_percent", 30.0)
    tp_pct = _get_val("tp_percent", 10.0)
    use_atr = bool(strat_settings.get(f"{side}_use_atr") or defaults.get("use_atr", False))
    
    atr_indicator = "üìä ATR" if use_atr else "üéØ TP"
    
    return [
        f"{emoji} *{display_name} - {side.upper()} Settings*",
        "",
        f"üìä Entry: *{entry_pct}%* ‚îÇ üîª SL: *{sl_pct}%* ‚îÇ üéØ TP: *{tp_pct}%*",
        f"Mode: *{atr_indicator}*",
    ]


def get_strategy_side_keyboard(strategy: str, side: str, t: dict, settings: dict = None, global_cfg: dict = None) -> InlineKeyboardMarkup:
    """Build inline keyboard for strategy LONG or SHORT settings.
    
    Simplified and grouped menu (Feb 8, 2026):
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    üìä RISK MANAGEMENT
    - Entry % (—Ä–∞–∑–º–µ—Ä –ø–æ–∑–∏—Ü–∏–∏)
    - Stop-Loss %
    - Take-Profit %
    
    üìà ATR TRAILING (–¥–∏–Ω–∞–º—ñ—á–Ω–∏–π SL)
    - ATR Toggle + Trigger % + Step %
    
    üîí BREAK-EVEN (SL –≤ –±–µ–∑–∑–±–∏—Ç–æ–∫)
    - BE Toggle + Trigger %
    
    üìâ DCA (—É—Å–µ—Ä–µ–¥–Ω–µ–Ω–Ω—è)
    - DCA Toggle + Leg 1 + Leg 2
    
    ‚úÇÔ∏è PARTIAL TP (—á–∞—Å—Ç–∫–æ–≤–∏–π —Ç–µ–π–∫)
    - PTP Toggle + Step 1 + Step 2
    
    üìä LIMITS
    - Max Positions
    
    ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    REMOVED (moved to API Settings):
    - Enabled toggle (always enabled by default)
    - Leverage (per-exchange in API settings)
    - Order Type (per-exchange in API settings)
    """
    from coin_params import STRATEGY_DEFAULTS
    
    emoji = "üìà" if side == "long" else "üìâ"
    settings = settings or {}
    global_cfg = global_cfg or {}
    defaults = STRATEGY_DEFAULTS.get(side, STRATEGY_DEFAULTS["long"])
    
    def _get_val(key, default_val):
        """Get value with fallback: settings -> global_cfg -> defaults"""
        val = settings.get(f"{side}_{key}")
        if val is not None:
            return val
        if key in global_cfg and global_cfg.get(key) is not None:
            return global_cfg.get(key)
        return defaults.get(key, default_val)
    
    buttons = []
    
    # Get current values
    entry = _get_val("percent", 3.0)
    sl = _get_val("sl_percent", 30.0)
    tp = _get_val("tp_percent", 10.0)
    
    # ATR settings
    use_atr = settings.get(f"{side}_use_atr")
    if use_atr is None:
        use_atr = bool(global_cfg.get("use_atr")) if global_cfg.get("use_atr") is not None else defaults.get("use_atr", 0)
    use_atr = bool(use_atr)
    atr_trigger = _get_val("atr_trigger_pct", 3.0)
    atr_step = _get_val("atr_step_pct", 0.5)
    
    # BE settings
    be_enabled = settings.get(f"{side}_be_enabled")
    if be_enabled is None:
        be_enabled = defaults.get("be_enabled", 0)
    be_enabled = bool(be_enabled)
    be_trigger = settings.get(f"{side}_be_trigger_pct") or defaults.get("be_trigger_pct", 1.0)
    
    # DCA settings
    dca_enabled = settings.get(f"{side}_dca_enabled")
    if dca_enabled is None:
        dca_enabled = bool(global_cfg.get("dca_enabled")) if global_cfg.get("dca_enabled") is not None else defaults.get("dca_enabled", 0)
    dca_enabled = bool(dca_enabled)
    dca_pct_1 = settings.get(f"{side}_dca_pct_1") or global_cfg.get("dca_pct_1") or defaults.get("dca_pct_1", 10.0)
    dca_pct_2 = settings.get(f"{side}_dca_pct_2") or global_cfg.get("dca_pct_2") or defaults.get("dca_pct_2", 25.0)
    
    # Partial TP settings
    ptp_enabled = settings.get(f"{side}_partial_tp_enabled")
    if ptp_enabled is None:
        ptp_enabled = defaults.get("partial_tp_enabled", 0)
    ptp_enabled = bool(ptp_enabled)
    ptp_1_trigger = settings.get(f"{side}_partial_tp_1_trigger_pct") or defaults.get("partial_tp_1_trigger_pct", 2.0)
    ptp_1_close = settings.get(f"{side}_partial_tp_1_close_pct") or defaults.get("partial_tp_1_close_pct", 30.0)
    ptp_2_trigger = settings.get(f"{side}_partial_tp_2_trigger_pct") or defaults.get("partial_tp_2_trigger_pct", 5.0)
    ptp_2_close = settings.get(f"{side}_partial_tp_2_close_pct") or defaults.get("partial_tp_2_close_pct", 30.0)
    
    # Max positions
    max_positions = settings.get(f"{side}_max_positions") or defaults.get("max_positions", 0)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # üìä RISK MANAGEMENT GROUP
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    buttons.append([InlineKeyboardButton(
        f"üìä üìä Entry %: {entry}%", 
        callback_data=f"strat_param:{strategy}:{side}_percent"
    )])
    
    buttons.append([InlineKeyboardButton(
        f"üîª üîª Stop-Loss %: {sl}%", 
        callback_data=f"strat_param:{strategy}:{side}_sl_percent"
    )])
    
    buttons.append([InlineKeyboardButton(
        f"üéØ üî∫ Take-Profit %: {tp}%", 
        callback_data=f"strat_param:{strategy}:{side}_tp_percent"
    )])
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # üìà ATR TRAILING GROUP
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    atr_status = "‚úÖ" if use_atr else "‚ùå"
    buttons.append([InlineKeyboardButton(
        f"üìä {t.get('atr_trailing', 'ATR Trailing')}: {atr_status}", 
        callback_data=f"strat_side_atr_toggle:{strategy}:{side}"
    )])
    
    if use_atr:
        buttons.append([
            InlineKeyboardButton(f"üéØ –¢—Ä–∏–≥–µ—Ä ATR %: {atr_trigger}%", callback_data=f"strat_param:{strategy}:{side}_atr_trigger_pct"),
            InlineKeyboardButton(f"üìè ATR Step: {atr_step}%", callback_data=f"strat_param:{strategy}:{side}_atr_step_pct")
        ])
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # üîí BREAK-EVEN GROUP
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    be_status = "‚úÖ" if be_enabled else "‚ùå"
    buttons.append([InlineKeyboardButton(
        f"üîí üîí {t.get('be_enabled_label', '–ë–µ–∑–∑–±–∏—Ç–∫–æ–≤—ñ—Å—Ç—å')}: {be_status}", 
        callback_data=f"strat_side_be:{strategy}:{side}:toggle"
    )])
    
    if be_enabled:
        buttons.append([InlineKeyboardButton(
            f"   üéØ BE Trigger: {be_trigger}%", 
            callback_data=f"strat_param:{strategy}:{side}_be_trigger_pct"
        )])
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # üìâ DCA GROUP
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    dca_status = "‚úÖ" if dca_enabled else "‚ùå"
    buttons.append([InlineKeyboardButton(
        f"üìâ {t.get('dca_enabled', 'DCA')}: {dca_status}", 
        callback_data=f"strat_side_dca_toggle:{strategy}:{side}"
    )])
    
    if dca_enabled:
        buttons.append([
            InlineKeyboardButton(f"üìâ Leg 1: -{dca_pct_1}%", callback_data=f"strat_param:{strategy}:{side}_dca_pct_1"),
            InlineKeyboardButton(f"üìâ Leg 2: -{dca_pct_2}%", callback_data=f"strat_param:{strategy}:{side}_dca_pct_2")
        ])
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚úÇÔ∏è PARTIAL TP GROUP
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    ptp_status = "‚úÖ" if ptp_enabled else "‚ùå"
    buttons.append([InlineKeyboardButton(
        f"‚úÇÔ∏è ‚úÇÔ∏è {t.get('partial_tp_label', '–ß–∞—Å—Ç–∫–æ–≤–∏–π TP')}: {ptp_status}", 
        callback_data=f"strat_side_ptp:{strategy}:{side}:toggle"
    )])
    
    if ptp_enabled:
        buttons.append([
            InlineKeyboardButton(f"1Ô∏è‚É£ +{ptp_1_trigger}%‚Üí{ptp_1_close}%", callback_data=f"strat_side_ptp:{strategy}:{side}:step1"),
            InlineKeyboardButton(f"2Ô∏è‚É£ +{ptp_2_trigger}%‚Üí{ptp_2_close}%", callback_data=f"strat_side_ptp:{strategy}:{side}:step2")
        ])
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # üìä LIMITS GROUP
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    max_pos_label = str(max_positions) if max_positions > 0 else "‚àû"
    buttons.append([InlineKeyboardButton(
        f"üìä Max Positions: {max_pos_label}", 
        callback_data=f"strat_param:{strategy}:{side}_max_positions"
    )])
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚¨ÖÔ∏è BACK BUTTON
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    buttons.append([InlineKeyboardButton(
        t.get('btn_back', '¬´ –ù–∞–∑–∞–¥'), 
        callback_data=f"strat_set:{strategy}"
    )])
    
    return InlineKeyboardMarkup(buttons)


def get_scryptomera_side_keyboard(side: str, t: dict, settings: dict = None) -> InlineKeyboardMarkup:
    """Build inline keyboard for Scryptomera LONG or SHORT settings (legacy wrapper)."""
    return get_strategy_side_keyboard("scryptomera", side, t, settings)


def get_scalper_side_keyboard(side: str, t: dict, settings: dict = None) -> InlineKeyboardMarkup:
    """Build inline keyboard for Scalper LONG or SHORT settings (legacy wrapper)."""
    return get_strategy_side_keyboard("scalper", side, t, settings)


def get_dca_settings_keyboard(t: dict, cfg: dict = None) -> InlineKeyboardMarkup:
    """Build inline keyboard for DCA settings."""
    cfg = cfg or {}
    dca_enabled = cfg.get("dca_enabled", 0)
    status_emoji = "‚úÖ" if dca_enabled else "‚ùå"
    
    buttons = [
        [InlineKeyboardButton(
            f"{status_emoji} " + t.get('dca_toggle', 'DCA Enabled'),
            callback_data="dca_toggle"
        )],
        [InlineKeyboardButton(t.get('dca_leg1', 'üìâ DCA Leg 1 %'), callback_data="dca_param:dca_pct_1")],
        [InlineKeyboardButton(t.get('dca_leg2', 'üìâ DCA Leg 2 %'), callback_data="dca_param:dca_pct_2")],
        [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="strat_set:back")],
    ]
    return InlineKeyboardMarkup(buttons)


def get_hl_strategy_keyboard(strategy: str, t: dict, uid: int = None) -> InlineKeyboardMarkup:
    """Build inline keyboard for HyperLiquid strategy settings."""
    hl_settings = db.get_hl_strategy_settings(uid, strategy) if uid else {}
    
    hl_enabled = hl_settings.get("hl_enabled", False)
    status_emoji = "‚úÖ" if hl_enabled else "‚ùå"
    
    hl_percent = hl_settings.get("hl_percent")
    hl_sl = hl_settings.get("hl_sl_percent")
    hl_tp = hl_settings.get("hl_tp_percent")
    hl_lev = hl_settings.get("hl_leverage")
    
    percent_label = f"{hl_percent}%" if hl_percent else t.get('global_default', 'Global')
    sl_label = f"{hl_sl}%" if hl_sl else t.get('global_default', 'Global')
    tp_label = f"{hl_tp}%" if hl_tp else t.get('global_default', 'Global')
    lev_label = f"{hl_lev}x" if hl_lev else t.get('global_default', 'Global')
    
    display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
    
    buttons = [
        [InlineKeyboardButton(
            f"{status_emoji} " + t.get('hl_trading_enabled', 'HyperLiquid Trading'),
            callback_data=f"hl_strat:toggle:{strategy}"
        )],
        [InlineKeyboardButton(
            t.get('param_percent', 'üìä Entry %') + f": {percent_label}",
            callback_data=f"hl_strat:param:{strategy}:hl_percent"
        )],
        [InlineKeyboardButton(
            t.get('param_sl', 'üîª Stop-Loss %') + f": {sl_label}",
            callback_data=f"hl_strat:param:{strategy}:hl_sl_percent"
        )],
        [InlineKeyboardButton(
            t.get('param_tp', 'üî∫ Take-Profit %') + f": {tp_label}",
            callback_data=f"hl_strat:param:{strategy}:hl_tp_percent"
        )],
        [InlineKeyboardButton(
            t.get('param_leverage', '‚ö° Leverage') + f": {lev_label}",
            callback_data=f"hl_strat:param:{strategy}:hl_leverage"
        )],
        [InlineKeyboardButton(
            t.get('hl_reset_settings', 'üîÑ Reset to Bybit Settings'),
            callback_data=f"hl_strat:reset:{strategy}"
        )],
        [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data=f"strat_set:{strategy}")],
    ]
    return InlineKeyboardMarkup(buttons)


@require_access
@with_texts
@log_calls
async def cmd_strategy_settings(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show strategy settings menu."""
    uid = update.effective_user.id
    cfg = get_user_config(uid)
    active_exchange = db.get_exchange_type(uid) or "bybit"
    context = db.get_user_trading_context(uid)
    account_type = context.get("account_type", "demo")
    global_use_atr = bool(cfg.get("use_atr", 1))
    
    # Build status message
    lines = [ctx.t.get('strategy_settings_header', '‚öôÔ∏è *Strategy Settings*')]
    lines.append("")
    
    for strat_key, strat_name in STRATEGY_NAMES_MAP.items():
        strat_settings = db.get_strategy_settings(uid, strat_key, active_exchange, account_type)
        status_parts = _build_strategy_status_parts(strat_key, strat_settings, active_exchange, global_use_atr, global_cfg=cfg)
        if status_parts:
            lines.append(f"*{strat_name}*: {', '.join(status_parts)}")
        else:
            lines.append(f"*{strat_name}*: {ctx.t.get('using_global', 'Using global settings')}")
    
    lines.append("")
    dca_status = '‚úÖ' if cfg.get('dca_enabled', 0) else '‚ùå'
    lines.append(f"*DCA*: {dca_status} Leg1={cfg.get('dca_pct_1', 10.0)}%, Leg2={cfg.get('dca_pct_2', 25.0)}%")
    
    await update.message.reply_text(
        "\n".join(lines),
        parse_mode="Markdown",
        reply_markup=get_strategy_settings_keyboard(ctx.t, cfg, uid=uid)
    )


async def _show_global_settings_menu(query, uid: int, t: dict):
    """Helper to display Global Trading Settings menu."""
    cfg = get_user_config(uid)
    sl_val = cfg.get('sl_percent', cfg.get('sl_pct', 3))
    tp_val = cfg.get('tp_percent', cfg.get('tp_pct', 6))
    
    # ATR mode (trailing vs fixed)
    use_atr = cfg.get('use_atr', 1)
    atr_status = "‚úÖ" if use_atr else "‚ùå"
    atr_label = "Trailing Stop" if use_atr else "Fixed SL/TP"
    
    # ATR parameters (simplified: only trigger and step)
    atr_trigger = cfg.get('atr_trigger_pct', ATR_TRIGGER_PCT)
    atr_step = cfg.get('atr_step_pct', 0.5)  # Default 0.5%
    
    # Limit ladder info
    ladder_enabled = cfg.get('limit_ladder_enabled', 0)
    ladder_count = cfg.get('limit_ladder_count', 3)
    ladder_status = "‚úÖ" if ladder_enabled else "‚ùå"
    
    # Order type (market/limit)
    order_type = cfg.get('global_order_type', 'market')
    order_emoji = "‚ö°" if order_type == "market" else "üéØ"
    order_label = "Market" if order_type == "market" else "Limit"
    
    # Trading mode (demo/real/both)
    trading_mode = get_trading_mode(uid) or "demo"
    mode_emoji = {"demo": "üß™", "real": "üí∞", "both": "üîÑ"}.get(trading_mode, "üß™")
    mode_label = {"demo": "Demo", "real": "Real", "both": "Both"}.get(trading_mode, "Demo")
    
    # Break-Even settings
    be_enabled = cfg.get('be_enabled', 0)
    be_trigger = cfg.get('be_trigger_pct', 1.0)
    be_status = "‚úÖ" if be_enabled else "‚ùå"
    
    lines = [t.get('global_settings_header', 'üåê *Global Trading Settings*')]
    lines.append("")
    lines.append(f"üìä Entry %: *{cfg.get('percent', 1)}%*")
    lines.append(f"üõë SL %: *{sl_val}%*")
    lines.append(f"üéØ TP %: *{tp_val}%*")
    lines.append(f"üéö Leverage: *{cfg.get('leverage', 10)}x*")
    lines.append(f"üìâ Stop Mode: *{atr_label}* {atr_status}")
    lines.append(f"üîí Break-Even: {be_status} ({be_trigger}%)" if be_enabled else f"üîí Break-Even: {be_status}")
    lines.append(f"{order_emoji} Order type: *{order_label}*")
    lines.append(f"{mode_emoji} Account: *{mode_label}*")
    lines.append("")
    # Trailing Stop Settings section (simplified)
    if use_atr:
        lines.append(f"üìà *Trailing Stop:*")
        lines.append(f"  üéØ Trigger: *{atr_trigger}%* (activate at profit)")
        lines.append(f"  üìè Step: *{atr_step}%* (SL distance from price)")
        lines.append("")
    # Break-Even info
    if be_enabled:
        lines.append(f"üîí *Break-Even:*")
        lines.append(f"  üéØ Trigger: *{be_trigger}%* (move SL to entry)")
        lines.append("")
    lines.append(f"üìà {t.get('limit_ladder', 'Limit Ladder')}: {ladder_status} (*{ladder_count}* orders)")
    lines.append("")
    lines.append(t.get('global_settings_info', 'These settings are used as defaults when strategy-specific settings are not configured.'))
    
    buttons = [
        [InlineKeyboardButton(t.get('param_percent', 'üìä Entry %'), callback_data="global_param:percent")],
        [InlineKeyboardButton(t.get('param_sl', 'üõë Stop-Loss %'), callback_data="global_param:sl_percent")],
        [InlineKeyboardButton(t.get('param_tp', 'üéØ Take-Profit %'), callback_data="global_param:tp_percent")],
        [InlineKeyboardButton(t.get('param_leverage', 'üéö Leverage'), callback_data="global_param:leverage")],
        [InlineKeyboardButton(f"{atr_status} üìâ {atr_label}", callback_data="global_param:use_atr")],
        [InlineKeyboardButton(f"{be_status} üîí Break-Even", callback_data="global_be:toggle")],
        [InlineKeyboardButton(f"{order_emoji} Order: {order_label}", callback_data="global_param:order_type")],
        [InlineKeyboardButton(f"{mode_emoji} Account: {mode_label}", callback_data="global_param:trading_mode")],
        [InlineKeyboardButton("‚öôÔ∏è Trailing Stop Settings", callback_data="global_atr:settings")],
        [InlineKeyboardButton("‚öôÔ∏è Break-Even Settings", callback_data="global_be:settings")],
        [InlineKeyboardButton(f"{ladder_status} {t.get('limit_ladder', 'üìà Limit Ladder')}", callback_data="global_ladder:toggle")],
        [InlineKeyboardButton(t.get('limit_ladder_settings', '‚öôÔ∏è Ladder Settings'), callback_data="global_ladder:settings")],
        [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="strat_set:back")],
    ]
    
    try:
        await query.message.edit_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
    except Exception as e:
        logger.error(f"Error editing global settings message: {e}")
        await query.message.edit_text(
            "\n".join(lines),
            reply_markup=InlineKeyboardMarkup(buttons)
        )


async def _show_global_atr_settings_menu(query, uid: int, t: dict):
    """Helper to display Global ATR Settings menu.
    
    SIMPLIFIED: Only 2 parameters:
    - Trigger %: Price movement % to activate trailing stop
    - Step %: SL follows price at this distance %
    """
    cfg = get_user_config(uid)
    
    atr_trigger = cfg.get('atr_trigger_pct', ATR_TRIGGER_PCT)
    atr_step = cfg.get('atr_step_pct', 0.5)
    use_atr = cfg.get('use_atr', 1)
    
    lines = [t.get('atr_settings_header', 'üìà *Trailing Stop Settings*')]
    lines.append("")
    lines.append(f"üìä Mode: {'‚úÖ Enabled' if use_atr else '‚ùå Disabled'}")
    lines.append("")
    lines.append(t.get('atr_settings_desc', '_Dynamic trailing stop-loss that follows price._'))
    lines.append("")
    lines.append(f"üéØ *Trigger %*: {atr_trigger}%")
    lines.append("   _Price moves this % in profit ‚Üí trailing activates_")
    lines.append("")
    lines.append(f"üìè *Step %*: {atr_step}%")
    lines.append("   _SL follows price at this distance_")
    lines.append("")
    lines.append("_Example: Trigger=2%, Step=1%_")
    lines.append("_‚Üí Price moves +2% ‚Üí SL set at +1%_")
    lines.append("_‚Üí Price moves +3% ‚Üí SL moves to +2%_")
    
    buttons = [
        [InlineKeyboardButton(f"üéØ Trigger: {atr_trigger}%", callback_data="global_atr:trigger")],
        [InlineKeyboardButton(f"üìè Step: {atr_step}%", callback_data="global_atr:step")],
        [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="strat_set:global")],
    ]
    
    try:
        await query.message.edit_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
    except Exception as e:
        logger.error(f"Error editing ATR settings message: {e}")
        await query.message.edit_text(
            "\n".join(lines),
            reply_markup=InlineKeyboardMarkup(buttons)
        )


async def _show_global_be_settings_menu(query, uid: int, t: dict):
    """Helper to display Global Break-Even Settings menu.
    
    Break-Even moves SL to entry price when profit reaches trigger %.
    """
    cfg = get_user_config(uid)
    
    be_enabled = cfg.get('be_enabled', 0)
    be_trigger = cfg.get('be_trigger_pct', 1.0)
    
    lines = [t.get('be_settings_header', 'üîí *Break-Even Settings*')]
    lines.append("")
    lines.append(f"üìä Mode: {'‚úÖ Enabled' if be_enabled else '‚ùå Disabled'}")
    lines.append("")
    lines.append(t.get('be_settings_desc', '_Move SL to entry when profit reaches trigger %_'))
    lines.append("")
    lines.append(f"üéØ *Trigger %*: {be_trigger}%")
    lines.append("   _Price moves this % in profit ‚Üí SL moves to entry_")
    lines.append("")
    lines.append("_Example: Trigger=1%_")
    lines.append("_‚Üí Entry: $100, Price: $101 (+1%)_")
    lines.append("_‚Üí SL moves from $97 to $100 (breakeven)_")
    
    buttons = [
        [InlineKeyboardButton(
            f"{'‚úÖ' if be_enabled else '‚ùå'} Break-Even: {'ON' if be_enabled else 'OFF'}", 
            callback_data="global_be:toggle"
        )],
        [InlineKeyboardButton(f"üéØ Trigger: {be_trigger}%", callback_data="global_be:trigger")],
        [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="strat_set:global")],
    ]
    
    try:
        await query.message.edit_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
    except Exception as e:
        logger.error(f"Error editing BE settings message: {e}")
        await query.message.edit_text(
            "\n".join(lines),
            reply_markup=InlineKeyboardMarkup(buttons)
        )


async def _show_ladder_settings_menu(query, uid: int, t: dict):
    """Helper to display Ladder Settings menu."""
    cfg = get_user_config(uid)
    ladder_count = cfg.get('limit_ladder_count', 3)
    ladder_settings = cfg.get('limit_ladder_settings', [])
    
    # Default settings if empty
    if not ladder_settings:
        ladder_settings = [
            {"pct_from_entry": 1.0, "pct_of_deposit": 5.0},
            {"pct_from_entry": 2.0, "pct_of_deposit": 7.0},
            {"pct_from_entry": 3.0, "pct_of_deposit": 10.0},
        ]
    
    lines = [t.get('limit_ladder_header', 'üìà *Limit Ladder Settings*')]
    lines.append("")
    lines.append(f"üìä {t.get('ladder_count', 'Number of orders')}: *{ladder_count}*")
    lines.append("")
    for i, leg in enumerate(ladder_settings[:ladder_count], 1):
        pct_entry = leg.get('pct_from_entry', 1.0)
        pct_deposit = leg.get('pct_of_deposit', 5.0)
        lines.append(f"üìâ *Order {i}*: -{pct_entry}% @ {pct_deposit}% deposit")
    lines.append("")
    lines.append(t.get('ladder_info', 'Limit orders placed below entry price for DCA entries.'))
    
    buttons = [
        [InlineKeyboardButton(f"üìä {t.get('ladder_count', 'Count')}: {ladder_count}", callback_data="global_ladder:count")],
    ]
    for i in range(min(ladder_count, 5)):
        leg = ladder_settings[i] if i < len(ladder_settings) else {"pct_from_entry": 1.0, "pct_of_deposit": 5.0}
        pct_entry = leg.get('pct_from_entry', 1.0)
        pct_deposit = leg.get('pct_of_deposit', 5.0)
        buttons.append([
            InlineKeyboardButton(f"üìâ #{i+1}: -{pct_entry}%", callback_data=f"global_ladder:pct_entry:{i}"),
            InlineKeyboardButton(f"üí∞ #{i+1}: {pct_deposit}%", callback_data=f"global_ladder:pct_deposit:{i}"),
        ])
    buttons.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="strat_set:global")])
    
    try:
        await query.message.edit_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
    except Exception as e:
        logger.error(f"Error editing ladder settings message: {e}")
        await query.message.edit_text(
            "\n".join(lines),
            reply_markup=InlineKeyboardMarkup(buttons)
        )


@log_calls
async def callback_strategy_settings(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle strategy settings inline button callbacks."""
    query = update.callback_query
    # Note: Don't call query.answer() here - each handler will answer with appropriate message
    
    uid = query.from_user.id
    data = query.data
    logger.info(f"[CALLBACK] callback_strategy_settings called: uid={uid}, data={data}")
    
    # Handle noop callback (header buttons, separators)
    if data == "noop":
        await query.answer()
        return
    
    cfg = get_user_config(uid)
    lang = cfg.get("lang", DEFAULT_LANG)
    t = LANGS.get(lang, LANGS[DEFAULT_LANG])
    
    if data == "strat_set:close":
        await query.answer()
        await query.message.delete()
        return
    
    if data == "strat_set:back":
        # Rebuild main strategy menu
        active_exchange = db.get_exchange_type(uid) or "bybit"
        context = db.get_user_trading_context(uid)
        account_type = context.get("account_type", "demo")
        global_use_atr = bool(cfg.get("use_atr", 1))
        lines = [t.get('strategy_settings_header', '‚öôÔ∏è *Strategy Settings*')]
        lines.append("")
        
        for strat_key, strat_name in STRATEGY_NAMES_MAP.items():
            strat_settings = db.get_strategy_settings(uid, strat_key, active_exchange, account_type)
            status_parts = _build_strategy_status_parts(strat_key, strat_settings, active_exchange, global_use_atr, global_cfg=cfg)
            if status_parts:
                lines.append(f"*{strat_name}*: {', '.join(status_parts)}")
            else:
                lines.append(f"*{strat_name}*: {t.get('using_global', 'Using global settings')}")
        
        lines.append("")
        dca_status = '‚úÖ' if cfg.get('dca_enabled', 0) else '‚ùå'
        lines.append(f"*DCA*: {dca_status} Leg1={cfg.get('dca_pct_1', 10.0)}%, Leg2={cfg.get('dca_pct_2', 25.0)}%")
        
        await query.message.edit_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
        )
        await query.answer()
        return
    
    if data == "strat_set:global":
        # DEPRECATED: Global settings removed - redirect to strategy settings
        # Each strategy now has its own Long/Short settings with Entry%, SL%, TP%, ATR
        db.clear_pending_input(uid)
        cfg = get_user_config(uid)
        await query.message.edit_text(
            t.get('strategies_menu_header', 'üìä *Strategy Settings*'),
            parse_mode="Markdown",
            reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
        )
        await query.answer()
        return
    
    # Global ATR mode toggle (ATR Trailing vs Fixed SL/TP)
    if data == "global_param:use_atr":
        current = cfg.get('use_atr', 1)
        new_val = 0 if current else 1
        set_user_field(uid, 'use_atr', new_val)
        status = "‚úÖ ATR Trailing enabled" if new_val else "‚ùå Fixed SL/TP mode"
        await query.answer(status)
        # Return directly to global settings with updated value
        return await _show_global_settings_menu(query, uid, t)
    
    # Global order type toggle
    if data == "global_param:order_type":
        current = cfg.get('global_order_type', 'market')
        new_type = "limit" if current == "market" else "market"
        set_user_field(uid, 'global_order_type', new_type)
        emoji = "üéØ" if new_type == "limit" else "‚ö°"
        # Return directly to global settings with updated value
        return await _show_global_settings_menu(query, uid, t)
    
    # Global trading mode toggle (demo -> real -> both -> demo)
    if data == "global_param:trading_mode":
        current = get_trading_mode(uid) or "demo"
        # Cycle: demo -> real -> both -> demo
        modes = ["demo", "real", "both"]
        next_idx = (modes.index(current) + 1) % 3 if current in modes else 0
        new_mode = modes[next_idx]
        set_trading_mode(uid, new_mode)
        # Return directly to global settings with updated value
        return await _show_global_settings_menu(query, uid, t)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  GLOBAL ATR SETTINGS HANDLERS - DEPRECATED  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    # All global_atr: handlers redirect to strategy settings
    if data.startswith("global_atr:"):
        cfg = get_user_config(uid)
        await query.message.edit_text(
            t.get('global_settings_removed', '‚ö†Ô∏è *Global Settings Removed*\n\nPlease use per-strategy Long/Short settings instead.\n\nEach strategy now has its own Entry%, SL%, TP%, ATR settings.'),
            parse_mode="Markdown",
            reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
        )
        await query.answer()
        return
    
    # Limit ladder toggle
    if data == "global_ladder:toggle":
        current = cfg.get('limit_ladder_enabled', 0)
        new_val = 0 if current else 1
        set_user_field(uid, 'limit_ladder_enabled', new_val)
        cfg = get_user_config(uid)
        await query.message.edit_text(
            t.get('strategies_menu_header', 'üìä *Strategy Settings*'),
            parse_mode="Markdown",
            reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
        )
        return
    
    # Limit ladder settings
    if data == "global_ladder:settings":
        # Show ladder settings using helper
        return await _show_ladder_settings_menu(query, uid, t)
    
    # Ladder count adjustment
    if data == "global_ladder:count":
        current = cfg.get('limit_ladder_count', 3)
        new_count = (current % 5) + 1  # Cycle 1-5
        set_user_field(uid, 'limit_ladder_count', new_count)
        # Refresh ladder settings directly
        return await _show_ladder_settings_menu(query, uid, t)
    
    # Ladder leg parameter input
    if data.startswith("global_ladder:pct_entry:") or data.startswith("global_ladder:pct_deposit:"):
        parts = data.split(":")
        param_type = parts[1]  # "pct_entry" or "pct_deposit"
        leg_idx = int(parts[2])
        
        ctx.user_data["ladder_setting_mode"] = {"type": param_type, "leg": leg_idx}
        
        if param_type == "pct_entry":
            prompt = t.get('prompt_ladder_pct_entry', 'Enter % below entry price for order {idx}:').format(idx=leg_idx+1)
        else:
            prompt = t.get('prompt_ladder_pct_deposit', 'Enter % of deposit for order {idx}:').format(idx=leg_idx+1)
        
        await query.message.edit_text(
            prompt,
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get('btn_cancel', '‚ùå Cancel'), callback_data="global_ladder:settings")]
            ])
        )
        return
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  GLOBAL BREAK-EVEN SETTINGS HANDLERS - DEPRECATED  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    # All global_be: handlers redirect to strategy settings
    if data.startswith("global_be:"):
        cfg = get_user_config(uid)
        await query.message.edit_text(
            t.get('global_settings_removed', '‚ö†Ô∏è *Global Settings Removed*\n\nPlease use per-strategy Long/Short settings instead.\n\nEach strategy now has its own Entry%, SL%, TP%, ATR settings.'),
            parse_mode="Markdown",
            reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
        )
        await query.answer()
        return
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  HYPERLIQUID STRATEGY SETTINGS HANDLERS  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    # Handle opening HL settings for a strategy
    if data.startswith("strat_hl:"):
        strategy = data.split(":")[1]
        if strategy not in STRATEGY_NAMES_MAP:
            await query.answer(t.get("strategy_invalid", "‚ùå Invalid strategy"))
            return
        
        hl_settings = db.get_hl_strategy_settings(uid, strategy)
        bybit_settings = db.get_effective_settings(uid, strategy)
        
        hl_enabled = hl_settings.get("hl_enabled", False)
        hl_percent = hl_settings.get("hl_percent")
        hl_sl = hl_settings.get("hl_sl_percent")
        hl_tp = hl_settings.get("hl_tp_percent")
        hl_lev = hl_settings.get("hl_leverage")
        
        strat_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        text = f"üî∑ <b>HyperLiquid Settings: {strat_name}</b>\n\n"
        text += f"<b>Status:</b> {'‚úÖ Enabled' if hl_enabled else '‚ùå Disabled'}\n\n"
        
        text += "<b>Current Settings:</b>\n"
        text += f"üìä Entry %: {hl_percent if hl_percent else 'Use Bybit (' + str(bybit_settings.get('percent', 1.0)) + '%)'}\n"
        text += f"üîª Stop-Loss %: {hl_sl if hl_sl else 'Use Bybit (' + str(bybit_settings.get('sl_percent', 2.0)) + '%)'}\n"
        text += f"üî∫ Take-Profit %: {hl_tp if hl_tp else 'Use Bybit (' + str(bybit_settings.get('tp_percent', 3.0)) + '%)'}\n"
        text += f"‚ö° Leverage: {str(hl_lev) + 'x' if hl_lev else 'Use Bybit (' + str(bybit_settings.get('leverage', 10)) + 'x)'}\n\n"
        
        text += "<i>When enabled, signals will also open trades on HyperLiquid if the coin is available there.</i>"
        
        await query.message.edit_text(
            text,
            parse_mode="HTML",
            reply_markup=get_hl_strategy_keyboard(strategy, t, uid=uid)
        )
        return
    
    # Handle HL strategy toggle
    if data.startswith("hl_strat:toggle:"):
        strategy = data.split(":")[2]
        hl_settings = db.get_hl_strategy_settings(uid, strategy)
        current = hl_settings.get("hl_enabled", False)
        new_val = not current
        
        db.set_hl_strategy_setting(uid, strategy, "hl_enabled", new_val)
        
        status = "‚úÖ Enabled" if new_val else "‚ùå Disabled"
        await query.answer(f"üî∑ HyperLiquid {STRATEGY_NAMES_MAP.get(strategy, strategy)}: {status}")
        
        # Refresh the HL settings menu
        hl_settings = db.get_hl_strategy_settings(uid, strategy)
        bybit_settings = db.get_effective_settings(uid, strategy)
        
        strat_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        text = f"üî∑ <b>HyperLiquid Settings: {strat_name}</b>\n\n"
        text += f"<b>Status:</b> {'‚úÖ Enabled' if new_val else '‚ùå Disabled'}\n\n"
        
        hl_percent = hl_settings.get("hl_percent")
        hl_sl = hl_settings.get("hl_sl_percent")
        hl_tp = hl_settings.get("hl_tp_percent")
        hl_lev = hl_settings.get("hl_leverage")
        
        text += "<b>Current Settings:</b>\n"
        text += f"üìä Entry %: {hl_percent if hl_percent else 'Use Bybit (' + str(bybit_settings.get('percent', 1.0)) + '%)'}\n"
        text += f"üîª Stop-Loss %: {hl_sl if hl_sl else 'Use Bybit (' + str(bybit_settings.get('sl_percent', 2.0)) + '%)'}\n"
        text += f"üî∫ Take-Profit %: {hl_tp if hl_tp else 'Use Bybit (' + str(bybit_settings.get('tp_percent', 3.0)) + '%)'}\n"
        text += f"‚ö° Leverage: {str(hl_lev) + 'x' if hl_lev else 'Use Bybit (' + str(bybit_settings.get('leverage', 10)) + 'x)'}\n"
        
        await query.message.edit_text(
            text,
            parse_mode="HTML",
            reply_markup=get_hl_strategy_keyboard(strategy, t, uid=uid)
        )
        return
    
    # Handle HL strategy parameter input
    if data.startswith("hl_strat:param:"):
        parts = data.split(":")
        strategy = parts[2]
        param = parts[3]
        
        _awaiting_hl_param[uid] = {"strategy": strategy, "param": param}
        
        param_labels = {
            "hl_percent": "Entry %",
            "hl_sl_percent": "Stop-Loss %",
            "hl_tp_percent": "Take-Profit %",
            "hl_leverage": "Leverage"
        }
        
        strat_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        param_label = param_labels.get(param, param)
        
        await query.message.edit_text(
            f"üî∑ <b>{strat_name} - {param_label}</b>\n\n"
            f"Enter new value for {param_label}:\n\n"
            f"Send a number or /cancel to abort.",
            parse_mode="HTML"
        )
        return
    
    # Handle HL strategy reset
    if data.startswith("hl_strat:reset:"):
        strategy = data.split(":")[2]
        
        # Clear all HL settings for this strategy
        for field in ["hl_enabled", "hl_percent", "hl_sl_percent", "hl_tp_percent", "hl_leverage"]:
            db.set_hl_strategy_setting(uid, strategy, field, None)
        
        await query.answer(f"üîÑ HyperLiquid settings reset for {STRATEGY_NAMES_MAP.get(strategy, strategy)}")
        
        # Refresh the strategy menu
        context = db.get_user_trading_context(uid)
        active_exchange = context.get("exchange", "bybit")
        account_type = context.get("account_type", "demo")
        strat_settings = db.get_strategy_settings(uid, strategy, active_exchange, account_type)
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        await query.message.edit_text(
            f"‚öôÔ∏è <b>{display_name} Strategy Settings</b>\n\n"
            f"Configure {display_name} signal parameters.\n"
            f"Use buttons below to adjust settings.",
            parse_mode="HTML",
            reply_markup=get_strategy_param_keyboard(strategy, t, strat_settings)
        )
        return
    
    if data == "strat_set:dca":
        # Show DCA settings
        dca_enabled = cfg.get('dca_enabled', 0)
        status = t.get('status_enabled', 'Enabled') if dca_enabled else t.get('status_disabled', 'Disabled')
        text = t.get('dca_settings_header', '‚öôÔ∏è *DCA Settings (Futures)*\n\n')
        text += f"*{t.get('dca_status', 'Status')}*: {'‚úÖ' if dca_enabled else '‚ùå'} {status}\n\n"
        text += f"üìâ *Leg 1*: -{cfg.get('dca_pct_1', 10.0)}%\n"
        text += f"üìâ *Leg 2*: -{cfg.get('dca_pct_2', 25.0)}%\n\n"
        text += t.get('dca_description', '_DCA will add to position when price moves against you._')
        
        await query.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=get_dca_settings_keyboard(t, cfg)
        )
        return
    
    # Handle strategy enable/disable toggle
    if data.startswith("strat_toggle:"):
        strategy = data.split(":")[1]
        
        # Handle Spot toggle separately
        if strategy == "spot":
            current = cfg.get("spot_enabled", 0)
            new_val = 0 if current else 1
            set_user_field(uid, "spot_enabled", new_val)
            cfg = get_user_config(uid)
            
            status = "‚úÖ ON" if new_val else "‚ùå OFF"
            await query.answer(f"üíπ Spot: {status}")
            
            # Refresh the strategies menu
            active_exchange = db.get_exchange_type(uid) or "bybit"
            context = db.get_user_trading_context(uid)
            account_type = context.get("account_type", "demo")
            global_use_atr = bool(cfg.get("use_atr", 1))
            lines = [t.get('strategy_settings_header', '‚öôÔ∏è *Strategy Settings*')]
            lines.append("")
            for strat_key, strat_nm in STRATEGY_NAMES_MAP.items():
                strat_settings = db.get_strategy_settings(uid, strat_key, active_exchange, account_type)
                status_parts = _build_strategy_status_parts(strat_key, strat_settings, active_exchange, global_use_atr, global_cfg=cfg)
                if status_parts:
                    lines.append(f"*{strat_nm}*: {', '.join(status_parts)}")
                else:
                    lines.append(f"*{strat_nm}*: {t.get('using_global', 'Using global settings')}")
            lines.append("")
            dca_status = '‚úÖ' if cfg.get('dca_enabled', 0) else '‚ùå'
            lines.append(f"*DCA*: {dca_status} Leg1={cfg.get('dca_pct_1', 10.0)}%, Leg2={cfg.get('dca_pct_2', 25.0)}%")
            
            await query.message.edit_text(
                "\n".join(lines),
                parse_mode="Markdown",
                reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
            )
            return
        
        field_map = {
            "oi": "trade_oi",
            "rsi_bb": "trade_rsi_bb",
            "scryptomera": "trade_scryptomera",
            "scalper": "trade_scalper",
            "elcaro": "trade_elcaro",
            "fibonacci": "trade_fibonacci",
            "manual": "trade_manual",  # Manual position monitoring
        }
        field = field_map.get(strategy)
        if field:
            current = cfg.get(field, 0)
            new_val = 0 if current else 1
            set_user_field(uid, field, new_val)
            cfg = get_user_config(uid)
            
            # CRITICAL SYNC: Also update user_strategy_settings for both sides
            # This ensures the dual system (trade_* + {side}_enabled) stays in sync
            active_exchange = db.get_exchange_type(uid) or "bybit"
            if strategy != "manual":  # manual has no per-side settings
                db.set_strategy_setting(uid, strategy, "long_enabled", bool(new_val), active_exchange)
                db.set_strategy_setting(uid, strategy, "short_enabled", bool(new_val), active_exchange)
                logger.info(f"[{uid}] Strategy {strategy} toggle synced: trade_{strategy}={new_val}, long_enabled={bool(new_val)}, short_enabled={bool(new_val)}")
            
            strat_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
            status = "‚úÖ ON" if new_val else "‚ùå OFF"
            await query.answer(f"{strat_name}: {status}")
            
            # Refresh the strategies menu
            context = db.get_user_trading_context(uid)
            account_type = context.get("account_type", "demo")
            global_use_atr = bool(cfg.get("use_atr", 1))
            lines = [t.get('strategy_settings_header', '‚öôÔ∏è *Strategy Settings*')]
            lines.append("")
            for strat_key, strat_nm in STRATEGY_NAMES_MAP.items():
                strat_settings = db.get_strategy_settings(uid, strat_key, active_exchange, account_type)
                status_parts = _build_strategy_status_parts(strat_key, strat_settings, active_exchange, global_use_atr, global_cfg=cfg)
                if status_parts:
                    lines.append(f"*{strat_nm}*: {', '.join(status_parts)}")
                else:
                    lines.append(f"*{strat_nm}*: {t.get('using_global', 'Using global settings')}")
            lines.append("")
            dca_status = '‚úÖ' if cfg.get('dca_enabled', 0) else '‚ùå'
            lines.append(f"*DCA*: {dca_status} Leg1={cfg.get('dca_pct_1', 10.0)}%, Leg2={cfg.get('dca_pct_2', 25.0)}%")
            
            await query.message.edit_text(
                "\n".join(lines),
                parse_mode="Markdown",
                reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
            )
        return
    
    # Handle strategy trading mode - CYCLE MODE (Demo ‚Üí Real ‚Üí Both ‚Üí Demo)
    # Format: strat_mode_cycle:{strategy}
    if data.startswith("strat_mode_cycle:"):
        strategy = data.split(":")[1]
        
        if strategy not in STRATEGY_NAMES_MAP:
            await query.answer("Unknown strategy")
            return
        
        # Get current mode and cycle to next
        current_mode = db.get_strategy_trading_mode(uid, strategy) or "demo"
        modes = ["demo", "real", "both"]
        next_idx = (modes.index(current_mode) + 1) % 3 if current_mode in modes else 0
        new_mode = modes[next_idx]
        
        logger.info(f"[STRAT_MODE_CYCLE] User {uid} cycling {strategy}: {current_mode} ‚Üí {new_mode}")
        
        # Save trading_mode for this strategy
        db.set_strategy_trading_mode(uid, strategy, new_mode)
        
        # Check credentials and warn if needed
        warnings = []
        
        # Check Bybit credentials
        if db.is_bybit_enabled(uid):
            creds = db.get_all_user_credentials(uid)
            has_demo = bool(creds.get("demo_api_key") and creds.get("demo_api_secret"))
            has_real = bool(creds.get("real_api_key") and creds.get("real_api_secret"))
            
            if new_mode == "real" and not has_real:
                warnings.append("Bybit: No Real keys")
            elif new_mode == "demo" and not has_demo:
                warnings.append("Bybit: No Demo keys")
            elif new_mode == "both":
                if not has_real:
                    warnings.append("Bybit: No Real keys")
                if not has_demo:
                    warnings.append("Bybit: No Demo keys")
        
        # Check HyperLiquid credentials
        if db.is_hl_enabled(uid):
            hl_creds = db.get_hl_credentials(uid)
            has_testnet = bool(hl_creds.get("hl_testnet_private_key"))
            if not has_testnet and hl_creds.get("hl_private_key") and hl_creds.get("hl_testnet"):
                has_testnet = True
            has_mainnet = bool(hl_creds.get("hl_mainnet_private_key"))
            if not has_mainnet and hl_creds.get("hl_private_key") and not hl_creds.get("hl_testnet"):
                has_mainnet = True
            
            if new_mode == "real" and not has_mainnet:
                warnings.append("HL: No Mainnet key")
            elif new_mode == "demo" and not has_testnet:
                warnings.append("HL: No Testnet key")
            elif new_mode == "both":
                if not has_mainnet:
                    warnings.append("HL: No Mainnet key")
                if not has_testnet:
                    warnings.append("HL: No Testnet key")
        
        warning = ""
        if warnings:
            warning = " ‚ö†Ô∏è " + ", ".join(warnings)
        
        # Use Testnet/Mainnet labels for HyperLiquid
        active_exchange = db.get_exchange_type(uid) or "bybit"
        if active_exchange == "hyperliquid":
            mode_labels = {"demo": "üß™ Testnet", "real": "üåê Mainnet", "both": "üîÄ Both"}
        else:
            mode_labels = {"demo": "üéÆ Demo", "real": "üíµ Real", "both": "üîÄ Both"}
        await query.answer(f"{STRATEGY_NAMES_MAP[strategy]}: {mode_labels.get(new_mode, new_mode)}{warning}", show_alert=bool(warning))
        
        # Refresh the strategies menu
        cfg = get_user_config(uid)
        
        await query.message.edit_reply_markup(
            reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
        )
        return
    
    # Handle strategy trading mode - DIRECT MODE SELECTION
    # Format: strat_mode:{strategy}:{mode}
    # mode is: demo, real, or both
    if data.startswith("strat_mode:"):
        parts = data.split(":")
        if len(parts) >= 3:
            strategy = parts[1]
            new_mode = parts[2]  # demo, real, or both
        else:
            # Fallback for old format (cycling) - shouldn't happen anymore
            strategy = parts[1] if len(parts) > 1 else ""
            new_mode = "demo"
        
        logger.info(f"[STRAT_MODE] User {uid} setting {strategy} mode to: {new_mode}")
        
        if strategy not in STRATEGY_NAMES_MAP:
            await query.answer("Unknown strategy")
            return
        
        # Validate mode
        if new_mode not in ("demo", "real", "both"):
            new_mode = "demo"
        
        # Save trading_mode for this strategy
        db.set_strategy_trading_mode(uid, strategy, new_mode)
        logger.info(f"[STRAT_MODE] {strategy}: set to {new_mode}")
        
        # Check credentials and warn if needed
        warning = ""
        creds = db.get_all_user_credentials(uid)
        has_demo = bool(creds.get("demo_api_key") and creds.get("demo_api_secret"))
        has_real = bool(creds.get("real_api_key") and creds.get("real_api_secret"))
        
        if new_mode == "real" and not has_real:
            warning = " ‚ö†Ô∏è No Real API keys!"
        elif new_mode == "demo" and not has_demo:
            warning = " ‚ö†Ô∏è No Demo API keys!"
        elif new_mode == "both":
            if not has_real and not has_demo:
                warning = " ‚ö†Ô∏è No API keys!"
            elif not has_real:
                warning = " ‚ö†Ô∏è No Real API keys!"
            elif not has_demo:
                warning = " ‚ö†Ô∏è No Demo API keys!"
        
        # Use Testnet/Mainnet labels for HyperLiquid
        active_exchange = db.get_exchange_type(uid) or "bybit"
        if active_exchange == "hyperliquid":
            mode_labels = {"demo": "üß™ Testnet", "real": "üåê Mainnet", "both": "üîÄ Both"}
        else:
            mode_labels = {"demo": "üéÆ Demo", "real": "üíµ Real", "both": "üîÄ Both"}
        await query.answer(f"{STRATEGY_NAMES_MAP[strategy]}: {mode_labels.get(new_mode, new_mode)}{warning}", show_alert=bool(warning))
        
        # Refresh the strategies menu
        cfg = get_user_config(uid)
        
        await query.message.edit_reply_markup(
            reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
        )
        return
    
    if data.startswith("strat_set:"):
        strategy = data.split(":")[1]
        
        # Handle Spot settings - open spot settings menu
        if strategy == "spot":
            spot_settings = cfg.get("spot_settings") or {} or {}
            if not spot_settings:
                spot_settings = {
                    "coins": SPOT_DCA_COINS.copy() if isinstance(SPOT_DCA_COINS, list) else SPOT_DCA_COINS.split(","),
                    "dca_amount": SPOT_DCA_DEFAULT_AMOUNT,
                    "frequency": "manual",
                    "auto_dca": False,
                    "total_invested": 0.0,
                    "trading_mode": "demo",
                }
            msg = format_spot_settings_message(t, cfg, spot_settings)
            keyboard = get_spot_settings_keyboard(t, cfg, spot_settings)
            await query.message.edit_text(msg, reply_markup=keyboard, parse_mode="HTML")
            return
        
        if strategy in STRATEGY_NAMES_MAP:
            # Get settings for current exchange/account_type context
            context = get_user_trading_context(uid)
            
            # Get account types where strategy trades - use first one for reading settings
            account_types = db.get_strategy_account_types(uid, strategy)
            if not account_types:
                account_types = [context["account_type"]]
            primary_account = account_types[0]
            
            strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
            display_name = STRATEGY_NAMES_MAP[strategy]
            
            # Show which context we're viewing
            if context["exchange"] == "hyperliquid":
                ctx_label = "Testnet" if primary_account == "testnet" else "Mainnet"
            else:
                ctx_label = "Demo" if primary_account == "demo" else "Real"
            
            # Use unified build function for settings display
            lines = [t.get('strategy_param_header', '‚öôÔ∏è *{name} Settings*').format(name=display_name)]
            lines.append(f"_{context['exchange'].title()} / {ctx_label}_")
            lines.append("")
            
            # Build settings text based on strategy features
            settings_text = build_strategy_settings_text(strategy, strat_settings, t)
            # Skip header from build function since we already have it
            settings_lines = settings_text.split("\n")
            if len(settings_lines) > 1:
                lines.extend(settings_lines[2:])  # Skip header and empty line
            
            # Info for Enliko/Fibonacci strategies
            if strategy in ("elcaro", "fibonacci"):
                lines.append("")
                lines.append("‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
                if strategy == "elcaro":
                    lines.append(t.get('elcaro_ai_info', 'ü§ñ *AI-Powered Trading*'))
                    lines.append("")
                    lines.append(t.get('elcaro_ai_desc_new', '_Your SL/TP/ATR/Leverage settings apply to all Enliko signals._'))
                else:
                    lines.append(t.get('fibonacci_info', 'üìê *Fibonacci Extension*'))
                    lines.append("")
                    lines.append(t.get('fibonacci_desc_new', '_Your SL/TP/ATR settings apply to all Fibonacci signals._'))
            
            await query.message.edit_text(
                "\n".join(lines),
                parse_mode="Markdown",
                reply_markup=get_strategy_param_keyboard(strategy, t, strat_settings)
            )
        return
    
    # Global parameter setting - DEPRECATED, redirect to strategy settings
    if data.startswith("global_param:"):
        # Global settings removed - redirect to main strategy menu
        cfg = get_user_config(uid)
        await query.message.edit_text(
            t.get('global_settings_removed', '‚ö†Ô∏è *Global Settings Removed*\n\nPlease use per-strategy Long/Short settings instead.\n\nEach strategy now has its own Entry%, SL%, TP%, ATR settings.'),
            parse_mode="Markdown",
            reply_markup=get_strategy_settings_keyboard(t, cfg, uid=uid)
        )
        await query.answer()
        return
    
    if data.startswith("strat_param:"):
        parts = data.split(":")
        strategy = parts[1]
        param = parts[2]
        
        # Store in BOTH user_data and DB (DB survives bot restarts)
        ctx.user_data["strat_setting_mode"] = {"strategy": strategy, "param": param}
        db.set_pending_input(uid, "strat_setting", f"{strategy}:{param}")
        
        param_names = {
            "percent": t.get('prompt_entry_pct', 'Enter Entry % (risk per trade):'),
            "sl_percent": t.get('prompt_sl_pct', 'Enter Stop-Loss %:'),
            "tp_percent": t.get('prompt_tp_pct', 'Enter Take-Profit %:'),
            "atr_trigger_pct": t.get('prompt_atr_trigger', 'Enter Trigger % (profit to activate trailing):'),
            "atr_step_pct": t.get('prompt_atr_step', 'Enter Step % (SL distance from price):'),
            "leverage": t.get('prompt_leverage', 'Enter Leverage (1-100):'),
            "min_quality": t.get('prompt_min_quality', 'Enter Min Quality % (0-100):'),
            # LONG settings
            "long_percent": t.get('prompt_long_entry_pct', 'üìà LONG Entry % (risk per trade):'),
            "long_sl_percent": t.get('prompt_long_sl_pct', 'üìà LONG Stop-Loss %:'),
            "long_tp_percent": t.get('prompt_long_tp_pct', 'üìà LONG Take-Profit %:'),
            "long_leverage": t.get('prompt_long_leverage', 'üìà LONG Leverage (1-100):'),
            "long_atr_trigger_pct": t.get('prompt_long_atr_trigger', 'üìà LONG Trigger % (profit to activate):'),
            "long_atr_step_pct": t.get('prompt_long_atr_step', 'üìà LONG Step % (SL distance):'),
            "long_be_trigger_pct": t.get('prompt_long_be_trigger', 'üìà LONG BE Trigger % (move SL to entry):'),
            # LONG Partial TP settings
            "long_partial_tp_1_trigger_pct": t.get('prompt_long_ptp_1_trigger', 'üìà LONG Step 1: Trigger % (profit to close part):'),
            "long_partial_tp_1_close_pct": t.get('prompt_long_ptp_1_close', 'üìà LONG Step 1: Close % (part of position):'),
            "long_partial_tp_2_trigger_pct": t.get('prompt_long_ptp_2_trigger', 'üìà LONG Step 2: Trigger % (profit to close part):'),
            "long_partial_tp_2_close_pct": t.get('prompt_long_ptp_2_close', 'üìà LONG Step 2: Close % (part of position):'),
            # SHORT settings
            "short_percent": t.get('prompt_short_entry_pct', 'üìâ SHORT Entry % (risk per trade):'),
            "short_sl_percent": t.get('prompt_short_sl_pct', 'üìâ SHORT Stop-Loss %:'),
            "short_tp_percent": t.get('prompt_short_tp_pct', 'üìâ SHORT Take-Profit %:'),
            "short_leverage": t.get('prompt_short_leverage', 'üìâ SHORT Leverage (1-100):'),
            "short_atr_trigger_pct": t.get('prompt_short_atr_trigger', 'üìâ SHORT Trigger % (profit to activate):'),
            "short_atr_step_pct": t.get('prompt_short_atr_step', 'üìâ SHORT Step % (SL distance):'),
            "short_be_trigger_pct": t.get('prompt_short_be_trigger', 'üìâ SHORT BE Trigger % (move SL to entry):'),
            # SHORT Partial TP settings
            "short_partial_tp_1_trigger_pct": t.get('prompt_short_ptp_1_trigger', 'üìâ SHORT Step 1: Trigger % (profit to close part):'),
            "short_partial_tp_1_close_pct": t.get('prompt_short_ptp_1_close', 'üìâ SHORT Step 1: Close % (part of position):'),
            "short_partial_tp_2_trigger_pct": t.get('prompt_short_ptp_2_trigger', 'üìâ SHORT Step 2: Trigger % (profit to close part):'),
            "short_partial_tp_2_close_pct": t.get('prompt_short_ptp_2_close', 'üìâ SHORT Step 2: Close % (part of position):'),
            # Additional side-specific params
            "long_dca_pct_1": t.get('prompt_long_dca_1', 'üìà LONG DCA Leg 1 % (trigger):'),
            "long_dca_pct_2": t.get('prompt_long_dca_2', 'üìà LONG DCA Leg 2 % (trigger):'),
            "long_limit_offset_pct": t.get('prompt_long_limit_offset', 'üìà LONG Limit Offset %:'),
            "long_max_positions": t.get('prompt_long_max_positions', 'üìà LONG Max Positions (0=unlimited):'),
            "short_dca_pct_1": t.get('prompt_short_dca_1', 'üìâ SHORT DCA Leg 1 % (trigger):'),
            "short_dca_pct_2": t.get('prompt_short_dca_2', 'üìâ SHORT DCA Leg 2 % (trigger):'),
            "short_limit_offset_pct": t.get('prompt_short_limit_offset', 'üìâ SHORT Limit Offset %:'),
            "short_max_positions": t.get('prompt_short_max_positions', 'üìâ SHORT Max Positions (0=unlimited):'),
        }
        
        # Determine the correct cancel callback based on param prefix
        if param.startswith("long_"):
            cancel_callback = f"strat_side:{strategy}:long"
        elif param.startswith("short_"):
            cancel_callback = f"strat_side:{strategy}:short"
        else:
            cancel_callback = f"strat_set:{strategy}"
        
        await query.message.edit_text(
            param_names.get(param, f"Enter value for {param}:"),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get('btn_cancel', '‚ùå Cancel'), callback_data=cancel_callback)]
            ])
        )
        return
    
    if data.startswith("strat_reset:"):
        strategy = data.split(":")[1]
        # Reset all settings for this strategy to ENV defaults for current exchange
        from core.db_postgres import pg_reset_strategy_to_defaults
        current_exchange = get_exchange_type(uid)
        pg_reset_strategy_to_defaults(uid, strategy, exchange=current_exchange)
        
        await query.answer(t.get('settings_reset_defaults', 'Settings reset to defaults'))
        
        # Go back to strategy menu
        await callback_strategy_settings(update, ctx)
        return
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  DIRECTION TOGGLE: cycles all -> long -> short -> all  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    if data.startswith("strat_dir_toggle:"):
        strategy = data.split(":")[1]
        context = get_user_trading_context(uid)
        current_exchange = context["exchange"]
        strat_settings = db.get_strategy_settings(uid, strategy, current_exchange, context["account_type"])
        
        long_enabled = strat_settings.get("long_enabled", True)
        short_enabled = strat_settings.get("short_enabled", True)
        
        # Determine current and next state
        if long_enabled and short_enabled:
            # all -> long only
            db.set_strategy_setting(uid, strategy, "long_enabled", True, current_exchange)
            db.set_strategy_setting(uid, strategy, "short_enabled", False, current_exchange)
            new_dir = "LONG only"
        elif long_enabled and not short_enabled:
            # long only -> short only
            db.set_strategy_setting(uid, strategy, "long_enabled", False, current_exchange)
            db.set_strategy_setting(uid, strategy, "short_enabled", True, current_exchange)
            new_dir = "SHORT only"
        else:
            # short only or disabled -> all
            db.set_strategy_setting(uid, strategy, "long_enabled", True, current_exchange)
            db.set_strategy_setting(uid, strategy, "short_enabled", True, current_exchange)
            new_dir = "ALL"
        
        await query.answer(f"Direction: {new_dir}")
        
        # Refresh strategy settings menu
        strat_settings = db.get_strategy_settings(uid, strategy, current_exchange, context["account_type"])
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        lines = [t.get('strategy_param_header', '‚öôÔ∏è *{name} Settings*').format(name=display_name)]
        lines.append("")
        lines.append(f"üéØ Direction: *{new_dir}*")
        
        await query.message.edit_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=get_strategy_param_keyboard(strategy, t, strat_settings)
        )
        return
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  SIDE SETTINGS: open LONG or SHORT settings menu  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    if data.startswith("strat_side:"):
        parts = data.split(":")
        strategy = parts[1]
        side = parts[2]  # 'long' or 'short'
        
        context = get_user_trading_context(uid)
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
        global_cfg = db.get_user_config(uid)  # Get global settings for fallback
        
        emoji = "üìà" if side == "long" else "üìâ"
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        # Build rich header with current values
        from coin_params import STRATEGY_DEFAULTS
        defaults = STRATEGY_DEFAULTS.get(side, {})
        
        def _get_side_val(key, default):
            val = strat_settings.get(f"{side}_{key}")
            return val if val is not None else defaults.get(key, default)
        
        entry_pct = _get_side_val("percent", 3.0)
        sl_pct = _get_side_val("sl_percent", 30.0)
        tp_pct = _get_side_val("tp_percent", 10.0)
        use_atr = bool(strat_settings.get(f"{side}_use_atr") or defaults.get("use_atr", False))
        
        atr_indicator = "üìä ATR" if use_atr else "üéØ TP"
        
        lines = [
            f"{emoji} *{display_name} - {side.upper()} Settings*",
            "",
            f"üìä Entry: *{entry_pct}%* ‚îÇ üîª SL: *{sl_pct}%* ‚îÇ üéØ TP: *{tp_pct}%*",
            f"Mode: *{atr_indicator}*",
        ]
        
        await query.message.edit_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=get_strategy_side_keyboard(strategy, side, t, strat_settings, global_cfg)
        )
        return
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  SIDE TOGGLE: enable/disable LONG or SHORT  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    if data.startswith("strat_side_toggle:"):
        parts = data.split(":")
        strategy = parts[1]
        side = parts[2]  # 'long' or 'short'
        
        context = get_user_trading_context(uid)
        current_exchange = context["exchange"]
        strat_settings = db.get_strategy_settings(uid, strategy, current_exchange, context["account_type"])
        global_cfg = db.get_user_config(uid)  # Get global settings for fallback
        
        field = f"{side}_enabled"
        current = strat_settings.get(field, True)
        new_val = not current
        
        db.set_strategy_setting(uid, strategy, field, new_val, current_exchange)
        
        # CRITICAL SYNC: Update users.trade_* to reflect if at least one side is enabled
        # Re-read settings to get updated values
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
        long_enabled = strat_settings.get("long_enabled", True)
        short_enabled = strat_settings.get("short_enabled", True)
        
        # Map strategy to trade_* field
        trade_field_map = {
            "oi": "trade_oi",
            "rsi_bb": "trade_rsi_bb",
            "scryptomera": "trade_scryptomera",
            "scalper": "trade_scalper",
            "elcaro": "trade_elcaro",
            "fibonacci": "trade_fibonacci",
        }
        trade_field = trade_field_map.get(strategy)
        if trade_field:
            # If at least one side is enabled, trade_* should be 1
            # If both sides are disabled, trade_* should be 0
            trade_enabled = 1 if (long_enabled or short_enabled) else 0
            current_trade = global_cfg.get(trade_field, 0)
            if trade_enabled != current_trade:
                set_user_field(uid, trade_field, trade_enabled)
                logger.info(f"[{uid}] Side toggle synced trade_{strategy}={trade_enabled} (long={long_enabled}, short={short_enabled})")
        
        status = "‚úÖ Enabled" if new_val else "‚ùå Disabled"
        await query.answer(f"{side.upper()}: {status}")
        
        # Refresh side settings menu
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
        global_cfg = db.get_user_config(uid)  # Re-read to get updated trade_* value
        
        # Build header with current values
        lines = _build_side_settings_header(strategy, side, strat_settings)
        
        await query.message.edit_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=get_strategy_side_keyboard(strategy, side, t, strat_settings, global_cfg)
        )
        return
    
    # DCA toggle
    if data == "dca_toggle":
        current = cfg.get("dca_enabled", 0)
        new_val = 0 if current else 1
        set_user_field(uid, "dca_enabled", new_val)
        cfg = get_user_config(uid)
        
        status = t.get('status_enabled', 'Enabled') if new_val else t.get('status_disabled', 'Disabled')
        await query.answer(f"DCA: {status}")
        
        # Refresh DCA settings
        text = t.get('dca_settings_header', '‚öôÔ∏è *DCA Settings (Futures)*\n\n')
        text += f"*{t.get('dca_status', 'Status')}*: {'‚úÖ' if new_val else '‚ùå'} {status}\n\n"
        text += f"üìâ *Leg 1*: -{cfg.get('dca_pct_1', 10.0)}%\n"
        text += f"üìâ *Leg 2*: -{cfg.get('dca_pct_2', 25.0)}%\n\n"
        text += t.get('dca_description', '_DCA will add to position when price moves against you._')
        
        await query.message.edit_text(
            text,
            parse_mode="Markdown",
            reply_markup=get_dca_settings_keyboard(t, cfg)
        )
        return
    
    if data.startswith("dca_param:"):
        param = data.split(":")[1]
        ctx.user_data["dca_setting_mode"] = param
        
        param_names = {
            "dca_pct_1": t.get('prompt_dca_leg1', 'Enter DCA Leg 1 % (e.g., 10):'),
            "dca_pct_2": t.get('prompt_dca_leg2', 'Enter DCA Leg 2 % (e.g., 25):'),
        }
        
        await query.message.edit_text(
            param_names.get(param, f"Enter value for {param}:"),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get('btn_cancel', '‚ùå Cancel'), callback_data="strat_set:dca")]
            ])
        )
        return
    
    # Order type toggle: market <-> limit
    if data.startswith("strat_order_type:"):
        parts = data.split(":")
        strategy = parts[1]
        current_type = parts[2]
        
        # Get context
        context = get_user_trading_context(uid)
        
        # Toggle order type - save to 'default' (applies to all accounts via fallback)
        new_type = "limit" if current_type == "market" else "market"
        db.set_strategy_setting(uid, strategy, "order_type", new_type,
                               context["exchange"])  # account_type='default' by default
        
        type_labels = {
            "market": t.get('order_type_market', '‚ö° Market orders'),
            "limit": t.get('order_type_limit', 'üéØ Limit orders'),
        }
        await query.answer(type_labels.get(new_type, new_type))
        
        # Refresh the settings view - use primary account from strategy account_types
        primary_account = account_types[0] if account_types else context["account_type"]
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        lines = [t.get('strategy_param_header', '‚öôÔ∏è *{name} Settings*').format(name=display_name)]
        lines.append("")
        
        # Order type
        order_type = strat_settings.get("order_type", "market")
        order_emoji = "üéØ" if order_type == "limit" else "‚ö°"
        order_label = "Limit" if order_type == "limit" else "Market"
        lines.append(f"*Order Type*: {order_emoji} {order_label}")
        lines.append("")
        
        global_lbl = t.get('global_default', 'Global')
        pct = strat_settings.get("percent")
        sl = strat_settings.get("sl_percent")
        tp = strat_settings.get("tp_percent")
        lines.append(f"Entry %: {pct if pct is not None else global_lbl}")
        lines.append(f"SL %: {sl if sl is not None else global_lbl}")
        lines.append(f"TP %: {tp if tp is not None else global_lbl}")
        lines.append("")
        atr_per = strat_settings.get("atr_periods")
        atr_mult = strat_settings.get("atr_multiplier_sl")
        atr_trig = strat_settings.get("atr_trigger_pct")
        lines.append(f"ATR Periods: {atr_per if atr_per is not None else global_lbl}")
        lines.append(f"ATR Mult (SL step): {atr_mult if atr_mult is not None else global_lbl}")
        lines.append(f"ATR Trigger %: {atr_trig if atr_trig is not None else global_lbl}")
        
        # Show Scryptomera-specific settings
        if strategy == "scryptomera":
            lines.append("")
            direction = strat_settings.get("direction", "all")
            dir_emoji = {"all": "üîÑ", "long": "üìà", "short": "üìâ"}.get(direction, "üîÑ")
            dir_label = {"all": "ALL", "long": "LONG only", "short": "SHORT only"}.get(direction, "ALL")
            lines.append(f"*Direction*: {dir_emoji} {dir_label}")
            
            l_pct = strat_settings.get("long_percent")
            l_sl = strat_settings.get("long_sl_percent")
            l_tp = strat_settings.get("long_tp_percent")
            if any(v is not None for v in [l_pct, l_sl, l_tp]):
                lines.append(f"üìà LONG: Entry={l_pct or global_lbl}, SL={l_sl or global_lbl}, TP={l_tp or global_lbl}")
            
            s_pct = strat_settings.get("short_percent")
            s_sl = strat_settings.get("short_sl_percent")
            s_tp = strat_settings.get("short_tp_percent")
            if any(v is not None for v in [s_pct, s_sl, s_tp]):
                lines.append(f"üìâ SHORT: Entry={s_pct or global_lbl}, SL={s_sl or global_lbl}, TP={s_tp or global_lbl}")
        
        await query.message.edit_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=get_strategy_param_keyboard(strategy, t, strat_settings)
        )
        return
    
    # Universal direction toggle handler for ALL strategies
    for strat_name in STRATEGY_NAMES_MAP.keys():
        if data.startswith(f"{strat_name}_dir:"):
            current = data.split(":")[1]
            next_dir = {"all": "long", "long": "short", "short": "all"}.get(current, "all")
            
            # Get context
            context = get_user_trading_context(uid)
            
            # Save new direction to 'default' (applies to all accounts via fallback)
            db.set_strategy_setting(uid, strat_name, "direction", next_dir,
                                   context["exchange"])  # account_type='default' by default
            
            dir_labels = {
                "all": t.get('dir_all', 'üîÑ ALL (LONG + SHORT)'),
                "long": t.get('dir_long_only', 'üìà LONG only'),
                "short": t.get('dir_short_only', 'üìâ SHORT only'),
            }
            await query.answer(dir_labels.get(next_dir, next_dir))
            
            # Refresh the settings view with updated settings
            strat_settings = db.get_strategy_settings(uid, strat_name, context["exchange"], context["account_type"])
            
            await query.message.edit_text(
                build_strategy_settings_text(strat_name, strat_settings, t),
                parse_mode="Markdown",
                reply_markup=get_strategy_param_keyboard(strat_name, t, strat_settings)
            )
            return
    
    # Universal LONG/SHORT side settings for ALL strategies with side_settings feature
    for strat_name in STRATEGY_NAMES_MAP.keys():
        features = STRATEGY_FEATURES.get(strat_name, {})
        if not features.get("side_settings"):
            continue
            
        if data.startswith(f"{strat_name}_side:"):
            side = data.split(":")[1]  # "long" or "short"
            
            # Get context for proper settings
            context = get_user_trading_context(uid)
            strat_settings = db.get_strategy_settings(uid, strat_name, context["exchange"], context["account_type"])
            
            side_upper = side.upper()
            emoji = "üìà" if side == "long" else "üìâ"
            global_lbl = t.get('global_default', 'Global')
            display_name = STRATEGY_NAMES_MAP.get(strat_name, strat_name.upper())
            
            pct = strat_settings.get(f"{side}_percent")
            sl = strat_settings.get(f"{side}_sl_percent")
            tp = strat_settings.get(f"{side}_tp_percent")
            atr_trigger = strat_settings.get(f"{side}_atr_trigger_pct")
            use_atr = strat_settings.get("use_atr", 0)
            
            lines = [f"{emoji} *{display_name} {side_upper} Settings*"]
            lines.append("")
            lines.append(f"Entry %: {pct if pct is not None else global_lbl}")
            
            # SL/TP only for strategies that support it (not elcaro/fibonacci)
            if strat_name not in ("elcaro", "fibonacci"):
                lines.append(f"SL %: {sl if sl is not None else global_lbl}")
                lines.append(f"TP %: {tp if tp is not None else global_lbl}")
            
            # ATR params only if ATR is enabled for this strategy
            if features.get("use_atr") and use_atr:
                atr_periods = strat_settings.get(f"{side}_atr_periods")
                atr_mult = strat_settings.get(f"{side}_atr_multiplier_sl")
                lines.append(f"ATR Periods: {atr_periods if atr_periods is not None else global_lbl}")
                lines.append(f"ATR Multiplier: {atr_mult if atr_mult is not None else global_lbl}")
                lines.append(f"ATR Trigger %: {atr_trigger if atr_trigger is not None else global_lbl}")
            
            global_cfg = db.get_user_config(uid)  # For fallback display
            await query.message.edit_text(
                "\n".join(lines),
                parse_mode="Markdown",
                reply_markup=get_strategy_side_keyboard(strat_name, side, t, strat_settings, global_cfg)
            )
            return
    
    # ATR toggle for strategies
    if data.startswith("strat_atr_toggle:"):
        strategy = data.split(":")[1]
        # Get context
        context = get_user_trading_context(uid)
        
        # Get account types where strategy trades - use first one for reading settings
        account_types = db.get_strategy_account_types(uid, strategy)
        if not account_types:
            account_types = [context["account_type"]]
        primary_account = account_types[0]
        
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        # Use 'or 0' because get() returns None if key exists with None value
        current = strat_settings.get("use_atr") or 0
        new_value = 0 if current else 1
        
        logger.info(f"[{uid}] ATR toggle for {strategy}: {current} -> {new_value}")
        
        # Save to 'default' (applies to all accounts via fallback)
        db.set_strategy_setting(uid, strategy, "use_atr", new_value,
                                context["exchange"])  # account_type='default' by default
        logger.info(f"[{uid}] ATR toggle saved to default (fallback for all accounts)")
        
        status = t.get('atr_enabled', '‚úÖ ATR Trailing enabled') if new_value else t.get('atr_disabled', '‚ùå ATR Trailing disabled')
        await query.answer(status)
        
        # Refresh settings from primary account
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        
        await query.message.edit_text(
            build_strategy_settings_text(strategy, strat_settings, t),
            parse_mode="Markdown",
            reply_markup=get_strategy_param_keyboard(strategy, t, strat_settings)
        )
        return
    
    # Side-specific ATR toggle (LONG/SHORT)
    if data.startswith("strat_side_atr_toggle:"):
        parts = data.split(":")
        strategy = parts[1]
        side = parts[2]  # 'long' or 'short'
        
        # Get context
        context = get_user_trading_context(uid)
        account_types = db.get_strategy_account_types(uid, strategy)
        if not account_types:
            account_types = [context["account_type"]]
        primary_account = account_types[0]
        
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        param_name = f"{side}_use_atr"
        current = strat_settings.get(param_name) or 0
        new_value = 0 if current else 1
        
        logger.info(f"[{uid}] {side.upper()} ATR toggle for {strategy}: {current} -> {new_value}")
        
        # Save to 'default' (applies to all accounts via fallback)
        db.set_strategy_setting(uid, strategy, param_name, new_value,
                                context["exchange"])  # account_type='default' by default
        
        status = t.get('atr_enabled', '‚úÖ ATR Trailing enabled') if new_value else t.get('atr_disabled', '‚ùå ATR Trailing disabled')
        await query.answer(f"{side.upper()}: {status}")
        
        # Refresh settings and show side menu
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        global_cfg = db.get_user_config(uid)  # For fallback display
        side_emoji = "üìà" if side == "long" else "üìâ"
        side_label = t.get(f'side_{side}', side.upper())
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        await query.message.edit_text(
            f"{side_emoji} *{display_name} - {side_label}*\n\n" + 
            t.get('side_settings_hint', 'Configure settings for this direction:'),
            parse_mode="Markdown",
            reply_markup=get_strategy_side_keyboard(strategy, side, t, strat_settings, global_cfg)
        )
        return
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Side-specific Break-Even toggle and settings (LONG/SHORT)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data.startswith("strat_side_be:"):
        parts = data.split(":")
        strategy = parts[1]
        side = parts[2]  # 'long' or 'short'
        action = parts[3]  # 'toggle' or 'trigger'
        
        # Get context
        context = get_user_trading_context(uid)
        account_types = db.get_strategy_account_types(uid, strategy)
        if not account_types:
            account_types = [context["account_type"]]
        primary_account = account_types[0]
        
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        
        if action == "toggle":
            param_name = f"{side}_be_enabled"
            current = strat_settings.get(param_name) or 0
            new_value = 0 if current else 1
            
            logger.info(f"[{uid}] {side.upper()} BE toggle for {strategy}: {current} -> {new_value}")
            
            # Save to 'default' (applies to all accounts via fallback)
            db.set_strategy_setting(uid, strategy, param_name, new_value,
                                    context["exchange"])  # account_type='default' by default
            
            status = t.get('be_status_enabled', '‚úÖ Break-Even enabled') if new_value else t.get('be_status_disabled', '‚ùå Break-Even disabled')
            await query.answer(f"{side.upper()}: {status}")
            
        elif action == "trigger":
            # Prompt for BE trigger input
            ctx.user_data["strat_param_mode"] = f"{strategy}:{side}_be_trigger_pct"
            current_val = strat_settings.get(f"{side}_be_trigger_pct") or 1.0
            
            await query.message.edit_text(
                t.get('prompt_be_trigger', 'üéØ *Break-Even Trigger %*\n\nEnter the profit % at which SL moves to entry.\n\nCurrent: {current}%\n\nExample: 1 = move SL to entry when +1% profit').format(
                    current=current_val
                ),
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get('btn_cancel', '‚ùå Cancel'), callback_data=f"strat_side:{strategy}:{side}")]
                ])
            )
            return
        
        # Refresh settings and show side menu
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        global_cfg = db.get_user_config(uid)  # For fallback display
        side_emoji = "üìà" if side == "long" else "üìâ"
        side_label = t.get(f'side_{side}', side.upper())
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        await query.message.edit_text(
            f"{side_emoji} *{display_name} - {side_label}*\n\n" + 
            t.get('side_settings_hint', 'Configure settings for this direction:'),
            parse_mode="Markdown",
            reply_markup=get_strategy_side_keyboard(strategy, side, t, strat_settings, global_cfg)
        )
        return
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Side-specific Partial Take Profit toggle and settings (LONG/SHORT)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data.startswith("strat_side_ptp:"):
        parts = data.split(":")
        strategy = parts[1]
        side = parts[2]  # 'long' or 'short'
        action = parts[3]  # 'toggle', 'step1', 'step2'
        
        # Get context
        context = get_user_trading_context(uid)
        account_types = db.get_strategy_account_types(uid, strategy)
        if not account_types:
            account_types = [context["account_type"]]
        primary_account = account_types[0]
        
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        
        if action == "toggle":
            param_name = f"{side}_partial_tp_enabled"
            current = strat_settings.get(param_name) or 0
            new_value = 0 if current else 1
            
            logger.info(f"[{uid}] {side.upper()} Partial TP toggle for {strategy}: {current} -> {new_value}")
            
            db.set_strategy_setting(uid, strategy, param_name, new_value, context["exchange"])
            
            status = t.get('partial_tp_status_enabled', '‚úÖ Partial TP enabled') if new_value else t.get('partial_tp_status_disabled', '‚ùå Partial TP disabled')
            await query.answer(f"{side.upper()}: {status}")
            
        elif action == "step1":
            # Show step 1 settings menu
            current_trigger = strat_settings.get(f"{side}_partial_tp_1_trigger_pct") or 2.0
            current_close = strat_settings.get(f"{side}_partial_tp_1_close_pct") or 30.0
            
            await query.message.edit_text(
                t.get('partial_tp_step1_menu', '‚úÇÔ∏è *Partial TP - Step 1*\n\nClose {close}% of position at +{trigger}% profit\n\n_Select parameter to change:_').format(
                    trigger=current_trigger, close=current_close
                ),
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(
                        f"üéØ {t.get('trigger_pct', 'Trigger')}: +{current_trigger}%", 
                        callback_data=f"strat_param:{strategy}:{side}_partial_tp_1_trigger_pct"
                    )],
                    [InlineKeyboardButton(
                        f"‚úÇÔ∏è {t.get('close_pct', 'Close')}: {current_close}%", 
                        callback_data=f"strat_param:{strategy}:{side}_partial_tp_1_close_pct"
                    )],
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data=f"strat_side:{strategy}:{side}")]
                ])
            )
            return
            
        elif action == "step2":
            # Show step 2 settings menu
            current_trigger = strat_settings.get(f"{side}_partial_tp_2_trigger_pct") or 5.0
            current_close = strat_settings.get(f"{side}_partial_tp_2_close_pct") or 30.0
            
            await query.message.edit_text(
                t.get('partial_tp_step2_menu', '‚úÇÔ∏è *Partial TP - Step 2*\n\nClose {close}% of position at +{trigger}% profit\n\n_Select parameter to change:_').format(
                    trigger=current_trigger, close=current_close
                ),
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(
                        f"üéØ {t.get('trigger_pct', 'Trigger')}: +{current_trigger}%", 
                        callback_data=f"strat_param:{strategy}:{side}_partial_tp_2_trigger_pct"
                    )],
                    [InlineKeyboardButton(
                        f"‚úÇÔ∏è {t.get('close_pct', 'Close')}: {current_close}%", 
                        callback_data=f"strat_param:{strategy}:{side}_partial_tp_2_close_pct"
                    )],
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data=f"strat_side:{strategy}:{side}")]
                ])
            )
            return
        
        # Refresh settings and show side menu
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        global_cfg = db.get_user_config(uid)
        side_emoji = "üìà" if side == "long" else "üìâ"
        side_label = t.get(f'side_{side}', side.upper())
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        await query.message.edit_text(
            f"{side_emoji} *{display_name} - {side_label}*\n\n" + 
            t.get('side_settings_hint', 'Configure settings for this direction:'),
            parse_mode="Markdown",
            reply_markup=get_strategy_side_keyboard(strategy, side, t, strat_settings, global_cfg)
        )
        return
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Side-specific Order Type toggle (LONG/SHORT Market/Limit)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data.startswith("strat_side_order_type:"):
        parts = data.split(":")
        strategy = parts[1]
        side = parts[2]  # 'long' or 'short'
        
        # Get context
        context = get_user_trading_context(uid)
        account_types = db.get_strategy_account_types(uid, strategy)
        if not account_types:
            account_types = [context["account_type"]]
        primary_account = account_types[0]
        
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        param_name = f"{side}_order_type"
        current = strat_settings.get(param_name) or "market"
        new_value = "limit" if current == "market" else "market"
        
        logger.info(f"[{uid}] {side.upper()} Order Type toggle for {strategy}: {current} -> {new_value}")
        
        # Save to database
        db.set_strategy_setting(uid, strategy, param_name, new_value, context["exchange"])
        
        status = "üéØ Limit" if new_value == "limit" else "‚ö° Market"
        await query.answer(f"{side.upper()}: {status}")
        
        # Refresh settings and show side menu
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        global_cfg = db.get_user_config(uid)
        side_emoji = "üìà" if side == "long" else "üìâ"
        side_label = t.get(f'side_{side}', side.upper())
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        await query.message.edit_text(
            f"{side_emoji} *{display_name} - {side_label}*\n\n" + 
            t.get('side_settings_hint', 'Configure settings for this direction:'),
            parse_mode="Markdown",
            reply_markup=get_strategy_side_keyboard(strategy, side, t, strat_settings, global_cfg)
        )
        return
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Side-specific DCA toggle (LONG/SHORT)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data.startswith("strat_side_dca_toggle:"):
        parts = data.split(":")
        strategy = parts[1]
        side = parts[2]  # 'long' or 'short'
        
        # Get context
        context = get_user_trading_context(uid)
        account_types = db.get_strategy_account_types(uid, strategy)
        if not account_types:
            account_types = [context["account_type"]]
        primary_account = account_types[0]
        
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        param_name = f"{side}_dca_enabled"
        current = strat_settings.get(param_name) or 0
        new_value = 0 if current else 1
        
        logger.info(f"[{uid}] {side.upper()} DCA toggle for {strategy}: {current} -> {new_value}")
        
        # Save to database
        db.set_strategy_setting(uid, strategy, param_name, new_value, context["exchange"])
        
        status = "‚úÖ DCA enabled" if new_value else "‚ùå DCA disabled"
        await query.answer(f"{side.upper()}: {status}")
        
        # Refresh settings and show side menu
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        global_cfg = db.get_user_config(uid)
        side_emoji = "üìà" if side == "long" else "üìâ"
        side_label = t.get(f'side_{side}', side.upper())
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        await query.message.edit_text(
            f"{side_emoji} *{display_name} - {side_label}*\n\n" + 
            t.get('side_settings_hint', 'Configure settings for this direction:'),
            parse_mode="Markdown",
            reply_markup=get_strategy_side_keyboard(strategy, side, t, strat_settings, global_cfg)
        )
        return
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Side-specific Coins selection (LONG/SHORT)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data.startswith("strat_side_coins:"):
        parts = data.split(":")
        strategy = parts[1]
        side = parts[2]  # 'long' or 'short'
        
        # Get context
        context = get_user_trading_context(uid)
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
        param_name = f"{side}_coins_group"
        current_group = strat_settings.get(param_name) or "ALL"
        
        buttons = [
            [InlineKeyboardButton(
                ("‚úì " if current_group == "ALL" else "") + "üåê ALL",
                callback_data=f"strat_side_coins_set:{strategy}:{side}:ALL"
            )],
            [InlineKeyboardButton(
                ("‚úì " if current_group in ("TOP", "TOP100") else "") + "üíé TOP",
                callback_data=f"strat_side_coins_set:{strategy}:{side}:TOP"
            )],
            [InlineKeyboardButton(
                ("‚úì " if current_group == "VOLATILE" else "") + "üî• VOLATILE",
                callback_data=f"strat_side_coins_set:{strategy}:{side}:VOLATILE"
            )],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data=f"strat_side:{strategy}:{side}")],
        ]
        
        side_emoji = "üìà" if side == "long" else "üìâ"
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        await query.message.edit_text(
            f"{side_emoji} *{display_name} {side.upper()}*\n\n" +
            t.get('select_coins_for_side', 'ü™ô Select coins group:'),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
        return
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # Side-specific Coins selection SET
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    if data.startswith("strat_side_coins_set:"):
        parts = data.split(":")
        strategy = parts[1]
        side = parts[2]  # 'long' or 'short'
        group = parts[3]  # 'ALL', 'TOP', 'VOLATILE'
        
        # Get context
        context = get_user_trading_context(uid)
        param_name = f"{side}_coins_group"
        
        logger.info(f"[{uid}] {side.upper()} Coins group set for {strategy}: {group}")
        
        # Save to database
        db.set_strategy_setting(uid, strategy, param_name, group, context["exchange"])
        
        await query.answer(f"{side.upper()}: {group}")
        
        # Refresh settings and show side menu
        account_types = db.get_strategy_account_types(uid, strategy)
        if not account_types:
            account_types = [context["account_type"]]
        primary_account = account_types[0]
        
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], primary_account)
        global_cfg = db.get_user_config(uid)
        side_emoji = "üìà" if side == "long" else "üìâ"
        side_label = t.get(f'side_{side}', side.upper())
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        await query.message.edit_text(
            f"{side_emoji} *{display_name} - {side_label}*\n\n" + 
            t.get('side_settings_hint', 'Configure settings for this direction:'),
            parse_mode="Markdown",
            reply_markup=get_strategy_side_keyboard(strategy, side, t, strat_settings, global_cfg)
        )
        return
    
    # Strategy coins group selection
    if data.startswith("strat_coins:"):
        strategy = data.split(":")[1]
        # Show coins group selection for this strategy
        context = db.get_user_trading_context(uid)
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
        current_group = strat_settings.get("coins_group")
        
        buttons = [
            [InlineKeyboardButton(
                ("‚úì " if current_group is None else "") + t.get('group_global', 'üìä Global (use common setting)'),
                callback_data=f"strat_coins_set:{strategy}:GLOBAL"
            )],
            [InlineKeyboardButton(
                ("‚úì " if current_group == "ALL" else "") + "üåê " + t.get('group_all', 'ALL'),
                callback_data=f"strat_coins_set:{strategy}:ALL"
            )],
            [InlineKeyboardButton(
                ("‚úì " if current_group in ("TOP", "TOP100") else "") + "üíé " + t.get('group_top', 'TOP'),
                callback_data=f"strat_coins_set:{strategy}:TOP"
            )],
            [InlineKeyboardButton(
                ("‚úì " if current_group == "VOLATILE" else "") + "üî• " + t.get('group_volatile', 'VOLATILE'),
                callback_data=f"strat_coins_set:{strategy}:VOLATILE"
            )],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data=f"strat_set:{strategy}")],
        ]
        
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        await query.message.edit_text(
            t.get('select_coins_for_strategy', 'ü™ô *Select coins group for {name}*').format(name=display_name),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
        return
    
    # Strategy coins group set
    if data.startswith("strat_coins_set:"):
        parts = data.split(":")
        strategy = parts[1]
        group = parts[2]  # "GLOBAL", "ALL", "TOP", "VOLATILE"
        
        # Get context
        context = get_user_trading_context(uid)
        
        # Set coins_group (None for global) - save to 'default' (applies to all accounts via fallback)
        new_value = None if group == "GLOBAL" else group
        db.set_strategy_setting(uid, strategy, "coins_group", new_value,
                               context["exchange"])  # account_type='default' by default
        
        group_labels = {
            "GLOBAL": t.get('group_global', 'üìä Global'),
            "ALL": "üåê " + t.get('group_all', 'ALL'),
            "TOP": "üíé " + t.get('group_top', 'TOP'),
            "TOP100": "üíé " + t.get('group_top', 'TOP'),  # backward compat
            "VOLATILE": "üî• " + t.get('group_volatile', 'VOLATILE'),
        }
        await query.answer(group_labels.get(group, group))
        
        # Go back to strategy settings - use current context
        strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
        display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
        
        lines = [t.get('strategy_param_header', '‚öôÔ∏è *{name} Settings*').format(name=display_name)]
        lines.append("")
        
        global_lbl = t.get('global_default', 'Global')
        
        # Coins group
        coins_group = strat_settings.get("coins_group")
        coins_label = coins_group if coins_group else global_lbl
        lines.append(f"*Coins*: {coins_label}")
        
        # Order type
        order_type = strat_settings.get("order_type", "market")
        order_emoji = "üéØ" if order_type == "limit" else "‚ö°"
        order_label = "Limit" if order_type == "limit" else "Market"
        lines.append(f"*Order Type*: {order_emoji} {order_label}")
        lines.append("")
        
        pct = strat_settings.get("percent")
        sl = strat_settings.get("sl_percent")
        tp = strat_settings.get("tp_percent")
        lines.append(f"Entry %: {pct if pct is not None else global_lbl}")
        lines.append(f"SL %: {sl if sl is not None else global_lbl}")
        lines.append(f"TP %: {tp if tp is not None else global_lbl}")
        
        await query.message.edit_text(
            "\n".join(lines),
            parse_mode="Markdown",
            reply_markup=get_strategy_param_keyboard(strategy, t, strat_settings)
        )
        return


@require_access
@with_texts
@log_calls
async def cmd_toggle_rsi_bb(update, ctx):
    uid = update.effective_user.id
    cfg = get_user_config(uid) or {}
    new = not bool(cfg.get("trade_rsi_bb", 0))
    set_user_field(uid, "trade_rsi_bb", int(new))
    await update.message.reply_text(
        ctx.t['toggle_rsi_bb_status'].format(
            feature=ctx.t['feature_rsi_bb'],
            status=ctx.t['status_enabled'] if new else ctx.t['status_disabled']
        ),
        reply_markup=main_menu_keyboard(ctx, update=update)
    )

@with_texts
@log_calls
async def cmd_start(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    user = update.effective_user
    
    # Check for deep link parameter (e.g., /start link_app or /start app_login)
    args = ctx.args
    if args and len(args) > 0:
        param = args[0]
        
        # Handle app_login - user came from iOS/Android app to login
        if param == "app_login":
            logger.info(f"[{uid}] User came from app via /start app_login - redirecting to /app_login")
            # Call cmd_app_login directly to generate login token and deep link
            await cmd_app_login(update, ctx)
            return
        
        # Handle link_app - user came from iOS/Android app to link Telegram
        if param == "link_app":
            logger.info(f"[{uid}] User came from app to link Telegram account")
            # User clicked "Link Telegram" in the app
            # Generate a linking token and send it back
            try:
                import secrets
                link_token = secrets.token_urlsafe(32)
                
                # Store in Redis with 5 min TTL
                from core.redis_client import get_redis
                redis = get_redis()
                token_data = {
                    "telegram_id": uid,
                    "telegram_username": user.username or "",
                    "telegram_first_name": user.first_name or "",
                    "telegram_last_name": user.last_name or "",
                    "created_at": datetime.datetime.now(datetime.timezone.utc).isoformat()
                }
                await redis.set(f"tg_link_token:{link_token}", json.dumps(token_data), ex=300)
                
                # Send linking instructions
                webapp_url = os.getenv("WEBAPP_URL", "https://enliko.com")
                link_url = f"{webapp_url}/auth/telegram/complete-link?token={link_token}"
                
                text = (
                    f"üîó <b>Link Telegram to Your Account</b>\n\n"
                    f"Your Telegram ID: <code>{uid}</code>\n"
                    f"Username: @{user.username or 'not set'}\n\n"
                    f"To complete linking, click the button below or copy this link to your browser:\n\n"
                    f"<code>{link_url}</code>\n\n"
                    f"‚è∞ This link expires in 5 minutes."
                )
                
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîó Complete Linking", url=link_url)],
                    [InlineKeyboardButton("‚ùå Cancel", callback_data="link_cancel")]
                ])
                
                await update.message.reply_text(text, parse_mode="HTML", reply_markup=keyboard)
                return
            except Exception as e:
                logger.exception(f"[{uid}] Failed to create link token: {e}")
                await update.message.reply_text(
                    "‚ùå Failed to create linking token. Please try again.",
                    parse_mode="HTML"
                )
                return

    if _is_banned(uid):
        await reply_with_keyboard(update, ctx, ctx.t['banned'])
        return

    if not _is_allowed_user(uid):
        await _notify_admin_new_user(update, ctx)
        await reply_with_keyboard(update, ctx, ctx.t['invite_only'])
        return

    cfg = get_user_config(uid) or {}
    if not cfg.get("terms_accepted", 0):
        await reply_with_keyboard(update, ctx, ctx.t['need_terms'])
        await cmd_terms(update, ctx)
        return
    
    # Check if user has accepted legal disclaimer (CRITICAL for compliance)
    if not cfg.get("disclaimer_accepted", 0):
        logger.info(f"[{uid}] Showing legal disclaimer (first time)")
        await show_disclaimer(update, ctx)
        return
    
    # Ensure Menu Button shows commands menu (configured via BotFather)
    try:
        await ctx.bot.set_chat_menu_button(chat_id=uid, menu_button=MenuButtonCommands())
    except Exception as e:
        logger.warning(f"Failed to set menu button for {uid}: {e}")

    # Send user guide PDF on first start (only once)
    if not cfg.get("guide_sent", 0):
        try:
            lang = cfg.get("lang", "en")
            pdf_buffer = get_user_guide_pdf(lang)
            guide_caption = ctx.t.get('guide_caption', 'üìö Trading Bot User Guide\n\nPlease read this guide to learn how to configure strategies and use the bot effectively.')
            await update.message.reply_document(
                document=InputFile(pdf_buffer, filename="Bybit_Trading_Bot_Guide.pdf"),
                caption=guide_caption
            )
            set_user_field(uid, "guide_sent", 1)
        except Exception as e:
            logger.warning(f"Failed to send user guide PDF to {uid}: {e}")

    # Build active strategies list for welcome message
    strategy_map = {
        "trade_oi": "üìä OI",
        "trade_rsi_bb": "üìâ RSI+BB", 
        "trade_scryptomera": "üîÆ Scryptomera",
        "trade_scalper": "üéØ Scalper",
        "trade_elcaro": "üî• Enliko",
        "trade_fibonacci": "üìê Fibonacci",
    }
    active_strategies = [name for key, name in strategy_map.items() if cfg.get(key, 0)]
    strategies_text = ", ".join(active_strategies) if active_strategies else ctx.t.get('no_strategies', '‚ùå None')
    
    welcome_text = f"{ctx.t['welcome']}\n\nüì° <b>Active Strategies:</b> {strategies_text}"
    await update.message.reply_text(welcome_text, reply_markup=main_menu_keyboard(ctx, update=update), parse_mode="HTML")

@with_texts
async def _notify_admin_new_user(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    u = update.effective_user
    uid = u.id
    name_raw = f"{u.first_name or ''} {u.last_name or ''}".strip() or ctx.t['mark_no']
    name = html.escape(name_raw)
    uname = f"@{u.username}" if u.username else ctx.t['mark_no']
    lang = getattr(u, "language_code", ctx.t['mark_no'])
    cfg = get_user_config(uid) or {}
    allowed = ctx.t['mark_yes'] if cfg.get('is_allowed') else ctx.t['mark_no']
    banned = ctx.t['mark_ban'] if cfg.get('is_banned') else ctx.t['mark_no']

    def T(k, **kw): 
        s = ctx.t.get(k, k)
        return s.format(**kw) if kw else s

    wave = T("wave")
    title = T("title")
    text = T("admin_new_user_html", wave=wave, title=title, uid=uid, name=name, uname=uname, lang=lang, allowed=allowed, banned=banned)
    kb = InlineKeyboardMarkup([[
        InlineKeyboardButton(T("btn_approve"), callback_data=f"mod:approve:{uid}"),
        InlineKeyboardButton(T("btn_ban"), callback_data=f"mod:ban:{uid}")
    ]])
    try:
        await ctx.bot.send_message(ADMIN_ID, text, parse_mode="HTML", reply_markup=kb, disable_web_page_preview=True)
    except Exception as e:
        logger.warning(T("admin_notify_fail", e=e))


@with_texts
@log_calls
async def on_moderate_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    admin_uid = update.effective_user.id
    if admin_uid != ADMIN_ID:
        await q.answer(ctx.t['not_allowed'], show_alert=True)
        return
    try:
        _, action, raw_uid = q.data.split(":", 2)
        target_uid = int(raw_uid)
    except Exception:
        await q.answer(ctx.t['bad_payload'], show_alert=True)
        return

    if action == "approve":
        set_user_field(target_uid, "is_allowed", 1)
        set_user_field(target_uid, "is_banned", 0)
        await q.edit_message_reply_markup(reply_markup=None)
        await q.message.reply_text(ctx.t['moderation_approved'].format(target=target_uid))
        try:
            await ctx.bot.send_message(target_uid, ctx.t['approved_user_dm'])
        except Exception:
            pass
    elif action == "ban":
        set_user_field(target_uid, "is_banned", 1)
        set_user_field(target_uid, "is_allowed", 0)
        await q.edit_message_reply_markup(reply_markup=None)
        await q.message.reply_text(ctx.t['moderation_banned'].format(target=target_uid))
        try:
            await ctx.bot.send_message(target_uid, ctx.t['banned_user_dm'])
        except Exception:
            pass
    else:
        await q.answer(ctx.t['unknown_action'], show_alert=True)

# Cache for realized PnL (TTL 5 minutes) to avoid slow API calls
_realized_pnl_cache: dict[str, tuple[float, float]] = {}  # key: "uid:days:account_type" -> (pnl, timestamp)
_REALIZED_PNL_CACHE_TTL = 300  # 5 minutes

@log_calls
async def fetch_realized_pnl(uid: int, days: int = 1, account_type: str | None = None, exchange: str | None = None) -> float:
    """
    Fetch realized PnL for the last N days.
    
    Args:
        uid: User ID
        days: Number of days to look back (default: 1)
        account_type: 'demo' or 'real' (defaults to user's trading_mode)
        exchange: 'bybit' or 'hyperliquid' (defaults to user's active exchange)
    
    Returns:
        Total realized PnL in USDT
    
    Note: Results are cached for 5 minutes to avoid slow API calls.
    """
    import time as _time
    
    # Determine exchange and account_type for cache key
    if exchange is None:
        exchange = db.get_exchange_type(uid) or 'bybit'
    if account_type is None:
        account_type = get_trading_mode(uid)
        if account_type == 'both':
            account_type = 'demo'
    
    # Check cache for days >= 7 (slow queries)
    cache_key = f"{uid}:{days}:{account_type}"
    if days >= 7 and cache_key in _realized_pnl_cache:
        cached_pnl, cached_ts = _realized_pnl_cache[cache_key]
        if _time.time() - cached_ts < _REALIZED_PNL_CACHE_TTL:
            logger.info(f"[{uid}] ‚ö° week_pnl from cache ({_time.time() - cached_ts:.0f}s old)")
            return cached_pnl
    
    total_pnl = 0.0
    
    if exchange == 'hyperliquid':
        # Use HyperLiquid adapter for PnL
        end_ts = int(time.time() * 1000)
        start_ts = end_ts - days * 24 * 60 * 60 * 1000
        try:
            creds = db.get_hl_credentials(uid)
            if creds:
                from hl_adapter import HLAdapter
                from core.account_utils import get_hl_credentials_for_account
                # Use account_type to determine correct network and key
                _acc = account_type or 'demo'
                private_key, is_testnet, _wallet = get_hl_credentials_for_account(creds, _acc)
                if not private_key:
                    # Fallback to legacy key
                    private_key = creds.get("hl_private_key")
                    is_testnet = bool(creds.get("hl_testnet", False))
                if private_key:
                    adapter = HLAdapter(
                        private_key=private_key,
                        testnet=is_testnet
                        # vault_address and main_wallet_address auto-discovered
                    )
                    try:
                        await adapter.initialize()
                        
                        # Get fills for the period
                        fills = await adapter.get_fills_by_time(start_ts, end_ts)
                        for fill in fills:
                            try:
                                total_pnl += float(fill.get("closedPnl") or fill.get("pnl") or 0.0)
                            except Exception:
                                pass
                    finally:
                        await adapter.close()
        except Exception as e:
            logger.warning(f"[{uid}] HL realized PnL fetch error: {e}")
    else:
        # Bybit - API limits to 7 days per request, so we need to chunk
        # Split into 7-day chunks to avoid "time range cannot exceed 7 days" error
        chunk_days = 7
        end_ts = int(time.time() * 1000)
        overall_start_ts = end_ts - days * 24 * 60 * 60 * 1000
        
        # Process in 7-day chunks from most recent to oldest
        chunk_end = end_ts
        while chunk_end > overall_start_ts:
            chunk_start = max(chunk_end - chunk_days * 24 * 60 * 60 * 1000, overall_start_ts)
            
            cursor = None
            while True:
                params = {
                    "category": "linear",
                    "startTime": chunk_start,
                    "endTime": chunk_end,
                    "limit": 100,      
                }
                if cursor:
                    params["cursor"] = cursor

                try:
                    res = await _bybit_request(uid, "GET", "/v5/position/closed-pnl", params=params, account_type=account_type)
                    for item in res.get("list", []):
                        total_pnl += float(item.get("closedPnl", 0))

                    cursor = res.get("nextPageCursor")
                    if not cursor:
                        break
                except Exception as e:
                    logger.warning(f"[{uid}] Bybit closed-pnl chunk error: {e}")
                    break
            
            # Move to next chunk (older period)
            chunk_end = chunk_start

    # Cache result for slow queries (days >= 7)
    if days >= 7:
        _realized_pnl_cache[cache_key] = (total_pnl, _time.time())
    
    return total_pnl

@require_access
@with_texts
@log_calls
async def cmd_account(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show account summary - OPTIMIZED with parallel fetching."""
    uid = update.effective_user.id
    try:
        # OPTIMIZED: Run all fetches in parallel
        tz_str = get_user_tz(uid)
        bal_task = fetch_usdt_balance(uid)
        pnl_today_task = fetch_today_realized_pnl(uid, tz_str=tz_str)
        pnl_week_task = fetch_realized_pnl(uid, days=7)
        positions_task = fetch_open_positions(uid)
        
        bal, pnl_today, pnl_week, positions = await asyncio.gather(
            bal_task, pnl_today_task, pnl_week_task, positions_task,
            return_exceptions=True
        )
        
        # Handle exceptions
        if isinstance(bal, Exception):
            bal = 0.0
        if isinstance(pnl_today, Exception):
            pnl_today = 0.0
        if isinstance(pnl_week, Exception):
            pnl_week = 0.0
        if isinstance(positions, Exception):
            positions = []
        
        total_unreal  = sum(float(p.get("unrealisedPnl", 0)) for p in positions)
        total_im      = sum(float(p.get("positionIM",      0)) for p in positions)
        unreal_pct    = (total_unreal / total_im * 100) if total_im else 0.0

        text = "\n".join([
            ctx.t['account_balance'].format(balance=bal),
            "",
            ctx.t['account_realized_header'],
            ctx.t['account_realized_day'].format(pnl=pnl_today),
            ctx.t['account_realized_week'].format(pnl=pnl_week),
            "",
            ctx.t['account_unreal_header'],
            ctx.t['account_unreal_total'].format(unreal=total_unreal),
            ctx.t['account_unreal_pct'].format(pct=unreal_pct),
        ])
        await update.message.reply_text(text, parse_mode="Markdown")
    except Exception as e:
        logger.exception("Error –≤ cmd_account")
        await update.message.reply_text(ctx.t.get("error_generic", "Error: {msg}").format(msg=str(e)))

@require_access
@with_texts
@log_calls
async def cmd_show_config(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    cfg = get_user_config(uid) or {}

    coins = cfg.get('coins')
    if isinstance(coins, str):
        coins_display = coins if coins else 'ALL'
    else:
        coins_display = ', '.join(coins) if coins else 'ALL'

    percent   = cfg.get('percent', 1)
    tp_pct    = cfg.get('tp_percent', 0)
    sl_pct    = cfg.get('sl_percent', 0)

    # Status emojis
    on = "‚úÖ"
    off = "‚ùå"
    
    lines = [
        ctx.t['config_header'],
        f"‚Ä¢ üí† {ctx.t.get('config_coins_label', 'Coins')}: {coins_display}",
        f"‚Ä¢ üìä {ctx.t.get('config_percent_label', '% per Trade')}: {percent}%",
        f"‚Ä¢ üéØ TP%: {tp_pct}%  |  üõë SL%: {sl_pct}%",
        f"‚Ä¢ {ctx.t['config_stop_mode'].format(mode = ctx.t['mode_atr'] if cfg.get('use_atr',0) else ctx.t['mode_fixed'])}",
        f"‚Ä¢ DCA: Leg1=-{cfg.get('dca_pct_1', 10.0)}%, Leg2=-{cfg.get('dca_pct_2', 25.0)}%",
        "",
        "*‚îÅ‚îÅ‚îÅ Strategies ‚îÅ‚îÅ‚îÅ*",
    ]
    
    # Strategy details
    strategy_info = [
        ("oi", "üìâ OI", "trade_oi"),
        ("rsi_bb", "üìä RSI+BB", "trade_rsi_bb"),
        ("scryptomera", "üê± Scryptomera", "trade_scryptomera"),
        ("scalper", "‚ö° Scalper", "trade_scalper"),
        ("elcaro", "üî• Enliko", "trade_elcaro"),
    ]
    
    global_lbl = ctx.t.get('global_default', 'Global')
    context = db.get_user_trading_context(uid)
    active_exchange = context.get("exchange", "bybit")
    account_type = context.get("account_type", "demo")
    
    for strat_key, strat_name, trade_field in strategy_info:
        is_enabled = cfg.get(trade_field, 0)
        status = on if is_enabled else off
        
        strat_settings = db.get_strategy_settings(uid, strat_key, active_exchange, account_type)
        order_type = strat_settings.get("order_type", "market")
        order_lbl = "üéØL" if order_type == "limit" else "‚ö°M"
        coins_group = strat_settings.get("coins_group") or global_lbl
        
        pct = strat_settings.get("percent")
        sl = strat_settings.get("sl_percent")
        tp = strat_settings.get("tp_percent")
        
        details = []
        if pct is not None:
            details.append(f"E:{pct}%")
        if sl is not None:
            details.append(f"SL:{sl}%")
        if tp is not None:
            details.append(f"TP:{tp}%")
        
        detail_str = ", ".join(details) if details else global_lbl
        
        line = f"{status} {strat_name}: {order_lbl} | {coins_group}"
        if details:
            line += f" | {detail_str}"
        
        # Scryptomera special - show direction
        if strat_key == "scryptomera":
            direction = strat_settings.get("direction", "all")
            dir_icon = {"all": "üîÑ", "long": "üìà", "short": "üìâ"}.get(direction, "üîÑ")
            line += f" | {dir_icon}"
        
        lines.append(line)

    text = "\n".join(lines)

    await update.message.reply_text(
        text,
        parse_mode="Markdown",
        reply_markup=main_menu_keyboard(ctx, update=update)
    )


@log_calls
async def fetch_account_balance(user_id: int, account_type: str = None) -> dict:
    """Fetch full account balance including totalEquity (all assets converted to USD).
    
    OPTIMIZED: Uses single request for UNIFIED account (all coins),
    extracts USDT data from the same response instead of separate request.
    
    Returns dict with:
    - total_equity: Total account value in USD (all coins)
    - total_wallet: Total wallet balance in USD
    - available_balance: Available for trading (total, all collateral)
    - used_margin: Margin used by open positions
    - usdt_wallet: USDT wallet balance
    - usdt_available: USDT available for trading (key metric!)
    - usdt_position_margin: USDT margin in positions
    - usdt_order_margin: USDT margin in orders
    - coins: List of individual coin balances
    """
    def safe_float(val, default=0.0):
        """Convert value to float, handling empty strings and None"""
        if val is None or val == "" or val == "":
            return default
        try:
            return float(val)
        except (ValueError, TypeError):
            return default
    
    # OPTIMIZED: Single request gets all coins including USDT details
    params = {"accountType": "UNIFIED"}
    try:
        res = await _bybit_request(user_id, "GET", "/v5/account/wallet-balance", params=params, account_type=account_type)
    except MissingAPICredentials:
        return {"total_equity": 0.0, "available_balance": 0.0, "used_margin": 0.0, "usdt_available": 0.0, "coins": []}
    
    # Extract USDT data from the same response (no separate request needed!)
    usdt_wallet = 0.0
    usdt_available = 0.0
    usdt_position_im = 0.0
    usdt_order_im = 0.0
    usdt_equity = 0.0
    
    for acct in res.get("list", []) or []:
        # Account-level totals (all coins combined, in USD)
        total_equity = safe_float(acct.get("totalEquity"))
        total_wallet = safe_float(acct.get("totalWalletBalance"))
        total_available = safe_float(acct.get("totalAvailableBalance"))
        total_margin = safe_float(acct.get("totalInitialMargin"))
        
        # Individual coin balances and calculate margin from coins
        coins = []
        total_position_im = 0.0
        total_order_im = 0.0
        for c in acct.get("coin", []) or []:
            coin_name = c.get("coin", "")
            wallet_bal = safe_float(c.get("walletBalance"))
            usd_value = safe_float(c.get("usdValue"))
            position_im = safe_float(c.get("totalPositionIM"))
            order_im = safe_float(c.get("totalOrderIM"))
            
            total_position_im += position_im
            total_order_im += order_im
            
            # Extract USDT data directly from coins list (was separate request!)
            if coin_name == "USDT":
                usdt_wallet = wallet_bal
                usdt_equity = safe_float(c.get("equity"))
                usdt_position_im = position_im
                usdt_order_im = order_im
                usdt_available = usdt_wallet - usdt_position_im - usdt_order_im
                if usdt_available < 0:
                    usdt_available = 0.0
            
            if wallet_bal > 0 or usd_value > 0:
                coins.append({
                    "coin": coin_name,
                    "balance": wallet_bal,
                    "usd_value": usd_value
                })
        
        # For Demo accounts, calculate from coin data if account-level is empty
        if total_available == 0 and total_wallet > 0:
            total_available = total_wallet - total_position_im - total_order_im
            if total_available < 0:
                total_available = 0.0
        
        if total_margin == 0:
            total_margin = total_position_im + total_order_im
        
        # If USDT margin is still 0 and it's demo, fetch from positions API (Demo fallback)
        # NOTE: This is async but happens rarely, only for demo accounts with empty margin data
        if usdt_position_im == 0 and account_type == "demo" and usdt_wallet > 0:
            try:
                pos_res = await _bybit_request(user_id, "GET", "/v5/position/list", 
                                               params={"category": "linear", "settleCoin": "USDT"}, 
                                               account_type=account_type)
                positions = pos_res.get("list", [])
                for p in positions:
                    usdt_position_im += safe_float(p.get("positionIM"))
                
                usdt_available = usdt_wallet - usdt_position_im - usdt_order_im
                if usdt_available < 0:
                    usdt_available = 0.0
                    
                if total_margin == 0:
                    total_margin = usdt_position_im + usdt_order_im
            except Exception as e:
                logger.warning(f"Failed to fetch positions for margin calc: {e}")
        
        return {
            "total_equity": total_equity,
            "total_wallet": total_wallet,
            "available_balance": total_available,
            "used_margin": total_margin,
            "usdt_wallet": usdt_wallet,
            "usdt_available": usdt_available,
            "usdt_position_margin": usdt_position_im,
            "usdt_order_margin": usdt_order_im,
            "usdt_equity": usdt_equity,
            "coins": coins
        }
    
    return {"total_equity": 0.0, "available_balance": 0.0, "used_margin": 0.0, "usdt_available": 0.0, "coins": []}


@log_calls
async def fetch_usdt_balance(user_id: int, account_type: str = None, use_equity: bool = True) -> float:
    """Fetch USDT balance for position sizing.
    
    Supports both Bybit and HyperLiquid exchanges.
    
    Args:
        use_equity: If True (default), returns total equity (walletBalance) for consistent
                    position sizing regardless of open positions.
                    If False, returns available margin (free funds).
    
    Using equity ensures entry% is always calculated from total capital,
    making position sizes consistent and predictable.
    """
    # Check exchange type
    user_exchange = db.get_exchange_type(user_id) or "bybit"
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # HYPERLIQUID BALANCE
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    if user_exchange == "hyperliquid":
        try:
            hl_creds = db.get_hl_credentials(user_id)
            if not hl_creds:
                logger.warning(f"[{user_id}] No HL credentials for balance fetch")
                return 0.0
            
            # Determine testnet/mainnet from account_type first, then trading_mode, lastly hl_testnet
            if account_type in ("testnet", "demo"):
                is_testnet = True
            elif account_type in ("mainnet", "real"):
                is_testnet = False
            else:
                # No explicit account_type ‚Äî derive from trading_mode
                trading_mode = get_trading_mode(user_id)
                is_testnet = trading_mode in ("demo", "testnet", "both")
            
            # Use canonical credential helper
            from core.account_utils import get_hl_credentials_for_account
            _acc = "testnet" if is_testnet else "mainnet"
            private_key, is_testnet, wallet_address = get_hl_credentials_for_account(hl_creds, _acc)
            
            if not private_key:
                logger.warning(f"[{user_id}] Missing HL private_key")
                return 0.0
            
            from hl_adapter import HLAdapter
            # Main wallet auto-discovered if agent wallet
            async with HLAdapter(private_key=private_key, testnet=is_testnet) as adapter:
                balance_result = await adapter.get_balance(use_cache=True)
                if balance_result.get("success"):
                    data = balance_result.get("data", {})
                    equity = data.get("equity", 0.0)
                    available = data.get("available", 0.0)
                    is_unified = data.get("is_unified_account", False)
                    
                    if use_equity:
                        logger.info(f"[{user_id}] HL USDC equity for sizing: {equity:.2f} (available={available:.2f}, unified={is_unified}) [{account_type or 'auto'}]")
                        return equity
                    else:
                        logger.info(f"[{user_id}] HL USDC available: {available:.2f} (equity={equity:.2f}, unified={is_unified}) [{account_type or 'auto'}]")
                        return available
                else:
                    logger.error(f"[{user_id}] HL balance error: {balance_result.get('error')}")
                    return 0.0
        except Exception as e:
            logger.error(f"[{user_id}] HL balance fetch error: {e}")
            return 0.0
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # BYBIT BALANCE
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    params = {"accountType": "UNIFIED", "coin": "USDT"}
    try:
        res = await _bybit_request(user_id, "GET", "/v5/account/wallet-balance", params=params, account_type=account_type)
    except MissingAPICredentials:
        return 0.0

    for acct in res.get("list", []) or []:
        for c in acct.get("coin", []) or []:
            if c.get("coin") == "USDT":
                try:
                    wallet_balance = float(c.get("walletBalance") or 0)
                    position_im = float(c.get("totalPositionIM") or 0)
                    order_im = float(c.get("totalOrderIM") or 0)
                    
                    # Available for trading = wallet - margin in positions - margin in orders
                    available = wallet_balance - position_im - order_im
                    if available < 0:
                        available = 0.0
                    
                    if use_equity:
                        # Use total equity for consistent position sizing
                        logger.info(f"[{user_id}] USDT equity for sizing: {wallet_balance:.2f} (available={available:.2f}) [{account_type or 'auto'}]")
                        return wallet_balance
                    else:
                        # Use available margin
                        logger.info(f"[{user_id}] USDT available: {available:.2f} (equity={wallet_balance:.2f}) [{account_type or 'auto'}]")
                        return available
                except (TypeError, ValueError) as e:
                    logger.warning(f"[{user_id}] Error parsing USDT balance: {e}")
                    return 0.0
    return 0.0


# ==============================================================================
# SPOT TRADING MODULE
# ==============================================================================

@log_calls
async def fetch_spot_balance(user_id: int, account_type: str = None, exchange: str = None) -> dict:
    """Fetch Spot account balances.
    
    Args:
        user_id: Telegram user ID
        account_type: 'demo', 'real' for Bybit; 'testnet', 'mainnet' for HyperLiquid
        exchange: 'bybit' or 'hyperliquid' (auto-detected if None)
    
    Returns dict like: {"USDT": 100.0, "BTC": 0.001, "ETH": 0.5}
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    exchange = exchange.lower()
    
    if exchange == "hyperliquid":
        # HyperLiquid spot balance
        try:
            hl_creds = db.get_hl_credentials(user_id)
            if not hl_creds:
                return {}
            
            # Determine testnet based on account_type
            is_testnet = account_type in ("testnet", "demo", None)  # Default to testnet for HL
            
            # Get appropriate key
            private_key = hl_creds.get("hl_testnet_private_key" if is_testnet else "hl_mainnet_private_key")
            if not private_key:
                private_key = hl_creds.get("hl_private_key")  # Legacy fallback
                is_testnet = hl_creds.get("hl_testnet", False)
            
            if not private_key:
                return {}
            
            adapter = HLAdapter(private_key=private_key, testnet=is_testnet)
            await adapter.initialize()
            
            result = await adapter.get_spot_balance()
            if not result.get("success"):
                logger.error(f"HL spot balance error: {result.get('error')}")
                return {}
            
            # Convert HL format to Bybit-like format: {coin: balance}
            balances = {}
            for token in result.get("data", {}).get("tokens", []):
                coin = token.get("token", "")
                total = token.get("total", 0)
                if total > 0:
                    balances[coin] = total
            
            return balances
        except Exception as e:
            logger.error(f"fetch_spot_balance HL error: {e}")
            return {}
    
    # Bybit spot balance (original logic)
    params = {"accountType": "UNIFIED"}
    try:
        res = await _bybit_request(user_id, "GET", "/v5/account/wallet-balance", params=params, account_type=account_type)
    except MissingAPICredentials:
        return {}
    except Exception as e:
        logger.error(f"fetch_spot_balance error: {e}")
        return {}
    
    balances = {}
    for acct in res.get("list", []) or []:
        for c in acct.get("coin", []) or []:
            coin = c.get("coin", "")
            try:
                wallet_bal = float(c.get("walletBalance") or 0.0)
                if wallet_bal > 0:
                    balances[coin] = wallet_bal
            except (TypeError, ValueError):
                pass
    return balances


@log_calls
async def get_spot_ticker(user_id: int, symbol: str, account_type: str = None, exchange: str = None) -> dict:
    """Get current price info for a spot symbol (e.g., BTCUSDT or BTC for HL).
    
    Args:
        user_id: Telegram user ID
        symbol: Symbol like "BTCUSDT" (Bybit) or "BTC" (HL)
        account_type: Account type
        exchange: 'bybit' or 'hyperliquid' (auto-detected if None)
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    exchange = exchange.lower()
    
    if exchange == "hyperliquid":
        try:
            hl_creds = db.get_hl_credentials(user_id)
            if not hl_creds:
                return {}
            
            # Normalize symbol for HL (remove USDT/USDC suffix)
            token = symbol.upper().replace("USDT", "").replace("USDC", "")
            
            is_testnet = account_type in ("testnet", "demo", None)
            private_key = hl_creds.get("hl_testnet_private_key" if is_testnet else "hl_mainnet_private_key")
            if not private_key:
                private_key = hl_creds.get("hl_private_key")
                is_testnet = hl_creds.get("hl_testnet", False)
            
            if not private_key:
                return {}
            
            adapter = HLAdapter(private_key=private_key, testnet=is_testnet)
            await adapter.initialize()
            
            result = await adapter.get_spot_ticker(token)
            if not result.get("success"):
                return {}
            
            # Convert HLAdapter format to Bybit-like format
            # HLAdapter returns: {"success": True, "mid_price": X, "mark_price": Y, "prev_day_price": Z}
            mid_price = result.get("mid_price") or result.get("mark_price") or 0
            prev_day_price = result.get("prev_day_price") or mid_price
            
            # Calculate 24h price change percentage
            price_change_pct = 0
            if prev_day_price and prev_day_price > 0 and mid_price:
                price_change_pct = (mid_price - prev_day_price) / prev_day_price
            
            return {
                "lastPrice": str(mid_price),
                "prevPrice24h": str(prev_day_price),
                "price24hPcnt": str(price_change_pct),
                "volume24h": str(result.get("day_volume", 0)),
            }
        except Exception as e:
            logger.error(f"get_spot_ticker HL error for {symbol}: {e}")
            return {}
    
    # Bybit spot ticker (original logic)
    params = {"category": "spot", "symbol": symbol}
    try:
        res = await _bybit_request(user_id, "GET", "/v5/market/tickers", params=params, account_type=account_type)
        tickers = res.get("list", [])
        if tickers:
            return tickers[0]
    except Exception as e:
        logger.error(f"get_spot_ticker error for {symbol}: {e}")
    return {}


# Cache for Fear & Greed Index (updates every hour)
_fear_greed_cache = {"value": 50, "timestamp": 0}

# Cache for spot auto-DCA last execution timestamps per user
# Key: user_id, Value: last execution unix timestamp
_spot_dca_last_exec: dict[int, int] = {}

# Frequency intervals in seconds
SPOT_DCA_INTERVALS = {
    "daily": 24 * 60 * 60,      # 24 hours
    "weekly": 7 * 24 * 60 * 60,  # 7 days
    "monthly": 30 * 24 * 60 * 60,  # 30 days (approximate)
}

async def get_fear_greed_index() -> int:
    """
    Fetch the Fear & Greed Index from alternative.me API.
    Returns a value from 0 (Extreme Fear) to 100 (Extreme Greed).
    Caches the result for 1 hour.
    """
    global _fear_greed_cache
    
    now = time.time()
    # Return cached value if less than 1 hour old
    if now - _fear_greed_cache["timestamp"] < 3600:
        return _fear_greed_cache["value"]
    
    try:
        async with _session.get(
            "https://api.alternative.me/fng/",
            timeout=ClientTimeout(total=10)
        ) as resp:
            if resp.status == 200:
                data = await resp.json()
                if data.get("data") and len(data["data"]) > 0:
                    value = int(data["data"][0].get("value", 50))
                    _fear_greed_cache = {"value": value, "timestamp": now}
                    logger.info(f"Fear & Greed Index updated: {value}")
                    return value
    except Exception as e:
        logger.warning(f"Failed to fetch Fear & Greed Index: {e}")
    
    # Return cached or default value on error
    return _fear_greed_cache.get("value", 50)


async def calculate_smart_dca_amount(
    base_amount: float,
    strategy: str,
    coin: str,
    spot_settings: dict,
    user_id: int,
    account_type: str = None,
    exchange: str = None,
) -> float:
    """
    Calculate the adjusted DCA amount based on the selected strategy.
    
    Strategies:
    - fixed: Always return base_amount
    - value_avg: Increase amount when price is below avg, decrease when above
    - fear_greed: Increase amount during market fear
    - dip_buy: Only buy on significant dips
    - crash_boost: 3x buy when price drops >15% in 24h
    - momentum: Buy more in uptrends, less in downtrends
    - rsi_based: Buy more when RSI < 30 (oversold)
    
    Supports both Bybit and HyperLiquid exchanges.
    
    Returns the adjusted amount (0 if should skip this buy).
    """
    if strategy == "fixed":
        return base_amount
    
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    exchange = exchange.lower()
    
    # Build symbol based on exchange
    if exchange == "hyperliquid":
        symbol = coin  # HL uses just the token name
    else:
        symbol = f"{coin}USDT"  # Bybit uses COINUSDT format
    
    if strategy == "fear_greed":
        # Get Fear & Greed Index
        fg_index = await get_fear_greed_index()
        fear_threshold = spot_settings.get("fear_threshold", 25)
        
        if fg_index <= fear_threshold:
            # Extreme fear - buy 2x
            multiplier = 2.0
            logger.info(f"Fear & Greed = {fg_index} (extreme fear) ‚Üí 2x multiplier")
        elif fg_index <= 40:
            # Fear - buy 1.5x
            multiplier = 1.5
        elif fg_index >= 75:
            # Extreme greed - skip or reduce
            multiplier = 0.5
            logger.info(f"Fear & Greed = {fg_index} (extreme greed) ‚Üí 0.5x multiplier")
        else:
            # Neutral
            multiplier = 1.0
        
        return base_amount * multiplier
    
    if strategy == "dip_buy":
        # Only buy if price dropped by X% from 7-day high
        dip_threshold = spot_settings.get("dip_threshold", 5.0)
        
        try:
            # Get current price
            ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
            current_price = float(ticker.get("lastPrice") or ticker.get("mid_price") or ticker.get("mark_price") or 0)
            
            if exchange == "hyperliquid":
                # HL doesn't have kline API for spot, use simpler logic
                logger.info(f"[HL] dip_buy strategy using current price only for {coin}")
                return base_amount  # Fallback to base amount for HL
            
            # Get 7-day high (using klines) - Bybit only
            params = {
                "category": "spot",
                "symbol": symbol,
                "interval": "D",
                "limit": 7,
            }
            res = await _bybit_request(user_id, "GET", "/v5/market/kline", params=params, account_type=account_type)
            klines = res.get("list", [])
            
            if klines and current_price > 0:
                high_7d = max(float(k[2]) for k in klines)  # k[2] is high price
                drop_pct = ((high_7d - current_price) / high_7d) * 100
                
                if drop_pct >= dip_threshold:
                    # It's a dip! Buy more based on how much it dropped
                    multiplier = 1.0 + (drop_pct / 10)  # +10% for each 10% drop
                    logger.info(f"{coin} dip detected: -{drop_pct:.1f}% from 7d high ‚Üí {multiplier:.1f}x")
                    return base_amount * multiplier
                else:
                    logger.info(f"{coin} not a dip ({drop_pct:.1f}% < {dip_threshold}%) ‚Üí skip")
                    return 0.0  # Skip this buy
        except Exception as e:
            logger.error(f"dip_buy calculation error for {coin}: {e}")
            return base_amount  # Fallback to base amount
    
    if strategy == "value_avg":
        # Value averaging - try to maintain steady growth
        # Buy more when below target, less when above
        try:
            ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
            change_24h = float(ticker.get("price24hPcnt", 0)) * 100
            
            if change_24h < -5:
                # Price down significantly - buy more
                multiplier = 1.5
            elif change_24h < 0:
                # Price down slightly - buy normal
                multiplier = 1.2
            elif change_24h > 10:
                # Price up significantly - buy less
                multiplier = 0.5
            elif change_24h > 5:
                # Price up - buy slightly less
                multiplier = 0.8
            else:
                multiplier = 1.0
            
            logger.info(f"{coin} 24h change: {change_24h:.1f}% ‚Üí {multiplier:.1f}x multiplier")
            return base_amount * multiplier
        except Exception as e:
            logger.error(f"value_avg calculation error for {coin}: {e}")
            return base_amount
    
    if strategy == "crash_boost":
        # Buy 3x when price crashes >15% in 24h
        crash_threshold = spot_settings.get("crash_threshold", -15.0)
        
        try:
            ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
            change_24h = float(ticker.get("price24hPcnt", 0)) * 100
            
            if change_24h <= crash_threshold:
                # CRASH! Buy 3x
                multiplier = 3.0
                logger.info(f"üö® {coin} CRASH detected: {change_24h:.1f}% ‚Üí 3x boost!")
            elif change_24h <= crash_threshold / 2:
                # Significant drop - buy 2x
                multiplier = 2.0
                logger.info(f"üìâ {coin} significant drop: {change_24h:.1f}% ‚Üí 2x boost")
            elif change_24h <= -5:
                # Minor drop - buy 1.5x
                multiplier = 1.5
            else:
                # Normal - buy 1x
                multiplier = 1.0
            
            return base_amount * multiplier
        except Exception as e:
            logger.error(f"crash_boost calculation error for {coin}: {e}")
            return base_amount
    
    if strategy == "momentum":
        # Buy more when momentum is positive (uptrend), less when negative
        try:
            ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
            change_24h = float(ticker.get("price24hPcnt", 0)) * 100
            
            if exchange == "hyperliquid":
                # HL doesn't have kline API for spot, use simpler logic
                if change_24h > 5:
                    multiplier = 1.5
                elif change_24h < -5:
                    multiplier = 0.5
                else:
                    multiplier = 1.0
                logger.info(f"[HL] {coin} 24h change: {change_24h:.1f}% ‚Üí {multiplier:.1f}x momentum")
                return base_amount * multiplier
            
            # Get 7-day trend - Bybit only
            params = {
                "category": "spot",
                "symbol": symbol,
                "interval": "D",
                "limit": 7,
            }
            res = await _bybit_request(user_id, "GET", "/v5/market/kline", params=params, account_type=account_type)
            klines = res.get("list", [])
            
            if klines and len(klines) >= 7:
                # Calculate 7-day momentum (latest close vs oldest close)
                latest_close = float(klines[0][4])
                oldest_close = float(klines[-1][4])
                momentum_7d = ((latest_close - oldest_close) / oldest_close) * 100
                
                if momentum_7d > 15 and change_24h > 0:
                    # Strong uptrend - buy more to ride momentum
                    multiplier = 1.5
                    logger.info(f"üöÄ {coin} momentum +{momentum_7d:.1f}% ‚Üí 1.5x")
                elif momentum_7d < -15 and change_24h < 0:
                    # Strong downtrend - buy less, wait for reversal
                    multiplier = 0.5
                    logger.info(f"üìâ {coin} negative momentum {momentum_7d:.1f}% ‚Üí 0.5x")
                elif momentum_7d < -10:
                    # Downtrend but maybe bottoming - normal buy
                    multiplier = 1.0
                else:
                    multiplier = 1.0
                
                return base_amount * multiplier
        except Exception as e:
            logger.error(f"momentum calculation error for {coin}: {e}")
            return base_amount
    
    if strategy == "rsi_based":
        # Buy more when RSI is oversold (<30), less when overbought (>70)
        if exchange == "hyperliquid":
            # HL doesn't have kline API for spot, use fixed strategy
            logger.info(f"[HL] rsi_based not supported for spot, using fixed amount for {coin}")
            return base_amount
        
        try:
            # Get 14-day klines for RSI calculation - Bybit only
            params = {
                "category": "spot",
                "symbol": symbol,
                "interval": "D",
                "limit": 20,  # Need extra for RSI calculation
            }
            res = await _bybit_request(user_id, "GET", "/v5/market/kline", params=params, account_type=account_type)
            klines = res.get("list", [])
            
            if klines and len(klines) >= 15:
                # Calculate RSI (simplified)
                closes = [float(k[4]) for k in reversed(klines)]  # Oldest first
                
                gains = []
                losses = []
                for i in range(1, len(closes)):
                    diff = closes[i] - closes[i-1]
                    if diff > 0:
                        gains.append(diff)
                        losses.append(0)
                    else:
                        gains.append(0)
                        losses.append(abs(diff))
                
                # Average gain and loss over 14 periods
                period = 14
                if len(gains) >= period:
                    avg_gain = sum(gains[-period:]) / period
                    avg_loss = sum(losses[-period:]) / period
                    
                    if avg_loss == 0:
                        rsi = 100
                    else:
                        rs = avg_gain / avg_loss
                        rsi = 100 - (100 / (1 + rs))
                    
                    if rsi < 30:
                        # Oversold - buy 2x
                        multiplier = 2.0
                        logger.info(f"üìê {coin} RSI={rsi:.1f} (oversold) ‚Üí 2x")
                    elif rsi < 40:
                        # Getting oversold - buy 1.5x
                        multiplier = 1.5
                    elif rsi > 70:
                        # Overbought - buy 0.5x
                        multiplier = 0.5
                        logger.info(f"üìê {coin} RSI={rsi:.1f} (overbought) ‚Üí 0.5x")
                    elif rsi > 60:
                        # Getting overbought - buy 0.8x
                        multiplier = 0.8
                    else:
                        multiplier = 1.0
                    
                    return base_amount * multiplier
        except Exception as e:
            logger.error(f"rsi_based calculation error for {coin}: {e}")
            return base_amount
    
    return base_amount


@log_calls
async def get_spot_instrument_info(user_id: int, symbol: str, account_type: str = None, exchange: str = None) -> dict:
    """Get instrument info for spot symbol (min order size, decimals, etc)."""
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    if exchange.lower() == "hyperliquid":
        # HL doesn't have the same instrument info concept
        # Return minimal info
        return {"lotSizeFilter": {"basePrecision": "0.000001"}}
    
    # Bybit
    params = {"category": "spot", "symbol": symbol}
    try:
        res = await _bybit_request(user_id, "GET", "/v5/market/instruments-info", params=params, account_type=account_type)
        instruments = res.get("list", [])
        if instruments:
            return instruments[0]
    except Exception as e:
        logger.error(f"get_spot_instrument_info error for {symbol}: {e}")
    return {}


@log_calls  
async def place_spot_order(
    user_id: int,
    symbol: str,
    side: str,  # "Buy" or "Sell"
    qty: float,
    order_type: str = "Market",
    price: float = None,
    account_type: str = None,
    exchange: str = None,
) -> dict:
    """Place a spot order.
    
    Args:
        user_id: Telegram user ID
        symbol: Spot symbol like "BTCUSDT" (Bybit) or "BTC" (HL)
        side: "Buy" or "Sell"
        qty: Quantity to buy/sell (in quote currency for market buy on Bybit)
        order_type: "Market" or "Limit"
        price: Price for limit orders
        account_type: 'demo', 'real' (Bybit) or 'testnet', 'mainnet' (HL)
        exchange: 'bybit' or 'hyperliquid' (auto-detected if None)
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    exchange = exchange.lower()
    
    if exchange == "hyperliquid":
        # HyperLiquid spot order
        try:
            hl_creds = db.get_hl_credentials(user_id)
            if not hl_creds:
                raise ValueError("No HyperLiquid credentials")
            
            is_testnet = account_type in ("testnet", "demo", None)
            private_key = hl_creds.get("hl_testnet_private_key" if is_testnet else "hl_mainnet_private_key")
            if not private_key:
                private_key = hl_creds.get("hl_private_key")
                is_testnet = hl_creds.get("hl_testnet", False)
            
            if not private_key:
                raise ValueError("No HyperLiquid private key configured")
            
            # Normalize symbol for HL
            token = symbol.upper().replace("USDT", "").replace("USDC", "")
            
            adapter = HLAdapter(private_key=private_key, testnet=is_testnet)
            await adapter.initialize()
            
            if side.lower() == "buy":
                # For HL market buy, qty is USDC amount
                result = await adapter.spot_market_buy(token=token, usdc_amount=qty)
            else:
                # For HL sell, qty is token amount
                result = await adapter.spot_market_sell(token=token, qty=qty)
            
            if result.get("success"):
                logger.info(f"HL Spot order placed [{account_type or 'testnet'}]: {token} {side} qty={qty}")
                return {"retCode": 0, "retMsg": "OK", "result": {"orderId": result.get("order_id", "")}}
            else:
                raise ValueError(result.get("error", "HL spot order failed"))
        
        except ValueError as e:
            err_str = str(e)
            if "insufficient" in err_str.lower() or "balance" in err_str.lower():
                raise ValueError("INSUFFICIENT_BALANCE")
            raise
        except Exception as e:
            logger.error(f"HL place_spot_order error: {e}")
            raise
    
    # Bybit spot order (original logic)
    import uuid
    order_link_id = f"spot_{uuid.uuid4().hex[:20]}"
    
    # Get instrument info for proper qty rounding (fix "too many decimals" error)
    if side == "Sell" or order_type == "Limit":
        try:
            inst_info = await get_spot_instrument_info(user_id, symbol, account_type, exchange)
            if inst_info:
                # basePrecision is the decimal precision for base coin qty
                base_precision = inst_info.get("lotSizeFilter", {}).get("basePrecision", "0.00001")
                # Calculate decimal places from precision string
                if "." in base_precision:
                    decimals = len(base_precision.split(".")[1].rstrip("0")) or 1
                else:
                    decimals = 0
                # Round qty to proper precision
                import math
                qty = math.floor(qty * (10 ** decimals)) / (10 ** decimals)
                logger.debug(f"Spot order qty rounded to {decimals} decimals: {qty}")
        except Exception as e:
            logger.warning(f"Could not get spot instrument info for rounding: {e}")
    
    body = {
        "category": "spot",
        "symbol": symbol,
        "side": side,
        "orderType": order_type,
        "orderLinkId": order_link_id,
    }
    
    if order_type == "Market" and side == "Buy":
        # For market buy, use quote order qty (USDT amount)
        body["marketUnit"] = "quoteCoin"
        body["qty"] = str(qty)
    else:
        # For market sell or limit orders, qty is in base coin
        body["qty"] = str(qty)
        
    if order_type == "Limit" and price:
        body["price"] = str(price)
        body["timeInForce"] = "GTC"
    
    try:
        res = await _bybit_request(user_id, "POST", "/v5/order/create", body=body, account_type=account_type)
        logger.info(f"Spot order placed [{account_type or 'auto'}]: {res}")
        return res
    except RuntimeError as e:
        msg = str(e).lower()
        if "insufficient" in msg or "balance" in msg or "110007" in msg or "ab not enough" in msg:
            raise ValueError("INSUFFICIENT_BALANCE")
        # 170140 = Order value exceeded lower limit (order too small)
        if "170140" in str(e) or "lower limit" in msg:
            raise ValueError("ORDER_TOO_SMALL")
        # 170136 = Order qty too small
        if "170136" in str(e) or "qty" in msg and "small" in msg:
            raise ValueError("ORDER_TOO_SMALL")
        raise


async def execute_spot_dca_buy(
    user_id: int,
    coin: str,
    usdt_amount: float,
    account_type: str = None,
    exchange: str = None,
) -> dict:
    """Execute a DCA buy for a specific coin.
    
    Args:
        user_id: Telegram user ID
        coin: Coin to buy (e.g., "BTC", "ETH", "HYPE", "PURR")
        usdt_amount: Amount in USDT/USDC to spend
        account_type: 'demo', 'real' (Bybit) or 'testnet', 'mainnet' (HL)
        exchange: 'bybit' or 'hyperliquid' (auto-detected if None)
        
    Returns:
        dict with result info
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    exchange = exchange.lower()
    
    # Build symbol based on exchange
    if exchange == "hyperliquid":
        symbol = coin  # HL uses just the token name
    else:
        symbol = f"{coin}USDT"  # Bybit uses COINUSDT format
    
    # Get current price
    ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
    if not ticker:
        return {"success": False, "error": f"Could not get price for {symbol}"}
    
    current_price = float(ticker.get("lastPrice", 0))
    if current_price <= 0:
        return {"success": False, "error": f"Invalid price for {symbol}"}
    
    try:
        result = await place_spot_order(
            user_id=user_id,
            symbol=symbol,
            side="Buy",
            qty=usdt_amount,
            order_type="Market",
            account_type=account_type,
            exchange=exchange,
        )
        
        # Calculate approximate qty bought
        qty_bought = usdt_amount / current_price
        
        # Update purchase history for TP tracking
        try:
            cfg = db.get_user_config(user_id)
            spot_settings = cfg.get("spot_settings") or {}
            purchase_history = spot_settings.get("purchase_history", {})
            
            if coin not in purchase_history:
                purchase_history[coin] = {
                    "total_qty": 0.0,
                    "total_cost": 0.0,
                    "avg_price": 0.0,
                    "purchases": [],
                }
            
            coin_history = purchase_history[coin]
            coin_history["total_qty"] += qty_bought
            coin_history["total_cost"] += usdt_amount
            coin_history["avg_price"] = coin_history["total_cost"] / coin_history["total_qty"] if coin_history["total_qty"] > 0 else 0
            coin_history["purchases"].append({
                "ts": int(time.time()),
                "qty": qty_bought,
                "price": current_price,
                "usdt": usdt_amount,
            })
            
            # Keep only last 50 purchases per coin
            if len(coin_history["purchases"]) > 50:
                coin_history["purchases"] = coin_history["purchases"][-50:]
            
            purchase_history[coin] = coin_history
            spot_settings["purchase_history"] = purchase_history
            db.set_user_field(user_id, "spot_settings", json.dumps(spot_settings))
            
        except Exception as e:
            logger.warning(f"Failed to update purchase history: {e}")
        
        return {
            "success": True,
            "coin": coin,
            "symbol": symbol,
            "qty": qty_bought,
            "usdt_spent": usdt_amount,
            "price": current_price,
            "order": result,
        }
    except ValueError as e:
        err_str = str(e)
        if err_str == "ORDER_TOO_SMALL":
            # Silently skip - amount too small for exchange minimum
            logger.debug(f"Spot DCA {coin}: order too small (${usdt_amount:.2f}), skipping")
            return {"success": False, "error": "SKIP", "reason": "order_too_small"}
        if err_str == "INSUFFICIENT_BALANCE":
            return {"success": False, "error": "SKIP", "reason": "insufficient_balance"}
        return {"success": False, "error": err_str}
    except Exception as e:
        # Don't show raw API errors to user
        logger.warning(f"execute_spot_dca_buy {coin}: {e}")
        return {"success": False, "error": "SKIP", "reason": "api_error"}


async def execute_spot_sell(
    user_id: int,
    coin: str,
    qty: float = None,
    sell_pct: float = None,
    account_type: str = None,
    exchange: str = None,
) -> dict:
    """Execute a spot sell for a specific coin.
    
    Args:
        user_id: Telegram user ID
        coin: Coin to sell (e.g., "BTC", "ETH", "PURR")
        qty: Quantity to sell (in base coin). If None, use sell_pct.
        sell_pct: Percentage of holdings to sell (0-100). Used if qty is None.
        account_type: 'demo', 'real' (Bybit) or 'testnet', 'mainnet' (HL)
        exchange: 'bybit' or 'hyperliquid' (auto-detected if None)
        
    Returns:
        dict with result info
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    exchange = exchange.lower()
    
    # Build symbol based on exchange
    if exchange == "hyperliquid":
        symbol = coin.upper()  # HL uses just token name
        # Normalize account_type for HL
        if account_type in ("demo", "real"):
            account_type = "testnet" if account_type == "demo" else "mainnet"
    else:
        symbol = f"{coin}USDT"  # Bybit uses COINUSDT format
    
    # Get current balance if we need to calculate qty from percentage
    if qty is None:
        balances = await fetch_spot_balance(user_id, account_type=account_type, exchange=exchange)
        coin_balance = balances.get(coin.upper(), 0)
        
        if coin_balance <= 0:
            return {"success": False, "error": f"No {coin} balance to sell"}
        
        if sell_pct is None:
            sell_pct = 100.0  # Sell all by default
        
        qty = coin_balance * (sell_pct / 100.0)
        
        # For 100% sell, use slightly less to avoid "insufficient balance" due to rounding
        if sell_pct >= 99.9:
            qty = coin_balance * 0.9999  # Leave tiny dust to avoid rounding issues
    
    if qty <= 0:
        return {"success": False, "error": "Invalid quantity"}
    
    # Get current price
    ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
    if not ticker:
        return {"success": False, "error": f"Could not get price for {symbol}"}
    
    current_price = float(ticker.get("lastPrice", 0))
    if current_price <= 0:
        return {"success": False, "error": f"Invalid price for {symbol}"}
    
    try:
        result = await place_spot_order(
            user_id=user_id,
            symbol=symbol,
            side="Sell",
            qty=qty,
            order_type="Market",
            account_type=account_type,
            exchange=exchange,
        )
        
        usdt_received = qty * current_price
        
        # Update purchase history
        try:
            cfg = db.get_user_config(user_id)
            spot_settings = cfg.get("spot_settings") or {}
            purchase_history = spot_settings.get("purchase_history", {})
            
            if coin in purchase_history:
                coin_history = purchase_history[coin]
                # Reduce tracked qty
                coin_history["total_qty"] = max(0, coin_history["total_qty"] - qty)
                # Reduce cost proportionally
                if coin_history["total_qty"] > 0:
                    sold_ratio = qty / (coin_history["total_qty"] + qty)
                    coin_history["total_cost"] = coin_history["total_cost"] * (1 - sold_ratio)
                else:
                    coin_history["total_cost"] = 0
                    coin_history["avg_price"] = 0
                
                purchase_history[coin] = coin_history
                spot_settings["purchase_history"] = purchase_history
                db.set_user_field(user_id, "spot_settings", json.dumps(spot_settings))
        except Exception as e:
            logger.warning(f"Failed to update purchase history on sell: {e}")
        
        return {
            "success": True,
            "coin": coin,
            "symbol": symbol,
            "qty_sold": qty,
            "usdt_received": usdt_received,
            "price": current_price,
            "order": result,
        }
    except ValueError as e:
        return {"success": False, "error": str(e)}
    except Exception as e:
        logger.error(f"execute_spot_sell error: {e}")
        return {"success": False, "error": str(e)}


async def check_spot_tp_levels(
    user_id: int,
    account_type: str = None,
    exchange: str = None,
) -> list:
    """Check all spot holdings for TP level triggers and execute sells if needed.
    
    Args:
        user_id: Telegram user ID
        account_type: Account type
        exchange: 'bybit' or 'hyperliquid' (auto-detected if None)
    
    Returns list of executed sells.
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    exchange = exchange.lower()
    
    cfg = db.get_user_config(user_id)
    spot_settings = cfg.get("spot_settings") or {}
    
    if not spot_settings.get("tp_enabled"):
        return []
    
    purchase_history = spot_settings.get("purchase_history", {})
    tp_levels = spot_settings.get("tp_levels", DEFAULT_SPOT_TP_LEVELS)
    tp_executed = spot_settings.get("tp_executed", {})  # Track which levels were triggered
    
    executed_sells = []
    
    for coin, coin_history in purchase_history.items():
        avg_price = coin_history.get("avg_price", 0)
        total_qty = coin_history.get("total_qty", 0)
        
        if avg_price <= 0 or total_qty <= 0:
            continue
        
        # Build symbol based on exchange
        if exchange == "hyperliquid":
            symbol = coin.upper()
        else:
            symbol = f"{coin}USDT"
        
        try:
            ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
            if not ticker:
                continue
            
            current_price = float(ticker.get("lastPrice", 0))
            if current_price <= 0:
                continue
            
            # Calculate gain percentage
            gain_pct = ((current_price - avg_price) / avg_price) * 100
            
            # Check each TP level
            coin_tp_executed = tp_executed.get(coin, [])
            
            for i, level in enumerate(tp_levels):
                level_gain = level.get("gain_pct", 0)
                level_sell_pct = level.get("sell_pct", 0)
                
                # Skip if this level was already executed
                if i in coin_tp_executed:
                    continue
                
                # Check if gain reached this level
                if gain_pct >= level_gain:
                    logger.info(f"Spot TP triggered: {coin} +{gain_pct:.1f}% >= {level_gain}%, selling {level_sell_pct}% (exchange={exchange})")
                    
                    result = await execute_spot_sell(
                        user_id=user_id,
                        coin=coin,
                        sell_pct=level_sell_pct,
                        account_type=account_type,
                        exchange=exchange,
                    )
                    
                    if result.get("success"):
                        # Mark level as executed
                        coin_tp_executed.append(i)
                        tp_executed[coin] = coin_tp_executed
                        
                        executed_sells.append({
                            "coin": coin,
                            "level": i + 1,
                            "gain_pct": gain_pct,
                            "sell_pct": level_sell_pct,
                            "qty_sold": result.get("qty_sold", 0),
                            "usdt_received": result.get("usdt_received", 0),
                            "exchange": exchange,
                        })
                    else:
                        logger.error(f"Spot TP sell failed: {result.get('error')}")
        
        except Exception as e:
            logger.error(f"check_spot_tp_levels error for {coin}: {e}")
    
    # Save updated tp_executed state
    if executed_sells:
        spot_settings["tp_executed"] = tp_executed
        db.set_user_field(user_id, "spot_settings", json.dumps(spot_settings))
    
    return executed_sells


async def rebalance_spot_portfolio(
    user_id: int,
    account_type: str = None,
    exchange: str = None,
) -> dict:
    """Rebalance spot portfolio to match target allocation.
    
    Sells over-allocated coins and buys under-allocated coins.
    
    Args:
        user_id: Telegram user ID
        account_type: Account type
        exchange: 'bybit' or 'hyperliquid' (auto-detected if None)
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    exchange = exchange.lower()
    
    cfg = db.get_user_config(user_id)
    spot_settings = cfg.get("spot_settings") or {}
    
    portfolio = spot_settings.get("portfolio", "custom")
    if portfolio == "custom":
        allocation = spot_settings.get("allocation", {})
    else:
        portfolio_info = SPOT_PORTFOLIOS.get(portfolio, {})
        allocation = portfolio_info.get("coins", {})
    
    if not allocation:
        return {"success": False, "error": "No target allocation defined"}
    
    # Get current holdings
    balances = await fetch_spot_balance(user_id, account_type=account_type, exchange=exchange)
    
    # Calculate current portfolio value
    total_value = 0.0
    coin_values = {}
    
    # Determine quote currency based on exchange
    quote_currency = "USDC" if exchange == "hyperliquid" else "USDT"
    
    for coin in allocation.keys():
        qty = balances.get(coin, 0)
        if qty > 0:
            symbol = coin if exchange == "hyperliquid" else f"{coin}USDT"
            ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
            if ticker:
                price = float(ticker.get("lastPrice", 0))
                value = qty * price
                coin_values[coin] = value
                total_value += value
    
    # Add quote currency as available cash
    quote_balance = balances.get(quote_currency, 0)
    total_portfolio = total_value + quote_balance
    
    if total_portfolio < 10:  # Minimum $10 to rebalance
        return {"success": False, "error": "Portfolio too small to rebalance"}
    
    # Calculate target values and differences
    trades = {"buy": [], "sell": []}
    
    for coin, target_pct in allocation.items():
        target_value = total_portfolio * (target_pct / 100.0)
        current_value = coin_values.get(coin, 0)
        diff = target_value - current_value
        
        # Only rebalance if difference is more than 5% of target
        if abs(diff) < target_value * 0.05:
            continue
        
        if diff > 5:  # Need to buy at least $5
            trades["buy"].append({"coin": coin, "usdt": diff})
        elif diff < -5:  # Need to sell at least $5 worth
            trades["sell"].append({"coin": coin, "usdt": abs(diff)})
    
    results = {"sells": [], "buys": [], "total_rebalanced": 0.0}
    
    # Execute sells first to free up quote currency
    for trade in trades["sell"]:
        coin = trade["coin"]
        usdt_to_sell = trade["usdt"]
        
        symbol = coin if exchange == "hyperliquid" else f"{coin}USDT"
        ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
        if not ticker:
            continue
        
        price = float(ticker.get("lastPrice", 0))
        qty_to_sell = usdt_to_sell / price if price > 0 else 0
        
        result = await execute_spot_sell(user_id, coin, qty=qty_to_sell, account_type=account_type, exchange=exchange)
        if result.get("success"):
            results["sells"].append(f"Sold {qty_to_sell:.6f} {coin}")
            results["total_rebalanced"] += result.get("usdt_received", 0)
    
    # Execute buys
    for trade in trades["buy"]:
        coin = trade["coin"]
        usdt_to_buy = trade["usdt"]
        
        result = await execute_spot_dca_buy(user_id, coin, usdt_to_buy, account_type=account_type, exchange=exchange)
        if result.get("success"):
            results["buys"].append(f"Bought {result.get('qty', 0):.6f} {coin}")
            results["total_rebalanced"] += result.get("usdt_spent", 0)
    
    results["success"] = True
    return results


# ==================== SPOT TRAILING TP ====================

async def check_spot_trailing_tp(
    user_id: int,
    account_type: str = None,
    exchange: str = None,
) -> list:
    """
    Check spot holdings for trailing TP triggers.
    
    Logic:
    1. If price reaches activation_pct above avg_price -> activate trailing
    2. Track peak price after activation
    3. If price drops trail_pct from peak -> sell
    
    Args:
        user_id: Telegram user ID
        account_type: Account type
        exchange: 'bybit' or 'hyperliquid' (auto-detected if None)
    
    Returns list of executed sells.
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    exchange = exchange.lower()
    
    cfg = db.get_user_config(user_id)
    spot_settings = cfg.get("spot_settings") or {}
    
    trailing_config = spot_settings.get("trailing_tp", SPOT_TRAILING_TP_DEFAULTS)
    if not trailing_config.get("enabled"):
        return []
    
    activation_pct = trailing_config.get("activation_pct", 15.0)
    trail_pct = trailing_config.get("trail_pct", 5.0)
    
    purchase_history = spot_settings.get("purchase_history", {})
    trailing_state = spot_settings.get("trailing_state", {})  # {coin: {active, peak_price}}
    
    executed_sells = []
    state_changed = False
    
    balances = await fetch_spot_balance(user_id, account_type=account_type, exchange=exchange)
    
    for coin, coin_history in purchase_history.items():
        avg_price = coin_history.get("avg_price", 0)
        total_qty = coin_history.get("total_qty", 0)
        
        if avg_price <= 0 or total_qty <= 0:
            continue
        
        # Check actual balance
        actual_qty = balances.get(coin.upper(), 0)
        if actual_qty < 0.00001:
            continue
        
        # Build symbol based on exchange
        symbol = coin if exchange == "hyperliquid" else f"{coin}USDT"
        
        try:
            ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
            if not ticker:
                continue
            
            current_price = float(ticker.get("lastPrice", 0))
            if current_price <= 0:
                continue
            
            gain_pct = ((current_price - avg_price) / avg_price) * 100
            coin_state = trailing_state.get(coin, {"active": False, "peak_price": 0})
            
            if not coin_state.get("active"):
                # Check if we should activate trailing
                if gain_pct >= activation_pct:
                    coin_state["active"] = True
                    coin_state["peak_price"] = current_price
                    coin_state["activation_gain"] = gain_pct
                    trailing_state[coin] = coin_state
                    state_changed = True
                    logger.info(f"[SPOT-TRAIL] {coin} trailing activated at +{gain_pct:.1f}%, peak=${current_price:.4f} (exchange={exchange})")
            else:
                # Trailing is active - update peak and check for trigger
                peak = coin_state.get("peak_price", current_price)
                
                if current_price > peak:
                    # New peak
                    coin_state["peak_price"] = current_price
                    trailing_state[coin] = coin_state
                    state_changed = True
                    logger.debug(f"[SPOT-TRAIL] {coin} new peak: ${current_price:.4f}")
                else:
                    # Check if dropped enough from peak to trigger
                    drop_from_peak = ((peak - current_price) / peak) * 100
                    
                    if drop_from_peak >= trail_pct:
                        # TRIGGER! Sell all
                        logger.info(f"[SPOT-TRAIL] {coin} TRIGGER! Peak=${peak:.4f}, now=${current_price:.4f}, drop={drop_from_peak:.1f}% (exchange={exchange})")
                        
                        result = await execute_spot_sell(
                            user_id=user_id,
                            coin=coin,
                            qty=actual_qty,
                            account_type=account_type,
                            exchange=exchange,
                        )
                        
                        if result.get("success"):
                            usdt_received = result.get("usdt_received", actual_qty * current_price)
                            final_gain = ((current_price - avg_price) / avg_price) * 100
                            
                            executed_sells.append({
                                "coin": coin,
                                "qty_sold": actual_qty,
                                "usdt_received": usdt_received,
                                "gain_pct": final_gain,
                                "peak_price": peak,
                                "sell_price": current_price,
                                "exchange": exchange,
                            })
                            
                            # Reset state for this coin
                            coin_state["active"] = False
                            coin_state["peak_price"] = 0
                            trailing_state[coin] = coin_state
                            state_changed = True
                        else:
                            logger.error(f"Trailing TP sell failed for {coin}: {result.get('error')}")
                            
        except Exception as e:
            logger.error(f"check_spot_trailing_tp error for {coin}: {e}")
    
    # Save state
    if state_changed:
        spot_settings["trailing_state"] = trailing_state
        db.set_user_field(user_id, "spot_settings", json.dumps(spot_settings))
    
    return executed_sells


# ==================== SPOT LIMIT ORDERS ====================

async def place_spot_limit_order(
    user_id: int,
    coin: str,
    side: str,  # "Buy" or "Sell"
    price: float,
    usdt_amount: float = None,  # For Buy
    qty: float = None,          # For Sell
    account_type: str = None,
    exchange: str = None,
) -> dict:
    """
    Place a limit order for spot.
    
    For Buy: specify usdt_amount, qty will be calculated
    For Sell: specify qty directly
    
    Supports both Bybit and HyperLiquid exchanges.
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    exchange = exchange.lower()
    
    # Quote currency differs by exchange
    quote_currency = "USDC" if exchange == "hyperliquid" else "USDT"
    
    # Build symbol based on exchange
    if exchange == "hyperliquid":
        symbol = coin  # HL uses just the token name
    else:
        symbol = f"{coin}USDT"  # Bybit uses COINUSDT format
    
    if side == "Buy":
        if not usdt_amount or usdt_amount <= 0:
            return {"success": False, "error": f"Invalid {quote_currency} amount"}
        if not price or price <= 0:
            return {"success": False, "error": "Invalid price"}
        order_qty = usdt_amount / price
    else:
        if not qty or qty <= 0:
            return {"success": False, "error": "Invalid quantity"}
        order_qty = qty
    
    try:
        result = await place_spot_order(
            user_id=user_id,
            symbol=symbol,
            side=side,
            qty=order_qty,
            order_type="Limit",
            price=price,
            account_type=account_type,
            exchange=exchange,
        )
        
        # Save pending limit order to track
        cfg = db.get_user_config(user_id)
        spot_settings = cfg.get("spot_settings") or {}
        pending_orders = spot_settings.get("pending_limit_orders", [])
        
        order_id = result.get("orderId") or result.get("order_id")
        pending_orders.append({
            "order_id": order_id,
            "symbol": symbol,
            "coin": coin,
            "side": side,
            "price": price,
            "qty": order_qty,
            "usdt": usdt_amount if side == "Buy" else order_qty * price,
            "exchange": exchange,
            "created_ts": int(time.time()),
        })
        
        # Keep last 50 orders
        if len(pending_orders) > 50:
            pending_orders = pending_orders[-50:]
        
        spot_settings["pending_limit_orders"] = pending_orders
        db.set_user_field(user_id, "spot_settings", json.dumps(spot_settings))
        
        return {
            "success": True,
            "order_id": order_id,
            "symbol": symbol,
            "side": side,
            "price": price,
            "qty": order_qty,
            "exchange": exchange,
        }
        
    except Exception as e:
        logger.error(f"[{exchange}] place_spot_limit_order error: {e}")
        return {"success": False, "error": str(e)}


async def get_spot_open_orders(user_id: int, account_type: str = None, exchange: str = None) -> list:
    """Get all open spot orders.
    
    Supports both Bybit and HyperLiquid exchanges.
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    exchange = exchange.lower()
    
    if exchange == "hyperliquid":
        # HyperLiquid - get open spot orders
        try:
            hl_creds = db.get_hl_credentials(user_id)
            if not hl_creds:
                return []
            
            is_testnet = account_type in ("testnet", "demo", None)
            private_key = hl_creds.get("hl_testnet_private_key" if is_testnet else "hl_mainnet_private_key")
            if not private_key:
                private_key = hl_creds.get("hl_private_key")
                is_testnet = hl_creds.get("hl_testnet", False)
            
            if not private_key:
                return []
            
            adapter = HLAdapter(private_key=private_key, testnet=is_testnet)
            await adapter.initialize()
            
            # HL API for spot open orders
            user_state = await adapter._client._post_info({"type": "spotClearinghouseState", "user": adapter.main_wallet_address})
            orders = user_state.get("openOrders", [])
            
            # Format to match Bybit structure
            formatted_orders = []
            for order in orders:
                formatted_orders.append({
                    "orderId": str(order.get("oid", "")),
                    "symbol": order.get("coin", ""),
                    "side": "Buy" if order.get("side") == "A" else "Sell",  # A=Bid/Buy, B=Ask/Sell
                    "price": str(order.get("limitPx", 0)),
                    "qty": str(order.get("sz", 0)),
                    "orderStatus": "New",
                })
            return formatted_orders
        except Exception as e:
            logger.error(f"[HL] get_spot_open_orders error: {e}")
            return []
    
    # Bybit
    try:
        params = {"category": "spot"}
        res = await _bybit_request(user_id, "GET", "/v5/order/realtime", params=params, account_type=account_type)
        orders = res.get("list", [])
        return orders
    except Exception as e:
        logger.error(f"[Bybit] get_spot_open_orders error: {e}")
        return []


async def cancel_spot_order(user_id: int, symbol: str, order_id: str, account_type: str = None, exchange: str = None) -> dict:
    """Cancel a spot order.
    
    Supports both Bybit and HyperLiquid exchanges.
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    exchange = exchange.lower()
    
    if exchange == "hyperliquid":
        # HyperLiquid cancel spot order
        try:
            hl_creds = db.get_hl_credentials(user_id)
            if not hl_creds:
                return {"success": False, "error": "No HyperLiquid credentials"}
            
            is_testnet = account_type in ("testnet", "demo", None)
            private_key = hl_creds.get("hl_testnet_private_key" if is_testnet else "hl_mainnet_private_key")
            if not private_key:
                private_key = hl_creds.get("hl_private_key")
                is_testnet = hl_creds.get("hl_testnet", False)
            
            if not private_key:
                return {"success": False, "error": "No HyperLiquid private key"}
            
            adapter = HLAdapter(private_key=private_key, testnet=is_testnet)
            await adapter.initialize()
            
            # Cancel spot order using @0 prefix
            result = await adapter._client.cancel("@0", int(order_id))
            
            if result.get("status") == "ok":
                logger.info(f"[HL] Spot order cancelled: {order_id}")
                return {"success": True, "result": result}
            else:
                return {"success": False, "error": result.get("response", "Cancel failed")}
        except Exception as e:
            logger.error(f"[HL] cancel_spot_order error: {e}")
            return {"success": False, "error": str(e)}
    
    # Bybit
    try:
        params = {
            "category": "spot",
            "symbol": symbol,
            "orderId": order_id,
        }
        res = await _bybit_request(user_id, "POST", "/v5/order/cancel", params=params, account_type=account_type)
        return {"success": True, "result": res}
    except Exception as e:
        logger.error(f"[Bybit] cancel_spot_order error: {e}")
        return {"success": False, "error": str(e)}


# ==================== SPOT GRID BOT ====================

async def setup_spot_grid(
    user_id: int,
    coin: str,
    price_low: float,
    price_high: float,
    grid_count: int,
    total_investment: float,
    account_type: str = None,
    exchange: str = None,
) -> dict:
    """
    Setup a grid bot for spot trading.
    
    Creates limit buy orders at regular intervals from price_low to current price,
    and prepares sell levels above current price.
    
    Supports both Bybit and HyperLiquid exchanges.
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    exchange = exchange.lower()
    
    # Quote currency differs by exchange
    quote_currency = "USDC" if exchange == "hyperliquid" else "USDT"
    
    # Build symbol based on exchange
    if exchange == "hyperliquid":
        symbol = coin  # HL uses just the token name
    else:
        symbol = f"{coin}USDT"  # Bybit uses COINUSDT format
    
    try:
        # Get current price
        ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
        if not ticker:
            return {"success": False, "error": f"Could not get price for {symbol}"}
        
        current_price = float(ticker.get("lastPrice") or ticker.get("mid_price") or ticker.get("mark_price") or 0)
        if current_price <= 0:
            return {"success": False, "error": "Invalid current price"}
        
        if price_low >= price_high:
            return {"success": False, "error": "Price low must be less than price high"}
        
        if current_price < price_low or current_price > price_high:
            return {"success": False, "error": f"Current price ${current_price:.2f} must be within grid range ${price_low:.2f} - ${price_high:.2f}"}
        
        # Calculate grid step
        grid_step = (price_high - price_low) / grid_count
        usdt_per_grid = total_investment / grid_count
        
        # Generate grid levels
        grid_levels = []
        for i in range(grid_count + 1):
            level_price = price_low + (i * grid_step)
            grid_levels.append({
                "price": level_price,
                "side": "Buy" if level_price < current_price else "Sell",
                "usdt": usdt_per_grid,
                "qty": usdt_per_grid / level_price,
                "filled": False,
                "order_id": None,
            })
        
        # Place buy orders below current price
        placed_orders = []
        for level in grid_levels:
            if level["side"] == "Buy" and level["price"] < current_price * 0.99:  # 1% buffer
                result = await place_spot_limit_order(
                    user_id=user_id,
                    coin=coin,
                    side="Buy",
                    price=level["price"],
                    usdt_amount=level["usdt"],
                    account_type=account_type,
                    exchange=exchange,
                )
                
                if result.get("success"):
                    level["order_id"] = result.get("order_id")
                    placed_orders.append(level["price"])
        
        # Save grid config
        cfg = db.get_user_config(user_id)
        spot_settings = cfg.get("spot_settings") or {}
        
        grids = spot_settings.get("grids", {})
        grids[coin] = {
            "price_low": price_low,
            "price_high": price_high,
            "grid_count": grid_count,
            "grid_step": grid_step,
            "total_investment": total_investment,
            "usdt_per_grid": usdt_per_grid,
            "levels": grid_levels,
            "created_ts": int(time.time()),
            "active": True,
            "realized_profit": 0.0,
            "trades_count": 0,
            "exchange": exchange,
        }
        
        spot_settings["grids"] = grids
        db.set_user_field(user_id, "spot_settings", json.dumps(spot_settings))
        
        return {
            "success": True,
            "coin": coin,
            "price_low": price_low,
            "price_high": price_high,
            "grid_count": grid_count,
            "grid_step": grid_step,
            "orders_placed": len(placed_orders),
            "placed_at": placed_orders,
        }
        
    except Exception as e:
        logger.error(f"setup_spot_grid error: {e}")
        return {"success": False, "error": str(e)}


async def check_spot_grids(user_id: int, account_type: str = None) -> list:
    """
    Check and manage active spot grids.
    
    When a buy order fills -> place sell order at next level up
    When a sell order fills -> place buy order at the same level
    """
    cfg = db.get_user_config(user_id)
    spot_settings = cfg.get("spot_settings") or {}
    grids = spot_settings.get("grids", {})
    
    if not grids:
        return []
    
    events = []
    state_changed = False
    
    # Get all open orders
    open_orders = await get_spot_open_orders(user_id, account_type)
    open_order_ids = {o.get("orderId") for o in open_orders}
    
    for coin, grid_config in grids.items():
        if not grid_config.get("active"):
            continue
        
        symbol = f"{coin}USDT"
        levels = grid_config.get("levels", [])
        grid_step = grid_config.get("grid_step", 0)
        usdt_per_grid = grid_config.get("usdt_per_grid", 0)
        
        for i, level in enumerate(levels):
            order_id = level.get("order_id")
            if not order_id:
                continue
            
            # Check if order was filled (not in open orders anymore)
            if order_id not in open_order_ids and not level.get("filled"):
                level["filled"] = True
                state_changed = True
                
                if level["side"] == "Buy":
                    # Buy filled -> place sell at next level
                    sell_price = level["price"] + grid_step
                    qty = level["qty"]
                    
                    result = await place_spot_limit_order(
                        user_id=user_id,
                        coin=coin,
                        side="Sell",
                        price=sell_price,
                        qty=qty,
                        account_type=account_type,
                    )
                    
                    if result.get("success"):
                        # Create new level entry for sell
                        new_sell_level = {
                            "price": sell_price,
                            "side": "Sell",
                            "qty": qty,
                            "order_id": result.get("order_id"),
                            "filled": False,
                            "linked_buy_price": level["price"],
                        }
                        levels.append(new_sell_level)
                        
                        events.append({
                            "type": "grid_buy_filled",
                            "coin": coin,
                            "buy_price": level["price"],
                            "sell_placed": sell_price,
                            "qty": qty,
                        })
                        
                        grid_config["trades_count"] = grid_config.get("trades_count", 0) + 1
                
                elif level["side"] == "Sell":
                    # Sell filled -> place buy back at linked level, record profit
                    buy_price = level.get("linked_buy_price", level["price"] - grid_step)
                    qty = level["qty"]
                    profit = (level["price"] - buy_price) * qty
                    
                    result = await place_spot_limit_order(
                        user_id=user_id,
                        coin=coin,
                        side="Buy",
                        price=buy_price,
                        usdt_amount=qty * buy_price,
                        account_type=account_type,
                    )
                    
                    if result.get("success"):
                        # Update buy level
                        for buy_level in levels:
                            if buy_level.get("price") == buy_price and buy_level.get("side") == "Buy":
                                buy_level["filled"] = False
                                buy_level["order_id"] = result.get("order_id")
                                break
                        else:
                            # Create new buy level
                            levels.append({
                                "price": buy_price,
                                "side": "Buy",
                                "usdt": qty * buy_price,
                                "qty": qty,
                                "order_id": result.get("order_id"),
                                "filled": False,
                            })
                        
                        grid_config["realized_profit"] = grid_config.get("realized_profit", 0) + profit
                        grid_config["trades_count"] = grid_config.get("trades_count", 0) + 1
                        
                        events.append({
                            "type": "grid_sell_filled",
                            "coin": coin,
                            "sell_price": level["price"],
                            "profit": profit,
                            "total_profit": grid_config["realized_profit"],
                        })
        
        grid_config["levels"] = levels
    
    # Save state
    if state_changed:
        spot_settings["grids"] = grids
        db.set_user_field(user_id, "spot_settings", json.dumps(spot_settings))
    
    return events


async def stop_spot_grid(user_id: int, coin: str, account_type: str = None, exchange: str = None) -> dict:
    """Stop a grid bot and cancel all its orders.
    
    Supports both Bybit and HyperLiquid exchanges.
    """
    cfg = db.get_user_config(user_id)
    spot_settings = cfg.get("spot_settings") or {}
    grids = spot_settings.get("grids", {})
    
    if coin not in grids:
        return {"success": False, "error": f"No grid found for {coin}"}
    
    grid_config = grids[coin]
    
    # Get exchange from grid config or detect
    if exchange is None:
        exchange = grid_config.get("exchange") or db.get_exchange_type(user_id) or "bybit"
    exchange = exchange.lower()
    
    # Build symbol based on exchange
    if exchange == "hyperliquid":
        symbol = coin  # HL uses just the token name
    else:
        symbol = f"{coin}USDT"  # Bybit uses COINUSDT format
    
    # Cancel all open orders
    cancelled = 0
    for level in grid_config.get("levels", []):
        order_id = level.get("order_id")
        if order_id and not level.get("filled"):
            result = await cancel_spot_order(user_id, symbol, order_id, account_type, exchange)
            if result.get("success"):
                cancelled += 1
    
    # Mark grid as inactive
    grid_config["active"] = False
    grid_config["stopped_ts"] = int(time.time())
    grids[coin] = grid_config
    
    spot_settings["grids"] = grids
    db.set_user_field(user_id, "spot_settings", json.dumps(spot_settings))
    
    return {
        "success": True,
        "coin": coin,
        "orders_cancelled": cancelled,
        "total_profit": grid_config.get("realized_profit", 0),
        "total_trades": grid_config.get("trades_count", 0),
        "exchange": exchange,
    }


# ==================== SPOT PORTFOLIO STATS ====================

async def get_spot_portfolio_stats(user_id: int, account_type: str = None, exchange: str = None) -> dict:
    """
    Get comprehensive spot portfolio statistics.
    
    Returns:
    - Total value
    - Profit/loss per coin
    - Overall P&L
    - Comparison with HODL BTC
    
    Supports both Bybit and HyperLiquid exchanges.
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    exchange = exchange.lower()
    
    # Quote currency differs by exchange
    quote_currency = "USDC" if exchange == "hyperliquid" else "USDT"
    
    cfg = db.get_user_config(user_id)
    spot_settings = cfg.get("spot_settings") or {}
    purchase_history = spot_settings.get("purchase_history", {})
    total_invested = spot_settings.get("total_invested", 0)
    
    # Get current balances and prices
    balances = await fetch_spot_balance(user_id, account_type=account_type, exchange=exchange)
    
    coins_stats = []
    total_current_value = 0
    total_cost_basis = 0
    
    for coin, history in purchase_history.items():
        avg_price = history.get("avg_price", 0)
        total_qty = history.get("total_qty", 0)
        total_cost = history.get("total_cost", 0)
        
        if avg_price <= 0:
            continue
        
        # Get actual balance (may differ if user traded outside bot)
        actual_qty = balances.get(coin, 0)
        
        # Build symbol based on exchange
        if exchange == "hyperliquid":
            symbol = coin  # HL uses just the token name
        else:
            symbol = f"{coin}USDT"  # Bybit uses COINUSDT format
        
        try:
            ticker = await get_spot_ticker(user_id, symbol, account_type, exchange)
            if not ticker:
                continue
            
            current_price = float(ticker.get("lastPrice") or ticker.get("mid_price") or ticker.get("mark_price") or 0)
            change_24h = float(ticker.get("price24hPcnt", 0)) * 100
            
            current_value = actual_qty * current_price
            
            # Calculate P&L based on tracked history
            pnl_value = current_value - total_cost if actual_qty > 0 else 0
            pnl_pct = ((current_price - avg_price) / avg_price) * 100 if avg_price > 0 else 0
            
            coins_stats.append({
                "coin": coin,
                "qty": actual_qty,
                "avg_price": avg_price,
                "current_price": current_price,
                "current_value": current_value,
                "cost_basis": total_cost,
                "pnl_value": pnl_value,
                "pnl_pct": pnl_pct,
                "change_24h": change_24h,
            })
            
            total_current_value += current_value
            total_cost_basis += total_cost
            
        except Exception as e:
            logger.error(f"[{exchange}] get_spot_portfolio_stats error for {coin}: {e}")
    
    # Add quote currency balance
    quote_balance = balances.get(quote_currency, 0)
    total_current_value += quote_balance
    
    # Calculate overall P&L
    overall_pnl_value = total_current_value - total_cost_basis
    overall_pnl_pct = ((total_current_value - total_cost_basis) / total_cost_basis * 100) if total_cost_basis > 0 else 0
    
    # Compare with HODL BTC
    btc_comparison = None
    if total_invested > 0:
        try:
            btc_symbol = "BTC" if exchange == "hyperliquid" else "BTCUSDT"
            btc_ticker = await get_spot_ticker(user_id, btc_symbol, account_type, exchange)
            if btc_ticker:
                btc_price = float(btc_ticker.get("lastPrice") or btc_ticker.get("mid_price") or btc_ticker.get("mark_price") or 0)
                # Get historical price when user started (approximation using first purchase)
                first_purchase_ts = None
                for history in purchase_history.values():
                    purchases = history.get("purchases", [])
                    if purchases:
                        ts = purchases[0].get("ts", 0)
                        if first_purchase_ts is None or ts < first_purchase_ts:
                            first_purchase_ts = ts
                
                # If we had just held BTC instead
                # Simplified: assume we could have bought at avg of all our buy times
                # For now, just show what total invested would be worth in BTC at current price
                btc_qty_if_hodl = total_invested / btc_price if btc_price > 0 else 0
                # This is simplified - real comparison would need historical prices
                btc_comparison = {
                    "total_invested": total_invested,
                    "btc_price_now": btc_price,
                    "btc_qty_if_hodl": btc_qty_if_hodl,
                }
        except Exception as e:
            logger.error(f"[{exchange}] BTC comparison error: {e}")
    
    # Sort by value descending
    coins_stats.sort(key=lambda x: x["current_value"], reverse=True)
    
    return {
        "coins": coins_stats,
        "total_current_value": total_current_value,
        "total_cost_basis": total_cost_basis,
        "quote_balance": quote_balance,
        "quote_currency": quote_currency,
        "overall_pnl_value": overall_pnl_value,
        "overall_pnl_pct": overall_pnl_pct,
        "total_invested": total_invested,
        "btc_comparison": btc_comparison,
        "exchange": exchange,
    }


# ==================== MULTI-TIMEFRAME DCA ====================

async def execute_dca_plan(
    user_id: int,
    plan: dict,
    account_type: str = None,
    exchange: str = None,
) -> dict:
    """Execute a single DCA plan.
    
    Supports both Bybit and HyperLiquid exchanges.
    """
    # Detect exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    exchange = exchange.lower()
    
    coins = plan.get("coins", [])
    amount = plan.get("amount", 10.0)
    strategy = plan.get("strategy", "fixed")
    plan_name = plan.get("name", "Plan")
    
    results = []
    total_spent = 0.0
    skipped = []
    
    cfg = db.get_user_config(user_id)
    spot_settings = cfg.get("spot_settings") or {}
    
    for coin in coins:
        # Calculate amount per coin
        coin_amount = amount / len(coins) if coins else amount
        
        # Apply strategy
        adjusted_amount = await calculate_smart_dca_amount(
            base_amount=coin_amount,
            strategy=strategy,
            coin=coin,
            spot_settings=spot_settings,
            user_id=user_id,
            account_type=account_type,
            exchange=exchange,
        )
        
        if adjusted_amount <= 0:
            skipped.append(coin)
            continue
        
        result = await execute_spot_dca_buy(user_id, coin, adjusted_amount, account_type=account_type, exchange=exchange)
        if result.get("success"):
            spent = result.get("usdt_spent", adjusted_amount)
            results.append({
                "coin": coin,
                "qty": result.get("qty", 0),
                "spent": spent,
                "price": result.get("price", 0),
            })
            total_spent += spent
        elif result.get("error") == "SKIP":
            skipped.append(coin)
    
    return {
        "success": True,
        "plan_name": plan_name,
        "results": results,
        "total_spent": total_spent,
        "skipped": skipped,
        "exchange": exchange,
    }


def _normalize_order_id(res: dict) -> str:
    return str(res.get("orderId") or res.get("id") or res.get("order_id") or "")


@log_calls
async def fetch_open_positions(user_id, *args, exchange: str = None, **kwargs) -> list:
    """
    Fetch open positions using unified architecture when available
    Falls back to direct Bybit API if unified is disabled
    
    Args:
        user_id: User ID or Update object
        exchange: Exchange type ('bybit' or 'hyperliquid'), if None uses user's default
        **kwargs: account_type etc
    """
    # Use unified architecture if available
    if USE_UNIFIED_ARCHITECTURE and UNIFIED_AVAILABLE:
        try:
            uid = None
            if isinstance(user_id, int):
                uid = user_id
            else:
                update = user_id
                uid = getattr(getattr(update, "effective_user", None), "id", None)
            
            if uid is None:
                uid = kwargs.get("user_id")
            
            if uid is None:
                raise RuntimeError("fetch_open_positions: –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å user_id")
            
            # Get exchange and account type from user settings
            exchange_type = exchange or db.get_exchange_type(uid) or 'bybit'
            account_type = kwargs.get('account_type')
            if account_type is None:
                # Use get_last_viewed_account which prefers Real if has API keys
                account_type = db.get_last_viewed_account(uid, exchange_type)
            
            # Get unified Position objects
            positions = await get_positions_unified(
                uid, 
                exchange=exchange_type, 
                account_type=account_type
            )
            
            # CRITICAL: If positions is None, API error occurred ‚Äî propagate None
            # to prevent monitor loop from treating this as "all positions closed"
            if positions is None:
                logger.warning(f"[{uid}] fetch_open_positions: API error (positions=None), returning None")
                return None
            
            # Get active positions from DB to enrich with stored TP/SL
            db_positions = db.get_active_positions(uid, account_type=account_type, exchange=exchange_type)
            db_by_symbol = {p['symbol']: p for p in db_positions}
            
            # Convert to dicts for backward compatibility
            result = []
            for pos in positions:
                pos_dict = pos.to_dict()
                symbol = pos_dict.get('symbol', '')
                
                # Map unified fields to Bybit format for compatibility
                pos_dict['avgPrice'] = pos_dict['entry_price']
                pos_dict['markPrice'] = pos_dict['mark_price']
                pos_dict['unrealisedPnl'] = pos_dict['unrealized_pnl']
                pos_dict['positionIM'] = pos_dict['margin_used']
                pos_dict['liqPrice'] = pos_dict.get('liquidation_price')
                
                # Map TP/SL to Bybit format
                pos_dict['takeProfit'] = pos_dict.get('take_profit')
                pos_dict['stopLoss'] = pos_dict.get('stop_loss')
                
                # If exchange didn't return TP/SL, try to get from DB
                db_pos = db_by_symbol.get(symbol)
                if db_pos:
                    if not pos_dict.get('takeProfit') and db_pos.get('tp_price'):
                        pos_dict['takeProfit'] = db_pos['tp_price']
                    if not pos_dict.get('stopLoss') and db_pos.get('sl_price'):
                        pos_dict['stopLoss'] = db_pos['sl_price']
                    # Copy ALL DB metadata for detailed view
                    pos_dict['strategy'] = db_pos.get('strategy')
                    pos_dict['source'] = db_pos.get('source')
                    pos_dict['opened_by'] = db_pos.get('opened_by')
                    pos_dict['open_ts'] = db_pos.get('open_ts')
                    pos_dict['account_type'] = db_pos.get('account_type', account_type)
                    pos_dict['exchange'] = db_pos.get('exchange', exchange_type)
                    pos_dict['use_atr'] = db_pos.get('use_atr', False)
                    pos_dict['atr_activated'] = db_pos.get('atr_activated', False)
                    pos_dict['timeframe'] = db_pos.get('timeframe')
                else:
                    # Position not in DB - set defaults
                    pos_dict['account_type'] = account_type
                    pos_dict['exchange'] = exchange_type
                
                result.append(pos_dict)
            
            # Only log if positions changed or every 5 minutes
            if not hasattr(fetch_open_positions, '_last_count') or \
               fetch_open_positions._last_count != len(result) or \
               not hasattr(fetch_open_positions, '_last_log_time') or \
               (asyncio.get_event_loop().time() - fetch_open_positions._last_log_time) > 300:
                logger.info(f"‚úÖ Fetched {len(result)} positions via unified architecture")
                fetch_open_positions._last_count = len(result)
                fetch_open_positions._last_log_time = asyncio.get_event_loop().time()
            
            return result
            
        except Exception as e:
            logger.error(f"Unified fetch_open_positions error: {e}", exc_info=True)
            # Fall through to old code
    
    # OLD CODE (fallback) - with pagination
    try:
        uid = None
        if isinstance(user_id, int):
            uid = user_id
        else:
            # –ø—Ä–µ–¥–ø–æ–ª–∞–≥–∞–µ–º —á—Ç–æ —ç—Ç–æ update
            update = user_id
            uid = getattr(getattr(update, "effective_user", None), "id", None)

        if uid is None:
            uid = kwargs.get("user_id")

        if uid is None:
            raise RuntimeError("fetch_open_positions: –Ω–µ —É–¥–∞–ª–æ—Å—å –æ–ø—Ä–µ–¥–µ–ª–∏—Ç—å user_id")

        all_positions = []
        cursor = None
        
        while True:
            params = {"category": "linear", "settleCoin": "USDT", "limit": 200}
            if cursor:
                params["cursor"] = cursor
            
            res = await _bybit_request(
                uid, "GET", "/v5/position/list",
                params=params
            )
            
            positions = [p for p in (res.get("list") or []) if float(p.get("size") or 0) != 0.0]
            all_positions.extend(positions)
            
            cursor = res.get("nextPageCursor")
            if not cursor:
                break
        
        # Enrich with data from DB (TP/SL, strategy, etc.)
        account_type = kwargs.get('account_type')
        if not account_type:
            trading_mode = db.get_trading_mode(uid)
            account_type = 'real' if trading_mode == 'real' else 'demo'
        
        db_positions = db.get_active_positions(uid, account_type=account_type, exchange="bybit")
        db_by_symbol = {p['symbol']: p for p in db_positions}
        
        for pos in all_positions:
            symbol = pos.get('symbol', '')
            db_pos = db_by_symbol.get(symbol)
            if db_pos:
                # If exchange didn't return TP/SL, get from DB
                if not pos.get('takeProfit') and db_pos.get('tp_price'):
                    pos['takeProfit'] = str(db_pos['tp_price'])
                if not pos.get('stopLoss') and db_pos.get('sl_price'):
                    pos['stopLoss'] = str(db_pos['sl_price'])
                # Copy ALL DB metadata for detailed view
                pos['strategy'] = db_pos.get('strategy')
                pos['source'] = db_pos.get('source')
                pos['opened_by'] = db_pos.get('opened_by')
                pos['open_ts'] = db_pos.get('open_ts')
                pos['account_type'] = db_pos.get('account_type', account_type)
                pos['exchange'] = db_pos.get('exchange', 'bybit')
                pos['use_atr'] = db_pos.get('use_atr', False)
                pos['atr_activated'] = db_pos.get('atr_activated', False)
                pos['timeframe'] = db_pos.get('timeframe')
        
        return all_positions
    except MissingAPICredentials:
        return []
    except Exception as e:
        logger.error(f"Bybit fetch_open_positions error: {e}", exc_info=True)
        return None  # Return None on API error to prevent phantom position removal

async def _create_hl_adapter_for_account(uid: int, account_type: str):
    """Create and initialize HL adapter for given user and account_type (testnet/mainnet).
    Returns (adapter, is_testnet) or (None, False) if credentials missing.
    Caller MUST call adapter.close() when done."""
    from core.account_utils import get_hl_credentials_for_account
    hl_creds = get_hl_credentials(uid)
    private_key, is_testnet, _wallet = get_hl_credentials_for_account(hl_creds, account_type)
    if not private_key:
        return None, is_testnet
    adapter = HLAdapter(private_key=private_key, testnet=is_testnet)
    await adapter.initialize()
    return adapter, is_testnet


@log_calls
async def fetch_open_orders(user_id: int, symbol: str | None = None, account_type: str | None = None, exchange: str | None = None) -> list:
    """Fetch open orders with optional account_type override. Supports both Bybit and HyperLiquid."""
    # Determine exchange
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    if exchange == "hyperliquid":
        # HyperLiquid: use HL adapter
        adapter = None
        try:
            adapter, _is_testnet = await _create_hl_adapter_for_account(user_id, account_type or "testnet")
            if not adapter:
                return []
            result = await adapter.fetch_open_orders()
            if not result.get("success"):
                return []
            orders = result.get("data", [])
            # Convert to Bybit-compatible format for unified UI
            converted = []
            for o in orders:
                converted.append({
                    "symbol": o.get("symbol", ""),
                    "side": o.get("side", ""),
                    "qty": str(o.get("size", 0)),
                    "price": str(o.get("price", 0)),
                    "orderType": o.get("order_type", "Limit"),
                    "orderId": o.get("order_id", ""),
                    "orderStatus": "New",  # HL only returns open orders
                })
            return converted
        except Exception as e:
            logger.error(f"HL fetch_open_orders error: {e}", exc_info=True)
            return []
        finally:
            if adapter:
                await adapter.close()
    else:
        # Bybit
        params = {"category": "linear", "settleCoin": "USDT"}
        if symbol:
            params["symbol"] = symbol
        try:
            res = await _bybit_request(user_id, "GET", "/v5/order/realtime", params=params, account_type=account_type)
        except MissingAPICredentials:
            return []
        ALIVE = {"Created", "New", "PendingNew", "PartiallyFilled"}
        return [o for o in (res.get("list") or []) if o.get("orderStatus") in ALIVE]

@require_access
@with_texts
@log_calls
async def cmd_openorders(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show open orders - auto-selects based on exchange and enabled strategies."""
    uid = update.effective_user.id
    exchange = db.get_exchange_type(uid) or "bybit"
    
    # Get last viewed account or effective trading mode
    last_account = db.get_last_viewed_account(uid, exchange)
    await show_orders_for_account(update, ctx, last_account, exchange=exchange)


async def show_orders_for_account(update: Update, ctx: ContextTypes.DEFAULT_TYPE, account_type: str, exchange: str = None):
    """Show orders for specific account type - supports both Bybit and HyperLiquid."""
    uid = update.effective_user.id if hasattr(update, 'effective_user') else update.callback_query.from_user.id
    t = ctx.t
    
    # Detect exchange
    if exchange is None:
        exchange = ctx.user_data.get('orders_exchange') or db.get_exchange_type(uid) or "bybit"
    exchange = exchange.lower()
    ctx.user_data['orders_exchange'] = exchange
    
    # Determine switcher based on exchange
    if exchange == "hyperliquid":
        show_switcher = db.should_show_hl_network_switcher(uid)
    else:
        show_switcher = db.should_show_account_switcher(uid)
    
    # CRITICAL FIX: Normalize 'both' mode
    if account_type == 'both':
        if exchange == "hyperliquid":
            account_type = 'mainnet'
        else:
            creds = db.get_all_user_credentials(uid)
            if creds.get("real_api_key") and creds.get("real_api_secret"):
                account_type = 'real'
            else:
                account_type = 'demo'
        logger.info(f"[{uid}] Normalized account_type 'both' -> '{account_type}' for orders display")
    
    # Save last viewed account
    db.set_last_viewed_account(uid, account_type)
    
    try:
        ords = await fetch_open_orders(uid, account_type=account_type, exchange=exchange)
        
        mode_emoji, mode_label = _get_account_label(account_type, exchange)
        quote_currency = "USDC" if exchange == "hyperliquid" else "USDT"
        header = f"{mode_emoji} *{mode_label} Open Orders*\n\n"
        
        # Build switcher buttons
        switcher_row = _get_account_switcher_buttons(account_type, exchange, prefix="orders:switch") if show_switcher else []
        
        if not ords:
            text = header + t.get('no_open_orders', 'No open orders')
            
            buttons = []
            if switcher_row:
                buttons.append(switcher_row)
            buttons.append([InlineKeyboardButton("üîÑ " + t.get('refresh', 'Refresh'), callback_data="orders:refresh")])
            buttons.append([InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")])
            keyboard = InlineKeyboardMarkup(buttons)
            
            if hasattr(update, 'message') and update.message:
                await update.message.reply_text(text, reply_markup=keyboard, parse_mode="Markdown")
            else:
                await update.callback_query.edit_message_text(text, reply_markup=keyboard, parse_mode="Markdown")
            return

        lines = [header + t.get('open_orders_header', 'üìù Open Orders:'), ""]
        cancel_buttons = []
        for i, o in enumerate(ords, start=1):
            price = o.get('price')
            price_str = str(price) if price not in (None, "", 0, "0") else "‚Äî"
            qty_str = str(o.get('qty', "‚Äî"))
            symbol = o.get('symbol', "‚Äî")
            side   = o.get('side', "‚Äî")
            oid    = o.get('orderId', "‚Äî")
            side_emoji = "üü¢" if side == "Buy" else "üî¥"

            lines.append(
                f"{side_emoji} #{i} *{symbol}* {side}\n"
                f"  Qty: {qty_str} @ {price_str} {quote_currency}\n"
                f"  ID: `{oid}`"
            )
            lines.append("")
            
            # Add cancel button for each order
            cancel_buttons.append([
                InlineKeyboardButton(f"‚ùå Cancel #{i} {symbol}", callback_data=f"orders:cancel:{symbol}:{oid}")
            ])

        text = "\n".join(lines)
        
        # Build keyboard
        buttons = []
        # Cancel individual orders
        buttons.extend(cancel_buttons)
        # Cancel all button
        if len(ords) > 1:
            buttons.append([InlineKeyboardButton(f"üóë Cancel All ({len(ords)})", callback_data="orders:cancel_all")])
        # Switcher
        if switcher_row:
            buttons.append(switcher_row)
        # Refresh + Back
        buttons.append([InlineKeyboardButton("üîÑ " + t.get('refresh', 'Refresh'), callback_data="orders:refresh")])
        buttons.append([InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")])
        keyboard = InlineKeyboardMarkup(buttons)

        # Send message or edit existing
        if hasattr(update, 'message') and update.message:
            MAX_LEN = 3500
            for pos in range(0, len(text), MAX_LEN):
                chunk = text[pos:pos+MAX_LEN]
                await update.message.reply_text(
                    chunk, 
                    parse_mode="Markdown",
                    reply_markup=keyboard if pos + MAX_LEN >= len(text) else None
                )
        else:
            # Callback query - edit message
            if len(text) > 3500:
                text = text[:3450] + "\n...(truncated)"
            await update.callback_query.edit_message_text(
                text,
                parse_mode="Markdown",
                reply_markup=keyboard
            )

    except Exception as e:
        logger.error(f"Error in show_orders_for_account: {e}", exc_info=True)
        error_text = t.get('open_orders_error', 'Error fetching orders: {error}').format(error=e)
        
        if hasattr(update, 'message'):
            await update.message.reply_text(error_text)
        else:
            await update.callback_query.edit_message_text(error_text)


async def show_all_orders(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show orders from both Demo and Real accounts together."""
    uid = update.effective_user.id if hasattr(update, 'effective_user') else update.callback_query.from_user.id
    t = ctx.t
    show_switcher = db.should_show_account_switcher(uid)
    
    # Fetch orders from both accounts in parallel
    demo_ords, real_ords = await asyncio.gather(
        fetch_open_orders(uid, account_type="demo"),
        fetch_open_orders(uid, account_type="real"),
        return_exceptions=True
    )
    
    # Handle errors gracefully
    if isinstance(demo_ords, Exception):
        logger.warning(f"Error fetching demo orders for {uid}: {demo_ords}")
        demo_ords = []
    if isinstance(real_ords, Exception):
        logger.warning(f"Error fetching real orders for {uid}: {real_ords}")
        real_ords = []
    
    header = "üìä *All Open Orders (Demo + Real)*\n\n"
    
    if not demo_ords and not real_ords:
        text = header + t.get('no_open_orders', 'No open orders')
        if show_switcher:
            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("üéÆ Demo", callback_data="orders:demo"),
                    InlineKeyboardButton("üíé Real", callback_data="orders:real")
                ],
                [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
            ])
        else:
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
            ])
        
        if hasattr(update, 'message') and update.message:
            return await update.message.reply_text(text, reply_markup=keyboard, parse_mode="Markdown")
        else:
            return await update.callback_query.edit_message_text(text, reply_markup=keyboard, parse_mode="Markdown")
    
    lines = [header]
    
    # === DEMO ORDERS ===
    if demo_ords:
        lines.append(f"üéÆ *DEMO ORDERS* ({len(demo_ords)})")
        lines.append("‚îÄ" * 25)
        for i, o in enumerate(demo_ords, start=1):
            price = o.get('price')
            price_str = str(price) if price not in (None, "", 0, "0") else "‚Äî"
            qty_str = str(o.get('qty', "‚Äî"))
            symbol = o.get('symbol', "‚Äî")
            side = o.get('side', "‚Äî")
            side_emoji = "üü¢" if side == "Buy" else "üî¥"
            lines.append(f"  {side_emoji} {i}. {symbol} {side}")
            lines.append(f"     Qty: {qty_str} @ {price_str}")
        lines.append("")
    
    # === REAL ORDERS ===
    if real_ords:
        lines.append(f"üíé *REAL ORDERS* ({len(real_ords)})")
        lines.append("‚îÄ" * 25)
        for i, o in enumerate(real_ords, start=1):
            price = o.get('price')
            price_str = str(price) if price not in (None, "", 0, "0") else "‚Äî"
            qty_str = str(o.get('qty', "‚Äî"))
            symbol = o.get('symbol', "‚Äî")
            side = o.get('side', "‚Äî")
            side_emoji = "üü¢" if side == "Buy" else "üî¥"
            lines.append(f"  {side_emoji} {i}. {symbol} {side}")
            lines.append(f"     Qty: {qty_str} @ {price_str}")
        lines.append("")
    
    # === SUMMARY ===
    lines.append("‚ïê" * 25)
    total_count = len(demo_ords) + len(real_ords)
    lines.append(f"üìù *TOTAL:* {total_count} open orders")
    
    text = "\n".join(lines)
    
    if show_switcher:
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("üéÆ Demo", callback_data="orders:demo"),
                InlineKeyboardButton("üíé Real", callback_data="orders:real")
            ],
            [InlineKeyboardButton("üîÑ " + t.get('refresh', 'Refresh'), callback_data="orders:both")],
            [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
        ])
    else:
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üîÑ " + t.get('refresh', 'Refresh'), callback_data="orders:both")],
            [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
        ])
    
    # Send message or edit existing
    if hasattr(update, 'message') and update.message:
        MAX_LEN = 3500
        for pos in range(0, len(text), MAX_LEN):
            chunk = text[pos:pos+MAX_LEN]
            await update.message.reply_text(
                chunk,
                parse_mode="Markdown",
                reply_markup=keyboard if pos + MAX_LEN >= len(text) else None
            )
    else:
        if len(text) > 3500:
            text = text[:3450] + "\n...(truncated)"
        await update.callback_query.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=keyboard
        )


def _get_account_label(account_type: str, exchange: str = "bybit") -> tuple:
    """Return (emoji, label) for account_type based on exchange.
    Bybit: demo‚Üí(üéÆ,Demo), real‚Üí(üíé,Real)
    HyperLiquid: testnet‚Üí(üß™,Testnet), mainnet‚Üí(üåê,Mainnet)
    """
    if exchange == "hyperliquid":
        if account_type in ("testnet", "demo"):
            return "üß™", "Testnet"
        else:
            return "üåê", "Mainnet"
    else:
        if account_type == "demo":
            return "üéÆ", "Demo"
        else:
            return "üíé", "Real"


def _get_account_switcher_buttons(account_type: str, exchange: str = "bybit", prefix: str = "pos:switch") -> list:
    """Return switcher buttons based on exchange.
    Bybit: [Demo ‚úì] [Real]
    HyperLiquid: [Testnet ‚úì] [Mainnet]
    """
    if exchange == "hyperliquid":
        return [
            InlineKeyboardButton("üß™ Testnet" + (" ‚úì" if account_type in ("testnet", "demo") else ""), callback_data=f"{prefix}:testnet"),
            InlineKeyboardButton("üåê Mainnet" + (" ‚úì" if account_type in ("mainnet", "real") else ""), callback_data=f"{prefix}:mainnet")
        ]
    else:
        return [
            InlineKeyboardButton("üéÆ Demo" + (" ‚úì" if account_type == "demo" else ""), callback_data=f"{prefix}:demo"),
            InlineKeyboardButton("üíé Real" + (" ‚úì" if account_type == "real" else ""), callback_data=f"{prefix}:real")
        ]


@log_calls
@with_texts
async def handle_orders_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle orders account selection, cancel, and refresh callbacks."""
    query = update.callback_query
    await query.answer()
    
    uid = update.effective_user.id
    t = ctx.t
    data = query.data
    if not data.startswith("orders:"):
        return
    
    # Detect exchange from user_data or DB
    exchange = ctx.user_data.get('orders_exchange') or db.get_exchange_type(uid) or "bybit"
    exchange = exchange.lower()
    
    # Get account type from user_data or last viewed
    account_type = ctx.user_data.get('orders_account_type') or db.get_last_viewed_account(uid, exchange)
    
    # Handle different orders callbacks
    if data.startswith("orders:switch:"):
        # Switch account type (Demo/Real or Testnet/Mainnet)
        new_account_type = data.split(":")[2]
        db.set_last_viewed_account(uid, new_account_type)
        ctx.user_data['orders_account_type'] = new_account_type
        await show_orders_for_account(update, ctx, new_account_type, exchange=exchange)
    
    elif data == "orders:refresh":
        # Refresh orders
        await show_orders_for_account(update, ctx, account_type, exchange=exchange)
    
    elif data.startswith("orders:cancel:"):
        # Cancel single order: orders:cancel:SYMBOL:ORDER_ID
        parts = data.split(":")
        symbol = parts[2]
        order_id = parts[3]
        
        try:
            if exchange == "hyperliquid":
                adapter = None
                try:
                    adapter, _is_testnet = await _create_hl_adapter_for_account(uid, account_type)
                    if not adapter:
                        raise Exception("HyperLiquid not configured")
                    result = await adapter.cancel_order(symbol, order_id)
                    if not result.get("success", False) and result.get("retCode") != 0:
                        raise Exception(result.get("retMsg", result.get("error", "Cancel failed")))
                finally:
                    if adapter:
                        await adapter.close()
            else:
                # Bybit cancel
                body = {"category": "linear", "symbol": symbol, "orderId": order_id}
                await _bybit_request(uid, "POST", "/v5/order/cancel", data=body, account_type=account_type)
            
            await query.answer(f"‚úÖ Order {symbol} cancelled", show_alert=True)
            # Refresh orders view
            await show_orders_for_account(update, ctx, account_type, exchange=exchange)
        except Exception as e:
            logger.error(f"Cancel order {symbol}/{order_id} failed: {e}")
            await query.answer(f"‚ùå Cancel failed: {e}", show_alert=True)
    
    elif data == "orders:cancel_all":
        # Cancel all orders
        try:
            if exchange == "hyperliquid":
                adapter = None
                try:
                    adapter, _is_testnet = await _create_hl_adapter_for_account(uid, account_type)
                    if not adapter:
                        raise Exception("HyperLiquid not configured")
                    result = await adapter.cancel_all_orders()
                finally:
                    if adapter:
                        await adapter.close()
            else:
                # Bybit cancel all
                body = {"category": "linear", "settleCoin": "USDT"}
                await _bybit_request(uid, "POST", "/v5/order/cancel-all", data=body, account_type=account_type)
            
            await query.answer("‚úÖ All orders cancelled", show_alert=True)
            # Refresh orders view
            await show_orders_for_account(update, ctx, account_type, exchange=exchange)
        except Exception as e:
            logger.error(f"Cancel all orders failed: {e}")
            await query.answer(f"‚ùå Cancel all failed: {e}", show_alert=True)
    
    elif data in ("orders:demo", "orders:real", "orders:both"):
        # Legacy callback format ‚Äî redirect to switch
        legacy_type = data.split(":")[1]
        if legacy_type in ("demo", "real"):
            db.set_last_viewed_account(uid, legacy_type)
            ctx.user_data['orders_account_type'] = legacy_type
        if legacy_type == "both":
            await show_all_orders(update, ctx)
        else:
            await show_orders_for_account(update, ctx, legacy_type, exchange=exchange)

@require_access
@with_texts
@log_calls
async def cmd_select_coins(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    ctx.user_data['mode'] = 'select_coins'
    await update.message.reply_text(
        ctx.t['enter_coins'],
        parse_mode='Markdown'
    )

@require_access
@with_texts
@log_calls
async def cmd_positions(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show positions - uses last viewed account for UI persistence. Supports both exchanges."""
    uid = update.effective_user.id
    exchange = db.get_exchange_type(uid) or "bybit"
    
    # Get last viewed account (persists user's selection)
    last_account = db.get_last_viewed_account(uid, exchange)
    
    # Show positions for the last viewed account
    await show_positions_for_account(update, ctx, last_account, exchange=exchange)


def build_pnl_summary_by_strategy_and_exchange(
    api_positions: list[dict], 
    db_positions: list[dict]
) -> tuple[dict, dict, float]:
    """
    Build PnL summary grouped by strategy and exchange.
    
    Returns:
        tuple of (strategy_pnl, exchange_pnl, total_pnl)
        strategy_pnl: {strategy_name: {"pnl": float, "count": int}}
        exchange_pnl: {exchange_name: {"pnl": float, "count": int}}
    """
    # Create lookup from DB positions by symbol
    db_by_symbol = {p["symbol"]: p for p in db_positions}
    
    strategy_pnl: dict[str, dict] = {}
    exchange_pnl: dict[str, dict] = {}
    total_pnl = 0.0
    
    for pos in api_positions:
        sym = pos.get("symbol", "")
        pnl = float(pos.get("unrealisedPnl") or 0)
        total_pnl += pnl
        
        # Get strategy and exchange from DB
        db_pos = db_by_symbol.get(sym, {})
        strategy = db_pos.get("strategy") or "unknown"
        exchange = db_pos.get("exchange") or "bybit"
        
        # Aggregate by strategy
        if strategy not in strategy_pnl:
            strategy_pnl[strategy] = {"pnl": 0.0, "count": 0}
        strategy_pnl[strategy]["pnl"] += pnl
        strategy_pnl[strategy]["count"] += 1
        
        # Aggregate by exchange
        if exchange not in exchange_pnl:
            exchange_pnl[exchange] = {"pnl": 0.0, "count": 0}
        exchange_pnl[exchange]["pnl"] += pnl
        exchange_pnl[exchange]["count"] += 1
    
    return strategy_pnl, exchange_pnl, total_pnl


def format_pnl_summary(strategy_pnl: dict, exchange_pnl: dict, total_pnl: float, t: dict) -> str:
    """Format PnL summary section for positions view."""
    lines = []
    
    # Strategy breakdown
    if strategy_pnl:
        lines.append(t.get('pnl_by_strategy', 'üìä *PnL by Strategy:*'))
        # Sort by PnL descending
        for strat, data in sorted(strategy_pnl.items(), key=lambda x: x[1]["pnl"], reverse=True):
            pnl = data["pnl"]
            count = data["count"]
            emoji = "üìà" if pnl >= 0 else "üìâ"
            strat_display = strat.capitalize() if strat else "Manual"
            lines.append(f"  {emoji} {strat_display}: `{pnl:+.2f}` ({count})")
    
    # Exchange breakdown (only if more than one exchange)
    if len(exchange_pnl) > 1:
        lines.append("")
        lines.append(t.get('pnl_by_exchange', 'üè¶ *PnL by Exchange:*'))
        for exch, data in sorted(exchange_pnl.items(), key=lambda x: x[1]["pnl"], reverse=True):
            pnl = data["pnl"]
            count = data["count"]
            emoji = "üìà" if pnl >= 0 else "üìâ"
            exch_display = exch.upper() if exch else "BYBIT"
            lines.append(f"  {emoji} {exch_display}: `{pnl:+.2f}` ({count})")
    
    # Total
    lines.append("")
    total_emoji = "üìà" if total_pnl >= 0 else "üìâ"
    lines.append(f"{total_emoji} *{t.get('total_pnl', 'Total PnL')}:* `{total_pnl:+.2f}` USDT")
    
    return "\n".join(lines)


async def show_positions_for_account(update: Update, ctx: ContextTypes.DEFAULT_TYPE, account_type: str, exchange: str = None):
    """Show positions for specific account type with interactive 3-column keyboard.
    Works for both Bybit (demo/real) and HyperLiquid (testnet/mainnet)."""
    uid = update.effective_user.id if hasattr(update, 'effective_user') else update.callback_query.from_user.id
    t = ctx.t
    
    # Determine exchange
    if exchange is None:
        exchange = db.get_exchange_type(uid) or "bybit"
    
    if exchange == "hyperliquid":
        show_switcher = db.should_show_hl_network_switcher(uid)
    else:
        show_switcher = db.should_show_account_switcher(uid)
    
    # CRITICAL FIX: Normalize 'both' mode - prefer 'real' if has real API keys
    if account_type == 'both':
        if exchange == "hyperliquid":
            account_type = 'mainnet'
        else:
            creds = db.get_all_user_credentials(uid)
            if creds.get("real_api_key") and creds.get("real_api_secret"):
                account_type = 'real'
            else:
                account_type = 'demo'
        logger.info(f"[{uid}] Normalized account_type 'both' -> '{account_type}' for positions display")
    
    # Save account type to user_data for callbacks
    ctx.user_data['positions_account_type'] = account_type
    ctx.user_data['positions_exchange'] = exchange
    ctx.user_data['positions_page'] = 0
    
    pos_list = await fetch_open_positions(uid, account_type=account_type, exchange=exchange)
    
    mode_emoji, mode_label = _get_account_label(account_type, exchange)
    
    if not pos_list:
        text = f"{mode_emoji} *{mode_label}* üìä {t.get('open_positions', 'Open Positions')} (0)\n\n{t.get('no_positions', 'üö´ No open positions')}"
        keyboard = get_positions_list_keyboard([], 0, t, account_type=account_type, show_switcher=show_switcher, exchange=exchange)
        
        if hasattr(update, 'message') and update.message:
            return await update.message.reply_text(text, reply_markup=keyboard, parse_mode="Markdown")
        else:
            return await update.callback_query.edit_message_text(text, reply_markup=keyboard, parse_mode="Markdown")

    # Use the interactive 3-column keyboard format
    text = format_positions_list_header(pos_list, 0, t, account_type=account_type, exchange=exchange)
    keyboard = get_positions_list_keyboard(pos_list, 0, t, account_type=account_type, show_switcher=show_switcher, exchange=exchange)

    # Send message or edit existing
    if hasattr(update, 'message') and update.message:
        await update.message.reply_text(text, reply_markup=keyboard, parse_mode="Markdown")
    else:
        await update.callback_query.edit_message_text(text, reply_markup=keyboard, parse_mode="Markdown")


async def show_all_positions(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show positions from both Demo and Real accounts together."""
    uid = update.effective_user.id if hasattr(update, 'effective_user') else update.callback_query.from_user.id
    t = ctx.t
    show_switcher = db.should_show_account_switcher(uid)
    
    # Fetch positions from both accounts in parallel
    demo_pos, real_pos = await asyncio.gather(
        fetch_open_positions(uid, account_type="demo"),
        fetch_open_positions(uid, account_type="real"),
        return_exceptions=True
    )
    
    # Handle errors gracefully
    if isinstance(demo_pos, Exception):
        logger.warning(f"Error fetching demo positions for {uid}: {demo_pos}")
        demo_pos = []
    if isinstance(real_pos, Exception):
        logger.warning(f"Error fetching real positions for {uid}: {real_pos}")
        real_pos = []
    
    header = "üìä *All Positions (Demo + Real)*\n\n"
    
    if not demo_pos and not real_pos:
        text = header + t.get('no_positions', 'No open positions')
        if show_switcher:
            keyboard = InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("üéÆ Demo", callback_data="positions:demo"),
                    InlineKeyboardButton("üíé Real", callback_data="positions:real")
                ],
                [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
            ])
        else:
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
            ])
        
        if hasattr(update, 'message') and update.message:
            return await update.message.reply_text(text, reply_markup=keyboard, parse_mode="Markdown")
        else:
            return await update.callback_query.edit_message_text(text, reply_markup=keyboard, parse_mode="Markdown")
    
    # Get DB positions for strategy info
    user_exchange = db.get_exchange_type(uid) or "bybit"
    demo_db = db.get_active_positions(uid, account_type="demo", exchange=user_exchange)
    real_db = db.get_active_positions(uid, account_type="real", exchange=user_exchange)
    
    total_pnl = 0.0
    total_im = 0.0
    lines = [header]
    
    # === DEMO SECTION ===
    if demo_pos:
        demo_pnl = sum(float(p.get("unrealisedPnl") or 0) for p in demo_pos)
        demo_emoji = "üìà" if demo_pnl >= 0 else "üìâ"
        lines.append(f"üéÆ *DEMO POSITIONS* ({len(demo_pos)}) {demo_emoji} `{demo_pnl:+.2f}` USDT")
        lines.append("‚îÄ" * 25)
        
        db_by_symbol = {p["symbol"]: p for p in demo_db}
        for idx, p in enumerate(demo_pos, start=1):
            sym = p.get("symbol", "-")
            side = p.get("side", "-")
            lev = p.get("leverage", "-")
            pnl_i = float(p.get("unrealisedPnl") or 0)
            im = float(p.get("positionIM") or 0)
            
            db_pos = db_by_symbol.get(sym, {})
            strategy = db_pos.get("strategy") or "unknown"
            
            pct = (pnl_i / im * 100) if im else 0.0
            total_pnl += pnl_i
            total_im += im
            
            side_emoji = "üü¢" if side == "Buy" else "üî¥"
            pnl_emoji = "üìà" if pnl_i >= 0 else "üìâ"
            
            lines.append(f"  {side_emoji} {idx}. {sym} {side}x{lev}")
            lines.append(f"     [{strategy.capitalize()}] {pnl_emoji} `{pnl_i:+.2f}` ({pct:+.1f}%)")
        
        lines.append("")
    
    # === REAL SECTION ===
    if real_pos:
        real_pnl = sum(float(p.get("unrealisedPnl") or 0) for p in real_pos)
        real_emoji = "üìà" if real_pnl >= 0 else "üìâ"
        lines.append(f"üíé *REAL POSITIONS* ({len(real_pos)}) {real_emoji} `{real_pnl:+.2f}` USDT")
        lines.append("‚îÄ" * 25)
        
        db_by_symbol = {p["symbol"]: p for p in real_db}
        for idx, p in enumerate(real_pos, start=1):
            sym = p.get("symbol", "-")
            side = p.get("side", "-")
            lev = p.get("leverage", "-")
            pnl_i = float(p.get("unrealisedPnl") or 0)
            im = float(p.get("positionIM") or 0)
            
            db_pos = db_by_symbol.get(sym, {})
            strategy = db_pos.get("strategy") or "unknown"
            
            pct = (pnl_i / im * 100) if im else 0.0
            total_pnl += pnl_i
            total_im += im
            
            side_emoji = "üü¢" if side == "Buy" else "üî¥"
            pnl_emoji = "üìà" if pnl_i >= 0 else "üìâ"
            
            lines.append(f"  {side_emoji} {idx}. {sym} {side}x{lev}")
            lines.append(f"     [{strategy.capitalize()}] {pnl_emoji} `{pnl_i:+.2f}` ({pct:+.1f}%)")
        
        lines.append("")
    
    # === SUMMARY ===
    lines.append("‚ïê" * 25)
    total_emoji = "üìà" if total_pnl >= 0 else "üìâ"
    total_count = len(demo_pos) + len(real_pos)
    lines.append(f"üí∞ *TOTAL:* {total_count} positions {total_emoji} `{total_pnl:+.2f}` USDT")
    
    text = "\n".join(lines)
    
    if show_switcher:
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("üéÆ Demo", callback_data="positions:demo"),
                InlineKeyboardButton("üíé Real", callback_data="positions:real")
            ],
            [InlineKeyboardButton("üîÑ " + t.get('refresh', 'Refresh'), callback_data="positions:both")],
            [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
        ])
    else:
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üîÑ " + t.get('refresh', 'Refresh'), callback_data="positions:both")],
            [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
        ])
    
    # Send message or edit existing
    if hasattr(update, 'message') and update.message:
        escaped = html.escape(text)
        max_len = 3000
        for i in range(0, len(escaped), max_len):
            chunk = escaped[i : i + max_len]
            await ctx.bot.send_message(
                chat_id=update.effective_chat.id,
                text=f"<pre>{chunk}</pre>",
                parse_mode="HTML",
                reply_markup=keyboard if i + max_len >= len(escaped) else None,
                disable_web_page_preview=True
            )
    else:
        escaped = html.escape(text)
        if len(escaped) > 3000:
            escaped = escaped[:2950] + "\n...(truncated)"
        await update.callback_query.edit_message_text(
            f"<pre>{escaped}</pre>",
            parse_mode="HTML",
            reply_markup=keyboard,
            disable_web_page_preview=True
        )


@log_calls
@with_texts
async def handle_positions_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle positions account selection callbacks."""
    query = update.callback_query
    await query.answer()
    
    uid = update.effective_user.id
    data = query.data
    if not data.startswith("positions:"):
        return
    
    account_type = data.split(":")[1]  # "demo", "real" or "both"
    
    # Save last viewed account for UI persistence
    if account_type in ("demo", "real"):
        db.set_last_viewed_account(uid, account_type)
    
    if account_type == "both":
        await show_all_positions(update, ctx)
    else:
        await show_positions_for_account(update, ctx, account_type)


# ------------------------------------------------------------------------------------
# Open Positions Management (detailed view with pagination and close buttons)
# ------------------------------------------------------------------------------------

POSITIONS_PER_PAGE = 10  # Show 10 positions per page

def get_positions_list_keyboard(positions: list, page: int, t: dict, account_type: str = "demo", show_switcher: bool = True, exchange: str = "bybit") -> InlineKeyboardMarkup:
    """Build inline keyboard for paginated positions list (10 per page).
    Supports both Bybit (Demo/Real) and HyperLiquid (Testnet/Mainnet)."""
    buttons = []
    total = len(positions)
    total_pages = (total + POSITIONS_PER_PAGE - 1) // POSITIONS_PER_PAGE
    
    if total == 0:
        # No positions - show switcher and back
        if show_switcher:
            buttons.append(_get_account_switcher_buttons(account_type, exchange, prefix="pos:switch"))
        buttons.append([InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data="pos:back")])
        return InlineKeyboardMarkup(buttons)
    
    # Get positions for current page
    start_idx = page * POSITIONS_PER_PAGE
    end_idx = min(start_idx + POSITIONS_PER_PAGE, total)
    page_positions = positions[start_idx:end_idx]
    
    # Create button for each position on this page (3 columns: symbol, PnL, close)
    for idx, pos in enumerate(page_positions):
        global_idx = start_idx + idx + 1  # 1-based index
        sym = pos.get("symbol", "-")
        # Remove USDT suffix for shorter display
        sym_short = sym.replace("USDT", "") if sym.endswith("USDT") else sym
        side = pos.get("side", "-")
        pnl = float(pos.get("unrealisedPnl") or 0)
        
        emoji = "üî¥" if side == "Sell" else "üü¢"
        pnl_emoji = "üìà" if pnl >= 0 else "üìâ"
        
        # Row: position button + PnL button + close button (3 columns)
        buttons.append([
            InlineKeyboardButton(
                f"{emoji} {sym_short}",
                callback_data=f"pos:view:{sym}"
            ),
            InlineKeyboardButton(
                f"{pnl_emoji} {pnl:+.2f}",
                callback_data=f"pos:view:{sym}"
            ),
            InlineKeyboardButton("‚ùå", callback_data=f"pos:close:{sym}")
        ])
    
    # Navigation row (if multiple pages)
    if total_pages > 1:
        nav_row = []
        # Previous page
        if page > 0:
            nav_row.append(InlineKeyboardButton("‚óÄÔ∏è Prev", callback_data=f"pos:list:{page - 1}"))
        
        # Page counter
        nav_row.append(InlineKeyboardButton(f"{page + 1}/{total_pages}", callback_data="pos:noop"))
        
        # Next page
        if page < total_pages - 1:
            nav_row.append(InlineKeyboardButton("Next ‚ñ∂Ô∏è", callback_data=f"pos:list:{page + 1}"))
        
        buttons.append(nav_row)
    
    # Action buttons row (refresh + close all)
    action_row = [InlineKeyboardButton("üîÑ", callback_data=f"pos:list:{page}")]
    if total > 1:
        action_row.append(
            InlineKeyboardButton(
                f"‚ö†Ô∏è {t.get('btn_close_all', 'Close all')} ({total})",
                callback_data="pos:close_all"
            )
        )
    buttons.append(action_row)
    
    # Account type switcher (Demo/Real for Bybit, Testnet/Mainnet for HL)
    if show_switcher:
        buttons.append(_get_account_switcher_buttons(account_type, exchange, prefix="pos:switch"))
    
    # Back button
    buttons.append([
        InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data="pos:back")
    ])
    
    return InlineKeyboardMarkup(buttons)


def format_positions_list_header(positions: list, page: int, t: dict, account_type: str = "demo", exchange: str = "bybit") -> str:
    """Format header for paginated positions list. Supports both Bybit and HL."""
    total = len(positions)
    total_pages = (total + POSITIONS_PER_PAGE - 1) // POSITIONS_PER_PAGE
    
    total_pnl = sum(float(p.get("unrealisedPnl") or 0) for p in positions)
    pnl_emoji = "üìà" if total_pnl >= 0 else "üìâ"
    
    mode_emoji, mode_label = _get_account_label(account_type, exchange)
    quote = "USDC" if exchange == "hyperliquid" else "USDT"
    
    return (
        f"{mode_emoji} *{mode_label}* üìä {t.get('open_positions', 'Open Positions')} ({total})\n"
        f"{pnl_emoji} Total P/L: `{total_pnl:+.2f}` {quote}\n"
        f"üìÑ Page {page + 1}/{total_pages}\n"
        f"_Tap position to view details_"
    )


def get_positions_paginated_keyboard(positions: list, current_idx: int, t: dict, page: int = 0) -> InlineKeyboardMarkup:
    """Build inline keyboard for single position view with pagination."""
    buttons = []
    total = len(positions)
    
    if total == 0:
        return InlineKeyboardMarkup([[
            InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data="pos:back")
        ]])
    
    pos = positions[current_idx]
    sym = pos.get("symbol", "-")
    
    # Navigation row (if more than 1 position)
    if total > 1:
        nav_row = []
        # Previous button
        if current_idx > 0:
            nav_row.append(InlineKeyboardButton("‚óÄÔ∏è", callback_data=f"pos:page:{current_idx - 1}"))
        else:
            nav_row.append(InlineKeyboardButton("‚óÄÔ∏è", callback_data=f"pos:page:{total - 1}"))  # Wrap to end
        
        # Position counter
        nav_row.append(InlineKeyboardButton(f"{current_idx + 1}/{total}", callback_data="pos:noop"))
        
        # Next button
        if current_idx < total - 1:
            nav_row.append(InlineKeyboardButton("‚ñ∂Ô∏è", callback_data=f"pos:page:{current_idx + 1}"))
        else:
            nav_row.append(InlineKeyboardButton("‚ñ∂Ô∏è", callback_data=f"pos:page:0"))  # Wrap to start
        
        buttons.append(nav_row)
    
    # Close this position button
    buttons.append([
        InlineKeyboardButton(f"‚ùå {t.get('btn_close_position', 'Close position')}", callback_data=f"pos:close:{sym}")
    ])
    
    # Close all positions button (if more than 1)
    if total > 1:
        buttons.append([
            InlineKeyboardButton(
                f"‚ö†Ô∏è {t.get('btn_close_all', 'Close all')} ({total})",
                callback_data="pos:close_all"
            )
        ])
    
    # Refresh and Back - use pos:refresh:PAGE to preserve page
    buttons.append([
        InlineKeyboardButton("üîÑ", callback_data=f"pos:refresh:{page}"),
        InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data=f"pos:list:{page}")
    ])
    
    return InlineKeyboardMarkup(buttons)


def format_single_position(pos: dict, idx: int, total: int, t: dict) -> str:
    """Format detailed view of a single position for paginated display."""
    sym = pos.get("symbol", "-")
    side = pos.get("side", "-")
    lev = pos.get("leverage", "-")
    size = float(pos.get("size") or 0)
    entry = float(pos.get("avgPrice") or 0)
    mark = float(pos.get("markPrice") or 0)
    pnl = float(pos.get("unrealisedPnl") or 0)
    im = float(pos.get("positionIM") or 0)
    
    def to_float(key):
        raw = pos.get(key)
        return float(raw) if raw not in (None, "", "0") else None
    
    tp = to_float("takeProfit")
    sl = to_float("stopLoss")
    liq = to_float("liqPrice")
    
    # Calculate PnL percentage
    pnl_pct = (pnl / im * 100) if im else 0.0
    
    emoji = "üü¢" if side == "Buy" else "üî¥"
    side_text = "LONG" if side == "Buy" else "SHORT"
    pnl_emoji = "üìà" if pnl >= 0 else "üìâ"
    
    lines = [
        f"{emoji} *{sym}* {side_text} {lev}x",
        "",
        f"üìä Size: `{size}`",
        f"üí∞ Entry: `{entry:.6g}`",
        f"üìç Mark: `{mark:.6g}`",
    ]
    
    # TP info
    if tp:
        tp_pct = abs((tp - entry) / entry * 100) if entry else 0
        tp_sign = "+" if (side == "Buy" and tp > entry) or (side == "Sell" and tp < entry) else "-"
        lines.append(f"üéØ TP: `{tp:.6g}` ({tp_sign}{tp_pct:.2f}%)")
    else:
        lines.append(f"üéØ TP: ‚Äì")
    
    # SL info
    if sl:
        sl_pct = abs((sl - entry) / entry * 100) if entry else 0
        lines.append(f"üõë SL: `{sl:.6g}` (-{sl_pct:.2f}%)")
    else:
        lines.append(f"üõë SL: ‚Äì")
    
    # Liquidation
    if liq:
        lines.append(f"üíÄ Liq: `{liq:.6g}`")
    
    lines.append("")
    lines.append(f"{pnl_emoji} *P/L:* `{pnl:+.4f}` USDT ({pnl_pct:+.2f}%)")
    
    return "\n".join(lines)


def get_positions_keyboard(positions: list, t: dict) -> InlineKeyboardMarkup:
    """Build inline keyboard for positions management."""
    buttons = []
    for idx, p in enumerate(positions, start=1):
        sym = p.get("symbol", "-")
        side = p.get("side", "-")
        emoji = "üü¢" if side == "Buy" else "üî¥"
        # View details button
        buttons.append([
            InlineKeyboardButton(
                f"{emoji} {idx}. {sym}",
                callback_data=f"pos:view:{sym}"
            ),
            InlineKeyboardButton(
                f"‚ùå {t.get('btn_close_short', 'Close')}",
                callback_data=f"pos:close:{sym}"
            )
        ])
    
    # Close all and Back buttons
    if len(positions) > 0:
        buttons.append([
            InlineKeyboardButton(
                f"‚ö†Ô∏è {t.get('btn_close_all', 'Close all positions')} ({len(positions)})",
                callback_data="pos:close_all"
            )
        ])
    buttons.append([
        InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data="pos:back")
    ])
    return InlineKeyboardMarkup(buttons)


def format_position_summary(positions: list, t: dict) -> str:
    """Format positions summary for the overview message."""
    if not positions:
        return t.get('no_positions', 'No open positions')
    
    total_pnl = 0.0
    lines = [t.get('open_positions_header', 'üìä *Open positions*')]
    lines.append(f"{len(positions)} {t.get('positions_count', 'positions')}\n")
    
    for idx, p in enumerate(positions, start=1):
        sym = p.get("symbol", "-")
        side = p.get("side", "-")
        entry = float(p.get("avgPrice") or 0)
        mark = float(p.get("markPrice") or 0)
        pnl = float(p.get("unrealisedPnl") or 0)
        im = float(p.get("positionIM") or 0)
        
        # Calculate PnL percentage
        pct = (pnl / im * 100) if im else 0.0
        
        total_pnl += pnl
        
        # Format line - always show in USDT
        emoji = "üü¢" if side == "Buy" else "üî¥"
        pnl_emoji = "üìà" if pnl >= 0 else "üìâ"
        
        lines.append(
            f"{idx}. {emoji} *{sym}* | Entry: `{entry:.6g}`\n"
            f"   {pnl_emoji} {pct:+.2f}% ({pnl:+.4f} USDT)"
        )
    
    # Total in USDT
    lines.append(f"\n*{t.get('total_unrealized_pnl', 'Total Unrealized P/L')}:* {total_pnl:+.2f} USDT")
    
    return "\n".join(lines)


def format_position_detail(p: dict, t: dict) -> str:
    """Format detailed view of a single position."""
    import datetime
    
    sym = p.get("symbol", "-")
    side = p.get("side", "-")
    lev = p.get("leverage", "-")
    size = float(p.get("size") or 0)
    entry = float(p.get("avgPrice") or 0)
    mark = float(p.get("markPrice") or 0)
    pnl = float(p.get("unrealisedPnl") or 0)
    im = float(p.get("positionIM") or 0)
    
    # Get extended info from DB
    strategy = p.get("strategy", "Unknown")
    account_type = p.get("account_type", "demo")
    exchange = p.get("exchange", "bybit")
    open_ts = p.get("open_ts")
    use_atr = p.get("use_atr", False)
    atr_activated = p.get("atr_activated", False)
    timeframe = p.get("timeframe")
    
    def to_float(key):
        raw = p.get(key)
        return float(raw) if raw not in (None, "", "0") else None
    
    tp = to_float("takeProfit")
    sl = to_float("stopLoss")
    liq = to_float("liqPrice")
    
    # Calculate percentages
    pnl_pct = (pnl / im * 100) if im else 0.0
    tp_pct = ((tp - entry) / entry * 100) if tp and entry else None
    sl_pct = ((entry - sl) / entry * 100) if sl and entry and side == "Buy" else None
    if sl and entry and side == "Sell":
        sl_pct = ((sl - entry) / entry * 100)
    
    emoji = "üü¢" if side == "Buy" else "üî¥"
    side_text = "LONG" if side == "Buy" else "SHORT"
    pnl_emoji = "üìà" if pnl >= 0 else "üìâ"
    
    # Format strategy name nicely
    strategy_names = {
        "scryptomera": "üì∞ Scryptomera",
        "scalper": "‚ö° Scalper", 
        "elcaro": "üéØ Enliko",
        "wyckoff": "üìä Wyckoff",
        "oi": "üìà OI Delta",
        "fibonacci": "üî¢ Fibonacci",
        "rsi_bb": "üìâ RSI/BB",
        "manual": "‚úã Manual",
    }
    strategy_display = strategy_names.get(strategy.lower() if strategy else "", f"üé≤ {strategy}")
    
    # Format exchange and account
    exchange_emoji = "üü°" if exchange == "bybit" else "üü£"  # Yellow for Bybit, Purple for HL
    account_emoji = "üéÆ" if account_type == "demo" else "üíé"
    account_label = "Demo" if account_type == "demo" else "Real"
    
    lines = [
        f"{emoji} *{sym}* {lev}x {side_text}",
        f"",
        f"üìç Entry: `{entry:.6g}` ‚Üí Now: `{mark:.6g}`",
        f"üì¶ Size: `{size:.6g}`"
    ]
    
    # TP/SL info
    if tp:
        tp_sign = "+" if (side == "Buy" and tp > entry) or (side == "Sell" and tp < entry) else ""
        tp_pct_val = abs((tp - entry) / entry * 100) if entry else 0
        lines.append(f"üéØ TP: `{tp:.6g}` ({tp_sign}{tp_pct_val:.1f}%)")
    else:
        lines.append(f"üéØ TP: ‚Äì")
    
    if sl:
        sl_pct_val = abs((sl - entry) / entry * 100) if entry else 0
        lines.append(f"üõë SL: `{sl:.6g}` (-{sl_pct_val:.1f}%)")
    else:
        lines.append(f"üõë SL: ‚Äì")
    
    # Liquidation price if available
    if liq and liq > 0:
        liq_pct = abs((liq - entry) / entry * 100) if entry else 0
        lines.append(f"üíÄ Liq: `{liq:.6g}` (-{liq_pct:.1f}%)")
    
    # PnL
    lines.append(f"")
    lines.append(f"{pnl_emoji} *PnL:* {pnl_pct:+.2f}% ({pnl:+.4f} USDT)")
    
    # Separator
    lines.append(f"")
    lines.append(f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ")
    
    # Strategy info
    lines.append(f"üìã Strategy: {strategy_display}")
    
    # Exchange & Account
    lines.append(f"{exchange_emoji} {exchange.upper()} ‚Ä¢ {account_emoji} {account_label}")
    
    # ATR Trailing Stop status
    if use_atr:
        atr_status = "‚úÖ Active" if atr_activated else "‚è≥ Waiting"
        lines.append(f"üîÑ ATR Trailing: {atr_status}")
    
    # Time opened
    if open_ts:
        try:
            dt = datetime.datetime.fromtimestamp(open_ts)
            # Calculate duration
            now = datetime.datetime.now()
            duration = now - dt
            hours = int(duration.total_seconds() // 3600)
            mins = int((duration.total_seconds() % 3600) // 60)
            if hours > 24:
                days = hours // 24
                hours = hours % 24
                duration_str = f"{days}d {hours}h"
            elif hours > 0:
                duration_str = f"{hours}h {mins}m"
            else:
                duration_str = f"{mins}m"
            lines.append(f"‚è± Opened: {dt.strftime('%d.%m %H:%M')} ({duration_str} ago)")
        except Exception:
            pass
    
    # Timeframe if available
    if timeframe:
        lines.append(f"üìä Timeframe: {timeframe}")
    
    return "\n".join(lines)


# ------------------------------------------------------------------------------------
# Direct Balance/Positions/Orders functions (skip mode selection for single-mode users)
# ------------------------------------------------------------------------------------

@log_calls
async def fetch_spot_unrealized_pnl(user_id: int, coins: list, account_type: str = None) -> dict:
    """Calculate unrealized PnL for spot holdings.
    
    Uses EXACTLY the same method as format_spot_stats():
    - fetch_spot_balance() for coin quantities
    - get_spot_ticker() for current market prices
    - holdings_value = sum(qty * lastPrice for each DCA coin)
    - PnL = holdings_value - total_invested
    
    This ensures Balance and Spot DCA Statistics show identical values.
    
    OPTIMIZED: Fetches all tickers in parallel instead of sequentially.
    
    Args:
        user_id: User ID
        coins: List of coin balances from wallet API (not used, kept for compatibility)
        account_type: 'demo' or 'real'
    
    Returns:
        dict with:
        - total_unrealized: Total unrealized PnL in USDT
        - holdings_value: Total current value of DCA holdings
        - total_invested: Total invested via DCA
        - pnl_pct: Percentage PnL
    """
    # Get stored DCA data from spot_settings
    cfg = db.get_user_config(user_id) or {}
    spot_settings = cfg.get("spot_settings") or {}
    total_invested = float(spot_settings.get("total_invested", 0.0))
    dca_coins = spot_settings.get("coins", [])  # Coins tracked by DCA
    
    # No DCA setup = no spot PnL
    if not dca_coins or total_invested <= 0:
        return {
            "total_unrealized": 0.0,
            "holdings_value": 0.0,
            "total_invested": 0.0,
            "pnl_pct": 0.0,
            "coin_values": {}
        }
    
    # Get spot balances using same method as format_spot_stats
    balances = await fetch_spot_balance(user_id, account_type=account_type)
    
    # OPTIMIZED: Fetch all tickers in parallel instead of sequentially
    # This reduces ~N*200ms to ~200ms for N coins
    coins_with_balance = [(coin, balances.get(coin, 0)) for coin in dca_coins if balances.get(coin, 0) > 0]
    
    if not coins_with_balance:
        return {
            "total_unrealized": 0.0,
            "holdings_value": 0.0,
            "total_invested": total_invested,
            "pnl_pct": 0.0,
            "coin_values": {}
        }
    
    # Fetch all tickers in parallel
    async def fetch_ticker_safe(coin):
        try:
            symbol = f"{coin}USDT"
            return await get_spot_ticker(user_id, symbol, account_type=account_type)
        except Exception:
            return None
    
    ticker_results = await asyncio.gather(
        *[fetch_ticker_safe(coin) for coin, _ in coins_with_balance],
        return_exceptions=True
    )
    
    # Calculate holdings value using results
    holdings_value = 0.0
    coin_values = {}
    
    for (coin, qty), ticker in zip(coins_with_balance, ticker_results):
        if isinstance(ticker, Exception) or ticker is None:
            continue
        price = float(ticker.get("lastPrice", 0))
        if price > 0:
            value = qty * price
            holdings_value += value
            coin_values[coin] = value
    
    # Calculate PnL same as Spot DCA Statistics
    total_unrealized = holdings_value - total_invested
    pnl_pct = (total_unrealized / total_invested * 100) if total_invested > 0 else 0.0
    
    logger.debug(f"[{user_id}] Spot PnL: holdings={holdings_value:.2f}, invested={total_invested:.2f}, pnl={total_unrealized:.2f} ({pnl_pct:.1f}%)")
    
    return {
        "total_unrealized": total_unrealized,
        "holdings_value": holdings_value,
        "total_invested": total_invested,
        "pnl_pct": pnl_pct,
        "coin_values": coin_values
    }


@log_calls
async def fetch_spot_pnl(user_id: int, days: int = 7, account_type: str = None) -> dict:
    """Fetch spot trading PnL by analyzing execution history.
    
    Returns:
        dict with:
        - total_pnl: Net realized profit/loss from spot trades
        - buy_volume: Total USDT spent buying
        - sell_volume: Total USDT received selling
        - trades_count: Number of spot trades
    """
    end_ts = int(time.time() * 1000)
    start_ts = end_ts - days * 24 * 60 * 60 * 1000
    
    total_buy = 0.0
    total_sell = 0.0
    trades_count = 0
    
    cursor = None
    try:
        while True:
            params = {
                "category": "spot",
                "startTime": start_ts,
                "endTime": end_ts,
                "limit": 100,
            }
            if cursor:
                params["cursor"] = cursor
            
            res = await _bybit_request(user_id, "GET", "/v5/execution/list", params=params, account_type=account_type)
            trades = res.get("list", []) or []
            
            for trade in trades:
                try:
                    exec_type = trade.get("execType", "")
                    if exec_type != "Trade":
                        continue
                        
                    side = trade.get("side", "")
                    exec_price = float(trade.get("execPrice") or 0)
                    exec_qty = float(trade.get("execQty") or 0)
                    exec_value = float(trade.get("execValue") or 0) or (exec_price * exec_qty)
                    fee = float(trade.get("execFee") or 0)
                    
                    if side == "Buy":
                        total_buy += exec_value + abs(fee)
                    elif side == "Sell":
                        total_sell += exec_value - abs(fee)
                    
                    trades_count += 1
                except (ValueError, TypeError):
                    continue
            
            cursor = res.get("nextPageCursor")
            if not cursor or len(trades) < 100:
                break
                
    except MissingAPICredentials:
        pass
    except Exception as e:
        logger.warning(f"[{user_id}] Spot PnL fetch error: {e}")
    
    # PnL = what we sold - what we bought (simplified)
    # Note: This is an approximation. Real PnL requires tracking cost basis per coin
    return {
        "total_pnl": total_sell - total_buy,
        "buy_volume": total_buy,
        "sell_volume": total_sell,
        "trades_count": trades_count
    }


async def _fetch_balance_data_parallel(uid: int, account_type: str, tz_str: str) -> dict:
    """Fetch all balance data in parallel for speed optimization.
    
    Instead of 5 sequential API calls, runs them all in parallel via asyncio.gather().
    This reduces total wait time from ~5-10 seconds to ~1-2 seconds.
    """
    # Run all fetches in parallel (no per-call logging to reduce noise)
    results = await asyncio.gather(
        fetch_account_balance(uid, account_type=account_type),
        fetch_today_realized_pnl(uid, tz_str=tz_str, account_type=account_type),
        fetch_realized_pnl(uid, days=7, account_type=account_type),
        fetch_open_positions(uid, account_type=account_type),
        fetch_spot_pnl(uid, days=7, account_type=account_type),
        return_exceptions=True
    )
    
    # Unpack results with error handling
    account_bal = results[0] if not isinstance(results[0], Exception) else {}
    pnl_today = results[1] if not isinstance(results[1], Exception) else 0.0
    pnl_week = results[2] if not isinstance(results[2], Exception) else 0.0
    positions = results[3] if not isinstance(results[3], Exception) else []
    spot_pnl = results[4] if not isinstance(results[4], Exception) else {}
    
    # Log any errors
    for i, r in enumerate(results):
        if isinstance(r, Exception):
            logger.warning(f"[{uid}] Balance fetch parallel error (index {i}): {r}")
    
    return {
        "account_bal": account_bal,
        "pnl_today": pnl_today,
        "pnl_week": pnl_week,
        "positions": positions,
        "spot_pnl": spot_pnl
    }


async def show_balance_for_account(update: Update, ctx: ContextTypes.DEFAULT_TYPE, account_type: str):
    """Show balance for specific account type directly (no mode selection menu).
    
    OPTIMIZED: All API calls run in parallel via asyncio.gather() for 3-5x faster loading.
    """
    uid = update.effective_user.id
    t = ctx.t
    show_switcher = db.should_show_account_switcher(uid)
    
    # CRITICAL FIX: Normalize 'both' mode - prefer 'real' if has real API keys
    # 'both' is a trading config that means "trade on demo AND real", but for display
    # we need to pick one. Prefer 'real' as it's the priority account.
    if account_type == 'both':
        creds = db.get_all_user_credentials(uid)
        if creds.get("real_api_key") and creds.get("real_api_secret"):
            account_type = 'real'
        else:
            account_type = 'demo'
        logger.info(f"[{uid}] Normalized account_type 'both' -> '{account_type}' for balance display")
    
    try:
        # OPTIMIZED: Fetch ALL data in parallel (was sequential = slow!)
        tz_str = get_user_tz(uid)
        data = await _fetch_balance_data_parallel(uid, account_type, tz_str)
        
        account_bal = data["account_bal"]
        pnl_today = data["pnl_today"]
        pnl_week = data["pnl_week"]
        positions = data["positions"]
        spot_pnl = data["spot_pnl"]
        
        # Extract account balance fields
        total_equity = account_bal.get("total_equity", 0.0)
        total_wallet = account_bal.get("total_wallet", 0.0)
        available = account_bal.get("available_balance", 0.0)
        used_margin = account_bal.get("used_margin", 0.0)
        coins = account_bal.get("coins", [])
        
        # USDT-specific trading margin (what we actually trade with)
        usdt_wallet = account_bal.get("usdt_wallet", 0.0)
        usdt_available = account_bal.get("usdt_available", 0.0)
        usdt_position_margin = account_bal.get("usdt_position_margin", 0.0)
        usdt_order_margin = account_bal.get("usdt_order_margin", 0.0)
        
        # Calculate unrealized PnL from futures positions
        total_unreal = sum(float(p.get("unrealisedPnl", 0)) for p in positions)
        total_im = sum(float(p.get("positionIM", 0)) for p in positions)
        unreal_pct = (total_unreal / total_im * 100) if total_im else 0.0
        
        # Spot stats
        spot_trades = spot_pnl.get("trades_count", 0)
        spot_volume = spot_pnl.get("buy_volume", 0) + spot_pnl.get("sell_volume", 0)
        
        # Fetch spot unrealized PnL (needs coins list)
        spot_unrealized_data = await fetch_spot_unrealized_pnl(uid, coins, account_type=account_type)
        
        mode_emoji = "üéÆ" if account_type == "demo" else "üíé"
        mode_label = "Demo" if account_type == "demo" else "Real"
        
        # Format assets list (only coins with balance > 0)
        assets_text = ""
        # Sort by USD value descending
        sorted_coins = sorted(coins, key=lambda x: x.get("usd_value", 0), reverse=True)
        for coin_data in sorted_coins[:10]:  # Show top 10 assets
            coin = coin_data.get("coin", "")
            balance = coin_data.get("balance", 0)
            usd_val = coin_data.get("usd_value", 0)
            if balance > 0 or usd_val > 0:
                # Format balance nicely
                if balance >= 1:
                    bal_str = f"{balance:,.4f}"
                else:
                    bal_str = f"{balance:.8f}".rstrip('0').rstrip('.')
                assets_text += f"  ‚Ä¢ {coin}: {bal_str} (${usd_val:,.2f})\n"
        
        if not assets_text:
            assets_text = "  No assets\n"
        
        pnl_emoji_today = "üü¢" if pnl_today >= 0 else "üî¥"
        pnl_emoji_week = "üü¢" if pnl_week >= 0 else "üî¥"
        unreal_emoji = "üü¢" if total_unreal >= 0 else "üî¥"
        
        # Build spot stats section
        spot_unrealized = spot_unrealized_data.get("total_unrealized", 0.0)
        spot_pnl_pct = spot_unrealized_data.get("pnl_pct", 0.0)
        spot_invested = spot_unrealized_data.get("total_invested", 0.0)
        spot_unreal_emoji = "üü¢" if spot_unrealized >= 0 else "üî¥"
        
        spot_stats = ""
        if spot_invested > 0 or spot_trades > 0:
            spot_stats = f"\n\nüíπ *Spot DCA:*"
            if spot_invested > 0:
                spot_stats += f"\n{spot_unreal_emoji} *Unrealized:* {spot_unrealized:+,.2f} USDT ({spot_pnl_pct:+.1f}%)"
            if spot_trades > 0:
                spot_stats += f"\nüõí *7d Activity:* {spot_trades} trades, ${spot_volume:,.2f} volume"
        
        text = f"""
üí∞ *Bybit Balance* {mode_emoji} {mode_label}

üíé *Total Equity:* ${total_equity:,.2f}
üíµ *Wallet Balance:* ${total_wallet:,.2f}

üíµ *USDT Trading Margin:*
  ‚Ä¢ Wallet: {usdt_wallet:,.2f} USDT
  ‚Ä¢ In Positions: {usdt_position_margin:,.2f} USDT
  ‚Ä¢ In Orders: {usdt_order_margin:,.2f} USDT
  ‚úÖ *Available:* {usdt_available:,.2f} USDT

üì¶ *Assets:*
{assets_text}
üìà *Futures Realized:*
{pnl_emoji_today} Today: {pnl_today:+,.2f} USDT
{pnl_emoji_week} 7 Days: {pnl_week:+,.2f} USDT

{unreal_emoji} *Futures Unrealized:* {total_unreal:+,.2f} USDT ({unreal_pct:+.2f}%){spot_stats}
"""
        
        # Only show mode switch buttons if user should see switcher
        if show_switcher:
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üéÆ Demo", callback_data="balance:bybit:demo"),
                 InlineKeyboardButton("üíé Real", callback_data="balance:bybit:real")],
                [InlineKeyboardButton("üîô Back", callback_data="menu:main")]
            ])
        else:
            # Single mode - just back button
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
            ])
        
        await update.message.reply_text(text, reply_markup=keyboard, parse_mode="Markdown")
        
    except Exception as e:
        logger.error(f"Balance fetch error (Bybit {account_type}): {e}")
        await update.message.reply_text(t.get('error_fetch_balance', '‚ùå Error fetching balance: {error}').format(error=str(e)))


async def show_positions_direct(update: Update, ctx: ContextTypes.DEFAULT_TYPE, account_type: str):
    """Show positions directly without mode selection (for single-mode users)."""
    uid = update.effective_user.id
    t = ctx.t
    show_switcher = db.should_show_account_switcher(uid)
    
    # CRITICAL FIX: Normalize 'both' mode - prefer 'real' if has real API keys
    if account_type == 'both':
        creds = db.get_all_user_credentials(uid)
        if creds.get("real_api_key") and creds.get("real_api_secret"):
            account_type = 'real'
        else:
            account_type = 'demo'
        logger.info(f"[{uid}] Normalized account_type 'both' -> '{account_type}' for positions display")
    
    pos_list = await fetch_open_positions(uid, account_type=account_type)
    
    mode_emoji = "üéÆ" if account_type == "demo" else "üíé"
    mode_label = "Demo" if account_type == "demo" else "Real"
    
    if not pos_list:
        text = f"{mode_emoji} *{mode_label} Positions*\n\n" + t.get('no_positions', 'üö´ No open positions')
        
        # Only show mode switch buttons if user should see switcher
        if show_switcher:
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üéÆ Demo", callback_data="positions:demo"),
                 InlineKeyboardButton("üíé Real", callback_data="positions:real")],
                [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
            ])
        else:
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
            ])
        
        return await update.message.reply_text(text, reply_markup=keyboard, parse_mode="Markdown")
    
    # Show paginated positions list
    text = format_positions_list_header(pos_list, 0, t)
    text = f"{mode_emoji} *{mode_label}* " + text
    
    # Store account_type in context for pagination
    ctx.user_data['positions_account_type'] = account_type
    keyboard = get_positions_list_keyboard(pos_list, 0, t)
    
    await update.message.reply_text(text, parse_mode="Markdown", reply_markup=keyboard)


async def show_orders_direct(update: Update, ctx: ContextTypes.DEFAULT_TYPE, account_type: str):
    """Show orders directly without mode selection (for single-mode users)."""
    uid = update.effective_user.id
    t = ctx.t
    show_switcher = db.should_show_account_switcher(uid)
    
    try:
        ords = await fetch_open_orders(uid, account_type=account_type)
        
        mode_emoji = "üéÆ" if account_type == "demo" else "üíé"
        mode_label = "Demo" if account_type == "demo" else "Real"
        header = f"{mode_emoji} *{mode_label} Open Orders*\n\n"
        
        if not ords:
            text = header + t.get('no_open_orders', 'üö´ No open orders')
            
            # Only show mode switch buttons if user should see switcher
            if show_switcher:
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("üéÆ Demo", callback_data="orders:demo"),
                     InlineKeyboardButton("üíé Real", callback_data="orders:real")],
                    [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
                ])
            else:
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
                ])
            
            await update.message.reply_text(text, reply_markup=keyboard, parse_mode="Markdown")
            return

        lines = [header + t.get('open_orders_header', 'üìù Open Orders:'), ""]
        for i, o in enumerate(ords, start=1):
            price = o.get('price')
            price_str = str(price) if price not in (None, "", 0, "0") else "‚Äî"
            qty_str = str(o.get('qty', "‚Äî"))
            symbol = o.get('symbol', "‚Äî")
            side = o.get('side', "‚Äî")
            oid = o.get('orderId', "‚Äî")

            lines.append(
                t.get('open_orders_item', '#{idx} {symbol} {side}\n  Qty: {qty} @ {price}\n  ID: {id}').format(
                    idx=i,
                    symbol=symbol,
                    side=side,
                    qty=qty_str,
                    price=price_str,
                    id=oid
                )
            )
            lines.append("")

        text = "\n".join(lines)
        
        # Only show mode switch buttons if user should see switcher
        if show_switcher:
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üéÆ Demo", callback_data="orders:demo"),
                 InlineKeyboardButton("üíé Real", callback_data="orders:real")],
                [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
            ])
        else:
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô " + t.get('back', 'Back'), callback_data="menu:main")]
            ])

        MAX_LEN = 3500
        for pos in range(0, len(text), MAX_LEN):
            chunk = text[pos:pos+MAX_LEN]
            await update.message.reply_text(
                chunk,
                parse_mode="Markdown",
                reply_markup=keyboard if pos + MAX_LEN >= len(text) else None
            )
    except Exception as e:
        logger.error(f"Orders fetch error ({account_type}): {e}")
        await update.message.reply_text(t.get('error_fetch_orders', '‚ùå Error fetching orders: {error}').format(error=str(e)))


@log_calls
@with_texts  
async def handle_balance_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle balance mode selection callbacks.
    
    OPTIMIZED: All API calls run in parallel via asyncio.gather() for 3-5x faster loading.
    """
    import time
    start_time = time.time()
    
    query = update.callback_query
    await query.answer()
    
    uid = update.effective_user.id
    data = query.data
    t = ctx.t
    
    if not data.startswith("balance:"):
        return
        
    logger.info(f"[{uid}] Balance callback received: {data}")
    parts = data.split(":")
    if len(parts) != 3:
        return
        
    _, exchange, mode = parts
    logger.info(f"[{uid}] Balance request: exchange={exchange}, mode={mode}")
    
    # Save last viewed account for UI persistence
    db.set_last_viewed_account(uid, mode)
    
    if exchange == "bybit":
        # Fetch Bybit balance for selected mode - OPTIMIZED with parallel fetching
        try:
            # OPTIMIZED: Fetch ALL data in parallel (was sequential = slow!)
            tz_str = get_user_tz(uid)
            bal_data = await _fetch_balance_data_parallel(uid, mode, tz_str)
            logger.info(f"[{uid}] Balance data fetched in {time.time() - start_time:.2f}s")
            
            account_bal = bal_data["account_bal"]
            pnl_today = bal_data["pnl_today"]
            pnl_week = bal_data["pnl_week"]
            positions = bal_data["positions"]
            spot_pnl = bal_data["spot_pnl"]
            
            total_equity = account_bal.get("total_equity", 0.0)
            total_wallet = account_bal.get("total_wallet", 0.0)
            available = account_bal.get("available_balance", 0.0)
            used_margin = account_bal.get("used_margin", 0.0)
            coins = account_bal.get("coins", [])
            
            # USDT-specific trading margin (what we actually trade with)
            usdt_wallet = account_bal.get("usdt_wallet", 0.0)
            usdt_available = account_bal.get("usdt_available", 0.0)
            usdt_position_margin = account_bal.get("usdt_position_margin", 0.0)
            usdt_order_margin = account_bal.get("usdt_order_margin", 0.0)
            
            total_unreal = sum(float(p.get("unrealisedPnl", 0)) for p in positions)
            total_im = sum(float(p.get("positionIM", 0)) for p in positions)
            unreal_pct = (total_unreal / total_im * 100) if total_im else 0.0
            
            # Spot stats
            spot_trades = spot_pnl.get("trades_count", 0)
            spot_volume = spot_pnl.get("buy_volume", 0) + spot_pnl.get("sell_volume", 0)
            
            # Fetch spot unrealized PnL (needs coins list)
            spot_unrealized_data = await fetch_spot_unrealized_pnl(uid, coins, account_type=mode)
            
            show_switcher = db.should_show_account_switcher(uid)
            
            mode_emoji = "üéÆ" if mode == "demo" else "üíé"
            mode_label = "Demo" if mode == "demo" else "Real"
            
            # Format assets list
            assets_text = ""
            sorted_coins = sorted(coins, key=lambda x: x.get("usd_value", 0), reverse=True)
            for coin_data in sorted_coins[:10]:
                coin = coin_data.get("coin", "")
                balance = coin_data.get("balance", 0)
                usd_val = coin_data.get("usd_value", 0)
                if balance > 0 or usd_val > 0:
                    if balance >= 1:
                        bal_str = f"{balance:,.4f}"
                    else:
                        bal_str = f"{balance:.8f}".rstrip('0').rstrip('.')
                    assets_text += f"  ‚Ä¢ {coin}: {bal_str} (${usd_val:,.2f})\n"
            
            if not assets_text:
                assets_text = "  No assets\n"
            
            pnl_emoji_today = "üü¢" if pnl_today >= 0 else "üî¥"
            pnl_emoji_week = "üü¢" if pnl_week >= 0 else "üî¥"
            unreal_emoji = "üü¢" if total_unreal >= 0 else "üî¥"
            
            # Build spot stats section
            spot_unrealized = spot_unrealized_data.get("total_unrealized", 0.0)
            spot_pnl_pct = spot_unrealized_data.get("pnl_pct", 0.0)
            spot_invested = spot_unrealized_data.get("total_invested", 0.0)
            spot_unreal_emoji = "üü¢" if spot_unrealized >= 0 else "üî¥"
            
            spot_stats = ""
            if spot_invested > 0 or spot_trades > 0:
                spot_stats = f"\n\nüíπ *Spot DCA:*"
                if spot_invested > 0:
                    spot_stats += f"\n{spot_unreal_emoji} *Unrealized:* {spot_unrealized:+,.2f} USDT ({spot_pnl_pct:+.1f}%)"
                if spot_trades > 0:
                    spot_stats += f"\nüõí *7d Activity:* {spot_trades} trades, ${spot_volume:,.2f} volume"
            
            text = f"""
üí∞ *Bybit Balance* {mode_emoji} {mode_label}

üíé *Total Equity:* ${total_equity:,.2f}
üíµ *Wallet Balance:* ${total_wallet:,.2f}

üíµ *USDT Trading Margin:*
  ‚Ä¢ Wallet: {usdt_wallet:,.2f} USDT
  ‚Ä¢ In Positions: {usdt_position_margin:,.2f} USDT
  ‚Ä¢ In Orders: {usdt_order_margin:,.2f} USDT
  ‚úÖ *Available:* {usdt_available:,.2f} USDT

üì¶ *Assets:*
{assets_text}
üìà *Futures Realized:*
{pnl_emoji_today} Today: {pnl_today:+,.2f} USDT
{pnl_emoji_week} 7 Days: {pnl_week:+,.2f} USDT

{unreal_emoji} *Futures Unrealized:* {total_unreal:+,.2f} USDT ({unreal_pct:+.2f}%){spot_stats}
"""
            
            # Only show mode switch buttons if user should see switcher
            if show_switcher:
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("üéÆ Demo", callback_data="balance:bybit:demo"),
                     InlineKeyboardButton("üíé Real", callback_data="balance:bybit:real")],
                    [InlineKeyboardButton("üîô Back", callback_data="menu:main")]
                ])
            else:
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîô Back", callback_data="menu:main")]
                ])
            
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="Markdown")
            logger.info(f"[{uid}] Balance callback completed in {time.time() - start_time:.2f}s")
            
        except Exception as e:
            logger.error(f"Balance fetch error (Bybit {mode}): {e}")
            await query.edit_message_text(
                f"‚ùå Error fetching balance: {str(e)}",
                parse_mode="Markdown"
            )
            
    elif exchange == "hl":
        # Fetch HyperLiquid balance for selected mode
        # OPTIMIZED: Use cache from bot_unified to avoid rate limits and speed up display
        from bot_unified import _get_hl_cache, _set_hl_cache
        
        adapter = None
        try:
            testnet = (mode == "testnet")
            account_type_for_cache = "testnet" if testnet else "mainnet"
            
            # Check cache first (180s TTL from bot_unified)
            cache_key = f"balance:{uid}:{account_type_for_cache}"
            cached_data = _get_hl_cache(cache_key)
            
            if cached_data is not None:
                # Use cached data - instant response!
                logger.debug(f"[{uid}] HL balance from cache (instant!)")
                data_bal = cached_data
            else:
                # Cache miss - fetch from API
                hl_creds = get_hl_credentials(uid)
            
                # Get correct private key for network (multitenancy)
                if testnet:
                    hl_private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
                    wallet_address = hl_creds.get("hl_testnet_wallet_address") or hl_creds.get("hl_wallet_address")
                else:
                    hl_private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
                    wallet_address = hl_creds.get("hl_mainnet_wallet_address") or hl_creds.get("hl_wallet_address")
                
                if not hl_private_key:
                    await query.edit_message_text(
                        f"‚ùå HyperLiquid {'Testnet' if testnet else 'Mainnet'} not configured. Use üîë HL API to set up.",
                        parse_mode="Markdown"
                    )
                    return
                
                adapter = HLAdapter(
                    private_key=hl_private_key,
                    testnet=testnet
                    # main_wallet_address auto-discovered via userRole API
                )
                
                result = await adapter.get_balance()
                
                if not result.get("success"):
                    await query.edit_message_text(
                        f"‚ùå Failed to fetch balance: {result.get('error', 'Unknown error')}",
                        parse_mode="Markdown"
                    )
                    return
                
                data_bal = result.get("data", {})
                # Cache the result for next time
                _set_hl_cache(cache_key, data_bal)
            
            # Parse balance data (works for both cached and fresh data)
            equity = float(data_bal.get("equity", 0))
            available = float(data_bal.get("available", 0))
            margin_used = float(data_bal.get("margin_used", 0))
            total_notional = float(data_bal.get("total_notional", 0))
            unrealized_pnl = float(data_bal.get("unrealized_pnl", 0))
            position_value = float(data_bal.get("position_value", 0))
            num_positions = int(data_bal.get("num_positions", 0))
            currency = data_bal.get("currency", "USDC")
            
            pnl_emoji = "üü¢" if unrealized_pnl >= 0 else "üî¥"
            network = "üß™ Testnet" if testnet else "üåê Mainnet"
            
            # Calculate margin level if margin used > 0
            margin_level = ""
            if margin_used > 0:
                level_pct = (equity / margin_used) * 100
                margin_level = f"\nüìê *Margin Level:* {level_pct:.1f}%"
            
            text = f"""
üí∞ *HyperLiquid Balance* {network}

üíé *Account Equity:* ${equity:,.2f} {currency}
‚úÖ *Available for Trading:* ${available:,.2f} {currency}
üìä *Margin Used:* ${margin_used:,.2f} {currency}{margin_level}

üì¶ *Positions:*
  ‚Ä¢ Active: {num_positions} positions
  ‚Ä¢ Notional Value: ${total_notional:,.2f}
  ‚Ä¢ Position Value: ${position_value:,.2f}

{pnl_emoji} *Unrealized PnL:* ${unrealized_pnl:,.2f} {currency}
"""
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton("üß™ Testnet", callback_data="balance:hl:testnet"),
                 InlineKeyboardButton("üåê Mainnet", callback_data="balance:hl:mainnet")],
                [InlineKeyboardButton("üîô Back", callback_data="menu:main")]
            ])
            
            await query.edit_message_text(text, reply_markup=keyboard, parse_mode="Markdown")
            logger.info(f"[{uid}] HL Balance callback completed in {time.time() - start_time:.2f}s")
                
        except Exception as e:
            logger.error(f"Balance fetch error (HL {mode}): {e}")
            await query.edit_message_text(
                f"‚ùå Error: {str(e)}",
                parse_mode="Markdown"
            )
        finally:
            if adapter:
                await adapter.close()


@with_texts
async def on_positions_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle position management callbacks. Works for both Bybit and HyperLiquid."""
    query = update.callback_query
    await query.answer()
    
    uid = update.effective_user.id
    data = query.data
    t = ctx.t
    
    # Get current exchange and account_type from user_data or DB
    exchange = ctx.user_data.get('positions_exchange')
    if not exchange:
        exchange = db.get_exchange_type(uid) or "bybit"
        ctx.user_data['positions_exchange'] = exchange
    
    account_type = ctx.user_data.get('positions_account_type')
    if not account_type:
        account_type = db.get_last_viewed_account(uid, exchange)
        ctx.user_data['positions_account_type'] = account_type
    
    if exchange == "hyperliquid":
        show_switcher = db.should_show_hl_network_switcher(uid)
    else:
        show_switcher = db.should_show_account_switcher(uid)
    
    if data == "pos:back":
        # Go back to main menu
        await query.message.delete()
        await ctx.bot.send_message(
            chat_id=uid,
            text=t.get("welcome", "Welcome!"),
            reply_markup=main_menu_keyboard(ctx, user_id=uid)
        )
        return
    
    if data == "pos:noop":
        # Do nothing - just for counter button
        return
    
    # Handle account type switch (supports demo/real AND testnet/mainnet)
    if data.startswith("pos:switch:"):
        new_account_type = data.split(":")[2]
        ctx.user_data['positions_account_type'] = new_account_type
        ctx.user_data['positions_page'] = 0  # Reset to first page
        
        # Save to DB for persistence across sessions
        db.set_last_viewed_account(uid, new_account_type)
        
        positions = await fetch_open_positions(uid, account_type=new_account_type, exchange=exchange)
        
        if not positions:
            mode_emoji, mode_label = _get_account_label(new_account_type, exchange)
            text = f"{mode_emoji} *{mode_label}* üìä {t.get('open_positions', 'Open Positions')} (0)\n\n{t.get('no_positions', 'üö´ No open positions')}"
            keyboard = get_positions_list_keyboard([], 0, t, account_type=new_account_type, show_switcher=show_switcher, exchange=exchange)
            await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
            return
        
        text = format_positions_list_header(positions, 0, t, account_type=new_account_type, exchange=exchange)
        keyboard = get_positions_list_keyboard(positions, 0, t, account_type=new_account_type, show_switcher=show_switcher, exchange=exchange)
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
        return
    
    if data.startswith("pos:refresh"):
        # Refresh positions list - show list view
        # Support pos:refresh or pos:refresh:PAGE format
        parts = data.split(":")
        saved_page = int(parts[2]) if len(parts) > 2 else ctx.user_data.get('positions_page', 0)
        
        positions = await fetch_open_positions(uid, account_type=account_type, exchange=exchange)
        if not positions:
            mode_emoji, mode_label = _get_account_label(account_type, exchange)
            text = f"{mode_emoji} *{mode_label}* üìä {t.get('open_positions', 'Open Positions')} (0)\n\n{t.get('no_positions', 'üö´ No open positions')}"
            keyboard = get_positions_list_keyboard([], 0, t, account_type=account_type, show_switcher=show_switcher, exchange=exchange)
            await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
            return
        
        # Validate page is still valid after position changes
        total_pages = (len(positions) + POSITIONS_PER_PAGE - 1) // POSITIONS_PER_PAGE
        page = max(0, min(saved_page, total_pages - 1))
        ctx.user_data['positions_page'] = page
        
        text = format_positions_list_header(positions, page, t, account_type=account_type, exchange=exchange)
        keyboard = get_positions_list_keyboard(positions, page, t, account_type=account_type, show_switcher=show_switcher, exchange=exchange)
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
        return
    
    if data.startswith("pos:list:"):
        # Navigate to specific page of positions list
        page = int(data.split(":")[2])
        positions = await fetch_open_positions(uid, account_type=account_type, exchange=exchange)
        if not positions:
            mode_emoji, mode_label = _get_account_label(account_type, exchange)
            text = f"{mode_emoji} *{mode_label}* üìä {t.get('open_positions', 'Open Positions')} (0)\n\n{t.get('no_positions', 'üö´ No open positions')}"
            keyboard = get_positions_list_keyboard([], 0, t, account_type=account_type, show_switcher=show_switcher, exchange=exchange)
            await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
            return
        
        # Ensure valid page
        total_pages = (len(positions) + POSITIONS_PER_PAGE - 1) // POSITIONS_PER_PAGE
        page = max(0, min(page, total_pages - 1))
        
        # Save current page for later restoration
        ctx.user_data['positions_page'] = page
        
        text = format_positions_list_header(positions, page, t, account_type=account_type, exchange=exchange)
        keyboard = get_positions_list_keyboard(positions, page, t, account_type=account_type, show_switcher=show_switcher, exchange=exchange)
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
        return
    
    if data.startswith("pos:page:"):
        # Legacy: Navigate to specific single position (keeping for backward compatibility)
        page_idx = int(data.split(":")[2])
        positions = await fetch_open_positions(uid, account_type=account_type, exchange=exchange)
        if not positions:
            mode_emoji, mode_label = _get_account_label(account_type, exchange)
            text = f"{mode_emoji} *{mode_label}* üìä {t.get('open_positions', 'Open Positions')} (0)\n\n{t.get('no_positions', 'üö´ No open positions')}"
            keyboard = get_positions_list_keyboard([], 0, t, account_type=account_type, show_switcher=show_switcher, exchange=exchange)
            await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
            return
        
        # Ensure valid index
        page_idx = max(0, min(page_idx, len(positions) - 1))
        
        # Get saved page from user_data
        saved_page = ctx.user_data.get('positions_page', 0)
        
        text = format_single_position(positions[page_idx], page_idx, len(positions), t)
        keyboard = get_positions_paginated_keyboard(positions, page_idx, t, page=saved_page)
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
        return
    
    if data.startswith("pos:view:"):
        # View detailed position
        symbol = data.split(":")[2]
        positions = await fetch_open_positions(uid, account_type=account_type, exchange=exchange)
        pos = next((p for p in positions if p["symbol"] == symbol), None)
        
        # Get saved page from user_data
        saved_page = ctx.user_data.get('positions_page', 0)
        
        if not pos:
            await query.edit_message_text(
                t.get('position_not_found', 'Position not found'),
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data=f"pos:refresh:{saved_page}")
                ]])
            )
            return
        
        text = format_position_detail(pos, t)
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(f"‚ùå {t.get('btn_close_position', 'Close position')}", callback_data=f"pos:close:{symbol}")],
            [InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data=f"pos:refresh:{saved_page}")]
        ])
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
        return
    
    if data.startswith("pos:close:"):
        # Close single position
        symbol = data.split(":")[2]
        positions = await fetch_open_positions(uid, account_type=account_type, exchange=exchange)
        pos = next((p for p in positions if p["symbol"] == symbol), None)
        
        # Get saved page
        saved_page = ctx.user_data.get('positions_page', 0)
        
        if not pos:
            await query.edit_message_text(
                t.get('position_not_found', 'Position not found'),
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data=f"pos:refresh:{saved_page}")
                ]])
            )
            return
        
        # Confirm close
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(f"‚úÖ {t.get('btn_confirm_close', 'Confirm close')}", callback_data=f"pos:confirm_close:{symbol}")],
            [InlineKeyboardButton(t.get('btn_cancel', '‚ùå Cancel'), callback_data=f"pos:refresh:{saved_page}")]
        ])
        side_text = "LONG" if pos["side"] == "Buy" else "SHORT"
        size = float(pos.get("size") or 0)
        pnl = float(pos.get("unrealisedPnl") or 0)
        pnl_emoji = "üìà" if pnl >= 0 else "üìâ"
        quote_currency = "USDC" if exchange == "hyperliquid" else "USDT"
        
        await query.edit_message_text(
            f"‚ö†Ô∏è {t.get('confirm_close_position', 'Close position')}?\n\n"
            f"*{symbol}* {side_text}\n"
            f"Size: {size}\n"
            f"{pnl_emoji} P/L: {pnl:+.4f} {quote_currency}",
            parse_mode="Markdown",
            reply_markup=keyboard
        )
        return
    
    if data.startswith("pos:confirm_close:"):
        # Execute close
        symbol = data.split(":")[2]
        positions = await fetch_open_positions(uid, account_type=account_type, exchange=exchange)
        pos = next((p for p in positions if p["symbol"] == symbol), None)
        
        # Get saved page
        saved_page = ctx.user_data.get('positions_page', 0)
        quote_currency = "USDC" if exchange == "hyperliquid" else "USDT"
        
        if not pos:
            await query.edit_message_text(
                t.get('position_already_closed', 'Position already closed'),
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data=f"pos:refresh:{saved_page}")
                ]])
            )
            return
        
        try:
            close_side = "Sell" if pos["side"] == "Buy" else "Buy"
            size = float(pos.get("size") or 0)
            entry_price = float(pos.get("avgPrice") or 0)
            mark_price = float(pos.get("markPrice") or 0)
            unrealized_pnl = float(pos.get("unrealisedPnl") or 0)
            im = float(pos.get("positionIM") or 0)
            pnl_pct = (unrealized_pnl / im * 100) if im else 0.0
            side_text = "LONG" if pos["side"] == "Buy" else "SHORT"
            
            # --- Close position: exchange-aware ---
            if exchange == "hyperliquid":
                adapter = None
                try:
                    adapter, _is_testnet = await _create_hl_adapter_for_account(uid, account_type)
                    if not adapter:
                        raise Exception("HyperLiquid not configured for this account")
                    result = await adapter.close_position(symbol)
                    if result.get("retCode") != 0:
                        raise Exception(result.get("retMsg", "Unknown HL error"))
                finally:
                    if adapter:
                        await adapter.close()
            else:
                await place_order(
                    user_id=uid,
                    symbol=symbol,
                    side=close_side,
                    orderType="Market",
                    qty=size,
                    account_type=account_type
                )
            
            # Get active position info for strategy
            active_pos = get_active_positions(uid, account_type=account_type, exchange=exchange)
            ap = next((a for a in active_pos if a["symbol"] == symbol), None)
            strategy = ap.get("strategy") if ap else None
            strategy_display = {
                "scryptomera": "Scryptomera",
                "scalper": "Scalper", 
                "rsi_bb": "RSI+BB",
                "oi": "OI",
                "elcaro": "Enliko",
                "fibonacci": "Fibonacci",
                "webapp": "WebApp",
            }.get(strategy, strategy.title() if strategy and strategy != "manual" and strategy != "unknown" else "Unknown")
            
            # Log the trade
            try:
                log_exit_and_remove_position(
                    user_id=uid,
                    signal_id=ap.get("signal_id") if ap else None,
                    symbol=symbol,
                    side=pos["side"],
                    entry_price=entry_price,
                    exit_price=mark_price,
                    exit_reason="MANUAL",
                    size=size,
                    strategy=strategy,
                    account_type=account_type,
                    # Fix #2: Use saved SL/TP % from position open time
                    applied_sl_pct=ap.get("applied_sl_pct") if ap else None,
                    applied_tp_pct=ap.get("applied_tp_pct") if ap else None,
                    exchange=exchange,  # Use detected exchange
                )
            except Exception as log_err:
                logger.warning(f"Failed to log manual close for {symbol}: {log_err}")
            
            # Clean up internal tracking (log_exit_and_remove_position already removes position)
            reset_pyramid(uid, symbol)
            
            # Send notification about closed position
            if notification_service:
                try:
                    await notification_service.send_position_closed_notification(
                        user_id=uid,
                        position_data={
                            'symbol': symbol,
                            'side': side_text,
                            'entry_price': entry_price,
                            'exit_price': mark_price,
                            'quantity': size,
                            'pnl': unrealized_pnl,
                            'pnl_percent': pnl_pct,
                            'strategy': strategy_display,
                            'close_reason': 'Manual'
                        },
                        t=t
                    )
                except Exception as notif_err:
                    logger.error(f"Failed to send position closed notification: {notif_err}")
            
            # Format beautiful close message
            pnl_emoji = "üìà" if unrealized_pnl >= 0 else "üìâ"
            emoji = "üü¢" if pos["side"] == "Buy" else "üî¥"
            
            close_msg = (
                f"‚úÖ *{t.get('position_closed_success', 'Position closed')}*\n\n"
                f"{emoji} *{symbol}* {side_text}\n"
                f"‚Ä¢ Strategy: `{strategy_display}`\n"
                f"‚Ä¢ Entry: `{entry_price:.6g}`\n"
                f"‚Ä¢ Exit: `{mark_price:.6g}`\n"
                f"{pnl_emoji} P/L: `{unrealized_pnl:+.4f}` {quote_currency} ({pnl_pct:+.2f}%)"
            )
            
            await query.edit_message_text(
                close_msg,
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data=f"pos:refresh:{saved_page}")
                ]])
            )
        except Exception as e:
            logger.error(f"Close position {symbol} failed: {e}")
            await query.edit_message_text(
                f"‚ùå {t.get('position_close_error', 'Error closing position')}: {str(e)}",
                reply_markup=InlineKeyboardMarkup([[
                    InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data=f"pos:refresh:{saved_page}")
                ]])
            )
        return
    
    if data == "pos:close_all":
        # Confirm close all
        positions = await fetch_open_positions(uid, account_type=account_type, exchange=exchange)
        if not positions:
            mode_emoji, mode_label = _get_account_label(account_type, exchange)
            text = f"{mode_emoji} *{mode_label}* üìä {t.get('open_positions', 'Open Positions')} (0)\n\n{t.get('no_positions', 'üö´ No open positions')}"
            keyboard = get_positions_list_keyboard([], 0, t, account_type=account_type, show_switcher=show_switcher, exchange=exchange)
            await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
            return
        
        total_pnl = sum(float(p.get("unrealisedPnl") or 0) for p in positions)
        pnl_emoji = "üìà" if total_pnl >= 0 else "üìâ"
        mode_emoji, mode_label = _get_account_label(account_type, exchange)
        quote_currency = "USDC" if exchange == "hyperliquid" else "USDT"
        
        saved_page = ctx.user_data.get('positions_page', 0)
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(f"‚úÖ {t.get('btn_confirm_close_all', 'Yes, close all')}", callback_data="pos:confirm_close_all")],
            [InlineKeyboardButton(t.get('btn_cancel', '‚ùå Cancel'), callback_data=f"pos:refresh:{saved_page}")]
        ])
        
        await query.edit_message_text(
            f"‚ö†Ô∏è {t.get('confirm_close_all', 'Close ALL positions')}?\n\n"
            f"{mode_emoji} *{mode_label}*\n"
            f"{t.get('positions_count_total', 'Total positions')}: {len(positions)}\n"
            f"{pnl_emoji} {t.get('total_pnl', 'Total P/L')}: {total_pnl:+.4f} {quote_currency}",
            parse_mode="Markdown",
            reply_markup=keyboard
        )
        return
    
    if data == "pos:pause_after_close":
        # Disable all strategies after closing positions
        set_user_field(uid, "trade_scryptomera", 0)
        set_user_field(uid, "trade_scalper", 0)
        set_user_field(uid, "trade_elcaro", 0)
        set_user_field(uid, "trade_fibonacci", 0)
        
        saved_page = ctx.user_data.get('positions_page', 0)
        await query.edit_message_text(
            "‚úÖ *All trading paused!*\n\n"
            "All strategies disabled. No new positions will open.\n\n"
            "To resume trading, enable strategies in Settings ‚Üí Strategy.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([[
                InlineKeyboardButton("‚öôÔ∏è Strategy Settings", callback_data="settings:strategy"),
                InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data=f"pos:refresh:{saved_page}")
            ]])
        )
        return
    
    if data == "pos:confirm_close_all":
        # Execute close all
        positions = await fetch_open_positions(uid, account_type=account_type, exchange=exchange)
        if not positions:
            mode_emoji, mode_label = _get_account_label(account_type, exchange)
            text = f"{mode_emoji} *{mode_label}* üìä {t.get('open_positions', 'Open Positions')} (0)\n\n{t.get('no_positions', 'üö´ No open positions')}"
            keyboard = get_positions_list_keyboard([], 0, t, account_type=account_type, show_switcher=show_switcher, exchange=exchange)
            await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
            return
        
        closed = 0
        errors = 0
        total_pnl = 0.0
        closed_positions = []
        active_list = get_active_positions(uid, account_type=account_type, exchange=exchange)
        quote_currency = "USDC" if exchange == "hyperliquid" else "USDT"
        
        # Create HL adapter once for all positions if HyperLiquid
        hl_adapter = None
        if exchange == "hyperliquid":
            try:
                hl_adapter, _is_testnet = await _create_hl_adapter_for_account(uid, account_type)
            except Exception as e:
                logger.error(f"Failed to create HL adapter for close_all: {e}")
        
        try:
            for pos in positions:
                try:
                    close_side = "Sell" if pos["side"] == "Buy" else "Buy"
                    size = float(pos["size"])
                    symbol = pos["symbol"]
                    entry_price = float(pos.get("avgPrice") or 0)
                    mark_price = float(pos.get("markPrice") or 0)
                    unrealized_pnl = float(pos.get("unrealisedPnl") or 0)
                    
                    # --- Close position: exchange-aware ---
                    if exchange == "hyperliquid":
                        if not hl_adapter:
                            raise Exception("HyperLiquid not configured")
                        result = await hl_adapter.close_position(symbol)
                        if result.get("retCode") != 0:
                            raise Exception(result.get("retMsg", "Unknown HL error"))
                    else:
                        await place_order(
                            user_id=uid,
                            symbol=symbol,
                            side=close_side,
                            orderType="Market",
                            qty=size,
                            account_type=account_type
                        )
                    
                    # Log the trade
                    ap = next((a for a in active_list if a["symbol"] == symbol), None)
                    strategy = ap.get("strategy") if ap else None
                    try:
                        log_exit_and_remove_position(
                            user_id=uid,
                            signal_id=ap.get("signal_id") if ap else None,
                            symbol=symbol,
                            side=pos["side"],
                            entry_price=entry_price,
                            exit_price=mark_price,
                            exit_reason="MANUAL",
                            size=size,
                            strategy=strategy,
                            account_type=account_type,
                            # Fix #2: Use saved SL/TP % from position open time
                            applied_sl_pct=ap.get("applied_sl_pct") if ap else None,
                            applied_tp_pct=ap.get("applied_tp_pct") if ap else None,
                            exchange=exchange,  # Use detected exchange
                        )
                    except Exception as log_err:
                        logger.warning(f"Failed to log manual close for {symbol}: {log_err}")
                    # Send position-closed notification (for Close All flow)
                    try:
                        strategy_display = {
                            "scryptomera": "Scryptomera",
                            "scalper": "Scalper",
                            "rsi_bb": "RSI+BB",
                            "oi": "OI",
                            "elcaro": "Enliko",
                            "fibonacci": "Fibonacci",
                            "webapp": "WebApp",
                        }.get(strategy, strategy.title() if strategy and strategy != "manual" and strategy != "unknown" else "Unknown")
                        if notification_service:
                            pnl_pct = 0.0
                            try:
                                if entry_price:
                                    pnl_pct = (mark_price / entry_price - 1.0) * (100 if pos["side"] == "Buy" else -100)
                            except Exception:
                                pnl_pct = 0.0
                            await notification_service.send_position_closed_notification(
                                user_id=uid,
                                position_data={
                                    'symbol': symbol,
                                    'side': pos.get('side'),
                                    'entry_price': entry_price,
                                    'exit_price': mark_price,
                                    'quantity': size,
                                    'pnl': unrealized_pnl,
                                    'pnl_percent': pnl_pct,
                                    'strategy': strategy_display,
                                    'close_reason': 'Manual'
                                },
                                t=t
                            )
                    except Exception as notif_err:
                        logger.error(f"Failed to send position closed notification (close_all): {notif_err}")
                    
                    # log_exit_and_remove_position already removes position
                    reset_pyramid(uid, symbol)
                    closed += 1
                    total_pnl += unrealized_pnl
                    closed_positions.append({
                        "symbol": symbol,
                        "side": pos["side"],
                        "pnl": unrealized_pnl
                    })
                except Exception as e:
                    logger.error(f"Close position {pos['symbol']} failed: {e}")
                    errors += 1
        finally:
            # Clean up HL adapter
            if hl_adapter:
                try:
                    await hl_adapter.close()
                except Exception:
                    pass
        
        # Set cooldown flag to prevent monitoring loop from re-adding positions
        import time
        _close_all_cooldown[uid] = time.time() + 30  # 30 seconds cooldown
        
        # Format result message
        pnl_emoji = "üìà" if total_pnl >= 0 else "üìâ"
        result_lines = [f"‚úÖ *{t.get('all_positions_closed', 'All positions closed')}*\n"]
        
        for cp in closed_positions:
            cp_emoji = "üü¢" if cp["side"] == "Buy" else "üî¥"
            cp_pnl_emoji = "+" if cp["pnl"] >= 0 else ""
            result_lines.append(f"{cp_emoji} {cp['symbol']}: `{cp_pnl_emoji}{cp['pnl']:.4f}` {quote_currency}")
        
        result_lines.append(f"\n{pnl_emoji} *{t.get('total_pnl', 'Total P/L')}:* `{total_pnl:+.4f}` {quote_currency}")
        
        if errors:
            result_lines.append(f"\n‚ùå {t.get('errors', 'Errors')}: {errors}")
        
        result_lines.append("\n‚ö†Ô∏è *Strategies still active!* New signals may open positions.")
        
        saved_page = ctx.user_data.get('positions_page', 0)
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚è∏ Pause All Trading", callback_data="pos:pause_after_close")],
            [InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data=f"pos:refresh:{saved_page}")]
        ])
        
        await query.edit_message_text(
            "\n".join(result_lines),
            parse_mode="Markdown",
            reply_markup=keyboard
        )
        return


@require_access
@with_texts
@log_calls
async def cmd_open_positions(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show open positions with inline management buttons and pagination (10 per page)."""
    uid = update.effective_user.id
    positions = await fetch_open_positions(uid)
    
    if not positions:
        return await update.message.reply_text(ctx.t.get('no_positions', 'No open positions'))
    
    # Show positions list with pagination (10 per page)
    text = format_positions_list_header(positions, 0, ctx.t)
    keyboard = get_positions_list_keyboard(positions, 0, ctx.t)
    
    await update.message.reply_text(text, parse_mode="Markdown", reply_markup=keyboard)


# ------------------------------------------------------------------------------------
# Trading Statistics
# ------------------------------------------------------------------------------------
STRATEGY_DISPLAY_NAMES = {
    "oi": "üìâ OI",
    "rsi_bb": "üìä RSI+BB",
    "scryptomera": "üê± Scryptomera",
    "scalper": "‚ö° Scalper",
    "elcaro": "üî• Enliko",
    "fibonacci": "üìê Fibonacci",
    "manual": "‚úã Manual",
    "all": "üìà All",
}

ACCOUNT_DISPLAY_NAMES = {
    "demo": "üîµ Demo",
    "real": "üü¢ Real",
}

async def format_trade_stats(stats: dict, t: dict, strategy_name: str = "all", period_label: str = "", unrealized_pnl: float = 0.0, uid: int = None, account_type: str = "demo", period: str = "all", api_pnl: float = None) -> str:
    """Format trade statistics in beautiful style like the screenshot.
    
    Args:
        stats: Trade stats from database
        t: Translations dict
        strategy_name: Strategy filter
        period_label: Human-readable period label
        unrealized_pnl: Unrealized PnL from open positions
        uid: User ID
        account_type: 'demo' or 'real'
        period: Period key ('today', 'week', 'month', 'all')
        api_pnl: PnL from exchange API (for comparison/accuracy)
    """
    strat_display = STRATEGY_DISPLAY_NAMES.get(strategy_name, strategy_name.upper())
    account_display = ACCOUNT_DISPLAY_NAMES.get(account_type, account_type.capitalize())
    
    total = stats.get("total", 0)
    tp_count = stats.get("tp_count", 0)
    sl_count = stats.get("sl_count", 0)
    eod_count = stats.get("eod_count", 0)
    winrate = stats.get("winrate", 0.0)
    total_pnl = stats.get("total_pnl", 0.0)
    avg_pnl_pct = stats.get("avg_pnl_pct", 0.0)
    long_count = stats.get("long_count", 0)
    short_count = stats.get("short_count", 0)
    long_winrate = stats.get("long_winrate", 0.0)
    short_winrate = stats.get("short_winrate", 0.0)
    gross_profit = stats.get("gross_profit", 0.0)
    gross_loss = stats.get("gross_loss", 0.0)
    profit_factor = stats.get("profit_factor", 0.0)
    
    # R calculation (assuming 1R = 1% of account)
    total_r = total_pnl / 100 if total_pnl != 0 else 0
    avg_r = avg_pnl_pct / 100 if avg_pnl_pct != 0 else 0
    
    # Long/Short R
    long_pnl = gross_profit * (long_count / max(total, 1)) if long_count > 0 else 0
    short_pnl = gross_profit * (short_count / max(total, 1)) if short_count > 0 else 0
    
    # Closed trades = total from DB (this is already the count of closed trades in trade_logs)
    # Open trades come from active_positions table
    open_trades = stats.get("open_count", 0)  # From active_positions table
    closed = total  # total from trade_logs = all closed trades
    total_with_open = closed + open_trades  # Include open positions in total
    
    # Combined PnL: realized + unrealized
    combined_pnl = total_pnl + unrealized_pnl
    
    pnl_sign = "+" if total_pnl >= 0 else ""
    pnl_emoji = "üìà" if total_pnl >= 0 else "üìâ"
    unreal_sign = "+" if unrealized_pnl >= 0 else ""
    unreal_emoji = "üìà" if unrealized_pnl >= 0 else "üìâ"
    combined_sign = "+" if combined_pnl >= 0 else ""
    combined_emoji = "üìà" if combined_pnl >= 0 else "üìâ"
    
    lines = [
        f"üìä *{t.get('stats_title', 'Trading Statistics')}* {account_display}",
        f"‚îú {t.get('stats_strategy', 'Strategy')}: {strat_display}",
        f"‚îî {t.get('stats_period', 'Period')}: üìÖ {period_label}",
        "",
        f"*{t.get('stats_overview', 'Overview')}*",
        f"‚îú‚îÄ {t.get('stats_total_trades', 'Total trades')}: {total_with_open}",
        f"‚îú‚îÄ {t.get('stats_closed', 'Closed')}: {closed}",
        f"‚îî‚îÄ {t.get('stats_open', 'Open')}: {open_trades}",
        "",
        f"*{t.get('stats_results', 'Results')}*",
        f"‚îú‚îÄ TP: {tp_count} ‚îÇ SL: {sl_count} ‚îÇ EOD: {eod_count}",
        f"‚îú‚îÄ {t.get('stats_winrate', 'Winrate')}: {winrate:.1f}%",
        f"‚îú‚îÄ {t.get('stats_total_r', 'Total R')}: {pnl_sign}{total_r:.2f}R",
        f"‚îî‚îÄ {t.get('stats_avg_r', 'Avg R')}: {pnl_sign}{avg_r:.2f}R",
        "",
        f"*{t.get('stats_by_direction', 'By Direction')}*",
        f"‚îú‚îÄ üü¢ {t.get('stats_long', 'Long')}: {long_count} ‚îÇ {t.get('stats_winrate', 'WR')}: {long_winrate:.1f}%",
        f"‚îî‚îÄ üî¥ {t.get('stats_short', 'Short')}: {short_count} ‚îÇ {t.get('stats_winrate', 'WR')}: {short_winrate:.1f}%",
        "",
        f"*{t.get('stats_pnl', 'Profit/Loss')}*",
        f"‚îú‚îÄ {t.get('stats_gross_profit', 'Profit')}: ${gross_profit:.2f}",
        f"‚îú‚îÄ {t.get('stats_gross_loss', 'Loss')}: ${abs(gross_loss):.2f}",
    ]
    
    # Use API PnL as primary if available (more accurate), otherwise use DB
    if api_pnl is not None and strategy_name == "all":
        # API PnL is the real truth from exchange
        display_pnl = api_pnl
        display_sign = "+" if api_pnl >= 0 else ""
        display_emoji = "üìà" if api_pnl >= 0 else "üìâ"
        lines.append(f"‚îú‚îÄ {display_emoji} {t.get('stats_realized_pnl', 'Realized')}: ${display_sign}{display_pnl:.2f}")
        
        # Calculate combined with API PnL
        combined_pnl = api_pnl + unrealized_pnl
        combined_sign = "+" if combined_pnl >= 0 else ""
        combined_emoji = "üìà" if combined_pnl >= 0 else "üìâ"
    else:
        # Fallback to DB tracked PnL
        lines.append(f"‚îú‚îÄ {pnl_emoji} {t.get('stats_realized_pnl', 'Realized')}: ${pnl_sign}{total_pnl:.2f}")
    
    # Add unrealized PnL if there are open positions
    if open_trades > 0:
        lines.append(f"‚îú‚îÄ {unreal_emoji} {t.get('stats_unrealized_pnl', 'Unrealized')}: ${unreal_sign}{unrealized_pnl:.2f}")
        lines.append(f"‚îú‚îÄ {combined_emoji} {t.get('stats_combined_pnl', 'Combined')}: ${combined_sign}{combined_pnl:.2f}")
    
    lines.append(f"‚îî‚îÄ {t.get('stats_profit_factor', 'PF')}: {profit_factor:.2f}" if profit_factor != float('inf') else f"‚îî‚îÄ {t.get('stats_profit_factor', 'PF')}: ‚àû")
    
    # Add strategy settings if specific strategy is selected and uid is provided
    if uid and strategy_name != "all":
        context = db.get_user_trading_context(uid)
        active_exchange = context.get("exchange", "bybit")
        account_type = context.get("account_type", "demo")
        strat_settings = db.get_strategy_settings(uid, strategy_name, active_exchange, account_type)
        if strat_settings:
            lines.append("")
            lines.append(f"*‚öôÔ∏è {t.get('stats_strategy_settings', 'Strategy Settings')}*")
            
            # Entry percentage
            entry_pct = strat_settings.get("percent", 0)
            if entry_pct:
                lines.append(f"‚îú‚îÄ {t.get('settings_entry_pct', 'Entry')}: {entry_pct}%")
            
            # SL/TP percentages
            sl_pct = strat_settings.get("sl_percent", 0)
            tp_pct = strat_settings.get("tp_percent", 0)
            if sl_pct or tp_pct:
                lines.append(f"‚îú‚îÄ SL: {sl_pct}% ‚îÇ TP: {tp_pct}%")
            
            # Leverage
            leverage = strat_settings.get("leverage", 0)
            if leverage:
                lines.append(f"‚îú‚îÄ {t.get('settings_leverage', 'Leverage')}: {leverage}x")
            
            # Trading mode
            trading_mode = strat_settings.get("trading_mode", "")
            if trading_mode:
                mode_display = {"market": "üîµ Market", "limit": "üü° Limit", "both": "üîÑ Both"}.get(trading_mode, trading_mode)
                lines.append(f"‚îú‚îÄ {t.get('settings_trading_mode', 'Mode')}: {mode_display}")
            
            # Direction
            direction = strat_settings.get("direction", "")
            if direction:
                dir_display = {"long": "üü¢ Long", "short": "üî¥ Short", "both": "üîÑ Both"}.get(direction, direction)
                lines.append(f"‚îî‚îÄ {t.get('settings_direction', 'Direction')}: {dir_display}")
    
    return "\n".join(lines)


def format_trade_list(trades: list, t: dict, strategy_name: str = "all", period_label: str = "",
                      account_type: str = "demo", page: int = 0, total_count: int = 0,
                      per_page: int = 8) -> str:
    """Format individual trade list for Telegram display (Bybit-style).
    
    Args:
        trades: List of trade dicts from get_trade_logs_list()
        t: Translations dict
        strategy_name: Current strategy filter
        period_label: Human-readable period label
        account_type: Account type
        page: Current page (0-indexed)
        total_count: Total number of trades matching filters
        per_page: Trades per page
    """
    strat_display = STRATEGY_DISPLAY_NAMES.get(strategy_name, strategy_name.upper())
    account_display = ACCOUNT_DISPLAY_NAMES.get(account_type, account_type.capitalize())
    total_pages = max(1, (total_count + per_page - 1) // per_page)
    
    lines = [
        f"üìã *{t.get('trades_title', 'Trade History')}* {account_display}",
        f"‚îú {t.get('stats_strategy', 'Strategy')}: {strat_display}",
        f"‚îú {t.get('stats_period', 'Period')}: üìÖ {period_label}",
        f"‚îî {t.get('trades_page', 'Page')}: {page + 1}/{total_pages} ({total_count} {t.get('trades_total', 'trades')})",
        "",
    ]
    
    if not trades:
        lines.append(f"üì≠ {t.get('trades_empty', 'No trades found for this filter.')}")
        return "\n".join(lines)
    
    for trade in trades:
        symbol = trade.get("symbol", "?")
        side = trade.get("side", "?")
        entry = trade.get("entry_price") or 0
        exit_p = trade.get("exit_price") or 0
        pnl = trade.get("pnl") or 0
        pnl_pct = trade.get("pnl_percent") or 0
        exit_reason = trade.get("exit_reason") or "?"
        strategy = trade.get("strategy") or "?"
        ts = trade.get("time") or ""
        
        # Side emoji
        side_emoji = "üü¢" if side in ("Buy", "Long", "buy", "long") else "üî¥"
        side_label = "Long" if side in ("Buy", "Long", "buy", "long") else "Short"
        
        # PnL emoji
        pnl_emoji = "‚úÖ" if pnl > 0 else "‚ùå" if pnl < 0 else "‚ûñ"
        pnl_sign = "+" if pnl >= 0 else ""
        
        # Exit reason display
        reason_map = {
            "TP": "üéØ TP",
            "SL": "üõë SL",
            "MANUAL": "‚úã Manual",
            "ATR": "üìè ATR",
            "EOD": "‚è∞ EOD",
            "LIQ": "üí• Liq",
            "ADL": "‚ö° ADL",
            "TRAILING": "üìè Trail",
            "PARTIAL_TP": "üìä PTP",
            "webapp_close": "üåê Web",
            "UNKNOWN": "‚ùì",
        }
        reason_display = reason_map.get(exit_reason, exit_reason[:8])
        
        # Strategy display
        strat_short = {
            "oi": "OI", "rsi_bb": "RSI", "scryptomera": "SCR", "scalper": "SCA",
            "elcaro": "ELK", "fibonacci": "FIB", "manual": "MAN", "unknown": "?"
        }.get(strategy, strategy[:3].upper())
        
        # Time formatting - relative time
        time_str = ""
        if ts:
            try:
                import datetime
                from zoneinfo import ZoneInfo
                if isinstance(ts, str):
                    # Try parsing ISO format
                    for fmt in ("%Y-%m-%d %H:%M:%S", "%Y-%m-%dT%H:%M:%S", "%Y-%m-%d %H:%M:%S.%f"):
                        try:
                            dt = datetime.datetime.strptime(ts, fmt).replace(tzinfo=ZoneInfo("UTC"))
                            break
                        except ValueError:
                            continue
                    else:
                        dt = None
                elif isinstance(ts, (int, float)):
                    dt = datetime.datetime.fromtimestamp(ts, tz=ZoneInfo("UTC"))
                else:
                    dt = ts if hasattr(ts, 'strftime') else None
                
                if dt:
                    now = datetime.datetime.now(ZoneInfo("UTC"))
                    diff = now - dt
                    if diff.days > 0:
                        time_str = f"{diff.days}d"
                    elif diff.seconds >= 3600:
                        time_str = f"{diff.seconds // 3600}h"
                    else:
                        time_str = f"{diff.seconds // 60}m"
            except Exception:
                time_str = ""
        
        # Format price with appropriate decimals
        def fmt_price(p):
            if p == 0:
                return "0"
            if p >= 1000:
                return f"{p:,.1f}"
            elif p >= 1:
                return f"{p:.2f}"
            else:
                return f"{p:.4f}"
        
        # Compact trade row
        lines.append(
            f"{pnl_emoji} {side_emoji} `{symbol}` {strat_short}\n"
            f"   {fmt_price(entry)} ‚Üí {fmt_price(exit_p)} | {reason_display}\n"
            f"   {pnl_sign}${pnl:.2f} ({pnl_sign}{pnl_pct:.1f}%)"
            + (f" ‚Ä¢ {time_str} ago" if time_str else "")
        )
        lines.append("")
    
    return "\n".join(lines)


def get_trades_keyboard(t: dict, current_strategy: str = "all", current_period: str = "all",
                        current_account: str = "demo", exchange: str = "bybit",
                        page: int = 0, total_pages: int = 1) -> InlineKeyboardMarkup:
    """Build inline keyboard for trade list navigation.
    
    Args:
        t: Translation dict
        current_strategy: Currently selected strategy
        current_period: Currently selected period
        current_account: Currently selected account type
        exchange: Exchange type
        page: Current page (0-indexed)
        total_pages: Total pages
    """
    strategies = [
        ("all", t.get('stats_all', 'üìà All')),
        ("oi", t.get('stats_oi', 'üìâ OI')),
        ("rsi_bb", t.get('stats_rsi_bb', 'üìä RSI+BB')),
        ("scryptomera", t.get('stats_scryptomera', 'üê± Scryptomera')),
        ("scalper", t.get('stats_scalper', '‚ö° Scalper')),
        ("elcaro", t.get('stats_elcaro', 'üî• Enliko')),
        ("fibonacci", t.get('stats_fibonacci', 'üìê Fibonacci')),
        ("manual", t.get('stats_manual', '‚úã Manual')),
    ]
    
    periods = [
        ("all", t.get('stats_period_all', 'üìÖ All')),
        ("today", t.get('stats_period_today', 'üìÜ 24h')),
        ("week", t.get('stats_period_week', 'üìÖ Week')),
        ("month", t.get('stats_period_month', 'üóì Month')),
    ]
    
    # Exchange-specific account labels
    if exchange == "hyperliquid":
        accounts = [
            ("testnet", t.get('stats_testnet', 'üß™ Testnet')),
            ("mainnet", t.get('stats_mainnet', 'üåê Mainnet')),
        ]
    else:
        accounts = [
            ("demo", t.get('stats_demo', 'üîµ Demo')),
            ("real", t.get('stats_real', 'üü¢ Real')),
        ]
    
    # Account type buttons
    account_buttons = []
    for key, label in accounts:
        marker = "‚úì " if key == current_account else ""
        account_buttons.append(InlineKeyboardButton(
            f"{marker}{label}",
            callback_data=f"trades:acc:{current_strategy}:{current_period}:{key}:0"
        ))
    
    # Strategy buttons (2 per row)
    strat_buttons = []
    row = []
    for i, (key, label) in enumerate(strategies):
        marker = "‚úì " if key == current_strategy else ""
        row.append(InlineKeyboardButton(
            f"{marker}{label}",
            callback_data=f"trades:strat:{key}:{current_period}:{current_account}:0"
        ))
        if len(row) == 2:
            strat_buttons.append(row)
            row = []
    if row:
        strat_buttons.append(row)
    
    # Period buttons
    period_buttons = []
    for key, label in periods:
        marker = "‚úì" if key == current_period else ""
        period_buttons.append(InlineKeyboardButton(
            f"{marker}{label}",
            callback_data=f"trades:period:{current_strategy}:{key}:{current_account}:0"
        ))
    
    # Pagination row
    nav_row = []
    if page > 0:
        nav_row.append(InlineKeyboardButton(
            "‚óÄÔ∏è " + t.get('btn_prev', 'Prev'),
            callback_data=f"trades:page:{current_strategy}:{current_period}:{current_account}:{page - 1}"
        ))
    nav_row.append(InlineKeyboardButton(
        f"üìÑ {page + 1}/{total_pages}",
        callback_data="noop"
    ))
    if page < total_pages - 1:
        nav_row.append(InlineKeyboardButton(
            t.get('btn_next', 'Next') + " ‚ñ∂Ô∏è",
            callback_data=f"trades:page:{current_strategy}:{current_period}:{current_account}:{page + 1}"
        ))
    
    # Back to stats + close
    bottom_row = [
        InlineKeyboardButton("üìä " + t.get('trades_to_stats', 'Statistics'), callback_data="trades:to_stats"),
        InlineKeyboardButton(t.get('btn_close', '‚ùå Close'), callback_data="trades:close"),
    ]
    
    keyboard = [account_buttons] + strat_buttons + [period_buttons]
    if total_pages > 1:
        keyboard.append(nav_row)
    keyboard.append(bottom_row)
    
    return InlineKeyboardMarkup(keyboard)


def get_stats_keyboard(t: dict, current_strategy: str = "all", current_period: str = "all", current_account: str = "demo", exchange: str = "bybit") -> InlineKeyboardMarkup:
    """Build inline keyboard for statistics navigation.
    
    Args:
        t: Translation dict
        current_strategy: Currently selected strategy
        current_period: Currently selected period
        current_account: Currently selected account type
        exchange: Exchange type ('bybit' or 'hyperliquid') - determines account labels
    """
    strategies = [
        ("all", t.get('stats_all', 'üìà All')),
        ("oi", t.get('stats_oi', 'üìâ OI')),
        ("rsi_bb", t.get('stats_rsi_bb', 'üìä RSI+BB')),
        ("scryptomera", t.get('stats_scryptomera', 'üê± Scryptomera')),
        ("scalper", t.get('stats_scalper', '‚ö° Scalper')),
        ("elcaro", t.get('stats_elcaro', 'üî• Enliko')),
        ("fibonacci", t.get('stats_fibonacci', 'üìê Fibonacci')),
        ("manual", t.get('stats_manual', '‚úã Manual')),
        ("spot", t.get('stats_spot', 'üíπ Spot')),
    ]
    
    periods = [
        ("all", t.get('stats_period_all', 'üìÖ All')),
        ("today", t.get('stats_period_today', 'üìÜ 24h')),
        ("week", t.get('stats_period_week', 'üìÖ Week')),
        ("month", t.get('stats_period_month', 'üóì Month')),
    ]
    
    # Exchange-specific account labels
    if exchange == "hyperliquid":
        accounts = [
            ("testnet", t.get('stats_testnet', 'üß™ Testnet')),
            ("mainnet", t.get('stats_mainnet', 'üåê Mainnet')),
        ]
    else:
        accounts = [
            ("demo", t.get('stats_demo', 'üîµ Demo')),
            ("real", t.get('stats_real', 'üü¢ Real')),
        ]
    
    # Account type buttons (first row)
    account_buttons = []
    for key, label in accounts:
        marker = "‚úì " if key == current_account else ""
        account_buttons.append(InlineKeyboardButton(f"{marker}{label}", callback_data=f"stats:acc:{current_strategy}:{current_period}:{key}"))
    
    # Strategy buttons (2 per row)
    strat_buttons = []
    row = []
    for i, (key, label) in enumerate(strategies):
        marker = "‚úì " if key == current_strategy else ""
        row.append(InlineKeyboardButton(f"{marker}{label}", callback_data=f"stats:strat:{key}:{current_period}:{current_account}"))
        if len(row) == 2:
            strat_buttons.append(row)
            row = []
    if row:
        strat_buttons.append(row)
    
    # Period buttons (1 row)
    period_buttons = []
    for key, label in periods:
        marker = "‚úì" if key == current_period else ""
        period_buttons.append(InlineKeyboardButton(f"{marker}{label}", callback_data=f"stats:period:{current_strategy}:{key}:{current_account}"))
    
    # Combine: Account selector first, then strategies, periods, trades button, and back
    keyboard = [account_buttons] + strat_buttons + [period_buttons]
    keyboard.append([
        InlineKeyboardButton("üìã " + t.get('trades_list_btn', 'Trade List'), callback_data=f"trades:view:{current_strategy}:{current_period}:{current_account}:0"),
        InlineKeyboardButton(t.get('btn_close', '‚ùå Close'), callback_data="stats:close"),
    ])
    
    return InlineKeyboardMarkup(keyboard)


async def get_unrealized_pnl(user_id: int, strategy: str | None = None, account_type: str | None = None) -> float:
    """Get total unrealized PnL from Bybit positions, optionally filtered by strategy and account_type.
    
    OPTIMIZED: Fetches positions for specified account type or all account types in parallel.
    """
    try:
        # Get positions from specified account or all accounts
        if account_type:
            account_types = [account_type]
        else:
            account_types = get_active_account_types(user_id)
        
        if not account_types:
            return 0.0
        
        user_exchange = db.get_exchange_type(user_id) or "bybit"
        db_positions = db.get_active_positions(user_id, account_type=account_type, exchange=user_exchange)
        
        # Build a mapping of symbol -> strategy from DB
        symbol_strategy_map = {p["symbol"]: p.get("strategy") for p in db_positions}
        
        async def fetch_positions_for_account(acc_type: str) -> float:
            """Fetch unrealized PnL for a single account type."""
            account_unrealized = 0.0
            try:
                cursor = None
                while True:
                    params = {"category": "linear", "settleCoin": "USDT", "limit": 200}
                    if cursor:
                        params["cursor"] = cursor
                    
                    data = await _bybit_request(
                        user_id, "GET", "/v5/position/list",
                        params=params,
                        account_type=acc_type
                    )
                    positions = data.get("list", [])
                    
                    for p in positions:
                        size = float(p.get("size") or 0)
                        if size <= 0:
                            continue
                        
                        symbol = p.get("symbol", "")
                        pos_strategy = symbol_strategy_map.get(symbol)
                        
                        # Filter by strategy if specified
                        if strategy and pos_strategy != strategy:
                            continue
                        
                        unrealized = float(p.get("unrealisedPnl") or 0)
                        account_unrealized += unrealized
                    
                    cursor = data.get("nextPageCursor")
                    if not cursor:
                        break
                    
            except Exception as e:
                logger.warning(f"Failed to get positions for {acc_type}: {e}")
            return account_unrealized
        
        # OPTIMIZED: Fetch all account types in parallel
        results = await asyncio.gather(
            *[fetch_positions_for_account(acc) for acc in account_types],
            return_exceptions=True
        )
        
        total_unrealized = sum(r for r in results if isinstance(r, (int, float)))
        return total_unrealized
        
    except Exception as e:
        logger.warning(f"Failed to get unrealized PnL: {e}")
        return 0.0


@require_access
@with_texts
@log_calls
async def cmd_trade_stats(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show trading statistics (unified for Bybit + HyperLiquid)."""
    uid = update.effective_user.id
    t = ctx.t
    
    # Get user's active exchange for 4D multitenancy filtering
    user_exchange = db.get_exchange_type(uid) or "bybit"
    
    # Determine default account type based on exchange and trading_mode
    if user_exchange == "hyperliquid":
        _tm = get_trading_mode(uid)
        if _tm == "real":
            default_account = "mainnet"
        elif _tm == "both":
            # Default to mainnet when both, user can switch
            default_account = "mainnet" if db.get_hl_credentials(uid).get("hl_mainnet_private_key") else "testnet"
        else:
            default_account = "testnet"
    else:
        creds = db.get_all_user_credentials(uid)
        default_account = "real" if creds.get("real_api_key") else "demo"
    
    # Default: all strategies, all time, detected account
    stats = get_trade_stats(uid, strategy=None, period="all", account_type=default_account, exchange=user_exchange)
    period_label = t.get('stats_period_all', 'All time')
    
    # Get unrealized PnL from open positions for the selected account
    unrealized_pnl = await get_unrealized_pnl(uid, strategy=None, account_type=default_account)
    
    # For "all time" period, we don't fetch API PnL (would be too expensive)
    text = await format_trade_stats(stats, t, strategy_name="all", period_label=period_label, unrealized_pnl=unrealized_pnl, uid=uid, account_type=default_account, period="all", api_pnl=None)
    keyboard = get_stats_keyboard(t, current_strategy="all", current_period="all", current_account=default_account, exchange=user_exchange)
    
    await update.message.reply_text(text, parse_mode="Markdown", reply_markup=keyboard)


@with_texts
@log_calls
async def on_stats_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle statistics navigation callbacks."""
    import time
    start_time = time.time()
    
    query = update.callback_query
    await query.answer()
    
    data = query.data
    t = ctx.t
    uid = update.effective_user.id
    
    logger.info(f"[{uid}] Stats callback received: {data}")
    
    if data == "stats:close":
        await query.delete_message()
        await ctx.bot.send_message(
            chat_id=uid,
            text=t.get("welcome", "Welcome!"),
            reply_markup=main_menu_keyboard(ctx, user_id=uid)
        )
        return
    
    parts = data.split(":")
    if len(parts) < 4:
        return
    
    # Parse callback data - now includes account_type
    # Format: stats:action:strategy:period:account_type
    _, action, *rest = parts
    
    # Handle different formats
    if action == "acc":
        # stats:acc:strategy:period:new_account_type -> switch account
        strategy = rest[0] if len(rest) > 0 else "all"
        period = rest[1] if len(rest) > 1 else "all"
        account_type = rest[2] if len(rest) > 2 else "demo"
        # Save to DB for persistence (supports both Bybit and HL account types)
        if account_type in ("demo", "real", "testnet", "mainnet"):
            db.set_last_viewed_account(uid, account_type)
    elif action == "strat":
        # stats:strat:new_strategy:period:account_type -> switch strategy
        strategy = rest[0] if len(rest) > 0 else "all"
        period = rest[1] if len(rest) > 1 else "all"
        account_type = rest[2] if len(rest) > 2 else "demo"
    elif action == "period":
        # stats:period:strategy:new_period:account_type -> switch period
        strategy = rest[0] if len(rest) > 0 else "all"
        period = rest[1] if len(rest) > 1 else "all"
        account_type = rest[2] if len(rest) > 2 else "demo"
    else:
        return
    
    period_labels = {
        "all": t.get('stats_period_all', 'All time'),
        "today": t.get('stats_period_today', '24h'),
        "week": t.get('stats_period_week', 'Week'),
        "month": t.get('stats_period_month', 'Month'),
    }
    period_label = period_labels.get(period, period)
    
    # Get exchange type for proper keyboard labels (testnet/mainnet vs demo/real)
    user_exchange = db.get_exchange_type(uid) or "bybit"
    
    # Special handling for Spot statistics
    if strategy == "spot":
        text = await format_spot_stats(uid, t, period_label, account_type=account_type)
        keyboard = get_stats_keyboard(t, current_strategy=strategy, current_period=period, current_account=account_type, exchange=user_exchange)
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
        return
    
    # Special handling for Manual trades (NULL strategy)
    if strategy == "manual":
        from db import get_trade_stats_unknown
        stats = get_trade_stats_unknown(uid, period=period, account_type=account_type, exchange=user_exchange)
        # Format manual stats with minimal info
        strat_display = "‚úã Manual"
        account_display = ACCOUNT_DISPLAY_NAMES.get(account_type, account_type.capitalize())
        text = (
            f"üìä *{t.get('stats_title', 'Trading Statistics')}* {account_display}\n"
            f"‚îú {t.get('stats_strategy', 'Strategy')}: {strat_display}\n"
            f"‚îî {t.get('stats_period', 'Period')}: üìÖ {period_label}\n\n"
            f"*{t.get('stats_overview', 'Overview')}*\n"
            f"‚îú‚îÄ {t.get('stats_total_trades', 'Total trades')}: {stats['total']}\n"
            f"‚îú‚îÄ {t.get('stats_winrate', 'Winrate')}: {stats['winrate']:.1f}%\n"
            f"‚îî‚îÄ PnL: {stats['total_pnl']:+.2f} USDT\n\n"
            f"_These are trades closed manually without strategy attribution._"
        )
        keyboard = get_stats_keyboard(t, current_strategy=strategy, current_period=period, current_account=account_type, exchange=user_exchange)
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
        return
    
    # Get stats based on selection
    strat_filter = None if strategy == "all" else strategy
    stats = get_trade_stats(uid, strategy=strat_filter, period=period, account_type=account_type, exchange=user_exchange)
    
    # OPTIMIZED: Get unrealized PnL and API PnL in parallel
    async def get_api_pnl():
        """Fetch API PnL for comparison."""
        if strategy != "all":
            return None
        try:
            exchange = db.get_exchange_type(uid) or 'bybit'
            if exchange == 'bybit':
                if period == "today":
                    return await fetch_today_realized_pnl(uid, account_type=account_type)
                elif period == "week":
                    return await fetch_realized_pnl(uid, days=7, account_type=account_type)
                elif period == "month":
                    return await fetch_realized_pnl(uid, days=30, account_type=account_type)
                elif period == "all":
                    return await fetch_realized_pnl(uid, days=90, account_type=account_type)
        except Exception as e:
            logger.warning(f"Failed to fetch API PnL for stats: {e}")
        return None
    
    # Fetch unrealized PnL and API PnL in parallel
    unrealized_pnl, api_pnl = await asyncio.gather(
        get_unrealized_pnl(uid, strategy=strat_filter, account_type=account_type),
        get_api_pnl(),
        return_exceptions=True
    )
    
    # Handle exceptions
    if isinstance(unrealized_pnl, Exception):
        unrealized_pnl = 0.0
    if isinstance(api_pnl, Exception):
        api_pnl = None
    
    text = await format_trade_stats(stats, t, strategy_name=strategy, period_label=period_label, unrealized_pnl=unrealized_pnl, uid=uid, account_type=account_type, period=period, api_pnl=api_pnl)
    keyboard = get_stats_keyboard(t, current_strategy=strategy, current_period=period, current_account=account_type, exchange=user_exchange)
    
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    logger.info(f"[{uid}] Stats callback completed in {time.time() - start_time:.2f}s")


@with_texts
@log_calls
async def on_trades_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle trade list navigation callbacks.
    
    Callback format: trades:action:strategy:period:account_type:page
    Actions: view, acc, strat, period, page, to_stats, close
    """
    query = update.callback_query
    await query.answer()
    
    data = query.data
    t = ctx.t
    uid = update.effective_user.id
    
    logger.info(f"[{uid}] Trades callback: {data}")
    
    if data == "trades:close":
        await query.delete_message()
        await ctx.bot.send_message(
            chat_id=uid,
            text=t.get("welcome", "Welcome!"),
            reply_markup=main_menu_keyboard(ctx, user_id=uid)
        )
        return
    
    if data == "trades:to_stats":
        # Switch back to stats view - reuse on_stats_callback logic
        user_exchange = db.get_exchange_type(uid) or "bybit"
        creds = db.get_all_user_credentials(uid)
        default_account = "real" if creds.get("real_api_key") else "demo"
        stats = get_trade_stats(uid, strategy=None, period="all", account_type=default_account, exchange=user_exchange)
        period_label = t.get('stats_period_all', 'All time')
        unrealized_pnl = await get_unrealized_pnl(uid, strategy=None, account_type=default_account)
        text = await format_trade_stats(stats, t, strategy_name="all", period_label=period_label,
                                        unrealized_pnl=unrealized_pnl, uid=uid, account_type=default_account,
                                        period="all", api_pnl=None)
        keyboard = get_stats_keyboard(t, current_strategy="all", current_period="all",
                                      current_account=default_account, exchange=user_exchange)
        await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
        return
    
    if data == "noop":
        return
    
    parts = data.split(":")
    if len(parts) < 6:
        return
    
    # Parse: trades:action:strategy:period:account_type:page
    _, action, strategy, period, account_type, page_str = parts[:6]
    page = int(page_str) if page_str.isdigit() else 0
    
    # Handle account switch
    if action == "acc":
        account_type = parts[4] if len(parts) > 4 else "demo"
        page = 0
    elif action == "strat":
        strategy = parts[2] if len(parts) > 2 else "all"
        page = 0
    elif action == "period":
        period = parts[3] if len(parts) > 3 else "all"
        page = 0
    elif action == "page":
        pass  # page already parsed
    elif action == "view":
        pass  # initial view
    else:
        return
    
    period_labels = {
        "all": t.get('stats_period_all', 'All time'),
        "today": t.get('stats_period_today', '24h'),
        "week": t.get('stats_period_week', 'Week'),
        "month": t.get('stats_period_month', 'Month'),
    }
    period_label = period_labels.get(period, period)
    
    user_exchange = db.get_exchange_type(uid) or "bybit"
    per_page = 8
    
    # Fetch trades with filters
    strat_filter = None if strategy == "all" else strategy
    
    # Manual strategy includes unknown
    if strategy == "manual":
        # Get both manual and unknown trades
        trades_manual, count_manual = db.get_trade_logs_list(
            uid, limit=per_page, offset=page * per_page,
            strategy="manual", account_type=account_type,
            exchange=user_exchange, period=period, return_count=True
        )
        trades_unknown, count_unknown = db.get_trade_logs_list(
            uid, limit=per_page, offset=0,
            strategy="unknown", account_type=account_type,
            exchange=user_exchange, period=period, return_count=True
        )
        # Merge and sort
        all_trades = trades_manual + trades_unknown
        total_count = count_manual + count_unknown
        # Sort by time desc and take per_page
        all_trades.sort(key=lambda x: x.get("time", ""), reverse=True)
        trades = all_trades[:per_page]
    else:
        trades, total_count = db.get_trade_logs_list(
            uid, limit=per_page, offset=page * per_page,
            strategy=strat_filter, account_type=account_type,
            exchange=user_exchange, period=period, return_count=True
        )
    
    total_pages = max(1, (total_count + per_page - 1) // per_page)
    
    text = format_trade_list(
        trades, t, strategy_name=strategy, period_label=period_label,
        account_type=account_type, page=page, total_count=total_count,
        per_page=per_page
    )
    
    keyboard = get_trades_keyboard(
        t, current_strategy=strategy, current_period=period,
        current_account=account_type, exchange=user_exchange,
        page=page, total_pages=total_pages
    )
    
    await query.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)


async def format_spot_stats(uid: int, t: dict, period_label: str, account_type: str = "demo") -> str:
    """Format Spot DCA statistics."""
    cfg = db.get_user_config(uid)
    spot_settings = cfg.get("spot_settings") or {}
    
    total_invested = spot_settings.get("total_invested", 0.0)
    coins = spot_settings.get("coins", SPOT_DCA_COINS)
    dca_amount = spot_settings.get("dca_amount", SPOT_DCA_DEFAULT_AMOUNT)
    auto_dca = spot_settings.get("auto_dca", False)
    purchase_history = spot_settings.get("purchase_history", {})
    
    # Use provided account_type instead of auto-detecting
    account_display = ACCOUNT_DISPLAY_NAMES.get(account_type, account_type.capitalize())
    
    holdings_value = 0.0
    holdings_lines = []
    
    try:
        balances = await fetch_spot_balance(uid, account_type=account_type)
        
        for coin in coins:
            if coin in balances and balances[coin] > 0:
                symbol = f"{coin}USDT"
                ticker = await get_spot_ticker(uid, symbol, account_type=account_type)
                if ticker:
                    price = float(ticker.get("lastPrice", 0))
                    qty = balances[coin]
                    value = qty * price
                    holdings_value += value
                    
                    # Calculate PnL per coin using purchase history
                    coin_history = purchase_history.get(coin, {})
                    avg_price = coin_history.get("avg_price", 0)
                    total_cost = coin_history.get("total_cost", 0)
                    
                    if avg_price > 0:
                        # PnL = current value - cost basis (proportional to held qty)
                        pnl = value - (qty * avg_price)
                        pnl_sign = "+" if pnl >= 0 else ""
                        pnl_emoji = "üü¢" if pnl >= 0 else "üî¥"
                        holdings_lines.append(f"‚îú‚îÄ {coin}: {qty:.8g} ‚âà ${value:.2f} {pnl_emoji} {pnl_sign}${pnl:.2f}")
                    elif total_invested > 0 and holdings_value > 0:
                        # Fallback: estimate cost proportionally from total invested
                        coin_share = value / holdings_value if holdings_value > 0 else 0
                        estimated_cost = total_invested * coin_share
                        pnl = value - estimated_cost
                        pnl_sign = "+" if pnl >= 0 else ""
                        pnl_emoji = "üü¢" if pnl >= 0 else "üî¥"
                        holdings_lines.append(f"‚îú‚îÄ {coin}: {qty:.8g} ‚âà ${value:.2f} {pnl_emoji} ~{pnl_sign}${pnl:.2f}")
                    else:
                        holdings_lines.append(f"‚îú‚îÄ {coin}: {qty:.8g} ‚âà ${value:.2f}")
    except Exception as e:
        logger.error(f"Error getting spot holdings for stats: {e}")
        holdings_lines.append("‚îú‚îÄ Unable to fetch holdings")
    
    # Calculate P/L
    pnl = holdings_value - total_invested if total_invested > 0 else 0
    pnl_pct = (pnl / total_invested * 100) if total_invested > 0 else 0
    pnl_sign = "+" if pnl >= 0 else ""
    pnl_emoji = "üìà" if pnl >= 0 else "üìâ"
    
    coins_str = ", ".join(coins) if isinstance(coins, list) else str(coins)
    auto_status = "‚úÖ" if auto_dca else "‚ùå"
    
    lines = [
        f"üíπ *{t.get('stats_spot_title', 'Spot DCA Statistics')}* {account_display}",
        f"‚îî {t.get('stats_period', 'Period')}: üìÖ {period_label}",
        "",
        f"*{t.get('stats_spot_config', 'Configuration')}*",
        f"‚îú‚îÄ ü™ô {t.get('spot_coins_label', 'Coins')}: {coins_str}",
        f"‚îú‚îÄ üíµ {t.get('spot_dca_amount_label', 'DCA Amount')}: ${dca_amount:.2f}",
        f"‚îî‚îÄ üîÑ {t.get('spot_auto_dca_label', 'Auto DCA')}: {auto_status}",
        "",
        f"*{t.get('stats_spot_holdings', 'Holdings')}*",
    ]
    
    if holdings_lines:
        lines.extend(holdings_lines)
    else:
        lines.append("‚îú‚îÄ No holdings")
    
    lines.extend([
        "",
        f"*{t.get('stats_spot_summary', 'Summary')}*",
        f"‚îú‚îÄ {t.get('spot_total_invested', 'Total Invested')}: ${total_invested:.2f}",
        f"‚îú‚îÄ {t.get('stats_spot_current_value', 'Current Value')}: ${holdings_value:.2f}",
        f"‚îî‚îÄ {pnl_emoji} {t.get('stats_total_pnl', 'P/L')}: {pnl_sign}${pnl:.2f} ({pnl_sign}{pnl_pct:.1f}%)",
    ])
    
    return "\n".join(lines)


@require_access
@with_texts
@log_calls
async def cmd_set_percent(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    ctx.user_data['mode'] = 'set_percent'
    await reply_with_keyboard(update, ctx, ctx.t['set_percent_prompt'])


@require_access
@with_texts
@log_calls
async def cmd_toggle_limit(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    cfg = get_user_config(uid)
    new = not bool(cfg.get("limit_enabled", 0))
    set_user_field(uid, "limit_enabled", int(new))
    await update.message.reply_text(ctx.t['limit_only_toggled'].format(state=ctx.t['status_enabled'] if new else ctx.t['status_disabled']),
        reply_markup=main_menu_keyboard(ctx, update=update)
)

@require_access
@with_texts
@log_calls
async def cmd_indicators(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton("1. RSI + BB",     url="https://ru.tradingview.com/script/SCDoLiri-elcaro-bollinger-rsi-win-strategy-v0-1/")],
        [InlineKeyboardButton("2. Trading Chaos",url="https://ru.tradingview.com/script/iRZwhDIu-trading-chaos-strategy-risk-management-strict/")],
        [InlineKeyboardButton("3. Adaptive Trend", url="https://ru.tradingview.com/script/TMWJzpka-adaptivnyj-kanal-regressiya-ehkstremumy/")],
        [InlineKeyboardButton("4. Dynamic Regression", url="https://ru.tradingview.com/script/CnqpAgCb-adaptivnyj-regressionnyj-kanal-v2/")],
    ]
    await ctx.bot.send_message(
        chat_id=update.effective_chat.id,
        text=ctx.t['indicators_header'],
        reply_markup=InlineKeyboardMarkup(keyboard),
        parse_mode="Markdown"
    )

@with_texts
@log_calls
async def cmd_support(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    keyboard = [
        [InlineKeyboardButton(ctx.t['support_button'], url="https://t.me/elcaronosam")]
    ]
    await ctx.bot.send_message(
        chat_id=update.effective_chat.id,
        text=ctx.t['support_prompt'],
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


@with_texts
@log_calls
async def cmd_app_login(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """
    Generate one-time login link for iOS/Android app.
    User clicks link ‚Üí app opens ‚Üí automatic login with Telegram account.
    """
    uid = update.effective_user.id
    
    # Generate one-time token
    import secrets
    token = secrets.token_urlsafe(32)
    
    # Store in Redis with 5 min expiry (or fallback to DB)
    try:
        from core.redis_client import get_redis
        redis_client = await get_redis()
        token_data = json.dumps({
            "telegram_id": uid,
            "created_at": datetime.now().isoformat(),
            "first_name": update.effective_user.first_name,
            "username": update.effective_user.username
        })
        await redis_client.set(f"app_login:{token}", token_data, ttl=300)
    except Exception as e:
        logger.warning(f"cmd_app_login Redis error (using DB fallback): {e}")
        # Fallback: store in database if Redis unavailable
        try:
            from core.db_postgres import execute
            execute(
                "INSERT INTO login_tokens (token, user_id, expires_at) VALUES (%s, %s, NOW() + INTERVAL '5 minutes')",
                (token, uid)
            )
        except Exception as db_e:
            logger.error(f"cmd_app_login DB error: {db_e}")
            await update.message.reply_text(
                "‚ùå –ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ–∑–¥–∞—Ç—å —Å—Å—ã–ª–∫—É –¥–ª—è –≤—Ö–æ–¥–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.",
                parse_mode="HTML"
            )
            return
    
    # Create deep link
    webapp_url = os.getenv("WEBAPP_URL", "https://enliko.com")
    deep_link = f"{webapp_url}/auth/app-login?token={token}&tid={uid}"
    
    # Also create enliko:// scheme link for native app
    native_link = f"enliko://login?token={token}&tid={uid}"
    
    keyboard = [
        [InlineKeyboardButton("üì± –û—Ç–∫—Ä—ã—Ç—å –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–∏", url=native_link)],
        [InlineKeyboardButton("üåê –û—Ç–∫—Ä—ã—Ç—å –≤ –±—Ä–∞—É–∑–µ—Ä–µ", url=deep_link)]
    ]
    
    text = ctx.t.get('app_login_prompt', """
üîê <b>–í—Ö–æ–¥ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ Enliko</b>

–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É –Ω–∏–∂–µ –¥–ª—è –≤—Ö–æ–¥–∞ –≤ iOS –∏–ª–∏ Android –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.
–°—Å—ã–ª–∫–∞ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–∞ 5 –º–∏–Ω—É—Ç.

‚ö†Ô∏è –ù–µ –ø–µ—Ä–µ–¥–∞–≤–∞–π—Ç–µ —ç—Ç—É —Å—Å—ã–ª–∫—É –¥—Ä—É–≥–∏–º –ª—é–¥—è–º!
""")
    
    await update.message.reply_text(
        text,
        parse_mode="HTML",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


@log_calls
async def normalize_qty_price(
    user_id: int,
    symbol: str,
    order_type: str,       
    qty: float,
    price: float | None = None,
    account_type: str = None
) -> tuple[str, str | None, float, float, float]:
    filt = await get_symbol_filters(user_id, symbol, account_type=account_type)
    min_qty   = float(filt["minQty"])
    step_qty  = float(filt["qtyStep"])
    tick_size = float(filt["tickSize"])
    min_price = float(filt["minPrice"])

    inst = await _bybit_request(
        user_id, "GET", "/v5/market/instruments-info",
        params={"category": "linear", "symbol": symbol},
        account_type=account_type
    )
    if not inst.get("list"):
        raise ValueError(f"Symbol {symbol} not found")
    lot = inst["list"][0]["lotSizeFilter"]
    if order_type == "Market":
        raw_max = lot.get("maxMktOrderQty")
    else:
        raw_max = lot.get("maxOrderQty") or lot.get("maxMktOrderQty")
    max_qty = float(raw_max) if raw_max not in (None, "", 0, "0") else float("inf")

    q = quantize(qty, step_qty)
    if q < min_qty:
        q = min_qty

    q = min(q, max_qty)
    q = quantize(q, step_qty)
    if q < min_qty:
        q = min_qty

    qty_decimals   = _decimals_from_step(step_qty)
    price_decimals = _decimals_from_step(tick_size)
    qty_str = f"{q:.{qty_decimals}f}"

    price_str = None
    if order_type == "Limit":
        if price is None:
            raise ValueError("For Limit-order need price")
        px_q = quantize(float(price), tick_size)
        if px_q < min_price:
            raise ValueError(
                f"Price - min: {px_q:.{price_decimals}f} < {min_price:.{price_decimals}f}"
            )
        price_str = f"{px_q:.{price_decimals}f}"

    return qty_str, price_str, min_qty, max_qty, tick_size

@log_calls
async def get_symbol_filters(user_id: int, symbol: str, account_type: str = None, exchange: str = None) -> dict:
    """Get symbol trading filters with caching (1 hour TTL).
    
    For HyperLiquid: Uses local constants for size decimals (no API call needed).
    For Bybit: Fetches from Bybit API instruments-info.
    """
    # Determine exchange if not provided
    if exchange is None:
        exchange = db.get_exchange_type(user_id) or "bybit"
    
    now = time.time()
    cache_key = f"{exchange}:{symbol}"
    
    # Check cache first - filters are same for all users per exchange
    if cache_key in _symbol_filters_cache:
        ts, cached = _symbol_filters_cache[cache_key]
        if now - ts < SYMBOL_FILTERS_CACHE_TTL:
            return cached
    
    # HyperLiquid - use local constants
    if exchange == "hyperliquid":
        from hyperliquid.constants import get_size_decimals, DEFAULT_SIZE_DECIMALS
        # Convert symbol to coin (BTCUSDC -> BTC, BTC -> BTC)
        coin = symbol.replace("USDC", "").replace("USDT", "")
        sz_decimals = get_size_decimals(coin)
        qty_step = 10 ** (-sz_decimals)
        min_qty = qty_step  # Minimum is 1 step
        # HyperLiquid uses 5 significant digits for price (tick_size derived from price level)
        tick_size = 0.00001  # Default, actual precision varies by price
        filters = {
            "tickSize":      tick_size,
            "minPrice":      0.0,
            "minQty":        min_qty,
            "qtyStep":       qty_step,
        }
        _symbol_filters_cache[cache_key] = (now, filters)
        return filters
    
    # Bybit - fetch from API
    res = await _bybit_request(user_id, "GET", "/v5/market/instruments-info", params={"category":"linear","symbol":symbol}, account_type=account_type)
    if not res.get("list"):
        raise ValueError(f"Symbol {symbol} not found on Bybit")
    inst = res["list"][0]
    price_f = inst["priceFilter"]
    lot_f   = inst["lotSizeFilter"]
    filters = {
        "tickSize":      float(price_f["tickSize"]),
        "minPrice":      float(price_f["minPrice"]),
        "minQty":        float(lot_f["minOrderQty"]),
        "qtyStep":       float(lot_f["qtyStep"]),
    }
    # Store in cache
    _symbol_filters_cache[cache_key] = (now, filters)
    return filters

@log_calls
async def place_limit_order(
    user_id: int,
    symbol: str,
    side: str,
    price: float,
    qty: float,
    account_type: str = None,
):
    filt = await get_symbol_filters(user_id, symbol, account_type=account_type)
    tick_size = filt["tickSize"]
    min_qty   = filt["minQty"]
    qty_step  = filt["qtyStep"]

    price_q = quantize(price, tick_size)
    price_decimals = _decimals_from_step(tick_size)
    if price_q < filt["minPrice"]:
        raise ValueError(
            f"Price - min: {price_q:.{price_decimals}f} < {filt['minPrice']:.{price_decimals}f}"
        )

    qty_q = quantize(qty, qty_step)
    if qty_q < min_qty:
        qty_q = min_qty

    inst = await _bybit_request(
        user_id, "GET", "/v5/market/instruments-info",
        params={"category": "linear", "symbol": symbol},
        account_type=account_type
    )
    if not inst.get("list"):
        raise ValueError(f"Symbol {symbol} not found")
    lot = inst["list"][0]["lotSizeFilter"]
    max_qty_raw = lot.get("maxOrderQty") or lot.get("maxMktOrderQty")
    max_qty = float(max_qty_raw) if max_qty_raw not in (None, "", 0, "0") else float("inf")

    qty_q = min(qty_q, max_qty)
    qty_q = quantize(qty_q, qty_step)
    if qty_q < min_qty:
        qty_q = min_qty

    qty_decimals = _decimals_from_step(qty_step)
    qty_str   = f"{qty_q:.{qty_decimals}f}"
    price_str = f"{price_q:.{price_decimals}f}"

    order_body = {
        "category":    "linear",
        "symbol":      symbol,
        "side":        side,
        "orderType":   "Limit",
        "qty":         qty_str,
        "price":       price_str,
        "timeInForce": "GTC",
    }

    mode = await get_position_mode(user_id, symbol, account_type=account_type)
    order_body["positionIdx"] = position_idx_for(side, mode)

    try:
        res = await _bybit_request(user_id, "POST", "/v5/order/create", body=order_body, account_type=account_type)
    except RuntimeError as e:
        msg = str(e)

        if "insufficient" in msg.lower() or "balance" in msg.lower() or "110007" in msg or "ab not enough" in msg.lower():
            raise ValueError("INSUFFICIENT_BALANCE")

        if "position idx not match position mode" in msg.lower():
            alt_mode = "one_way" if mode == "hedge" else "hedge"
            order_body["positionIdx"] = position_idx_for(side, alt_mode)
            _position_mode_cache[(user_id, symbol)] = alt_mode
            logger.info(f"{symbol}: retry limit with alt position mode {alt_mode}")
            res = await _bybit_request(user_id, "POST", "/v5/order/create", body=order_body, account_type=account_type)
        elif "110013" in msg or "cannot set leverage" in msg.lower():
            logger.info(f"Leverage error on {symbol}, setting leverage=10 and retrying limit order")
            await set_leverage(user_id, symbol, leverage=10, account_type=account_type)
            res = await _bybit_request(user_id, "POST", "/v5/order/create", body=order_body, account_type=account_type)
        else:
            raise

    logger.info(f"‚úÖ Limit order placed: {symbol} {side} {qty_q}@{price_q} [{account_type or 'auto'}]")
    return res


@log_calls
async def place_limit_order_all_accounts(
    user_id: int,
    symbol: str,
    side: str,
    price: float,
    qty: float,
    strategy: str = None,
) -> dict:
    """
    Place limit order on all active accounts based on strategy's trading_mode or global trading_mode.
    If trading_mode is 'both', places order on both demo and real accounts.
    Returns dict with results per account type.
    """
    if strategy:
        account_types = get_strategy_account_types(user_id, strategy)
    else:
        account_types = get_active_account_types(user_id)
    
    if not account_types:
        raise ValueError("No API credentials configured")
    
    results = {}
    errors = []
    
    for acc_type in account_types:
        try:
            res = await place_limit_order(user_id, symbol, side, price, qty, account_type=acc_type)
            results[acc_type] = {"success": True, "result": res}
            logger.info(f"‚úÖ [{acc_type.upper()}] Limit order placed: {symbol} {side}")
        except Exception as e:
            results[acc_type] = {"success": False, "error": str(e)}
            errors.append(f"[{acc_type.upper()}] {str(e)}")
            logger.error(f"‚ùå [{acc_type.upper()}] Limit order failed for {symbol}: {e}")
    
    if errors and not any(r["success"] for r in results.values()):
        raise RuntimeError(f"All orders failed: {'; '.join(errors)}")
    
    return results


@log_calls
async def place_limit_order_with_strategy(
    user_id: int,
    symbol: str,
    side: str,
    price: float,
    qty: float,
    signal_id: int,
    strategy: str,
) -> dict:
    """
    Place limit order on all accounts for strategy and add to pending_limit_orders for each.
    Returns dict with results per account type.
    """
    account_types = get_strategy_account_types(user_id, strategy)
    
    if not account_types:
        raise ValueError("No API credentials configured")
    
    results = {}
    errors = []
    created_ts = int(time.time() * 1000)
    
    for acc_type in account_types:
        try:
            res = await place_limit_order(user_id, symbol, side, price, qty, account_type=acc_type)
            order_id = _normalize_order_id(res)
            tif = str(res.get("timeInForce") or "GTC")
            
            # Add to pending_limit_orders with account_type
            add_pending_limit_order(
                user_id=user_id,
                order_id=order_id,
                symbol=symbol,
                side=side,
                qty=qty,
                price=price,
                signal_id=signal_id,
                created_ts=created_ts,
                time_in_force=tif,
                strategy=strategy,
                account_type=acc_type,
                exchange="bybit",
            )
            
            results[acc_type] = {"success": True, "result": res, "order_id": order_id}
            logger.info(f"‚úÖ [{acc_type.upper()}] Limit order placed: {symbol} {side} @ {price}")
        except Exception as e:
            results[acc_type] = {"success": False, "error": str(e)}
            errors.append(f"[{acc_type.upper()}] {str(e)}")
            logger.error(f"‚ùå [{acc_type.upper()}] Limit order failed for {symbol}: {e}")
    
    if errors and not any(r["success"] for r in results.values()):
        raise RuntimeError(f"All orders failed: {'; '.join(errors)}")
    
    return results


@log_calls
async def place_ladder_limit_orders(
    user_id: int,
    symbol: str,
    side: str,
    entry_price: float,
    strategy: str,
    ctx=None
) -> dict:
    """
    Place ladder limit orders below (for LONG) or above (for SHORT) entry price.
    Returns dict with results for each ladder order.
    
    Settings from user config:
    - limit_ladder_enabled: bool
    - limit_ladder_count: int (1-5)
    - limit_ladder_settings: list of {pct_from_entry, pct_of_deposit}
    """
    cfg = get_user_config(user_id)
    
    if not cfg.get('limit_ladder_enabled', 0):
        logger.debug(f"[{user_id}] Ladder disabled for {symbol}")
        return {"skipped": True, "reason": "Ladder disabled"}
    
    ladder_count = cfg.get('limit_ladder_count', 3)
    ladder_settings = cfg.get('limit_ladder_settings', [])
    
    # Default settings if empty
    if not ladder_settings:
        ladder_settings = [
            {"pct_from_entry": 1.0, "pct_of_deposit": 5.0},
            {"pct_from_entry": 2.0, "pct_of_deposit": 7.0},
            {"pct_from_entry": 3.0, "pct_of_deposit": 10.0},
        ]
    
    # Get balance for calculating qty
    account_types = get_strategy_account_types(user_id, strategy)
    if not account_types:
        logger.warning(f"[{user_id}] No accounts configured for ladder on {symbol}")
        return {"skipped": True, "reason": "No accounts configured"}
    
    logger.info(f"[{user_id}] üìâ Placing ladder for {symbol}: {ladder_count} orders, accounts={account_types}")
    
    # Get instrument info for qty normalization
    try:
        inst = await _bybit_request(
            user_id, "GET", "/v5/market/instruments-info",
            params={"category": "linear", "symbol": symbol},
            account_type=account_types[0]
        )
        if not inst.get("list"):
            logger.error(f"[{user_id}] Symbol {symbol} not found in instruments")
            return {"skipped": True, "reason": f"Symbol {symbol} not found"}
        lot = inst["list"][0]["lotSizeFilter"]
        min_qty = float(lot["minOrderQty"])
        step_qty = float(lot["qtyStep"])
        raw_max = lot.get("maxMktOrderQty")
        max_qty = float(raw_max) if raw_max not in (None, "", 0, "0") else float("inf")
    except Exception as e:
        logger.error(f"[{user_id}] Failed to get instrument info for {symbol}: {e}")
        return {"skipped": True, "reason": f"Instrument info error: {e}"}
    
    results = {}
    placed_count = 0
    
    for i in range(min(ladder_count, len(ladder_settings))):
        leg = ladder_settings[i]
        pct_from_entry = leg.get('pct_from_entry', 1.0 + i)
        pct_of_deposit = leg.get('pct_of_deposit', 5.0 + i * 2)
        
        # Calculate price: below entry for LONG, above entry for SHORT
        if side == "Buy":
            ladder_price = entry_price * (1 - pct_from_entry / 100)
        else:
            ladder_price = entry_price * (1 + pct_from_entry / 100)
        
        try:
            # Get balance and calculate qty for this ladder order
            for acc_type in account_types:
                balance = await fetch_usdt_balance(user_id, account_type=acc_type)
                qty_usdt = balance * (pct_of_deposit / 100)
                raw_qty = qty_usdt / ladder_price
                
                # Normalize qty to exchange requirements
                qty = math.floor(raw_qty / step_qty) * step_qty
                qty = max(min_qty, qty)
                qty = min(max_qty, qty)
                
                if qty < min_qty:
                    logger.warning(f"[{user_id}] Ladder {i+1}: qty {raw_qty:.6f} < min_qty {min_qty}, skipping")
                    continue
                
                if qty <= 0:
                    logger.warning(f"[{user_id}] Ladder {i+1}: qty <= 0, skipping")
                    continue
                
                res = await place_limit_order(user_id, symbol, side, ladder_price, qty, account_type=acc_type)
                order_id = _normalize_order_id(res)
                
                # Add to pending_limit_orders
                created_ts = int(time.time() * 1000)
                add_pending_limit_order(
                    user_id=user_id,
                    order_id=order_id,
                    symbol=symbol,
                    side=side,
                    qty=qty,
                    price=ladder_price,
                    signal_id=0,
                    created_ts=created_ts,
                    time_in_force="GTC",
                    strategy=f"{strategy}_ladder_{i+1}",
                    account_type=acc_type,
                    exchange="bybit",
                )
                
                results[f"ladder_{i+1}_{acc_type}"] = {
                    "success": True, 
                    "price": ladder_price, 
                    "qty": qty, 
                    "pct_from_entry": pct_from_entry,
                    "pct_of_deposit": pct_of_deposit,
                    "order_id": order_id
                }
                placed_count += 1
                logger.info(f"üìâ Ladder {i+1} [{acc_type}]: {symbol} {side} @ {ladder_price:.6f} qty={qty:.4f}")
                
        except Exception as e:
            results[f"ladder_{i+1}"] = {"success": False, "error": str(e)}
            logger.error(f"‚ùå Ladder {i+1} failed: {e}")
    
    # Notify user if context available
    if ctx and placed_count > 0:
        t = ctx.t if hasattr(ctx, 't') else {}
        try:
            msg = t.get('ladder_orders_placed', "üìâ Placed {count} ladder limit orders for {symbol}").format(
                count=placed_count, symbol=symbol
            )
            await ctx.bot.send_message(user_id, msg, parse_mode="Markdown")
            logger.info(f"[{user_id}] Sent ladder notification: {placed_count} orders for {symbol}")
        except Exception as e:
            logger.error(f"[{user_id}] Failed to send ladder notification: {e}")
    elif placed_count == 0:
        logger.warning(f"[{user_id}] No ladder orders placed for {symbol}")
    
    results["placed_count"] = placed_count
    return results


@log_calls
async def calc_qty(
    user_id: int,
    symbol: str,
    price: float,
    risk_pct: float,
    sl_pct: float,
    account_type: str = None,
    exchange: str = None
) -> float:
    """
    Calculate position size based on RISK-BASED position sizing.
    
    Formula: qty = (equity * risk_pct%) / (price * sl_pct%)
    
    This calculates how many contracts to buy so that if price moves
    by SL%, we lose exactly risk_pct% of equity.
    
    Example:
        equity = $1000, risk_pct = 1%, sl_pct = 3%, price = $100
        risk_usdt = $10 (amount we're willing to lose)
        price_move = $3 (how much 1 contract moves at SL)
        qty = 10/3 = 3.33 contracts
        If price drops 3%: loss = 3.33 * $3 = $10 = 1% of equity ‚úì
    
    NOTE: Leverage does NOT affect the risk calculation!
    Leverage only affects required margin, not the P&L per contract.
    
    Supports both Bybit and HyperLiquid exchanges.
    """
    # Check exchange type
    user_exchange = db.get_exchange_type(user_id) or "bybit"
    
    # Use equity (total capital) for consistent position sizing
    equity = await fetch_usdt_balance(user_id, account_type=account_type, use_equity=True)
    
    if equity <= 0:
        # Record error for admin reporting
        asyncio.create_task(error_monitor.record_error(
            user_id=user_id,
            error_type="EQUITY_ZERO",
            error_message=f"equity={equity}, account_type={account_type}, exchange={user_exchange}",
            function_name="calc_qty",
            symbol=symbol,
            account_type=account_type,
            notify_user=True,
            risk_pct=risk_pct,
            sl_pct=sl_pct
        ))
        raise ValueError(f"Don't have USDT (equity={equity}, account_type={account_type}, exchange={user_exchange})")
    
    risk_usdt = equity * (risk_pct / 100)
    price_move = price * (sl_pct / 100)
    
    if price_move <= 0:
        raise ValueError("Wrong sl_pct for price_move")

    raw_qty = risk_usdt / price_move
    
    # Log the calculation for debugging
    logger.info(
        f"[calc_qty] uid={user_id} {symbol}: "
        f"equity=${equity:.2f}, risk%={risk_pct:.2f}%, sl%={sl_pct:.2f}% ‚Üí "
        f"risk_usdt=${risk_usdt:.2f}, price_move=${price_move:.4f}, raw_qty={raw_qty:.4f} [exchange={user_exchange}]"
    )

    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # HYPERLIQUID: Use built-in size decimals from constants
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    if user_exchange == "hyperliquid":
        from hyperliquid.constants import get_size_decimals, DEFAULT_SIZE_DECIMALS
        
        # Normalize symbol (remove USDT/USDC suffix)
        coin = symbol.upper().replace("USDT", "").replace("USDC", "").replace("PERP", "")
        sz_decimals = get_size_decimals(coin)
        
        # HyperLiquid has less strict min_qty (typically 0.001)
        min_qty = 10 ** (-sz_decimals)  # e.g., decimals=2 ‚Üí min=0.01
        step_qty = min_qty
        
        qty = round(raw_qty, sz_decimals)
        qty = max(min_qty, qty)
        
        logger.info(f"[calc_qty] uid={user_id} {symbol}: final_qty={qty:.{sz_decimals}f} (HL decimals={sz_decimals})")
        return qty
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # BYBIT: Query instrument info for precise lot sizes
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    inst = await _bybit_request(
        user_id, "GET", "/v5/market/instruments-info",
        params={"category":"linear", "symbol": symbol},
        account_type=account_type
    )
    if not inst.get("list"):
        raise ValueError(f"Symbol {symbol} not found")
    lot      = inst["list"][0]["lotSizeFilter"]
    min_qty  = float(lot["minOrderQty"])
    step_qty = float(lot["qtyStep"])
    raw_max  = lot.get("maxMktOrderQty")
    max_qty  = float(raw_max) if raw_max not in (None, "", 0, "0") else float("inf")

    qty = math.floor(raw_qty / step_qty) * step_qty
    qty = max(min_qty, qty)
    qty = min(max_qty, qty)
    
    # Round to avoid floating point precision issues (e.g., 1293.1000000000001 ‚Üí 1293.1)
    # Calculate decimals from step_qty (e.g., step 0.1 ‚Üí 1 decimal, step 0.01 ‚Üí 2 decimals)
    if step_qty >= 1:
        decimals = 0
    else:
        decimals = len(str(step_qty).split('.')[-1].rstrip('0'))
    qty = round(qty, decimals)

    if qty < min_qty:
        raise RuntimeError(f"qty < minOrderQty={min_qty}")
    if raw_qty > max_qty:
        logger.warning(
            f"raw_qty={raw_qty:.2f} > maxMktOrderQty={max_qty}, –∏—Å–ø–æ–ª—å–∑—É–µ–º {qty:.2f}"
        )
    
    logger.info(f"[calc_qty] uid={user_id} {symbol}: final_qty={qty:.4f} (min={min_qty}, step={step_qty})")

    return qty


async def _handle_calc_qty_error(
    bot,
    user_id: int, 
    symbol: str, 
    strategy: str, 
    error: Exception, 
    account_type: str, 
    t: dict
) -> None:
    """
    Handle calc_qty errors with daily notifications.
    Detects error type and sends user-friendly message once per day.
    """
    error_msg = str(error)
    
    # Detect error type
    if "Don't have USDT" in error_msg or "equity=0" in error_msg:
        # Zero balance error
        await notify_user_daily_error(
            bot, user_id, 
            DailyErrorType.ZERO_BALANCE, 
            account_type, t,
            {"symbol": symbol or "‚Äî", "strategy": (strategy or "‚Äî").upper()}
        )
    elif "API" in error_msg or "authentication" in error_msg.lower() or "401" in error_msg:
        # API keys error
        await notify_user_daily_error(
            bot, user_id, 
            DailyErrorType.API_KEYS_INVALID, 
            account_type, t
        )
    elif "timeout" in error_msg.lower() or "connection" in error_msg.lower():
        # Connection error
        await notify_user_daily_error(
            bot, user_id, 
            DailyErrorType.CONNECTION_ERROR, 
            account_type, t,
            {"exchange": "Bybit"}
        )
    # Log the error always
    logger.error(f"‚úñ calc_qty [uid={user_id}]: {error}")


async def handle_trade_error(
    bot,
    user_id: int,
    error: Exception,
    account_type: str,
    t: dict,
    strategy: str = None,
    symbol: str = None
) -> bool:
    """
    Handle trading errors with user-friendly notifications.
    Uses daily limit for repetitive errors (no spam!).
    Returns True if error was handled with user notification.
    """
    error_msg = str(error)
    
    # Zero balance error - send daily notification
    if "Don't have USDT" in error_msg or "equity=0" in error_msg or "equity <= 0" in error_msg:
        await notify_user_daily_error(
            bot, user_id, 
            DailyErrorType.ZERO_BALANCE, 
            account_type, t,
            {"symbol": symbol or "‚Äî", "strategy": (strategy or "‚Äî").upper()}
        )
        return True
    
    # Insufficient balance for this trade (margin locked in positions)
    if "INSUFFICIENT_BALANCE" in error_msg or "110007" in error_msg or "ab not enough" in error_msg.lower():
        # Get open positions count and equity for context
        try:
            positions = await fetch_open_positions(user_id, account_type=account_type)
            open_count = len(positions) if positions else 0
        except Exception:
            open_count = "?"
        
        try:
            equity = await fetch_usdt_balance(user_id, account_type=account_type, use_equity=True)
            equity_str = f"${equity:,.2f}"
        except Exception:
            equity_str = "‚Äî"
        
        await notify_user_daily_error(
            bot, user_id, 
            DailyErrorType.MARGIN_EXHAUSTED, 
            account_type, t,
            {
                "open_count": open_count,
                "symbol": symbol or "‚Äî",
                "strategy": (strategy or "‚Äî").upper(),
                "equity": equity_str,
            }
        )
        return True
    
    # API keys invalid
    if any(x in error_msg for x in ["API", "401", "403", "authentication", "Invalid API"]):
        await notify_user_daily_error(
            bot, user_id, 
            DailyErrorType.API_KEYS_INVALID, 
            account_type, t
        )
        return True
    
    # Connection errors
    if any(x in error_msg.lower() for x in ["timeout", "connection", "network", "unreachable"]):
        await notify_user_daily_error(
            bot, user_id, 
            DailyErrorType.CONNECTION_ERROR, 
            account_type, t,
            {"exchange": "Bybit"}
        )
        return True
    
    # Leverage errors - show immediately (not daily)
    if "110013" in error_msg or "cannot set leverage" in error_msg.lower() or "maxleverage" in error_msg.lower():
        match = re.search(r'maxLeverage\s*\[(\d+)\]', error_msg)
        max_lev = match.group(1) if match else "?"
        try:
            await bot.send_message(
                user_id,
                t.get('leverage_too_high_error', 
                    "‚ö†Ô∏è Leverage too high for {symbol}. Max allowed: {max_leverage}x"
                ).format(symbol=symbol or "this pair", max_leverage=max_lev),
                parse_mode="HTML"
            )
        except Exception:
            pass
        return True
    
    # Position limit exceeded - show immediately
    if "110090" in error_msg or "position limit exceeded" in error_msg.lower():
        try:
            await bot.send_message(
                user_id,
                t.get('position_limit_error',
                    "üõë Position limit exceeded for {symbol}. Reduce leverage or close some positions."
                ).format(strategy=strategy or "Unknown", symbol=symbol or "?"),
                parse_mode="HTML"
            )
        except Exception:
            pass
        return True
    
    # Notional too low (equity too small for any trade) - daily notification
    if "notional" in error_msg.lower() and "minimum" in error_msg.lower():
        await notify_user_daily_error(
            bot, user_id, 
            DailyErrorType.ZERO_BALANCE, 
            account_type, t,
            {"symbol": symbol or "‚Äî", "strategy": (strategy or "‚Äî").upper()}
        )
        return True
    
    # Unknown error - log only, no spam to user (once per user per 5 min)
    if once_per((user_id, "unhandled_trade_error", error_msg[:80]), 300):
        logger.warning(f"[{user_id}] Unhandled trade error: {error_msg}")
    return False


NUM = r'([0-9]+(?:[.,][0-9]+)?)'

def _tof(s: str) -> float:
    return float(s.replace(',', '.'))

def _to_mln(v: float, u: str) -> float:
    u = u.upper()
    if u == 'M':
        return round(v, 2)
    if u == 'K':
        return round(v / 1000.0, 2)
    return round(v, 2)

def _to_mln_ext(v: float, u: str, *, bare_is_units: bool = False) -> float:
    u = (u or '').strip().upper()
    if u == 'B':
        return round(v * 1000.0, 4)
    if u == 'M':
        return round(v, 4)
    if u == 'K':
        return round(v / 1000.0, 4)
    return round(v / 1_000_000.0, 6) if bare_is_units else round(v, 2)

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# SCRYPTOMERA SIGNAL PARSER
# Format: SCRIPTOMER SHORT SOLUSDT @ 189.45
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
BITK_RE_HDR = re.compile(r'^\s*SCRIPTOMER\s+(LONG|SHORT)\s+([A-Z0-9]+USDT)\s*@\s*([0-9]+(?:[.,][0-9]+)?)', re.I | re.M)

def is_bitk_signal(text: str) -> bool:
    """Check if message is Scryptomera signal by SCRIPTOMER keyword."""
    return bool(BITK_RE_HDR.search(text))

def parse_bitk_signal(text: str) -> dict | None:
    """
    Parse Scryptomera signal.
    Format: SCRIPTOMER SHORT SOLUSDT @ 189.45
    """
    m = BITK_RE_HDR.search(text)
    if not m:
        return None
    side = "Buy" if m.group(1).upper() == "LONG" else "Sell"
    symbol = m.group(2).upper()
    price = _tof(m.group(3))
    return {"symbol": symbol, "side": side, "price": price}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# RSI_BB SIGNAL PARSER
# Format: üü¢ LONG MERLUSDT\nüìä Score: 51% ‚≠ê C\nüìà (BB:15 RSI:12 Vol:0 OI:0)...
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
RSI_BB_RE_HDR = re.compile(r'^[üî¥üü¢]\s*(SHORT|LONG)\s+([A-Z0-9]+USDT)', re.I | re.M)
RSI_BB_RE_SCORE = re.compile(r'üìä\s*Score:\s*\d+%', re.I)
RSI_BB_RE_INDICATORS = re.compile(r'üìà\s*\(BB:\d+\s+RSI:\d+', re.I)
RSI_BB_RE_ENTRY = re.compile(r'üí≤\s*Entry:\s*([0-9]+(?:\.[0-9]+)?)', re.I)

def is_rsi_bb_signal(text: str) -> bool:
    """Check if message is RSI_BB signal by unique Score + BB + RSI pattern."""
    # RSI_BB format: emoji+SIDE+SYMBOL AND Score AND BB/RSI indicators
    return bool(RSI_BB_RE_HDR.search(text) and RSI_BB_RE_SCORE.search(text) and RSI_BB_RE_INDICATORS.search(text))

def parse_rsi_bb_signal(text: str) -> dict | None:
    """
    Parse RSI_BB signal.
    Format: üü¢ LONG MERLUSDT + üìä Score: 51% + üìà (BB:15 RSI:12...) + üí≤ Entry: 0.17049
    """
    if not is_rsi_bb_signal(text):
        return None
    
    m = RSI_BB_RE_HDR.search(text)
    if not m:
        return None
        
    side = "Buy" if m.group(1).upper() == "LONG" else "Sell"
    symbol = m.group(2).upper()
    
    # Get entry price from üí≤ Entry: line
    m_entry = RSI_BB_RE_ENTRY.search(text)
    price = _tof(m_entry.group(1)) if m_entry else None
    
    if price:
        return {"symbol": symbol, "side": side, "price": price}
    
    return None

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# SCALPER SIGNAL PARSER (NEW FORMAT)
# Format: SCALPER LONG BTCUSDT @ 95432.50
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
SCALPER_RE_HDR = re.compile(r'^\s*SCALPER\s+(LONG|SHORT)\s+([A-Z0-9]+USDT)\s*@\s*([0-9]+(?:[.,][0-9]+)?)', re.I | re.M)

def is_scalper_signal(text: str) -> bool:
    """Check if message is Scalper signal by unique SCALPER keyword."""
    return bool(SCALPER_RE_HDR.search(text))

def parse_scalper_signal(text: str) -> dict | None:
    """
    Parse Scalper signal.
    Format: SCALPER LONG BTCUSDT @ 95432.50
    """
    m = SCALPER_RE_HDR.search(text)
    if not m:
        return None
    side = "Buy" if m.group(1).upper() == "LONG" else "Sell"
    symbol = m.group(2).upper()
    price = _tof(m.group(3))
    return {"symbol": symbol, "side": side, "price": price}

# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
# OI SIGNAL PARSER (NEW FORMAT)
# Format: üéØ OI SIGNAL ‚≠êÔ∏è... with üöÄ SQUEEZE... ÔøΩ LONG BTCUSDT @ 95432.50
# ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
OI_SIGNAL_RE_HDR = re.compile(r'üéØ\s*OI\s+SIGNAL', re.I)
# Updated: also matches üü¢/üî¥ emojis which are used in real signals
OI_SIGNAL_RE_MAIN = re.compile(r'[üìàüìâüü¢üî¥]\s*(LONG|SHORT)\s+([A-Z0-9]+USDT)\s*@\s*([0-9]+(?:[.,][0-9]+)?)', re.I)
OI_SIGNAL_RE_OI_CHANGE = re.compile(r'OI\s*:\s*([+\-]?[0-9]+(?:[.,][0-9]+)?)%', re.I)
OI_SIGNAL_RE_SCORE = re.compile(r'Score\s*:\s*([0-9]+(?:[.,][0-9]+)?)', re.I)

def is_oi_signal(text: str) -> bool:
    """Check if message is OI Signal by unique üéØ OI SIGNAL header."""
    return bool(OI_SIGNAL_RE_HDR.search(text))

def parse_oi_signal(text: str) -> dict | None:
    """
    Parse OI Signal.
    Format:
        üéØ OI SIGNAL ‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è‚≠êÔ∏è
        üöÄ SQUEEZE (–°–∫–≤–∏–∑ —à–æ—Ä—Ç–æ–≤)
        üìà LONG BTCUSDT @ 95432.50
        üìä OI: +5.23% | Vol z=2.1 | CVD z=1.8
        üéØ Score: 4.2
    """
    if not is_oi_signal(text):
        return None
    
    m = OI_SIGNAL_RE_MAIN.search(text)
    if not m:
        return None
    
    side = "Buy" if m.group(1).upper() == "LONG" else "Sell"
    symbol = m.group(2).upper()
    price = _tof(m.group(3))
    
    # Parse OI change percentage
    oi_chg = None
    oi_m = OI_SIGNAL_RE_OI_CHANGE.search(text)
    if oi_m:
        oi_chg = _tof(oi_m.group(1))
    
    # Parse score
    score = None
    score_m = OI_SIGNAL_RE_SCORE.search(text)
    if score_m:
        score = _tof(score_m.group(1))
    
    # Calculate oi_prev and oi_now from oi_chg (we use dummy values for compatibility)
    # The actual OI values don't matter, only the change percentage matters for trigger
    oi_now = 100.0  # Dummy base
    oi_prev = oi_now / (1 + oi_chg / 100) if oi_chg and abs(oi_chg) > 0.01 else oi_now
    
    return {
        "symbol": symbol,
        "side": side,
        "price": price,
        "oi_prev": oi_prev,
        "oi_now": oi_now,
        "oi_chg": oi_chg,
        "score": score,
    }

# --- Enliko parser (new format) ---
# Header: "Enliko" on first line (optional - can detect by structure)
ELCARO_RE_HDR = re.compile(r'^Elcaro\s*$', re.I | re.M)
# Symbol line: üîî FILUSDT üìâ SHORT or üîî BTCUSDT üìà LONG or üîî XRPUSDT üìâ SHORT üü¢‚ö™Ô∏è‚ö™Ô∏è
# More flexible pattern - allows emojis and extra characters between symbol and side
ELCARO_RE_MAIN = re.compile(r'üîî\s*([A-Z0-9]+(?:USDT|USDC)?)\s*[üìâüìàüîªüî∫]*\s*(LONG|SHORT)', re.I)
# Timeframe and leverage: ‚è±Ô∏è 60 | üéö 68  OR  ‚è±Ô∏è 5 | üéö 62
ELCARO_RE_TF_LEV = re.compile(r'‚è±Ô∏è\s*(\d+)\s*\|\s*üéö\s*(\d+)', re.I)
# Entry price: üí∞ Entry: 1.253000 (also handle commas in prices)
ELCARO_RE_ENTRY = re.compile(r'üí∞\s*Entry\s*[:Ôºö]\s*' + NUM, re.I)
# SL: üõë SL: 1.281500 (2.27%) [ATR] - make the bracket part optional
ELCARO_RE_SL = re.compile(r'üõë\s*SL\s*[:Ôºö]\s*' + NUM + r'\s*\((' + NUM + r')%\)', re.I)
# TP: üéØ TP: 1.215000 (3.03%) [AGG] - make the bracket part optional
ELCARO_RE_TP = re.compile(r'üéØ\s*TP\s*[:Ôºö]\s*' + NUM + r'\s*\((' + NUM + r')%\)', re.I)
# ATR line: üìâ ATR: 14 | √ó1.5 | Trigger: 30%
# Note: NUM already has capture group, so we use indices 1, 2, 4 for periods, mult, trigger
ELCARO_RE_ATR = re.compile(r'üìâ\s*ATR\s*[:Ôºö]\s*(\d+)\s*\|\s*[√óx]' + NUM + r'\s*\|\s*Trigger\s*[:Ôºö]\s*' + NUM + r'%', re.I)
# RR line: üìä RR: 5.0:1 | ATR Exit: ‚úÖ
ELCARO_RE_RR = re.compile(r'üìä\s*RR\s*[:Ôºö]\s*' + NUM + r'\s*:\s*1', re.I)
# ATR Exit marker: ATR Exit: ‚úÖ
ELCARO_RE_ATR_EXIT = re.compile(r'ATR\s*Exit\s*[:Ôºö]\s*[‚úÖ‚úì]', re.I)

def is_elcaro_signal(text: str) -> bool:
    """Check if message is Enliko signal - by header OR by structure."""
    # Has explicit header
    if ELCARO_RE_HDR.search(text):
        return True
    # Detect by structure: has üîî SYMBOL, Entry, SL with %, TP with %
    # ATR Exit marker is optional now (more flexible detection)
    has_main = bool(ELCARO_RE_MAIN.search(text))
    has_entry = bool(ELCARO_RE_ENTRY.search(text))
    has_sl = bool(ELCARO_RE_SL.search(text))
    has_tp = bool(ELCARO_RE_TP.search(text))
    has_atr = bool(ELCARO_RE_ATR.search(text))
    has_atr_exit = bool(ELCARO_RE_ATR_EXIT.search(text))
    has_tf_lev = bool(ELCARO_RE_TF_LEV.search(text))
    
    # Core detection: üîî SYMBOL + Entry + SL% + TP%
    core_match = has_main and has_entry and has_sl and has_tp
    
    # Additional indicators that strengthen the match
    has_additional = has_atr_exit or has_atr or has_tf_lev
    
    # If core match and at least one additional indicator, it's Enliko
    return core_match and has_additional

def parse_elcaro_signal(text: str) -> dict | None:
    """
    –ü–∞—Ä—Å–∏—Ç —Å–∏–≥–Ω–∞–ª –æ—Ç Enliko (–Ω–æ–≤—ã–π —Ñ–æ—Ä–º–∞—Ç —Å ATR –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏).
    
    –§–æ—Ä–º–∞—Ç:
        üîî XRPUSDT üìâ SHORT üü¢‚ö™Ô∏è‚ö™Ô∏è
        ‚è±Ô∏è 5 | üéö 62
        
        üí∞ Entry: 1.858300
        üõë SL: 1.865350 (0.38%) [OB]
        üéØ TP: 1.848900 (0.51%) [AGG]
        
        üìä RR: 5.0:1 | ATR Exit: ‚úÖ
        üìâ ATR: 14 | √ó1.0 | Trigger: 30%
    
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å–ª–æ–≤–∞—Ä—å —Å–æ –≤—Å–µ–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏.
    """
    if not is_elcaro_signal(text):
        return None
    
    m_main = ELCARO_RE_MAIN.search(text)
    m_entry = ELCARO_RE_ENTRY.search(text)
    
    if not (m_main and m_entry):
        return None
    
    symbol = m_main.group(1).upper()
    side = "Buy" if m_main.group(2).upper() == "LONG" else "Sell"
    entry_price = _tof(m_entry.group(1))
    
    result = {
        "symbol": symbol,
        "side": side,
        "price": entry_price,
        "entry": entry_price,  # Explicit entry price for limit orders
        "elcaro_mode": True,  # Flag for special Enliko handling
    }
    
    # Timeframe and leverage
    m_tf_lev = ELCARO_RE_TF_LEV.search(text)
    if m_tf_lev:
        result["timeframe"] = m_tf_lev.group(1) + "m"  # e.g. "60m"
        result["leverage"] = int(m_tf_lev.group(2))
    
    # SL with percentage
    m_sl = ELCARO_RE_SL.search(text)
    if m_sl:
        result["sl"] = _tof(m_sl.group(1))
        result["sl_pct"] = _tof(m_sl.group(2))
    
    # TP with percentage  
    m_tp = ELCARO_RE_TP.search(text)
    if m_tp:
        result["tp"] = _tof(m_tp.group(1))
        result["tp_pct"] = _tof(m_tp.group(2))
    
    # ATR parameters: periods, multiplier, trigger
    m_atr = ELCARO_RE_ATR.search(text)
    if m_atr:
        result["atr_periods"] = int(m_atr.group(1))
        result["atr_multiplier"] = _tof(m_atr.group(2))
        result["atr_trigger_pct"] = _tof(m_atr.group(3))
    
    # RR
    m_rr = ELCARO_RE_RR.search(text)
    if m_rr:
        result["rr"] = _tof(m_rr.group(1))
    
    return result


# --- Fibonacci Extension Strategy Parser ---
# Header: üìä FIBONACCI EXTENSION STRATEGY
FIBO_RE_HDR = re.compile(r'üìä\s*FIBONACCI\s+EXTENSION\s+STRATEGY', re.I)
# Symbol: ü™ô BTCUSDT | ... (price is optional, can be '‚Äî' or empty)
FIBO_RE_SYMBOL = re.compile(r'ü™ô\s*([A-Z0-9]+USDT)', re.I)
# Optional price after symbol: | $97,500.00 or | 97500.00
FIBO_RE_SYMBOL_PRICE = re.compile(r'ü™ô\s*[A-Z0-9]+USDT\s*\|\s*[$]?([\d,]+(?:\.\d+)?)', re.I)
# Direction: üìà LONG or üìâ SHORT
FIBO_RE_SIDE = re.compile(r'[üìàüìâ]\s*(LONG|SHORT)', re.I)
# Entry Zone: üéØ Entry Zone: 96,800.0000 ‚Äì 97,200.0000
FIBO_RE_ENTRY = re.compile(r'üéØ\s*Entry\s+Zone\s*[:Ôºö]\s*([\d,]+(?:\.\d+)?)\s*[‚Äì-]\s*([\d,]+(?:\.\d+)?)', re.I)
# Stop Loss: üõë Stop Loss: 95,500.0000
FIBO_RE_SL = re.compile(r'üõë\s*Stop\s+Loss\s*[:Ôºö]\s*([\d,]+(?:\.\d+)?)', re.I)
# Target: ‚úÖ Target 1: 99,000.0000
FIBO_RE_TP = re.compile(r'‚úÖ\s*Target\s*\d*\s*[:Ôºö]\s*([\d,]+(?:\.\d+)?)', re.I)
# Trigger info: ‚ö° Trigger: Spring detected + Price in 141.4%-161.8% zone
FIBO_RE_TRIGGER = re.compile(r'‚ö°\s*Trigger\s*[:Ôºö]\s*(.+)', re.I)
# Quality: üü¢ Quality: A (85/100) or üü° Quality: B+ (64/100) or ‚ö™ Quality: B (50/100)
FIBO_RE_QUALITY = re.compile(r'[üü¢üü°üü†‚ö™üî¥]\s*Quality\s*[:Ôºö]\s*([A-Z]\+?)\s*\((\d+)/\d+\)', re.I)


def is_fibonacci_signal(text: str) -> bool:
    """Check if message is Fibonacci Extension signal."""
    return bool(FIBO_RE_HDR.search(text))


def parse_fibonacci_signal(text: str) -> dict | None:
    """
    Parse Fibonacci Extension strategy signal.
    
    Format:
        üìä FIBONACCI EXTENSION STRATEGY

        ü™ô BTCUSDT | $97,500.00 (price can be '‚Äî' or missing)
        üìà LONG

        üéØ Entry Zone: 96,800.0000 ‚Äì 97,200.0000
        üõë Stop Loss: 95,500.0000
        ‚úÖ Target 1: 99,000.0000

        ‚ö° Trigger: Price in 141.4%-161.8% zone
        üü¢ Quality: A (85/100)
    
    Returns dict with all trading parameters.
    """
    if not is_fibonacci_signal(text):
        return None
    
    m_symbol = FIBO_RE_SYMBOL.search(text)
    m_side = FIBO_RE_SIDE.search(text)
    
    if not (m_symbol and m_side):
        return None
    
    symbol = m_symbol.group(1).upper()
    side = "Buy" if m_side.group(1).upper() == "LONG" else "Sell"
    
    # Try to get price from header (optional)
    m_price = FIBO_RE_SYMBOL_PRICE.search(text)
    current_price = None
    if m_price:
        current_price = _tof(m_price.group(1).replace(",", ""))
    
    result = {
        "symbol": symbol,
        "side": side,
        "fibonacci_mode": True,  # Flag for special Fibonacci handling
    }
    
    # Entry zone (for limit order range)
    m_entry = FIBO_RE_ENTRY.search(text)
    if m_entry:
        entry_low = _tof(m_entry.group(1).replace(",", ""))
        entry_high = _tof(m_entry.group(2).replace(",", ""))
        result["entry_low"] = entry_low
        result["entry_high"] = entry_high
        result["entry"] = (entry_low + entry_high) / 2  # Mid point for entry
        # If no price in header, use entry mid point
        if current_price is None:
            current_price = result["entry"]
    
    result["price"] = current_price
    
    # Stop Loss
    m_sl = FIBO_RE_SL.search(text)
    if m_sl:
        sl_price = _tof(m_sl.group(1).replace(",", ""))
        result["sl"] = sl_price
        # Calculate SL percentage
        if result.get("entry"):
            sl_pct = abs(result["entry"] - sl_price) / result["entry"] * 100
            result["sl_pct"] = round(sl_pct, 2)
    
    # Target (TP)
    m_tp = FIBO_RE_TP.search(text)
    if m_tp:
        tp_price = _tof(m_tp.group(1).replace(",", ""))
        result["tp"] = tp_price
        # Calculate TP percentage
        if result.get("entry"):
            tp_pct = abs(tp_price - result["entry"]) / result["entry"] * 100
            result["tp_pct"] = round(tp_pct, 2)
    
    # Trigger info
    m_trigger = FIBO_RE_TRIGGER.search(text)
    if m_trigger:
        result["trigger_info"] = m_trigger.group(1).strip()
    
    # Quality score
    m_quality = FIBO_RE_QUALITY.search(text)
    if m_quality:
        result["quality_grade"] = m_quality.group(1)
        result["quality_score"] = int(m_quality.group(2))
    
    return result


def parse_signal(txt: str) -> dict:
    tf_m    = re.search(r'(?:^|\n)\s*[^A-Za-z0-9_]*(?:TF|Timeframe)\s*[:=Ôºö]\s*([0-9]+[mhdD])', txt, re.I)
    side_m  = re.search(r'(?:^|\n).*?\b(LONG|SHORT|BUY|SELL|UP|DOWN)\b', txt, re.I)
    sym_m   = re.search(r'\b([A-Z0-9]{2,}USDT)\b', txt, re.I)
    price_m = re.search(r'(?:^|\n)\s*[^A-Za-z0-9_]*(?:Price|Px|Entry)\s*[:=]\s*' + NUM, txt, re.I)

    if not price_m and sym_m:
        start = max(0, sym_m.start() - 160)
        window = txt[start:sym_m.end() + 320]
        cand = re.findall(NUM, window)
        cand = [c for c in cand if ('.' in c or ',' in c)]
        if cand:
            class _Dummy:
                def group(self, i): return cand[0]
            price_m = _Dummy()

    oi_prev = oi_now = oi_chg = None
    
    # NEW FORMAT: PRE-ALERT signals with "OI Total: 74.88M (+794.75%, z=295.1)"
    # Format: OI Total: VALUE (+CHANGE%, z=SCORE)
    prealert_oi_match = re.search(
        r'OI\s+Total\s*:\s*([0-9]+(?:[.,][0-9]+)?)\s*([kKmMbB]?)\s*\(\s*([+\-]?[0-9]+(?:[.,][0-9]+)?)%',
        txt
    )
    if prealert_oi_match:
        # Parse OI value and change from PRE-ALERT format
        oi_val = _tof(prealert_oi_match.group(1))
        oi_unit = (prealert_oi_match.group(2) or '').upper()
        oi_chg = _tof(prealert_oi_match.group(3))
        
        oi_now = _to_mln_ext(oi_val, oi_unit, bare_is_units=True)
        # Calculate oi_prev from oi_now and oi_chg
        if oi_chg and abs(oi_chg) > 0.01:
            oi_prev = oi_now / (1 + oi_chg / 100)
        else:
            oi_prev = oi_now
        logger.debug(f"PRE-ALERT OI parsed: now={oi_now}M, prev={oi_prev:.4f}M, chg={oi_chg}%")
    else:
        # LEGACY FORMAT: Two separate OI lines
        oi_lines = [m.group(0) for m in re.finditer(
            r'(?im)^[^\n\r]*(?:\bOI\b|\bOpen\s+Interest\b)[^\n\r]*$', txt)]

        def _oi(line: str):
            norm = line.replace('\u00A0', ' ').replace('\u202F', ' ')
            m = re.search(r'([0-9]+(?:[.,][0-9]+)?)\s*([kKmMbB]?)', norm)
            if not m:
                return (None, None)
            v  = _tof(m.group(1))
            su = (m.group(2) or '').upper()  
            return (v, su or '')

        if oi_lines:
            v, u = _oi(oi_lines[0])
            if v is not None:
                oi_prev = _to_mln_ext(v, u, bare_is_units=True)
        if len(oi_lines) >= 2:
            v, u = _oi(oi_lines[1])
            if v is not None:
                oi_now = _to_mln_ext(v, u, bare_is_units=True)
        if oi_prev not in (None, 0) and oi_now is not None:
            oi_chg = round((oi_now - oi_prev) / oi_prev * 100, 2)

    vol_from = vol_to = None
    arrow_re = r'(?:‚Üí|->|=>)'
    vol_line = None
    for ln in txt.splitlines():
        if re.search(r'\b(Vol|Volume)\b', ln, re.I) or re.search(arrow_re, ln):
            if re.search(NUM + r'\s*([MK]).+?' + arrow_re + r'.+?' + NUM + r'\s*([MK])', ln):
                vol_line = ln
                break
    if vol_line:
        m = re.search(NUM + r'\s*([MK]).+?' + arrow_re + r'.+?' + NUM + r'\s*([MK])', vol_line)
        if m:
            v1, u1, v2, u2 = m.group(1), m.group(2), m.group(3), m.group(4)
            vol_from = _to_mln(_tof(v1), u1)
            vol_to   = _to_mln(_tof(v2), u2)

    price_chg_m = re.search(r'([+\-]?[0-9]+(?:[.,][0-9]+)?)\s*%', txt)
    vol_delta_m = re.search(r'\bV[^:\n\r]*[:=]\s*([+\-]?[0-9]+(?:[.,][0-9]+)?)', txt, re.I)
    rsi_m       = re.search(r'\bRSI(?:\s*\(p?\d+\))?\s*[:=]?\s*' + NUM, txt, re.I)

    bb_hi = bb_lo = None
    bb_vals = []
    for ln in txt.splitlines():
        if 'BB' in ln:
            for m in re.finditer(NUM, ln):
                bb_vals.append(_tof(m.group(1)))
    if bb_vals:
        bb_hi = max(bb_vals)
        bb_lo = min(bb_vals)

    return {
        "tf":         tf_m.group(1)            if tf_m    else None,
        "side":       side_m.group(1).upper()  if side_m  else None,
        "symbol":     sym_m.group(1).upper()   if sym_m   else None,
        "price":      _tof(price_m.group(1))   if price_m else None,
        "oi_prev":    oi_prev,
        "oi_now":     oi_now,
        "oi_chg":     oi_chg,
        "vol_from":   vol_from,
        "vol_to":     vol_to,
        "price_chg":  _tof(price_chg_m.group(1)) if price_chg_m else None,
        "vol_delta":  _tof(vol_delta_m.group(1)) if vol_delta_m else None,
        "rsi":        _tof(rsi_m.group(1))       if rsi_m else None,
        "bb_hi":      bb_hi,
        "bb_lo":      bb_lo,
    }

@log_calls
async def on_channel_post(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    logger.info(f"üì® Received channel post from chat_id={update.channel_post.chat_id if update.channel_post else 'None'}")
    try:
        ch_id = update.channel_post.chat_id
    except Exception:
        logger.warning("Channel post has no chat_id")
        return
    if SIGNAL_CHANNEL_IDS and ch_id not in SIGNAL_CHANNEL_IDS:
        logger.debug(f"Skip channel {ch_id} (not in allowlist)")
        return

    txt = (update.channel_post.text or update.channel_post.caption or "")
    logger.info(f"üìù Channel post text (first 200 chars): {txt[:200]!r}")
    if not txt.strip():
        logger.warning("Channel post has empty text/caption ‚Äî skip")
        return

    parsed_bitk = parse_bitk_signal(txt)
    is_bitk = parsed_bitk is not None
    
    # NEW: Parse RSI_BB signal - MUST be before Scryptomera check
    parsed_rsi_bb = parse_rsi_bb_signal(txt)
    is_rsi_bb = parsed_rsi_bb is not None
    
    parsed_scalper = parse_scalper_signal(txt)
    is_scalper = parsed_scalper is not None
    
    parsed_elcaro = parse_elcaro_signal(txt)
    is_elcaro = parsed_elcaro is not None
    
    parsed_fibonacci = parse_fibonacci_signal(txt)
    is_fibonacci = parsed_fibonacci is not None
    
    # NEW: Parse OI signal with new unique format
    parsed_oi = parse_oi_signal(txt)
    is_oi = parsed_oi is not None
    
    logger.debug(f"Raw signal (bitk={is_bitk}, rsi_bb={is_rsi_bb}, scalper={is_scalper}, elcaro={is_elcaro}, fibonacci={is_fibonacci}, oi={is_oi}): {txt!r}")

    parsed = parse_signal(txt)
    
    # Override parsed with specific parser data to ensure symbol is saved correctly
    # RSI_BB must be checked FIRST to prevent Scryptomera from catching it
    if is_rsi_bb and parsed_rsi_bb:
        parsed["symbol"] = parsed_rsi_bb.get("symbol")
        parsed["side"] = parsed_rsi_bb.get("side")
        parsed["price"] = parsed_rsi_bb.get("price")
    elif is_bitk and parsed_bitk:
        parsed["symbol"] = parsed_bitk.get("symbol")
        parsed["side"] = parsed_bitk.get("side")
        parsed["price"] = parsed_bitk.get("price")
    elif is_scalper and parsed_scalper:
        parsed["symbol"] = parsed_scalper.get("symbol")
        parsed["side"] = parsed_scalper.get("side")
        parsed["price"] = parsed_scalper.get("price")
    elif is_elcaro and parsed_elcaro:
        parsed["symbol"] = parsed_elcaro.get("symbol")
        parsed["side"] = parsed_elcaro.get("side")
        parsed["price"] = parsed_elcaro.get("price")
    elif is_fibonacci and parsed_fibonacci:
        parsed["symbol"] = parsed_fibonacci.get("symbol")
        parsed["side"] = parsed_fibonacci.get("side")
        parsed["price"] = parsed_fibonacci.get("price")
    elif is_oi and parsed_oi:
        parsed["symbol"] = parsed_oi.get("symbol")
        parsed["side"] = parsed_oi.get("side")
        parsed["price"] = parsed_oi.get("price")
        parsed["oi_prev"] = parsed_oi.get("oi_prev")
        parsed["oi_now"] = parsed_oi.get("oi_now")
        parsed["oi_chg"] = parsed_oi.get("oi_chg")
    
    # CRITICAL FIX: Skip non-signal messages (info messages from Fibo Bot etc)
    # Both symbol AND side are required for a valid trading signal
    # Messages with only symbol but no side (like "ü™ô AAVEUSDT üí≠ –ñ–¥—É –õ–û–ù–ì") are status updates, not signals
    if not parsed.get("symbol") or not parsed.get("side"):
        logger.info(f"Skip non-signal message (missing symbol or side): {txt[:100]!r}")
        return
    
    try:
        signal_id = db.add_signal(
            raw_data    = txt,  # Column is 'raw_data' in DB
            timeframe   = parsed.get("tf"),  # Column is 'timeframe' in DB
            side        = parsed.get("side"),
            symbol      = parsed.get("symbol"),
            price       = parsed.get("price"),
            oi_prev     = parsed.get("oi_prev"),
            oi_now      = parsed.get("oi_now"),
            oi_chg      = parsed.get("oi_chg"),
            vol_from    = parsed.get("vol_from"),
            vol_to      = parsed.get("vol_to"),
            price_chg   = parsed.get("price_chg"),
            vol_delta   = parsed.get("vol_delta"),
            rsi         = parsed.get("rsi"),
            bb_hi       = parsed.get("bb_hi"),
            bb_lo       = parsed.get("bb_lo"),
        )
    except Exception as e:
        logger.error(f"add_signal failed: {e}", exc_info=True)
        signal_id = None

    timeframe = parsed.get("tf") or "24h"

    try:
        # RSI_BB must be checked FIRST to prevent Scryptomera from catching it
        if is_rsi_bb:
            symbol     = parsed_rsi_bb["symbol"]
            side       = parsed_rsi_bb["side"]
            spot_price = float(parsed_rsi_bb["price"])
        elif is_bitk:
            symbol     = parsed_bitk["symbol"]
            side       = parsed_bitk["side"]
            spot_price = float(parsed_bitk["price"])
        elif is_scalper:
            symbol     = parsed_scalper["symbol"]
            side       = parsed_scalper["side"]
            spot_price = float(parsed_scalper["price"])
        elif is_elcaro:
            symbol     = parsed_elcaro["symbol"]
            side       = parsed_elcaro["side"]
            spot_price = float(parsed_elcaro["price"])
        elif is_fibonacci:
            symbol     = parsed_fibonacci["symbol"]
            side       = parsed_fibonacci["side"]
            spot_price = float(parsed_fibonacci["price"])
        elif is_oi:
            symbol     = parsed_oi["symbol"]
            side       = parsed_oi["side"]
            spot_price = float(parsed_oi["price"])
        else:
            side_txt = (parsed.get("side") or "").upper()
            if side_txt in ("LONG", "UP"):
                side = "Buy"
            elif side_txt in ("SHORT", "DOWN", "SELL"):
                side = "Sell"
            else:
                m_tr = re.search(r'\b(LONG|SHORT|UP|DOWN|BUY|SELL)\b', txt, re.I)
                if not m_tr:
                    logger.info(f"Non-trading message (no side): {txt[:100]!r}")
                    return
                raw_side = m_tr.group(1).upper()
                side = "Buy" if raw_side in ("LONG", "UP", "BUY") else "Sell"

            symbol = (parsed.get("symbol") or "").upper()
            price  = parsed.get("price")
            if not symbol or price is None:
                m_sym = re.search(r'\b([A-Z0-9]+USDT)\b.*?(?:Price|Px|Entry)\s*[:=]\s*([0-9]+(?:\.[0-9]+)?)', txt, re.I | re.S)
                if not m_sym:
                    logger.warning("Symbol/price not found ‚Äî skip")
                    return
                symbol, price = m_sym.group(1).upper(), float(m_sym.group(2))
            spot_price = float(price)
    except Exception as e:
        logger.error(f"Parse symbol/side/price failed: {e}", exc_info=True)
        return

    if symbol in BLACKLIST:
        logger.info(f"Skipping blacklisted symbol: {symbol}")
        return

    rsi_val = parsed.get("rsi")
    bb_hi   = parsed.get("bb_hi")
    bb_lo   = parsed.get("bb_lo")
    oi_prev = parsed.get("oi_prev")
    oi_now  = parsed.get("oi_now")

    liq_price_buy  = round(spot_price * 0.98, 6)
    liq_price_sell = round(spot_price * 1.02, 6)

    for uid in get_all_users():
        try:
            if GLOBAL_PAUSED:
                continue

            cfg  = get_user_config(uid) or {}
            lang = cfg.get("lang", DEFAULT_LANG)
            t    = LANGS.get(lang, LANGS[DEFAULT_LANG])
            
            # Check if user has API keys configured - skip silently if not
            api_key, api_secret = get_user_credentials(uid)
            if not api_key or not api_secret:
                # User doesn't have API keys - skip without spamming logs
                continue

            # Check trading limits silently - no spam, just skip if at max
            can_trade, _ = await check_trading_limits_user(uid, t)
            if not can_trade:
                # Notify only once per hour
                if once_per((uid, "positions_limit", ""), 3600):
                    try:
                        await ctx.bot.send_message(
                            uid, 
                            t.get('max_positions_reached', "‚ö†Ô∏è Maximum positions reached. New signals will be skipped until a position closes.")
                        )
                    except Exception:
                        pass
                continue

            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            # PER-EXCHANGE position check: skip only if position exists on ALL
            # target exchanges. If position on exchange A, still allow opening on B.
            # place_order_for_targets() has additional per-target checks (line ~8213).
            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
            all_db_positions = db.get_active_positions(uid)  # ALL exchanges
            exchanges_with_position = {
                p.get("exchange", "bybit")
                for p in all_db_positions
                if p.get("symbol") == symbol
            }

            user_exchange = get_exchange_type(uid)

            # Determine which exchanges user can trade on
            user_target_exchanges = set()
            if db.is_bybit_enabled(uid):
                user_target_exchanges.add("bybit")
            if db.is_hl_enabled(uid):
                user_target_exchanges.add("hyperliquid")
            if not user_target_exchanges:
                user_target_exchanges.add(user_exchange or "bybit")

            # Only skip if position exists on ALL user's target exchanges
            if user_target_exchanges and user_target_exchanges.issubset(exchanges_with_position):
                logger.info(f"[{uid}] {symbol}: already has open position on all exchanges ({', '.join(exchanges_with_position)}) ‚Üí skip signal")
                continue
            elif exchanges_with_position:
                logger.info(f"[{uid}] {symbol}: position on {', '.join(exchanges_with_position)}, continuing for other exchanges")

            # CRITICAL: Check if position was recently closed (prevent re-entry on repeated signals)
            # This handles cases where strategies like FIBONACCI send repeated signals
            if was_position_recently_closed(uid, symbol, spot_price, seconds=120, exchange=user_exchange):
                logger.info(f"[{uid}] {symbol}: position was recently closed at similar price ‚Üí skip signal")
                continue

            existing_orders = await fetch_open_orders(uid, symbol)
            if existing_orders:
                logger.info(f"[{uid}] {symbol}: has active order(s) ‚Üí skip signal")
                continue

            pending = get_pending_limit_orders(uid, exchange=user_exchange)
            if any(po.get("symbol") == symbol for po in pending):
                logger.info(f"[{uid}] {symbol}: pending limit order in DB ‚Üí skip signal")
                continue

            # Global coins filter (used as fallback if strategy doesn't have own setting)
            global_coins_mode = cfg.get("coins", "ALL")
            global_coins_mode = global_coins_mode.upper() if isinstance(global_coins_mode, str) else "ALL"

            if not any(p.get("symbol") == symbol for p in all_db_positions):
                reset_pyramid(uid, symbol)

            cnt = get_pyramid(uid, symbol)["count"]
            if cnt > 0:
                logger.info(f"[{uid}] {symbol}: pyramid count={cnt} ‚Üí skip signal")
                continue

            limit_enabled = bool(cfg.get("limit_enabled", 0))  # Legacy, kept for compatibility
            use_atr       = bool(cfg.get("use_atr", 0))

            # RSI_BB now uses its own parser flag instead of just checking parsed values
            rsi_bb_trigger  = (cfg.get("trade_rsi_bb", 0) and is_rsi_bb)
            bitk_trigger    = (cfg.get("trade_scryptomera", 0) and is_bitk)
            scalper_trigger = (cfg.get("trade_scalper", 0) and is_scalper)
            elcaro_trigger  = (cfg.get("trade_elcaro", 0) and is_elcaro)
            fibonacci_trigger = (cfg.get("trade_fibonacci", 0) and is_fibonacci)
            oi_trigger      = (cfg.get("trade_oi", 0) and is_oi)  # NEW: Use is_oi flag from new parser
            
            # Log strategy triggers for debugging
            if is_rsi_bb:
                logger.info(f"[{uid}] RSI_BB signal detected: trade_rsi_bb={cfg.get('trade_rsi_bb', 0)}, rsi_bb_trigger={rsi_bb_trigger}, symbol={symbol}")
            if is_bitk:
                logger.info(f"[{uid}] Scryptomera signal detected: trade_scryptomera={cfg.get('trade_scryptomera', 0)}, bitk_trigger={bitk_trigger}, symbol={symbol}")
            if is_scalper:
                logger.info(f"[{uid}] Scalper signal detected: trade_scalper={cfg.get('trade_scalper', 0)}, scalper_trigger={scalper_trigger}, symbol={symbol}")
            if is_fibonacci:
                logger.info(f"[{uid}] Fibonacci signal detected: trade_fibonacci={cfg.get('trade_fibonacci', 0)}, fibonacci_trigger={fibonacci_trigger}")
            if is_oi:
                logger.info(f"[{uid}] OI signal detected: trade_oi={cfg.get('trade_oi', 0)}, oi_trigger={oi_trigger}, symbol={symbol}, oi_chg={parsed.get('oi_chg')}%")

            # Get user's trading context for settings lookup
            user_context = get_user_trading_context(uid)
            ctx_exchange = user_context["exchange"]
            ctx_account_type = user_context["account_type"]

            # Get coins filter from exchange settings (simplified - Feb 10, 2026)
            # Instead of per-strategy, we now use per-exchange coins_group
            exchange_coins_field = "bybit_coins_group" if ctx_exchange == "bybit" else "hl_coins_group"
            exchange_coins_group = db.get_user_field(uid, exchange_coins_field) or "ALL"
            
            # Helper to check coins filter (uses exchange-level setting)
            def check_coins_filter(strat_name: str) -> bool:
                # Use exchange-level coins_group (simplified from per-strategy)
                filter_fn = SYMBOL_FILTER.get(exchange_coins_group, SYMBOL_FILTER["ALL"])
                if not filter_fn(symbol):
                    # Log on INFO level so admins can see why signals are skipped
                    logger.info(f"[{uid}] {symbol}: filtered by {ctx_exchange} coins_group={exchange_coins_group} ‚Üí skip signal")
                    return False
                return True

            # Apply coins filter per strategy
            if rsi_bb_trigger and not check_coins_filter("rsi_bb"):
                rsi_bb_trigger = False
            if bitk_trigger and not check_coins_filter("scryptomera"):
                bitk_trigger = False
            if scalper_trigger and not check_coins_filter("scalper"):
                scalper_trigger = False
            if elcaro_trigger and not check_coins_filter("elcaro"):
                elcaro_trigger = False
            if fibonacci_trigger and not check_coins_filter("fibonacci"):
                fibonacci_trigger = False
            if oi_trigger and not check_coins_filter("oi"):
                oi_trigger = False

            # Check Scryptomera enabled + direction filter
            if bitk_trigger:
                scrypto_settings = db.get_strategy_settings(uid, "scryptomera", ctx_exchange, ctx_account_type)
                signal_direction = "long" if side == "Buy" else "short"
                
                # CRITICAL: Check if this side is enabled
                side_enabled_key = f"{signal_direction}_enabled"
                side_enabled = scrypto_settings.get(side_enabled_key, True)
                logger.info(f"[{uid}] Scryptomera enabled check: {side_enabled_key}={side_enabled}")
                
                if not side_enabled:
                    logger.info(f"[{uid}] {symbol}: Scryptomera {signal_direction.upper()} disabled ‚Üí skip")
                    bitk_trigger = False
                else:
                    # Check direction filter
                    scrypto_direction = scrypto_settings.get("direction", "all")
                    logger.info(f"[{uid}] Scryptomera direction check: signal={signal_direction}, allowed={scrypto_direction}")
                    
                    if scrypto_direction != "all" and scrypto_direction != signal_direction:
                        logger.info(f"[{uid}] {symbol}: Scryptomera direction filter - signal={signal_direction}, allowed={scrypto_direction} ‚Üí skip")
                        bitk_trigger = False
                    else:
                        logger.info(f"[{uid}] Scryptomera {signal_direction.upper()} OK, proceeding with {symbol}")

            # Check Scalper enabled + direction filter
            if scalper_trigger:
                scalper_settings = db.get_strategy_settings(uid, "scalper", ctx_exchange, ctx_account_type)
                signal_direction = "long" if side == "Buy" else "short"
                
                # CRITICAL: Check if this side is enabled
                side_enabled_key = f"{signal_direction}_enabled"
                side_enabled = scalper_settings.get(side_enabled_key, True)
                logger.info(f"[{uid}] Scalper enabled check: {side_enabled_key}={side_enabled}")
                
                if not side_enabled:
                    logger.info(f"[{uid}] {symbol}: Scalper {signal_direction.upper()} disabled ‚Üí skip")
                    scalper_trigger = False
                else:
                    # Check direction filter
                    scalper_direction = scalper_settings.get("direction", "all")
                    logger.info(f"[{uid}] Scalper direction check: signal={signal_direction}, allowed={scalper_direction}")
                    
                    if scalper_direction != "all" and scalper_direction != signal_direction:
                        logger.info(f"[{uid}] {symbol}: Scalper direction filter - signal={signal_direction}, allowed={scalper_direction} ‚Üí skip")
                        scalper_trigger = False
                    else:
                        logger.info(f"[{uid}] Scalper {signal_direction.upper()} OK, proceeding with {symbol}")

            # Check Fibonacci enabled + direction filter
            if fibonacci_trigger:
                fibo_settings = db.get_strategy_settings(uid, "fibonacci", ctx_exchange, ctx_account_type)
                signal_direction = "long" if side == "Buy" else "short"
                
                # CRITICAL: Check if this side is enabled
                side_enabled_key = f"{signal_direction}_enabled"
                side_enabled = fibo_settings.get(side_enabled_key, True)
                logger.info(f"[{uid}] Fibonacci enabled check: {side_enabled_key}={side_enabled}")
                
                if not side_enabled:
                    logger.info(f"[{uid}] {symbol}: Fibonacci {signal_direction.upper()} disabled ‚Üí skip")
                    fibonacci_trigger = False
                else:
                    # Check direction filter
                    fibo_direction = fibo_settings.get("direction", "all")
                    logger.info(f"[{uid}] Fibonacci direction check: signal={signal_direction}, allowed={fibo_direction}")
                    
                    if fibo_direction != "all" and fibo_direction != signal_direction:
                        logger.info(f"[{uid}] {symbol}: Fibonacci direction filter - signal={signal_direction}, allowed={fibo_direction} ‚Üí skip")
                        fibonacci_trigger = False
                    else:
                        logger.info(f"[{uid}] Fibonacci {signal_direction.upper()} OK, proceeding with {symbol}")

            # Check RSI_BB enabled + direction filter
            if rsi_bb_trigger:
                rsi_bb_settings = db.get_strategy_settings(uid, "rsi_bb", ctx_exchange, ctx_account_type)
                signal_direction = "long" if side == "Buy" else "short"
                
                # CRITICAL: Check if this side is enabled
                side_enabled_key = f"{signal_direction}_enabled"
                side_enabled = rsi_bb_settings.get(side_enabled_key, True)
                logger.info(f"[{uid}] RSI_BB enabled check: {side_enabled_key}={side_enabled}")
                
                if not side_enabled:
                    logger.info(f"[{uid}] {symbol}: RSI_BB {signal_direction.upper()} disabled ‚Üí skip")
                    rsi_bb_trigger = False
                else:
                    # Check direction filter
                    rsi_bb_direction = rsi_bb_settings.get("direction", "all")
                    
                    if rsi_bb_direction != "all" and rsi_bb_direction != signal_direction:
                        logger.info(f"[{uid}] {symbol}: RSI_BB direction filter - signal={signal_direction}, allowed={rsi_bb_direction} ‚Üí skip")
                        rsi_bb_trigger = False
                    else:
                        logger.info(f"[{uid}] RSI_BB {signal_direction.upper()} OK, proceeding with {symbol}")

            # Check Enliko enabled + direction filter
            if elcaro_trigger:
                elcaro_settings = db.get_strategy_settings(uid, "elcaro", ctx_exchange, ctx_account_type)
                signal_direction = "long" if side == "Buy" else "short"
                
                # CRITICAL: Check if this side is enabled
                side_enabled_key = f"{signal_direction}_enabled"
                side_enabled = elcaro_settings.get(side_enabled_key, True)
                logger.info(f"[{uid}] Elcaro enabled check: {side_enabled_key}={side_enabled}")
                
                if not side_enabled:
                    logger.info(f"[{uid}] {symbol}: Elcaro {signal_direction.upper()} disabled ‚Üí skip")
                    elcaro_trigger = False
                else:
                    # Check direction filter
                    elcaro_direction = elcaro_settings.get("direction", "all")
                    
                    if elcaro_direction != "all" and elcaro_direction != signal_direction:
                        logger.info(f"[{uid}] {symbol}: Elcaro direction filter - signal={signal_direction}, allowed={elcaro_direction} ‚Üí skip")
                        elcaro_trigger = False
                    else:
                        logger.info(f"[{uid}] Elcaro {signal_direction.upper()} OK, proceeding with {symbol}")

            # Check OI enabled + direction filter
            if oi_trigger:
                oi_settings = db.get_strategy_settings(uid, "oi", ctx_exchange, ctx_account_type)
                signal_direction = "long" if side == "Buy" else "short"
                
                # CRITICAL: Check if this side is enabled
                side_enabled_key = f"{signal_direction}_enabled"
                side_enabled = oi_settings.get(side_enabled_key, True)
                logger.info(f"[{uid}] OI enabled check: {side_enabled_key}={side_enabled}")
                
                if not side_enabled:
                    logger.info(f"[{uid}] {symbol}: OI {signal_direction.upper()} disabled ‚Üí skip")
                    oi_trigger = False
                else:
                    # Check direction filter
                    oi_direction = oi_settings.get("direction", "all")
                    
                    if oi_direction != "all" and oi_direction != signal_direction:
                        logger.info(f"[{uid}] {symbol}: OI direction filter - signal={signal_direction}, allowed={oi_direction} ‚Üí skip")
                        oi_trigger = False
                    else:
                        logger.info(f"[{uid}] OI {signal_direction.upper()} OK, proceeding with {symbol}")

            if not (rsi_bb_trigger or bitk_trigger or scalper_trigger or elcaro_trigger or fibonacci_trigger or oi_trigger):
                continue

            # =====================================================
            # LICENSE CHECK - Verify user can trade the strategy
            # =====================================================
            license_info = get_user_license(uid)
            if not license_info["is_active"]:
                # User has no active license - skip all trading
                if once_per((uid, "no_license_warn", ""), 3600):  # Warn once per hour
                    try:
                        await ctx.bot.send_message(
                            uid,
                            t.get("no_license_trading", "‚ö†Ô∏è You need an active subscription to trade.\n\nUse /subscribe to purchase a license.")
                        )
                    except Exception:
                        pass
                continue
            
            # Get trading mode to check license restrictions
            trading_mode = cfg.get("trading_mode", "demo")
            is_real_trade = trading_mode in ("real", "both")
            
            # Determine which strategy is triggered (for license check)
            active_strategy = None
            if rsi_bb_trigger:
                active_strategy = "rsi_bb"
            elif bitk_trigger:
                active_strategy = "scryptomera"
            elif scalper_trigger:
                active_strategy = "scalper"
            elif elcaro_trigger:
                active_strategy = "elcaro"
            elif fibonacci_trigger:
                active_strategy = "fibonacci"
            elif oi_trigger:
                active_strategy = "oi"
            
            # =====================================================
            # MAX POSITIONS CHECK - Skip if limit reached for this strategy/side
            # =====================================================
            if active_strategy:
                signal_direction = "long" if side == "Buy" else "short"
                can_open, current_count, max_limit = await check_strategy_max_positions(
                    uid, active_strategy, signal_direction, ctx_exchange, ctx_account_type
                )
                if not can_open:
                    if once_per((uid, f"max_pos_{active_strategy}_{signal_direction}", ""), 3600):
                        try:
                            await ctx.bot.send_message(
                                uid,
                                t.get(
                                    "strategy_max_positions_reached",
                                    "‚ö†Ô∏è Max positions reached for {strategy} {side}: {current}/{max}\n\nClose a position or increase the limit in strategy settings."
                                ).format(
                                    strategy=active_strategy.upper(),
                                    side=signal_direction.upper(),
                                    current=current_count,
                                    max=max_limit
                                )
                            )
                        except Exception:
                            pass
                    continue
            
            # Check if user can trade this strategy on this account type
            if active_strategy and is_real_trade:
                access = check_license_access(uid, f"strategy_{active_strategy}", "real", exchange=ctx_exchange)
                if not access["allowed"]:
                    if access["reason"] == "trial_demo_only":
                        if once_per((uid, "trial_demo_warn", ""), 3600):
                            try:
                                await ctx.bot.send_message(
                                    uid,
                                    t.get("trial_demo_only", "‚ö†Ô∏è Trial license allows only demo trading.\n\nUpgrade to Premium or Basic for real trading: /subscribe")
                                )
                            except Exception:
                                pass
                        continue
                    elif access["reason"] == "basic_strategy_limit":
                        if once_per((uid, "basic_strategy_warn", active_strategy), 3600):
                            allowed = ", ".join(access.get("allowed_strategies", []))
                            try:
                                await ctx.bot.send_message(
                                    uid,
                                    t.get("basic_strategy_limit", "‚ö†Ô∏è Basic license on real account allows only: {strategies}\n\nUpgrade to Premium for all strategies: /subscribe").format(strategies=allowed)
                                )
                            except Exception:
                                pass
                        continue
                    elif access["reason"] == "basic_bybit_only":
                        if once_per((uid, "basic_bybit_warn", ""), 3600):
                            try:
                                await ctx.bot.send_message(
                                    uid,
                                    t.get("basic_bybit_only", "‚ö†Ô∏è Basic license allows only Bybit trading.\n\nUpgrade to Premium for HyperLiquid access: /subscribe")
                                )
                            except Exception:
                                pass
                        continue

            if rsi_bb_trigger:
                rsi_side_display = 'LONG' if side == 'Buy' else 'SHORT'
                logger.info(f"[{uid}] üìä Processing RSI_BB {rsi_side_display} trade for {symbol}")
                strat_settings = db.get_strategy_settings(uid, "rsi_bb", ctx_exchange, ctx_account_type)
                use_limit = strat_settings.get("order_type", "market") == "limit"
                params = get_strategy_trade_params(uid, cfg, symbol, "rsi_bb", side=side,
                                                  exchange=ctx_exchange, account_type=ctx_account_type)
                user_sl_pct, user_tp_pct = params["sl_pct"], params["tp_pct"]
                risk_pct = params["percent"]
                user_leverage = params.get("leverage")
                pos_use_atr = params.get("use_atr", False)
                logger.info(f"[{uid}] ‚öôÔ∏è RSI_BB {rsi_side_display} settings: entry%={risk_pct}, SL%={user_sl_pct}, TP%={user_tp_pct}, leverage={user_leverage}, ATR={'ON' if pos_use_atr else 'OFF'}, exchange={ctx_exchange}")
                try:
                    qty = await calc_qty(uid, symbol, spot_price, risk_pct, user_sl_pct, account_type=ctx_account_type, exchange=ctx_exchange)
                except Exception as e:
                    # Handle error with daily notifications (no spam!)
                    await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "rsi_bb", symbol)
                    continue
                
                # Set leverage from side-specific params
                if user_leverage:
                    try:
                        await set_leverage(uid, symbol, leverage=user_leverage, account_type=ctx_account_type)
                    except Exception as e:
                        logger.warning(f"[{uid}] rsi_bb: failed to set leverage: {e}")
                    
                if use_limit:
                    liq = liq_price_buy if side == "Buy" else liq_price_sell
                    try:
                        await place_limit_order_with_strategy(
                            uid, symbol, side, price=liq, qty=qty,
                            signal_id=(signal_id or 0), strategy="rsi_bb"
                        )
                        inc_pyramid(uid, symbol, side)
                        await ctx.bot.send_message(
                            uid,
                            t.get('rsi_bb_limit_entry', "üìä RSI+BB Limit: {symbol} {side} @ {price:.6f} qty={qty}")
                             .format(symbol=symbol, side=side, price=liq, qty=qty, sl_pct=user_sl_pct),
                            parse_mode="Markdown"
                        )
                    except Exception as e:
                        # Use unified error handler with daily notifications
                        handled = await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "rsi_bb", symbol)
                        if not handled:
                            await ctx.bot.send_message(
                                uid, t.get('rsi_bb_market_error', "‚ùå RSI+BB error: {msg}").format(
                                    symbol=symbol, side=side, msg=str(e)[:100]
                                )
                            )
                else:
                    try:
                        rv = float(rsi_val)
                        hi = float(bb_hi)
                        lo = float(bb_lo)
                        rsi_zone = (
                            t.get('rsi_zone_oversold', 'oversold') if rv < 23 else
                            t.get('rsi_zone_overbought', 'overbought') if rv > 77 else
                            t.get('rsi_zone_neutral', 'neutral')
                        )
                        
                        order_results = await place_order_all_accounts(
                            uid, symbol, side, orderType="Market", qty=qty, 
                            strategy="rsi_bb", leverage=user_leverage,
                            signal_id=signal_id, timeframe=timeframe,
                            calc_qty_per_target=True, entry_price=spot_price
                        )
                        
                        # Build success and skipped summary from order results
                        success_accounts = []
                        skipped_accounts = []
                        for target_key, result in order_results.items():
                            exchange_label = "Bybit" if result.get("exchange", "bybit") == "bybit" else "HyperLiquid"
                            acc_label = get_account_label_for_display(target_key, result.get("exchange"))
                            
                            if result.get("success"):
                                target_qty = result.get("qty", qty)
                                success_accounts.append(f"{exchange_label} {acc_label}: {target_qty}")
                            elif result.get("skipped"):
                                skipped_accounts.append(f"{exchange_label} {acc_label} ‚è≠Ô∏è (already open)")
                        
                        # NOTE: place_order_all_accounts ‚Üí place_order_for_targets already handles
                        # multi-exchange routing via get_execution_targets(). No need for separate
                        # place_order_hyperliquid/place_order_bybit_if_needed calls ‚Äî they would
                        # cause DUPLICATE orders on the secondary exchange!
                        
                        # Set TP/SL on ALL exchanges where position was opened
                        if side == "Buy":
                            actual_sl = spot_price * (1 - user_sl_pct / 100)
                            actual_tp = spot_price * (1 + user_tp_pct / 100) if user_tp_pct else None
                        else:
                            actual_sl = spot_price * (1 + user_sl_pct / 100)
                            actual_tp = spot_price * (1 - user_tp_pct / 100) if user_tp_pct else None
                        
                        # FIX: Set TP/SL per target exchange (not just active exchange)
                        if not pos_use_atr:
                            for target_key, target_result in order_results.items():
                                if target_result.get("success"):
                                    t_exchange = target_result.get("exchange", "bybit")
                                    t_acc = target_key.split(":")[1] if ":" in target_key else ctx_account_type
                                    t_acc = "demo" if t_acc == "paper" else ("real" if t_acc == "live" else t_acc)
                                    try:
                                        await set_trading_stop(uid, symbol, tp_price=actual_tp, sl_price=actual_sl, side_hint=side, account_type=t_acc, exchange=t_exchange)
                                    except Exception as ts_err:
                                        logger.warning(f"[{uid}] Failed to set TP/SL on {target_key}: {ts_err}")
                        
                        inc_pyramid(uid, symbol, side)
                        
                        # Note: Position is now saved inside place_order_all_accounts for each account_type
                        
                        # Send unified entry message with account details
                        side_display = 'LONG' if side == 'Buy' else 'SHORT'
                        
                        # Build accounts display string
                        accounts_lines = []
                        if success_accounts:
                            accounts_lines.extend(f'‚Ä¢ {acc}' for acc in success_accounts)
                        if skipped_accounts:
                            accounts_lines.extend(f'‚Ä¢ {acc}' for acc in skipped_accounts)
                        accounts_str = '\n'.join(accounts_lines) if accounts_lines else f'‚Ä¢ Qty: {qty}'
                        
                        # Calculate SL price
                        sl_price = spot_price * (1 - user_sl_pct/100) if side == 'Buy' else spot_price * (1 + user_sl_pct/100)
                        side_emoji = 'üìà' if side == 'Buy' else 'üìâ'
                        
                        signal_info = t.get('rsi_bb_entry', (
                            'üìä *RSI+BB* {side_emoji} *{side}*\n'
                            '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n'
                            'ü™ô `{symbol}`\n'
                            'üí∞ Entry: `{price:.6f}`\n'
                            'üìà RSI: `{rsi}` ({rsi_zone})\n'
                            'üõ°Ô∏è SL: `{sl_price:.6f}` ({sl_pct:.2f}%)\n\n'
                            '*Opened on:*\n{accounts}\n'
                            '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n'
                            '_üìä Indicators aligned. Execute._'
                        )).format(
                            side_emoji=side_emoji, side=side_display,
                            symbol=symbol, price=spot_price,
                            rsi=rv, rsi_zone=rsi_zone,
                            sl_price=sl_price, sl_pct=user_sl_pct,
                            accounts=accounts_str
                        )
                        
                        await ctx.bot.send_message(uid, signal_info, parse_mode="Markdown")
                        
                        # Place ladder limit orders if enabled
                        try:
                            await place_ladder_limit_orders(uid, symbol, side, spot_price, strategy="rsi_bb", ctx=ctx)
                        except Exception as ladder_err:
                            logger.warning(f"[{uid}] rsi_bb ladder error: {ladder_err}")
                    except Exception as e:
                        # Use unified error handler with daily notifications
                        handled = await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "rsi_bb", symbol)
                        if not handled:
                            await ctx.bot.send_message(
                                uid, t.get('rsi_bb_market_error', "‚ùå RSI+BB error: {msg}").format(
                                    symbol=symbol, side=side, msg=str(e)[:100]
                                )
                            )
                continue

            if bitk_trigger:
                side_display = 'LONG' if side == 'Buy' else 'SHORT'
                logger.info(f"[{uid}] üîÆ Processing Scryptomera {side_display} trade for {symbol}")
                strat_settings = db.get_strategy_settings(uid, "scryptomera", ctx_exchange, ctx_account_type)
                use_limit = strat_settings.get("order_type", "market") == "limit"
                params = get_strategy_trade_params(uid, cfg, symbol, "scryptomera", side=side,
                                                  exchange=ctx_exchange, account_type=ctx_account_type)
                user_sl_pct = params["sl_pct"]
                user_tp_pct = params["tp_pct"]
                risk_pct = params["percent"]
                user_leverage = params.get("leverage")
                pos_use_atr = params.get("use_atr", False)
                logger.info(f"[{uid}] ‚öôÔ∏è Scryptomera {side_display} settings: entry%={risk_pct}, SL%={user_sl_pct}, TP%={user_tp_pct}, leverage={user_leverage}, ATR={'ON' if pos_use_atr else 'OFF'}, exchange={ctx_exchange}")
                try:
                    if not user_sl_pct or user_sl_pct <= 0:
                        raise ValueError(f"User SL% not configured for {symbol}")

                    qty = await calc_qty(uid, symbol, spot_price, risk_pct, sl_pct=user_sl_pct, account_type=ctx_account_type, exchange=ctx_exchange)

                    # Set leverage from side-specific params (FIX: was using wrong key)
                    user_leverage = params.get("leverage")
                    if user_leverage:
                        try:
                            await set_leverage(uid, symbol, leverage=user_leverage, account_type=ctx_account_type)
                        except Exception as e:
                            logger.warning(f"[{uid}] scryptomera: failed to set leverage: {e}")

                    if use_limit:
                        liq = liq_price_buy if side == "Buy" else liq_price_sell
                        try:
                            await place_limit_order_with_strategy(
                                uid, symbol, side, price=liq, qty=qty,
                                signal_id=(signal_id or 0), strategy="scryptomera"
                            )
                            inc_pyramid(uid, symbol, side)
                            side_display = 'LONG' if side == 'Buy' else 'SHORT'
                            await ctx.bot.send_message(
                                uid,
                                t.get('bitk_limit_entry', "üîÆ Scryptomera Limit: {symbol} {side} @ {price:.6f}")
                                .format(symbol=symbol, side=side_display, price=liq, qty=qty, sl_pct=user_sl_pct),
                                parse_mode="Markdown"
                            )
                        except Exception as e:
                            await ctx.bot.send_message(
                                uid,
                                t.get('bitk_limit_error', "Scryptomera limit error: {msg}").format(msg=str(e))
                            )
                    else:
                        order_results = await place_order_all_accounts(
                            uid, symbol, side, orderType="Market", qty=qty, 
                            strategy="scryptomera", leverage=user_leverage,
                            signal_id=signal_id, timeframe=timeframe,
                            calc_qty_per_target=True, entry_price=spot_price
                        )
                        
                        # Build success and skipped summary from order results
                        success_accounts = []
                        skipped_accounts = []
                        for target_key, result in order_results.items():
                            exchange_label = "Bybit" if result.get("exchange", "bybit") == "bybit" else "HyperLiquid"
                            acc_label = get_account_label_for_display(target_key, result.get("exchange"))
                            
                            if result.get("success"):
                                target_qty = result.get("qty", qty)
                                success_accounts.append(f"{exchange_label} {acc_label}: {target_qty}")
                            elif result.get("skipped"):
                                skipped_accounts.append(f"{exchange_label} {acc_label} ‚è≠Ô∏è (already open)")
                        
                        # NOTE: place_order_all_accounts ‚Üí place_order_for_targets already handles
                        # multi-exchange routing. No separate HL/Bybit calls needed ‚Äî avoids duplicates!
                        
                        # Set TP/SL on ALL exchanges where position was opened
                        if side == "Buy":
                            actual_sl = spot_price * (1 - user_sl_pct / 100)
                            actual_tp = spot_price * (1 + user_tp_pct / 100)
                        else:
                            actual_sl = spot_price * (1 + user_sl_pct / 100)
                            actual_tp = spot_price * (1 - user_tp_pct / 100)
                        
                        if not pos_use_atr:
                            for target_key, target_result in order_results.items():
                                if target_result.get("success"):
                                    t_exchange = target_result.get("exchange", "bybit")
                                    t_acc = target_key.split(":")[1] if ":" in target_key else ctx_account_type
                                    t_acc = "demo" if t_acc == "paper" else ("real" if t_acc == "live" else t_acc)
                                    try:
                                        await set_trading_stop(uid, symbol, tp_price=actual_tp, sl_price=actual_sl, side_hint=side, account_type=t_acc, exchange=t_exchange)
                                    except Exception as ts_err:
                                        logger.warning(f"[{uid}] Failed to set TP/SL on {target_key}: {ts_err}")
                        
                        inc_pyramid(uid, symbol, side)
                        
                        # Note: Position is now saved inside place_order_all_accounts for each account_type
                        
                        side_display = 'LONG' if side == 'Buy' else 'SHORT'
                        side_emoji = 'üìà' if side == 'Buy' else 'üìâ'
                        
                        # Build accounts display string
                        accounts_lines = []
                        if success_accounts:
                            accounts_lines.extend(f'‚Ä¢ {acc}' for acc in success_accounts)
                        if skipped_accounts:
                            accounts_lines.extend(f'‚Ä¢ {acc}' for acc in skipped_accounts)
                        accounts_str = '\n'.join(accounts_lines) if accounts_lines else f'‚Ä¢ Qty: {qty}'
                        
                        # Calculate SL/TP prices
                        sl_price = spot_price * (1 - user_sl_pct/100) if side == 'Buy' else spot_price * (1 + user_sl_pct/100)
                        tp_price = spot_price * (1 + user_tp_pct/100) if side == 'Buy' else spot_price * (1 - user_tp_pct/100)
                        
                        signal_info = t.get('scryptomera_entry', (
                            'üîÆ *SCRYPTOMERA* {side_emoji} *{side}*\n'
                            '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n'
                            'ü™ô `{symbol}`\n'
                            'üí∞ Entry: `{price:.6f}`\n'
                            'üõ°Ô∏è SL: `{sl_price:.6f}` ({sl_pct:.2f}%)\n'
                            'üéØ TP: `{tp_price:.6f}` ({tp_pct:.2f}%)\n\n'
                            '*Opened on:*\n{accounts}\n'
                            '{atr_info}'
                            '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n'
                            '_üåô The oracle has spoken. Destiny awaits._'
                        )).format(
                            side_emoji=side_emoji, side=side_display,
                            symbol=symbol, price=spot_price,
                            sl_price=sl_price, sl_pct=user_sl_pct,
                            tp_price=tp_price, tp_pct=user_tp_pct,
                            accounts=accounts_str, atr_info=""
                        )
                        
                        await ctx.bot.send_message(uid, signal_info, parse_mode="Markdown")
                        
                        # Place ladder limit orders if enabled
                        try:
                            await place_ladder_limit_orders(uid, symbol, side, spot_price, strategy="scryptomera", ctx=ctx)
                        except Exception as ladder_err:
                            logger.warning(f"[{uid}] scryptomera ladder error: {ladder_err}")

                except Exception as e:
                    # Use unified error handler with daily notifications
                    handled = await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "scryptomera", symbol)
                    if not handled:
                        # Unknown error - show generic message
                        await ctx.bot.send_message(
                            uid,
                            t.get('bitk_market_error', "‚ùå Scryptomera error: {msg}").format(
                                msg=str(e)[:100], symbol=symbol, side=side
                            )
                        )
                continue

            if scalper_trigger:
                scalper_side_display = 'LONG' if side == 'Buy' else 'SHORT'
                logger.info(f"[{uid}] ‚ö° Processing Scalper {scalper_side_display} trade for {symbol}")
                strat_settings = db.get_strategy_settings(uid, "scalper", ctx_exchange, ctx_account_type)
                use_limit = strat_settings.get("order_type", "market") == "limit"
                params = get_strategy_trade_params(uid, cfg, symbol, "scalper", side=side,
                                                  exchange=ctx_exchange, account_type=ctx_account_type)
                user_sl_pct = params["sl_pct"]
                user_tp_pct = params["tp_pct"]
                risk_pct = params["percent"]
                user_leverage = params.get("leverage")
                pos_use_atr = params.get("use_atr", False)
                logger.info(f"[{uid}] ‚öôÔ∏è Scalper {scalper_side_display} settings: entry%={risk_pct}, SL%={user_sl_pct}, TP%={user_tp_pct}, leverage={user_leverage}, ATR={'ON' if pos_use_atr else 'OFF'}, exchange={ctx_exchange}")
                try:
                    if not user_sl_pct or user_sl_pct <= 0:
                        raise ValueError(f"User SL% not configured for {symbol}")

                    qty = await calc_qty(uid, symbol, spot_price, risk_pct, sl_pct=user_sl_pct, account_type=ctx_account_type, exchange=ctx_exchange)

                    # Set leverage from side-specific params (FIX: was using wrong key)
                    # Set leverage from side-specific params
                    if user_leverage:
                        try:
                            await set_leverage(uid, symbol, leverage=user_leverage, account_type=ctx_account_type)
                        except Exception as e:
                            logger.warning(f"[{uid}] scalper: failed to set leverage: {e}")

                    if use_limit:
                        liq = liq_price_buy if side == "Buy" else liq_price_sell
                        try:
                            await place_limit_order_with_strategy(
                                uid, symbol, side, price=liq, qty=qty,
                                signal_id=(signal_id or 0), strategy="scalper"
                            )
                            inc_pyramid(uid, symbol, side)
                            side_display = 'LONG' if side == 'Buy' else 'SHORT'
                            await ctx.bot.send_message(
                                uid,
                                t.get('scalper_limit_entry', "‚ö° Scalper Limit: {symbol} {side} @ {price:.6f}")
                                .format(symbol=symbol, side=side_display, price=liq, qty=qty, sl_pct=user_sl_pct),
                                parse_mode="Markdown"
                            )
                        except Exception as e:
                            await ctx.bot.send_message(
                                uid,
                                t.get('scalper_limit_error', "Scalper limit error: {msg}").format(msg=str(e))
                            )
                    else:
                        order_results = await place_order_all_accounts(
                            uid, symbol, side, orderType="Market", qty=qty, 
                            strategy="scalper", leverage=user_leverage,
                            signal_id=signal_id, timeframe=timeframe,
                            calc_qty_per_target=True, entry_price=spot_price
                        )
                        
                        # Build success and skipped summary from order results
                        success_accounts = []
                        skipped_accounts = []
                        for target_key, result in order_results.items():
                            exchange_label = "Bybit" if result.get("exchange", "bybit") == "bybit" else "HyperLiquid"
                            acc_label = get_account_label_for_display(target_key, result.get("exchange"))
                            
                            if result.get("success"):
                                target_qty = result.get("qty", qty)
                                success_accounts.append(f"{exchange_label} {acc_label}: {target_qty}")
                            elif result.get("skipped"):
                                skipped_accounts.append(f"{exchange_label} {acc_label} ‚è≠Ô∏è (already open)")
                        
                        # NOTE: place_order_all_accounts ‚Üí place_order_for_targets already handles
                        # multi-exchange routing. No separate HL/Bybit calls needed ‚Äî avoids duplicates!
                        
                        # Set TP/SL on ALL exchanges where position was opened
                        if side == "Buy":
                            actual_sl = spot_price * (1 - user_sl_pct / 100)
                            actual_tp = spot_price * (1 + user_tp_pct / 100)
                        else:
                            actual_sl = spot_price * (1 + user_sl_pct / 100)
                            actual_tp = spot_price * (1 - user_tp_pct / 100)
                        
                        if not pos_use_atr:
                            for target_key, target_result in order_results.items():
                                if target_result.get("success"):
                                    t_exchange = target_result.get("exchange", "bybit")
                                    t_acc = target_key.split(":")[1] if ":" in target_key else ctx_account_type
                                    t_acc = "demo" if t_acc == "paper" else ("real" if t_acc == "live" else t_acc)
                                    try:
                                        await set_trading_stop(uid, symbol, tp_price=actual_tp, sl_price=actual_sl, side_hint=side, account_type=t_acc, exchange=t_exchange)
                                    except Exception as ts_err:
                                        logger.warning(f"[{uid}] Failed to set TP/SL on {target_key}: {ts_err}")
                        
                        inc_pyramid(uid, symbol, side)
                        
                        # Note: Position is now saved inside place_order_all_accounts for each account_type
                        
                        side_display = 'LONG' if side == 'Buy' else 'SHORT'
                        side_emoji = 'üìà' if side == 'Buy' else 'üìâ'
                        
                        # Build accounts display string
                        accounts_lines = []
                        if success_accounts:
                            accounts_lines.extend(f'‚Ä¢ {acc}' for acc in success_accounts)
                        if skipped_accounts:
                            accounts_lines.extend(f'‚Ä¢ {acc}' for acc in skipped_accounts)
                        accounts_str = '\n'.join(accounts_lines) if accounts_lines else f'‚Ä¢ Qty: {qty}'
                        
                        # Calculate SL/TP prices
                        sl_price = spot_price * (1 - user_sl_pct/100) if side == 'Buy' else spot_price * (1 + user_sl_pct/100)
                        tp_price = spot_price * (1 + user_tp_pct/100) if side == 'Buy' else spot_price * (1 - user_tp_pct/100)
                        
                        signal_info = t.get('scalper_entry', (
                            '‚ö° *SCALPER* {side_emoji} *{side}*\n'
                            '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n'
                            'ü™ô `{symbol}`\n'
                            'üí∞ Entry: `{price:.6f}`\n'
                            'üõ°Ô∏è SL: `{sl_price:.6f}` ({sl_pct:.2f}%)\n'
                            'üéØ TP: `{tp_price:.6f}` ({tp_pct:.2f}%)\n\n'
                            '*Opened on:*\n{accounts}\n'
                            '{atr_info}'
                            '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n'
                            '_‚ö° Strike fast. Leave no trace._'
                        )).format(
                            side_emoji=side_emoji, side=side_display,
                            symbol=symbol, price=spot_price,
                            sl_price=sl_price, sl_pct=user_sl_pct,
                            tp_price=tp_price, tp_pct=user_tp_pct,
                            accounts=accounts_str, atr_info=""
                        )
                        
                        await ctx.bot.send_message(uid, signal_info, parse_mode="Markdown")
                        
                        # Place ladder limit orders if enabled
                        try:
                            await place_ladder_limit_orders(uid, symbol, side, spot_price, strategy="scalper", ctx=ctx)
                        except Exception as ladder_err:
                            logger.warning(f"[{uid}] scalper ladder error: {ladder_err}")

                except Exception as e:
                    # Use unified error handler with daily notifications
                    handled = await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "scalper", symbol)
                    if not handled:
                        await ctx.bot.send_message(
                            uid,
                            t.get('scalper_market_error', "‚ùå Scalper error: {msg}").format(
                                msg=str(e)[:100], symbol=symbol, side=side
                            )
                        )
                continue

            if elcaro_trigger:
                # Enliko (Elcaro) strategy - ALL parameters from USER SETTINGS, not signal
                # Signal only provides: symbol, side, entry price
                elcaro_side_display = 'LONG' if side == 'Buy' else 'SHORT'
                logger.info(f"[{uid}] üéØ Processing Elcaro {elcaro_side_display} trade for {symbol}")
                
                elcaro_strat_settings = db.get_strategy_settings(uid, "elcaro", ctx_exchange, ctx_account_type)
                params = get_strategy_trade_params(uid, cfg, symbol, "elcaro", side=side,
                                                  exchange=ctx_exchange, account_type=ctx_account_type)
                
                # Entry price from signal
                elcaro_entry = parsed_elcaro.get("price", spot_price)
                elcaro_timeframe = parsed_elcaro.get("timeframe") or parsed_elcaro.get("interval", "60m")
                
                # ALL trading params from USER SETTINGS (not from signal!)
                risk_pct = params["percent"]
                sl_pct = params["sl_pct"]
                tp_pct = params["tp_pct"]
                elcaro_leverage = params.get("leverage")  # FIX: use side-specific from params
                logger.info(f"[{uid}] ‚öôÔ∏è Elcaro {elcaro_side_display} settings: entry%={risk_pct}, SL%={sl_pct}, TP%={tp_pct}, leverage={elcaro_leverage}, exchange={ctx_exchange}")
                
                # ATR from user settings
                pos_use_atr = elcaro_strat_settings.get("use_atr", False)
                elcaro_atr_periods = elcaro_strat_settings.get("atr_periods") if pos_use_atr else None
                elcaro_atr_mult = elcaro_strat_settings.get("atr_multiplier_sl") if pos_use_atr else None
                elcaro_atr_trigger = elcaro_strat_settings.get("atr_trigger_pct") if pos_use_atr else None

                try:
                    qty = await calc_qty(uid, symbol, spot_price, risk_pct, sl_pct=sl_pct, account_type=ctx_account_type, exchange=ctx_exchange)

                    # Set leverage from user settings
                    if elcaro_leverage:
                        try:
                            await set_leverage(uid, symbol, leverage=elcaro_leverage, account_type=ctx_account_type)
                            logger.debug(f"[{uid}] Elcaro: set leverage={elcaro_leverage} for {symbol}")
                        except Exception as e:
                            logger.warning(f"[{uid}] Enliko: failed to set leverage: {e}")

                    # Enliko: automatically decide Market vs Limit based on Entry price
                    # If current price is close to Entry (within 0.3%) - use Market
                    # Otherwise use Limit at Entry price
                    entry_diff_pct = abs(spot_price - elcaro_entry) / spot_price * 100 if elcaro_entry else 0
                    use_limit_entry = elcaro_entry and entry_diff_pct > 0.3
                    
                    order_leverage = elcaro_leverage
                    
                    if use_limit_entry:
                        # Limit order at Entry price from signal
                        try:
                            await place_limit_order_with_strategy(
                                uid, symbol, side, price=elcaro_entry, qty=qty,
                                signal_id=(signal_id or 0), strategy="elcaro"
                            )
                            inc_pyramid(uid, symbol, side)
                            side_display = 'LONG' if side == 'Buy' else 'SHORT'
                            await ctx.bot.send_message(
                                uid,
                                t.get('elcaro_limit_entry', "üî• *Elcaro Limit Entry*\n‚Ä¢ {symbol} {side}\n‚Ä¢ Price: {price:.6f}\n‚Ä¢ Qty: {qty}\n‚Ä¢ SL: {sl_pct}%")
                                .format(symbol=symbol, side=side_display, price=elcaro_entry, qty=qty, sl_pct=sl_pct),
                                parse_mode="Markdown"
                            )
                        except Exception as e:
                            await ctx.bot.send_message(
                                uid,
                                t.get('elcaro_limit_error', "‚ùå Elcaro limit error: {msg}").format(msg=str(e))
                            )
                    else:
                        # Market order - price is close to Entry
                        try:
                            order_results = await place_order_all_accounts(
                                uid, symbol, side, orderType="Market", qty=qty, 
                                strategy="elcaro", leverage=order_leverage,
                                signal_id=signal_id, timeframe=elcaro_timeframe,
                                calc_qty_per_target=True, entry_price=spot_price
                            )
                            
                            # Build success and skipped summary from order results
                            success_accounts = []
                            skipped_accounts = []
                            for target_key, result in order_results.items():
                                exchange_label = "Bybit" if result.get("exchange", "bybit") == "bybit" else "HyperLiquid"
                                acc_label = get_account_label_for_display(target_key, result.get("exchange"))
                                
                                if result.get("success"):
                                    target_qty = result.get("qty", qty)
                                    success_accounts.append(f"{exchange_label} {acc_label}: {target_qty}")
                                elif result.get("skipped"):
                                    skipped_accounts.append(f"{exchange_label} {acc_label} ‚è≠Ô∏è (already open)")
                            
                            # NOTE: place_order_all_accounts ‚Üí place_order_for_targets already handles
                            # multi-exchange routing. No separate HL/Bybit calls needed ‚Äî avoids duplicates!
                            
                            # Calculate SL/TP prices from user settings percentages
                            if side == "Buy":
                                actual_sl = spot_price * (1 - sl_pct / 100)
                                actual_tp = spot_price * (1 + tp_pct / 100)
                            else:
                                actual_sl = spot_price * (1 + sl_pct / 100)
                                actual_tp = spot_price * (1 - tp_pct / 100)
                            
                            # Set TP/SL on ALL exchanges where position was opened
                            if not pos_use_atr:
                                for target_key, target_result in order_results.items():
                                    if target_result.get("success"):
                                        t_exchange = target_result.get("exchange", "bybit")
                                        t_acc = target_key.split(":")[1] if ":" in target_key else ctx_account_type
                                        t_acc = "demo" if t_acc == "paper" else ("real" if t_acc == "live" else t_acc)
                                        try:
                                            await set_trading_stop(uid, symbol, tp_price=actual_tp, sl_price=actual_sl, side_hint=side, account_type=t_acc, exchange=t_exchange)
                                        except Exception as ts_err:
                                            logger.warning(f"[{uid}] Failed to set TP/SL on {target_key}: {ts_err}")
                            
                            # Note: Position is now saved inside place_order_all_accounts for each account_type
                            inc_pyramid(uid, symbol, side)
                            
                            # Format signal message with account details
                            accounts_lines = []
                            if success_accounts:
                                accounts_lines.extend(f'‚Ä¢ {acc}' for acc in success_accounts)
                            if skipped_accounts:
                                accounts_lines.extend(f'‚Ä¢ {acc}' for acc in skipped_accounts)
                            accounts_str = '\n'.join(accounts_lines) if accounts_lines else f'‚Ä¢ Qty: {qty}'
                            
                            # ATR info line (from user settings)
                            atr_info = ""
                            if pos_use_atr and elcaro_atr_periods:
                                atr_info = f"üìâ ATR: {elcaro_atr_periods} | √ó{elcaro_atr_mult} | Trigger: {elcaro_atr_trigger}%\n"
                            
                            side_display = 'LONG' if side == 'Buy' else 'SHORT'
                            side_emoji = 'üìà' if side == 'Buy' else 'üìâ'
                            
                            signal_info = t.get('elcaro_entry', (
                                'üî• *ENLIKO* {side_emoji} *{side}*\n'
                                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n'
                                'ü™ô `{symbol}`\n'
                                'üí∞ Entry: `{price:.6f}`\n'
                                'üõ°Ô∏è SL: `{sl_price:.6f}` ({sl_pct:.2f}%)\n'
                                'üéØ TP: `{tp_price:.6f}` ({tp_pct:.2f}%)\n\n'
                                '*Opened on:*\n{accounts}\n'
                                '{atr_info}'
                                '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n'
                                '_üî• Liquidity burns. We collect the ashes._'
                            )).format(
                                side_emoji=side_emoji, side=side_display,
                                symbol=symbol, price=spot_price,
                                sl_price=actual_sl, sl_pct=sl_pct,
                                tp_price=actual_tp, tp_pct=tp_pct,
                                accounts=accounts_str, atr_info=atr_info
                            )
                            
                            await ctx.bot.send_message(uid, signal_info, parse_mode="Markdown")
                            
                            # Place ladder limit orders if enabled
                            try:
                                await place_ladder_limit_orders(uid, symbol, side, spot_price, strategy="elcaro", ctx=ctx)
                            except Exception as ladder_err:
                                logger.warning(f"[{uid}] elcaro ladder error: {ladder_err}")
                            
                        except Exception as e:
                            # Use unified error handler with daily notifications
                            handled = await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "elcaro", symbol)
                            if not handled:
                                await ctx.bot.send_message(
                                    uid,
                                    t.get('elcaro_market_error', "‚ùå Enliko error: {msg}").format(
                                        msg=str(e)[:100], symbol=symbol, side=side
                                    )
                                )
                except Exception as e:
                    # Use unified error handler with daily notifications
                    handled = await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "elcaro", symbol)
                    if not handled:
                        await ctx.bot.send_message(
                            uid,
                            t.get('elcaro_market_error', "‚ùå Enliko error: {msg}").format(
                                msg=str(e)[:100], symbol=symbol, side=side
                            )
                        )
                continue

            if fibonacci_trigger:
                # Fibonacci Extension Strategy
                # Signal provides: entry zone, quality info
                # ALL trading params (SL/TP/ATR) from USER SETTINGS
                fibo_side_display = 'LONG' if side == 'Buy' else 'SHORT'
                logger.info(f"[{uid}] üî¢ Processing Fibonacci {fibo_side_display} trade for {symbol}")
                
                fibo_entry = parsed_fibonacci.get("entry", spot_price)
                fibo_entry_low = parsed_fibonacci.get("entry_low")
                fibo_entry_high = parsed_fibonacci.get("entry_high")
                quality_grade = parsed_fibonacci.get("quality_grade", "B")
                quality_score = parsed_fibonacci.get("quality_score", 50)
                trigger_info = parsed_fibonacci.get("trigger_info", "")
                
                # Get ALL params from user settings (not from signal!)
                strat_settings = db.get_strategy_settings(uid, "fibonacci", ctx_exchange, ctx_account_type)
                params = get_strategy_trade_params(uid, cfg, symbol, "fibonacci", side=side,
                                                  exchange=ctx_exchange, account_type=ctx_account_type)
                risk_pct = params["percent"]
                user_leverage = params.get("leverage", 10)  # FIX: use side-specific from params
                fibo_sl_pct = params["sl_pct"]  # From user settings!
                fibo_tp_pct = params["tp_pct"]  # From user settings!
                logger.info(f"[{uid}] ‚öôÔ∏è Fibonacci {fibo_side_display} settings: entry%={risk_pct}, SL%={fibo_sl_pct}, TP%={fibo_tp_pct}, leverage={user_leverage}, exchange={ctx_exchange}")
                
                # ATR from user settings
                pos_use_atr = strat_settings.get("use_atr", False)
                fibo_atr_periods = strat_settings.get("atr_periods") if pos_use_atr else None
                fibo_atr_mult = strat_settings.get("atr_multiplier_sl") if pos_use_atr else None
                fibo_atr_trigger = strat_settings.get("atr_trigger_pct") if pos_use_atr else None
                
                logger.debug(f"[{uid}] Fibonacci using USER settings: Entry%={risk_pct}%, SL={fibo_sl_pct}%, TP={fibo_tp_pct}%, "
                            f"Leverage={user_leverage}, ATR={'ON' if pos_use_atr else 'OFF'}")
                
                # Quality filter - skip if quality score too low
                min_quality = strat_settings.get("min_quality", 50)
                if quality_score < min_quality:
                    logger.debug(f"[{uid}] Fibonacci {symbol}: quality {quality_score} < min {min_quality} ‚Üí skip")
                    continue
                
                try:
                    qty = await calc_qty(uid, symbol, spot_price, risk_pct, sl_pct=fibo_sl_pct, account_type=ctx_account_type, exchange=ctx_exchange)
                    
                    # Set leverage
                    if user_leverage:
                        try:
                            await set_leverage(uid, symbol, leverage=user_leverage, account_type=ctx_account_type)
                        except Exception as e:
                            logger.warning(f"[{uid}] Fibonacci: failed to set leverage: {e}")
                    
                    # Decide Market vs Limit based on entry zone
                    # If current price is within entry zone ‚Üí Market
                    # If current price is outside entry zone ‚Üí Limit at best boundary
                    use_limit_entry = False
                    limit_entry_price = fibo_entry  # Default to mid-point
                    
                    if fibo_entry_low and fibo_entry_high:
                        # For LONG: use lower boundary (buy cheaper)
                        # For SHORT: use upper boundary (sell higher)
                        if side == "Buy":
                            limit_entry_price = fibo_entry_low
                        else:  # Sell
                            limit_entry_price = fibo_entry_high
                        
                        if not (fibo_entry_low <= spot_price <= fibo_entry_high):
                            use_limit_entry = True
                    
                    if use_limit_entry:
                        # Limit order at optimal entry zone boundary
                        try:
                            await place_limit_order_with_strategy(
                                uid, symbol, side, price=limit_entry_price, qty=qty,
                                signal_id=(signal_id or 0), strategy="fibonacci"
                            )
                            inc_pyramid(uid, symbol, side)
                            side_display = 'LONG' if side == 'Buy' else 'SHORT'
                            entry_zone_display = f"{fibo_entry_low:.6f} ‚Äì {fibo_entry_high:.6f}"
                            await ctx.bot.send_message(
                                uid,
                                t.get('fibonacci_limit_entry', "üìê *Fibonacci Limit Entry*\n‚Ä¢ {symbol} {side}\n‚Ä¢ Limit: {price:.6f}\n‚Ä¢ Entry Zone: {entry_zone}\n‚Ä¢ Qty: {qty}\n‚Ä¢ SL: {sl_pct}%")
                                .format(symbol=symbol, side=side_display, price=limit_entry_price, entry_zone=entry_zone_display, qty=qty, sl_pct=fibo_sl_pct),
                                parse_mode="Markdown"
                            )
                        except Exception as e:
                            # Use unified error handler with daily notifications
                            handled = await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "fibonacci", symbol)
                            if not handled:
                                await ctx.bot.send_message(
                                    uid,
                                    t.get('fibonacci_limit_error', "‚ùå Fibonacci error: {msg}").format(
                                        symbol=symbol, side=side, msg=str(e)[:100]
                                    )
                                )
                    else:
                        # Market order - price is in entry zone
                        try:
                            order_results = await place_order_all_accounts(
                                uid, symbol, side, orderType="Market", qty=qty, 
                                strategy="fibonacci", leverage=user_leverage,
                                signal_id=signal_id, timeframe="1h",
                                calc_qty_per_target=True, entry_price=spot_price
                            )
                            
                            # Build success and skipped summary from order results
                            success_accounts = []
                            skipped_accounts = []
                            for target_key, result in order_results.items():
                                exchange_label = "Bybit" if result.get("exchange", "bybit") == "bybit" else "HyperLiquid"
                                acc_label = get_account_label_for_display(target_key, result.get("exchange"))
                                
                                if result.get("success"):
                                    target_qty = result.get("qty", qty)
                                    success_accounts.append(f"{exchange_label} {acc_label}: {target_qty}")
                                elif result.get("skipped"):
                                    skipped_accounts.append(f"{exchange_label} {acc_label} ‚è≠Ô∏è (already open)")
                            
                            # NOTE: place_order_all_accounts ‚Üí place_order_for_targets already handles
                            # multi-exchange routing. No separate HL/Bybit calls needed ‚Äî avoids duplicates!
                            
                            # Calculate SL/TP from user settings percentages
                            if side == "Buy":
                                actual_sl = spot_price * (1 - fibo_sl_pct / 100)
                                actual_tp = spot_price * (1 + fibo_tp_pct / 100)
                            else:
                                actual_sl = spot_price * (1 + fibo_sl_pct / 100)
                                actual_tp = spot_price * (1 - fibo_tp_pct / 100)
                            
                            # Set TP/SL on ALL exchanges where position was opened
                            if not pos_use_atr:
                                for target_key, target_result in order_results.items():
                                    if target_result.get("success"):
                                        t_exchange = target_result.get("exchange", "bybit")
                                        t_acc = target_key.split(":")[1] if ":" in target_key else ctx_account_type
                                        t_acc = "demo" if t_acc == "paper" else ("real" if t_acc == "live" else t_acc)
                                        try:
                                            await set_trading_stop(uid, symbol, tp_price=actual_tp, sl_price=actual_sl, side_hint=side, account_type=t_acc, exchange=t_exchange)
                                        except Exception as ts_err:
                                            logger.warning(f"[{uid}] Failed to set TP/SL on {target_key}: {ts_err}")
                            
                            # Note: Position is now saved inside place_order_all_accounts for each account_type
                            inc_pyramid(uid, symbol, side)
                            
                            # Format signal message with account details
                            accounts_lines = []
                            if success_accounts:
                                accounts_lines.extend(f'  ‚Ä¢ {acc}' for acc in success_accounts)
                            if skipped_accounts:
                                accounts_lines.extend(f'  ‚Ä¢ {acc}' for acc in skipped_accounts)
                            accounts_str = '\n'.join(accounts_lines) if accounts_lines else f'  ‚Ä¢ Qty: {qty}'
                            
                            # ATR info if enabled
                            atr_info = ""
                            if pos_use_atr and fibo_atr_periods:
                                atr_info = f"\nüìâ ATR: {fibo_atr_periods} | √ó{fibo_atr_mult} | Trigger: {fibo_atr_trigger}%"
                            
                            signal_info = (
                                f"üìê *Fibonacci* {'üìà LONG' if side=='Buy' else 'üìâ SHORT'}\n"
                                f"ü™ô {symbol}\n"
                                f"üí∞ Entry: {spot_price:.6g}\n"
                                f"üéØ Zone: {fibo_entry_low:.6g} ‚Äì {fibo_entry_high:.6g}\n"
                                f"üõë SL: {actual_sl:.6g} ({fibo_sl_pct:.2f}%)\n"
                                f"‚úÖ TP: {actual_tp:.6g} ({fibo_tp_pct:.2f}%)\n"
                                f"üü¢ Quality: {quality_grade} ({quality_score}/100){atr_info}\n\n"
                                f"*Opened on:*\n{accounts_str}"
                            )
                            if trigger_info:
                                signal_info += f"\n‚ö° {trigger_info}"
                            
                            await ctx.bot.send_message(uid, signal_info, parse_mode="Markdown")
                            
                        except Exception as e:
                            # Use unified error handler with daily notifications
                            handled = await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "fibonacci", symbol)
                            if not handled:
                                await ctx.bot.send_message(
                                    uid,
                                    t.get('fibonacci_market_error', "‚ùå Fibonacci error: {msg}").format(
                                        symbol=symbol, side=side, msg=str(e)[:100]
                                    )
                                )
                except Exception as e:
                    # Use unified error handler with daily notifications
                    handled = await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "fibonacci", symbol)
                    if not handled:
                        await ctx.bot.send_message(
                            uid,
                            t.get('fibonacci_market_error', "‚ùå Fibonacci error: {msg}").format(
                                symbol=symbol, side=side, msg=str(e)[:100]
                            )
                        )
                continue

            if oi_trigger:
                oi_side_display = 'LONG' if side == 'Buy' else 'SHORT'
                logger.info(f"[{uid}] üìâ Processing OI {oi_side_display} trade for {symbol}")
                strat_settings = db.get_strategy_settings(uid, "oi", ctx_exchange, ctx_account_type)
                use_limit = strat_settings.get("order_type", "market") == "limit"
                params = get_strategy_trade_params(uid, cfg, symbol, "oi", side=side,
                                                  exchange=ctx_exchange, account_type=ctx_account_type)
                user_sl_pct = params["sl_pct"]
                user_tp_pct = params["tp_pct"]
                risk_pct = params["percent"]
                user_leverage = params.get("leverage")  # FIX: use side-specific from params
                pos_use_atr = params.get("use_atr", False)
                logger.info(f"[{uid}] ‚öôÔ∏è OI {oi_side_display} settings: entry%={risk_pct}, SL%={user_sl_pct}, TP%={user_tp_pct}, leverage={user_leverage}, ATR={'ON' if pos_use_atr else 'OFF'}, exchange={ctx_exchange}")
                try:
                    if user_sl_pct <= 0:
                        user_sl_pct = 1.0
                    qty_total = await calc_qty(uid, symbol, spot_price, risk_pct, sl_pct=user_sl_pct, account_type=ctx_account_type, exchange=ctx_exchange)

                    # Set leverage if configured
                    if user_leverage:
                        try:
                            await set_leverage(uid, symbol, leverage=user_leverage, account_type=ctx_account_type)
                        except Exception as e:
                            logger.warning(f"[{uid}] oi: failed to set leverage: {e}")

                    filt     = await get_symbol_filters(uid, symbol, exchange=ctx_exchange)
                    step_qty = float(filt["qtyStep"])
                    min_qty  = float(filt["minQty"])
                    def q_qty(v: float) -> float:
                        return max(min_qty, quantize(v, step_qty))

                    if use_limit:
                        # Full limit order
                        qty_lim = q_qty(qty_total)
                        data = await _bybit_request(uid, "GET", "/v5/market/tickers", params={"category":"linear","symbol":symbol})
                        last = (data.get("list") or [{}])[0].get("lastPrice")
                        cur  = float(last) if last not in (None, "", "0") else float(spot_price)
                        lim_price = cur * (0.99 if side == "Buy" else 1.01)
                        await place_limit_order_with_strategy(
                            uid, symbol, side, price=lim_price, qty=qty_lim,
                            signal_id=(signal_id or 0), strategy="oi"
                        )
                        await ctx.bot.send_message(
                            uid,
                            t.get('oi_limit_entry', "üìâ OI Limit: {symbol} {side} @ {price:.6f} qty={qty}")
                             .format(symbol=symbol, side=side, price=lim_price, qty=qty_lim, sl_pct=user_sl_pct),
                            parse_mode="Markdown"
                        )
                        inc_pyramid(uid, symbol, side)
                    else:
                        # Full market order
                        qty_mkt = q_qty(qty_total)
                        order_results = await place_order_all_accounts(
                            uid, symbol, side, orderType="Market", qty=qty_mkt, 
                            strategy="oi", leverage=user_leverage,
                            signal_id=signal_id, timeframe=timeframe,
                            calc_qty_per_target=True, entry_price=spot_price
                        )
                        
                        # Build success and skipped summary from order results
                        success_accounts = []
                        skipped_accounts = []
                        for target_key, result in order_results.items():
                            exchange_label = "Bybit" if result.get("exchange", "bybit") == "bybit" else "HyperLiquid"
                            acc_label = get_account_label_for_display(target_key, result.get("exchange"))
                            
                            if result.get("success"):
                                target_qty = result.get("qty", qty_mkt)
                                success_accounts.append(f"{exchange_label} {acc_label}: {target_qty}")
                            elif result.get("skipped"):
                                skipped_accounts.append(f"{exchange_label} {acc_label} ‚è≠Ô∏è (already open)")
                        
                        # NOTE: place_order_all_accounts ‚Üí place_order_for_targets already handles
                        # multi-exchange routing. No separate HL/Bybit calls needed ‚Äî avoids duplicates!
                        
                        # Calculate SL/TP prices for set_trading_stop
                        if side == "Buy":
                            actual_sl = spot_price * (1 - user_sl_pct / 100)
                            actual_tp = spot_price * (1 + user_tp_pct / 100)
                        else:
                            actual_sl = spot_price * (1 + user_sl_pct / 100)
                            actual_tp = spot_price * (1 - user_tp_pct / 100)
                        
                        # Set TP/SL on ALL exchanges where position was opened
                        if not pos_use_atr:
                            for target_key, target_result in order_results.items():
                                if target_result.get("success"):
                                    t_exchange = target_result.get("exchange", "bybit")
                                    t_acc = target_key.split(":")[1] if ":" in target_key else ctx_account_type
                                    t_acc = "demo" if t_acc == "paper" else ("real" if t_acc == "live" else t_acc)
                                    try:
                                        await set_trading_stop(uid, symbol, tp_price=actual_tp, sl_price=actual_sl, side_hint=side, account_type=t_acc, exchange=t_exchange)
                                    except Exception as ts_err:
                                        logger.warning(f"[{uid}] Failed to set TP/SL on {target_key}: {ts_err}")
                        
                        # Note: Position is now saved inside place_order_all_accounts for each account_type
                        
                        side_display = 'LONG' if side == 'Buy' else 'SHORT'
                        side_emoji = 'üìà' if side == 'Buy' else 'üìâ'
                        
                        # Build accounts display string
                        accounts_lines = []
                        if success_accounts:
                            accounts_lines.extend(f'‚Ä¢ {acc}' for acc in success_accounts)
                        if skipped_accounts:
                            accounts_lines.extend(f'‚Ä¢ {acc}' for acc in skipped_accounts)
                        accounts_str = '\n'.join(accounts_lines) if accounts_lines else f'‚Ä¢ Qty: {qty_mkt}'
                        
                        # Calculate SL/TP prices
                        sl_price = spot_price * (1 - user_sl_pct/100) if side == 'Buy' else spot_price * (1 + user_sl_pct/100)
                        tp_price = spot_price * (1 + user_tp_pct/100) if side == 'Buy' else spot_price * (1 - user_tp_pct/100)
                        
                        signal_info = t.get('oi_entry', (
                            'üêã *OI SIGNAL* {side_emoji} *{side}*\n'
                            '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n'
                            'ü™ô `{symbol}`\n'
                            'üí∞ Entry: `{price:.6f}`\n'
                            'üõ°Ô∏è SL: `{sl_price:.6f}` ({sl_pct:.2f}%)\n'
                            'üéØ TP: `{tp_price:.6f}` ({tp_pct:.2f}%)\n\n'
                            '*Opened on:*\n{accounts}\n'
                            '{atr_info}'
                            '‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n'
                            '_ü¶à Whale detected. Hunt initiated._'
                        )).format(
                            side_emoji=side_emoji, side=side_display,
                            symbol=symbol, price=spot_price,
                            sl_price=sl_price, sl_pct=user_sl_pct,
                            tp_price=tp_price, tp_pct=user_tp_pct,
                            accounts=accounts_str, atr_info=""
                        )
                        
                        await ctx.bot.send_message(uid, signal_info, parse_mode="Markdown")
                        inc_pyramid(uid, symbol, side)
                        
                        # Place ladder limit orders if enabled
                        try:
                            await place_ladder_limit_orders(uid, symbol, side, spot_price, strategy="oi", ctx=ctx)
                        except Exception as ladder_err:
                            logger.warning(f"[{uid}] oi ladder error: {ladder_err}")

                except Exception as e:
                    # Use unified error handler with daily notifications
                    handled = await handle_trade_error(ctx.bot, uid, e, ctx_account_type, t, "oi", symbol)
                    if not handled:
                        await ctx.bot.send_message(
                            uid,
                            t.get('oi_market_error', "‚ùå OI error: {msg}").format(
                                symbol=symbol, side=side, msg=str(e)[:100]
                            )
                        )
                continue

        except Exception as e:
            # Handle Telegram rate limits gracefully
            from telegram.error import RetryAfter
            if isinstance(e, RetryAfter):
                _notification_retry_after[uid] = time.time() + e.retry_after
                logger.warning(f"[{uid}] Rate limited in channel handler, retry after {e.retry_after}s")
            else:
                logger.error(f"User loop error for uid={uid}: {e}", exc_info=True)
            continue

def log_exit_and_remove_position(
    user_id: int,
    *,
    signal_id: int | None,
    symbol: str,
    side: str,                 
    entry_price: float,
    exit_price: float,
    exit_reason: str,        
    size: float,
    signal_source: str | None = None,
    rsi: float | None = None, bb_hi: float | None = None, bb_lo: float | None = None,
    oi_prev: float | None = None, oi_now: float | None = None, oi_chg: float | None = None,
    vol_from: float | None = None, vol_to: float | None = None,
    price_chg: float | None = None, vol_delta: float | None = None,
    sl_price: float | None = None, tp_price: float | None = None,
    timeframe: str | None = None, entry_ts_ms: int | None = None,
    exit_order_type: str | None = None,
    strategy: str | None = None,
    account_type: str = "demo",
    applied_sl_pct: float | None = None,  # Fix #2: SL% at position open time
    applied_tp_pct: float | None = None,  # Fix #2: TP% at position open time
    exchange: str = "bybit",  # Fix #4: Exchange for trade log
    fee: float = 0.0,  # Trading fee/commission from exchange
) -> None:
    cfg = get_user_config(user_id) or {}
    
    # Fix #2: Use saved SL/TP % from position open time, fallback to current settings
    if applied_sl_pct is not None:
        sl_pct = applied_sl_pct
    elif strategy:
        sl_pct, _ = resolve_sl_tp_pct(cfg, symbol, strategy=strategy, user_id=user_id, side=side)
    else:
        sl_pct = float(cfg.get("sl_percent") or DEFAULT_SL_PCT)
    
    if applied_tp_pct is not None:
        tp_pct = applied_tp_pct
    elif strategy:
        _, tp_pct = resolve_sl_tp_pct(cfg, symbol, strategy=strategy, user_id=user_id, side=side)
    else:
        tp_pct = float(cfg.get("tp_percent") or DEFAULT_TP_PCT)

    pnl_abs = (exit_price - entry_price) * float(size) * (1 if side == "Buy" else -1)
    pnl_pct = (exit_price / entry_price - 1.0) * (100 if side == "Buy" else -100) if entry_price > 0 else 0.0

    add_trade_log(
        user_id=user_id, signal_id=signal_id, symbol=symbol, side=side,
        entry_price=float(entry_price), exit_price=float(exit_price),
        exit_reason=str(exit_reason), pnl=float(pnl_abs), pnl_pct=float(pnl_pct),
        signal_source=signal_source, rsi=rsi, bb_hi=bb_hi, bb_lo=bb_lo,
        oi_prev=oi_prev, oi_now=oi_now, oi_chg=oi_chg,
        vol_from=vol_from, vol_to=vol_to, price_chg=price_chg, vol_delta=vol_delta,
        sl_pct=sl_pct, tp_pct=tp_pct, sl_price=sl_price, tp_price=tp_price,
        timeframe=timeframe, entry_ts=int(entry_ts_ms or 0),
        exit_ts=int(time.time()*1000), exit_order_type=exit_order_type,
        strategy=strategy, account_type=account_type, exchange=exchange,
        fee=fee,
    )
    # Pass entry_price to prevent race condition where a NEW position (opened by signal)
    # gets deleted when closing OLD position (detected by monitor)
    remove_active_position(user_id, symbol, account_type=account_type, entry_price=entry_price, exchange=exchange)

def cleanup_limit_order_on_status(user_id: int, order_id: str, status: str, exchange: str = "bybit") -> None:
    status = (status or "").upper()
    if status in ("FILLED", "CANCELED", "EXPIRED"):
        try:
            remove_pending_limit_order(user_id, order_id, exchange=exchange)
        except Exception:
            pass

@log_calls
async def monitor_positions_loop(app: Application):
    """Main monitoring loop - optimized for multi-user."""
    global _close_all_cooldown
    bot = app.bot
    
    # Track previous open symbols per user to avoid spam notifications
    _open_syms_prev = {}
    
    # Track SL notifications already sent to avoid spam
    # Key: (uid, symbol), Value: timestamp when last notification was sent
    _sl_notified = {}
    
    # Track last stale cleanup time per user (run every 5 minutes)
    _last_stale_cleanup = {}
    
    # Track deep loss notifications (position without SL in deep loss)
    # Key: (uid, symbol), Value: timestamp when notification was sent
    _deep_loss_notified = {}
    
    # Track close position notifications already sent to avoid spam
    # Key: (uid, symbol, account_type), Value: timestamp when notification was sent
    # Prevents duplicate close notifications when remove_active_position() fails (e.g., entry_price mismatch)
    _close_notified = {}
    
    # Track already processed closures to prevent duplicate logging
    # Key: (uid, symbol, entry_price_rounded, pnl_rounded), Value: timestamp
    # This is a second layer of protection (first layer is in add_trade_log)
    _processed_closures = {}
    
    # Track new position notifications to prevent flood
    # Key: (uid, symbol, account_type), Value: timestamp
    # Prevents duplicate "–°–î–ï–õ–ö–ê –ò–°–ü–û–õ–ù–ï–ù–ê" notifications
    _new_position_notified = {}
    
    # Cooldown for new position notifications (5 minutes = 300 seconds)
    NEW_POSITION_NOTIFY_COOLDOWN = 300

    while True:
        try:
            # Use cached list of active trading users (with API keys)
            for uid in get_active_trading_users():
                try:
                    if GLOBAL_PAUSED:
                        continue
                    
                    cfg  = get_user_config(uid)  # Cached
                    
                    # Skip banned users
                    if cfg.get("is_banned"):
                        continue
                    
                    lang = cfg.get("lang", DEFAULT_LANG)
                    t    = LANGS.get(lang, LANGS[DEFAULT_LANG])
                    use_atr = bool(cfg.get("use_atr", 1))  # Default to ATR enabled
                    
                    # Get ALL user targets (for multi-account monitoring)
                    user_targets = get_user_targets(uid) if UNIFIED_AVAILABLE else []
                    
                    # Fallback to legacy if no targets from unified
                    if not user_targets:
                        user_trading_mode = get_trading_mode(uid) or "demo"
                        k, s = get_user_credentials(uid)
                        if not k or not s:
                            continue
                        # Create targets_to_check list for legacy mode (Bybit only)
                        if user_trading_mode == "both":
                            targets_to_check = [("bybit", "demo"), ("bybit", "real")]
                        else:
                            targets_to_check = [("bybit", user_trading_mode)]
                    else:
                        # Use targets from unified architecture
                        targets_to_check = [(tgt.exchange, tgt.account_type) for tgt in user_targets]
                        user_trading_mode = targets_to_check[0][1] if targets_to_check else "demo"
                    
                    # Process EACH target for this user (supports multi-exchange and multi-account)
                    for current_exchange, current_account_type in targets_to_check:
                        # Get previous symbols to avoid duplicate notifications
                        cache_key = f"{uid}:{current_exchange}:{current_account_type}"
                        open_syms_prev = _open_syms_prev.get(cache_key, set())
                        
                        # Pass exchange explicitly to ensure correct API is used
                        open_positions = await fetch_open_positions(uid, account_type=current_account_type, exchange=current_exchange)
                        
                        # CRITICAL GUARD: If fetch returned None, API error occurred.
                        # Skip this user/account entirely to prevent phantom position removal!
                        if open_positions is None:
                            logger.warning(f"[{uid}] {current_exchange}/{current_account_type}: API error fetching positions ‚Äî SKIPPING to protect DB positions")
                            continue
                        
                        open_positions = [p for p in open_positions if p["symbol"] not in BLACKLIST]
                        active = get_active_positions(uid, account_type=current_account_type, exchange=current_exchange)
                        
                        existing_syms = {ap.get("symbol") for ap in active if ap.get("symbol")}
                        tf_map = {ap.get('symbol'): ap.get('timeframe', '24h') for ap in active if ap.get('symbol')}
                        now = int(time.time())
                        open_syms = {p["symbol"] for p in open_positions}
                        
                        # Update previous symbols cache at end of processing
                        _open_syms_prev[cache_key] = open_syms.copy()
                        
                        # Small delay after HyperLiquid processing to avoid rate limits
                        if current_exchange == 'hyperliquid':
                            await asyncio.sleep(1.5)  # 1.5s delay between HL users
                        
                        pending = get_pending_limit_orders(uid, exchange=current_exchange)
                        if pending:
                            try:
                                open_orders = await fetch_open_orders(uid, account_type=current_account_type)
                                open_ids = {o["orderId"] for o in open_orders}
                            except Exception as e:
                                logger.warning(f"fetch_open_orders failed, skip pending check this tick: {e}")
                                open_ids = None  

                            if open_ids is not None:
                                for po in pending:
                                    order_id = po["order_id"]
                                    sym      = po["symbol"]
                                    sig = fetch_signal_by_id(po["signal_id"]) or {}
                                    tf_for_sym = sig.get("timeframe") or "24h"  # Column is 'timeframe' in DB

                                    if order_id not in open_ids:
                                        pos = next((p for p in open_positions if p["symbol"] == sym), None)
                                        if pos:
                                            # P0.5: Get use_atr from strategy settings
                                            strat_name = po.get("strategy") or "unknown"
                                            cfg_pending = get_user_config(uid) or {}
                                            trade_params_pending = get_strategy_trade_params(
                                                uid, cfg_pending, sym, strat_name,
                                                side=po["side"], account_type=current_account_type
                                            )
                                            pos_use_atr_pending = trade_params_pending.get("use_atr", False)
                                            # Get leverage from position (Bybit returns it)
                                            pos_leverage = pos.get("leverage")
                                            if pos_leverage:
                                                pos_leverage = int(float(pos_leverage))
                                            
                                            # Use current_account_type from the loop
                                            add_active_position(
                                                user_id     = uid,
                                                symbol      = sym,
                                                side        = po["side"],
                                                entry_price = float(pos["avgPrice"]),
                                                size        = float(pos["size"]),
                                                timeframe   = tf_for_sym,
                                                signal_id   = po["signal_id"],
                                                strategy    = strat_name,
                                                account_type = current_account_type,
                                                exchange    = current_exchange,  # Multitenancy fix
                                                use_atr     = pos_use_atr_pending,  # P0.5
                                                leverage    = pos_leverage,  # Save actual leverage
                                                # Fix #2: Save SL/TP % at position open time
                                                applied_sl_pct = trade_params_pending.get("sl_pct"),
                                                applied_tp_pct = trade_params_pending.get("tp_pct"),
                                            )
                                            await bot.send_message(
                                                uid,
                                                t['limit_order_filled'].format(
                                                    symbol = sym,
                                                    price  = pos["avgPrice"]
                                                )
                                            )
                                        else:
                                            await bot.send_message(
                                                uid,
                                                t['limit_order_cancelled'].format(symbol=sym, order_id=order_id)
                                            )                                
                                        remove_pending_limit_order(uid, order_id, exchange=current_exchange)

                        # Refresh active positions for this account type
                        active = get_active_positions(uid, account_type=current_account_type, exchange=current_exchange)
                        existing_syms = {ap.get("symbol") for ap in active if ap.get("symbol")}
                                    
                        for p in open_positions:
                            sym     = p["symbol"]
                            entry   = float(p["avgPrice"])
                            raw_sl  = p.get("stopLoss")
                            size    = float(p["size"])
                            side    = p["side"]
                            
                            # Reset detected_strategy for each position
                            detected_strategy = None

                            if sym not in existing_syms:
                                # Check if we're in cooldown period after close_all
                                cooldown_end = _close_all_cooldown.get(uid, 0)
                                if now < cooldown_end:
                                    # Skip adding new positions during cooldown
                                    logger.info(f"[{uid}] Skipping {sym} - in close_all cooldown ({int(cooldown_end - now)}s left)")
                                    continue
                                
                                # CRITICAL: Check if position with same entry price was recently closed
                                # This prevents re-adding positions that appear on Bybit API due to sync delay
                                entry_price_check = round(entry, 4)
                                recently_closed = was_position_recently_closed(uid, sym, entry_price_check, seconds=120, exchange=current_exchange)
                                if recently_closed:
                                    logger.info(f"[{uid}] Skipping {sym} - position with entry={entry_price_check} was recently closed (API sync delay)")
                                    continue
                                
                                # Timeframe will be determined from signal or default
                                tf_for_sym = "1h"  # Default timeframe for detected positions
                                
                                # Try to find a recent signal for this position
                                # This helps determine correct strategy when bot restarts and finds
                                # positions that were opened by bot but not yet recorded in active_positions
                                detected_strategy = None
                                sig = None
                                signal_id = None
                                
                                # Search for a recent signal for this symbol+side (within 3 minutes)
                                # This is safe because:
                                # 1. We only look at signals from last 3 minutes
                                # 2. We match both symbol AND side
                                # 3. We already confirmed position doesn't exist in our DB
                                try:
                                    from db import get_recent_signal_for_position
                                    sig = get_recent_signal_for_position(sym, side, within_seconds=180)
                                    if sig:
                                        signal_id = sig.get("id")
                                        logger.info(f"[{uid}] Found recent signal #{signal_id} for {sym} {side}")
                                except Exception as e:
                                    logger.warning(f"[{uid}] get_recent_signal_for_position failed: {e}")
                                
                                if sig:
                                    # Check signal source/strategy using parsers
                                    raw_msg = sig.get("raw_data") or ""  # Column is 'raw_data' in DB
                                    raw_upper = raw_msg.upper()
                                    
                                    # RSI_BB MUST be checked FIRST (it's most common and has unique pattern)
                                    if is_rsi_bb_signal(raw_msg):
                                        detected_strategy = "rsi_bb"
                                    # Use actual parsers to detect strategy (most reliable)
                                    elif is_fibonacci_signal(raw_msg):
                                        detected_strategy = "fibonacci"
                                    elif is_bitk_signal(raw_msg):  # Scryptomera
                                        detected_strategy = "scryptomera"
                                    elif is_scalper_signal(raw_msg):
                                        detected_strategy = "scalper"
                                    elif is_elcaro_signal(raw_msg):
                                        detected_strategy = "elcaro"
                                    elif is_oi_signal(raw_msg):
                                        detected_strategy = "oi"
                                    # Fallback to keyword detection for legacy signals
                                    elif "SCRYPTOMERA" in raw_upper or "DROP CATCH" in raw_msg or "DROPSBOT" in raw_upper or "TIGHTBTC" in raw_upper:
                                        detected_strategy = "scryptomera"
                                    elif "SCALPER" in raw_upper and "‚ö°" in raw_msg:
                                        detected_strategy = "scalper"
                                    elif "ELCARO" in raw_upper or "üî• ELCARO" in raw_msg or "üöÄ ELCARO" in raw_msg:
                                        detected_strategy = "elcaro"
                                    elif "FIBONACCI" in raw_upper or "FIBONACCI EXTENSION" in raw_upper:
                                        detected_strategy = "fibonacci"
                                    elif "OI SIGNAL" in raw_upper or "üéØ OI" in raw_msg:
                                        detected_strategy = "oi"
                                    
                                    if detected_strategy:
                                        logger.info(f"[{uid}] Detected strategy from signal: {detected_strategy}")
                                
                                # If no recent signal found or strategy not detected, it's truly external
                                final_strategy = detected_strategy or "manual"
                                
                                # P0.5: Get use_atr from strategy settings
                                cfg_detected = get_user_config(uid) or {}
                                trade_params_detected = get_strategy_trade_params(
                                    uid, cfg_detected, sym, final_strategy,
                                    side=side, account_type=current_account_type
                                )
                                pos_use_atr_detected = trade_params_detected.get("use_atr", False)
                                
                                # DEBUG: Log what trade_params_detected returned for SL/TP
                                logger.info(f"[{uid}] {sym}: trade_params_detected side={side} sl_pct={trade_params_detected.get('sl_pct')} tp_pct={trade_params_detected.get('tp_pct')}")
                                
                                # Get leverage from position data (Bybit returns it)
                                pos_leverage = p.get("leverage")
                                if pos_leverage:
                                    pos_leverage = int(float(pos_leverage))
                                
                                # FIX: For externally opened positions, use actual SL/TP from exchange
                                # instead of strategy settings to preserve user's original SL/TP
                                raw_sl_price = p.get("stopLoss")
                                raw_tp_price = p.get("takeProfit")
                                
                                # Calculate applied_sl_pct from actual SL price (if set on exchange)
                                if raw_sl_price and float(raw_sl_price) > 0 and entry > 0:
                                    actual_sl = float(raw_sl_price)
                                    if side == "Buy":
                                        # For Long: SL is below entry
                                        actual_sl_pct = abs(entry - actual_sl) / entry * 100
                                    else:
                                        # For Short: SL is above entry
                                        actual_sl_pct = abs(actual_sl - entry) / entry * 100
                                    applied_sl = round(actual_sl_pct, 2)
                                    logger.info(f"[{uid}] {sym}: Using actual SL from exchange: price={actual_sl:.6f}, pct={applied_sl}%")
                                else:
                                    applied_sl = trade_params_detected.get("sl_pct")
                                
                                # Calculate applied_tp_pct from actual TP price (if set on exchange)
                                if raw_tp_price and float(raw_tp_price) > 0 and entry > 0:
                                    actual_tp = float(raw_tp_price)
                                    if side == "Buy":
                                        # For Long: TP is above entry
                                        actual_tp_pct = abs(actual_tp - entry) / entry * 100
                                    else:
                                        # For Short: TP is below entry
                                        actual_tp_pct = abs(entry - actual_tp) / entry * 100
                                    applied_tp = round(actual_tp_pct, 2)
                                    logger.info(f"[{uid}] {sym}: Using actual TP from exchange: price={actual_tp:.6f}, pct={applied_tp}%")
                                else:
                                    applied_tp = trade_params_detected.get("tp_pct")
                                
                                add_active_position(
                                    user_id    = uid,
                                    symbol     = sym,
                                    side       = side,
                                    entry_price= entry,
                                    size       = size,
                                    timeframe  = tf_for_sym,
                                    signal_id  = signal_id,
                                    strategy   = final_strategy,
                                    account_type = current_account_type,
                                    exchange   = current_exchange,  # Multitenancy fix
                                    use_atr    = pos_use_atr_detected,  # P0.5
                                    leverage   = pos_leverage,  # Save actual leverage
                                    # Fix: Use actual SL/TP from exchange if available
                                    applied_sl_pct = applied_sl,
                                    applied_tp_pct = applied_tp,
                                    # Fix #3: Save SL/TP prices from exchange
                                    sl_price = float(raw_sl_price) if raw_sl_price and float(raw_sl_price) > 0 else None,
                                    tp_price = float(raw_tp_price) if raw_tp_price and float(raw_tp_price) > 0 else None,
                                )
                                
                                # CRITICAL FIX: Set detected_strategy to final_strategy so that
                                # the SL/TP setting code below uses the correct strategy settings.
                                # Otherwise detected_strategy remains None and global settings are used!
                                detected_strategy = final_strategy
                            
                                if detected_strategy:
                                    logger.info(f"[{uid}] Position {sym} detected with strategy={detected_strategy} from signal")
                                else:
                                    logger.info(f"[{uid}] Position {sym} added with strategy=manual (external/webapp)")

                                # Only send notification if not in cooldown (close_all and anti-flood)
                                cooldown_end = _close_all_cooldown.get(uid, 0)
                                
                                # Anti-flood: Check if we already sent notification for this position recently
                                # Key uses only (uid, sym, account_type) - entry price may fluctuate slightly
                                notify_key = (uid, sym, current_account_type)
                                last_notify_time = _new_position_notified.get(notify_key, 0)
                                notify_cooldown_ok = (now - last_notify_time) > NEW_POSITION_NOTIFY_COOLDOWN
                                
                                if now >= cooldown_end and notify_cooldown_ok:
                                    # Format exchange and market type for display
                                    exchange_display = current_exchange.upper() if current_exchange else "BYBIT"
                                    market_type_display = {
                                        "demo": "Demo",
                                        "real": "Real",
                                        "testnet": "Testnet",
                                        "mainnet": "Mainnet",
                                        "paper": "Paper",
                                        "live": "Live"
                                    }.get(current_account_type, current_account_type.title())
                                
                                    await safe_send_notification(
                                        bot, uid,
                                        t['new_position'].format(
                                            symbol=sym, 
                                            entry=entry, 
                                            size=size,
                                            exchange=exchange_display,
                                            market_type=market_type_display
                                        )
                                    )
                                    
                                    # Mark as notified to prevent flood
                                    _new_position_notified[notify_key] = now
                                elif not notify_cooldown_ok:
                                    logger.debug(f"[{uid}] Skipping new_position notification for {sym} - anti-flood cooldown")

                            if raw_sl in (None, "", "0", 0):
                                # Get strategy: for new positions use detected_strategy,
                                # for existing positions get from active_positions table
                                if detected_strategy:
                                    # New position - use what we just detected
                                    strategy = detected_strategy
                                else:
                                    # Existing or unknown position - get from DB
                                    ap_for_sym = next((ap for ap in active if ap.get("symbol") == sym), None)
                                    strategy = ap_for_sym.get("strategy") if ap_for_sym else None
                                
                                # Check if manual position monitoring is enabled
                                # If strategy is "manual" and trade_manual=0, skip SL/TP management
                                if strategy == "manual" and not cfg.get("trade_manual", 1):
                                    logger.debug(f"[{uid}] {sym}: Manual position - trade_manual disabled, skipping SL/TP")
                                    continue
                            
                                logger.debug(f"[{uid}] {sym}: SL/TP resolution with strategy={strategy}, side={side}")
                            
                                # Determine use_atr: strategy-specific takes priority over global
                                if strategy:
                                    strat_settings = db.get_strategy_settings(uid, strategy, exchange=current_exchange, account_type=current_account_type)
                                    strat_use_atr = strat_settings.get("use_atr")
                                    pos_use_atr = bool(strat_use_atr) if strat_use_atr is not None else use_atr
                                else:
                                    pos_use_atr = use_atr
                            
                                # Use strategy-aware SL/TP resolution WITH side for Scryptomera/Scalper
                                sl_pct, tp_pct = resolve_sl_tp_pct(cfg, sym, strategy=strategy, user_id=uid, side=side)
                                sl_price = round(
                                    entry * (1 - sl_pct/100) if side == "Buy" else entry * (1 + sl_pct/100), 6
                                )
                                tp_price = round(
                                    entry * (1 + tp_pct/100) if side == "Buy" else entry * (1 - tp_pct/100), 6
                                )
                                mark = float(p["markPrice"])
                                raw_tp = p.get("takeProfit")
                                current_tp = float(raw_tp) if raw_tp not in (None, "", 0, "0", 0.0) else None

                                try:
                                    # Check if we should notify about SL/TP changes
                                    # 1. Skip if position existed in previous iteration (not new)
                                    # 2. Skip if we're in cooldown period (positions being closed)
                                    # 3. Skip if we already notified for this position
                                    # 4. Skip if position already exists in DB (to avoid spam after bot restart)
                                    cooldown_end = _close_all_cooldown.get(uid, 0)
                                    sl_notify_key = (uid, sym)
                                    already_notified = sl_notify_key in _sl_notified
                                    position_existed_in_db = sym in existing_syms
                                    should_notify = (sym not in open_syms_prev) and (now >= cooldown_end) and not already_notified and not position_existed_in_db
                                
                                    # Helper to handle deep loss notification
                                    async def notify_deep_loss(symbol, side, entry, mark, move_pct):
                                        deep_loss_key = (uid, symbol)
                                        logger.info(f"[{uid}] {symbol}: Sending deep loss notification (loss: {move_pct:.2f}%)")
                                        if deep_loss_key in _deep_loss_notified:
                                            logger.debug(f"[{uid}] {symbol}: Already notified about deep loss, skipping")
                                            return  # Already notified
                                        _deep_loss_notified[deep_loss_key] = now
                                    
                                        # Calculate loss percentage
                                        loss_pct = abs(move_pct)
                                    
                                        # Create inline keyboard with options
                                        keyboard = [
                                            [
                                                InlineKeyboardButton(
                                                    t.get('btn_close_position', '‚ùå –ó–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é'),
                                                    callback_data=f"deep_loss:close:{symbol}"
                                                )
                                            ],
                                            [
                                                InlineKeyboardButton(
                                                    t.get('btn_enable_dca', 'üìà –í–∫–ª—é—á–∏—Ç—å DCA –¥–æ–±–æ—Ä'),
                                                    callback_data=f"deep_loss:dca:{symbol}"
                                                )
                                            ],
                                            [
                                                InlineKeyboardButton(
                                                    t.get('btn_ignore', 'üîá –ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å'),
                                                    callback_data=f"deep_loss:ignore:{symbol}"
                                                )
                                            ]
                                        ]
                                    
                                        msg_text = t.get('deep_loss_alert', 
                                            "‚ö†Ô∏è <b>–ü–æ–∑–∏—Ü–∏—è –≤ –≥–ª—É–±–æ–∫–æ–º –º–∏–Ω—É—Å–µ!</b>\n\n"
                                            "üìä <b>{symbol}</b> ({side})\n"
                                            "üìâ –£–±—ã—Ç–æ–∫: <code>{loss_pct:.2f}%</code>\n"
                                            "üí∞ –í—Ö–æ–¥: <code>{entry}</code>\n"
                                            "üìç –¢–µ–∫—É—â–∞—è: <code>{mark}</code>\n\n"
                                            "‚ùå –°—Ç–æ–ø-–ª–æ—Å—Å –Ω–µ–≤–æ–∑–º–æ–∂–Ω–æ —É—Å—Ç–∞–Ω–æ–≤–∏—Ç—å –≤—ã—à–µ —Ü–µ–Ω—ã –≤—Ö–æ–¥–∞.\n\n"
                                            "<b>–ß—Ç–æ –¥–µ–ª–∞—Ç—å?</b>\n"
                                            "‚Ä¢ <b>–ó–∞–∫—Ä—ã—Ç—å</b> - –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞—Ç—å —É–±—ã—Ç–æ–∫\n"
                                            "‚Ä¢ <b>DCA –¥–æ–±–æ—Ä</b> - —É—Å—Ä–µ–¥–Ω–∏—Ç—å –ø–æ–∑–∏—Ü–∏—é –¥–æ–±–æ—Ä–∞–º–∏\n"
                                            "‚Ä¢ <b>–ò–≥–Ω–æ—Ä–∏—Ä–æ–≤–∞—Ç—å</b> - –æ—Å—Ç–∞–≤–∏—Ç—å –∫–∞–∫ –µ—Å—Ç—å"
                                        ).format(
                                            symbol=symbol,
                                            side="LONG" if side == "Buy" else "SHORT",
                                            loss_pct=loss_pct,
                                            entry=entry,
                                            mark=mark
                                        )
                                    
                                        try:
                                            await safe_send_notification(
                                                bot, uid,
                                                msg_text,
                                                parse_mode="HTML",
                                                reply_markup=InlineKeyboardMarkup(keyboard)
                                            )
                                        except Exception as e:
                                            logger.warning(f"Failed to send deep loss notification to {uid}: {e}")
                                
                                    if not pos_use_atr:
                                        kwargs = {"sl_price": sl_price}
                                        if current_tp is None:
                                            if (side == "Buy" and tp_price > mark) or (side == "Sell" and tp_price < mark):
                                                kwargs["tp_price"] = tp_price
                                        try:
                                            result = await set_trading_stop(uid, sym, **kwargs, side_hint=side, account_type=current_account_type, exchange=current_exchange)
                                        
                                            if result == "deep_loss":
                                                # Calculate move_pct for deep loss notification
                                                move_pct_local = ((mark - entry) / entry * 100 if side == "Buy" else (entry - mark) / entry * 100) if entry > 0 else 0.0
                                                logger.debug(f"[{uid}] {sym} deep_loss: entry={entry}, mark={mark}, side={side}, move_pct={move_pct_local:.2f}%")
                                                await notify_deep_loss(sym, side, entry, mark, move_pct_local)
                                                continue
                                        except RuntimeError as e:
                                            if "no open positions" in str(e).lower():
                                                logger.debug(f"{sym}: Position closed before SL/TP could be set")
                                                continue
                                            raise
                                        # Only notify if truly new position AND not in cooldown AND not already notified
                                        if should_notify:
                                            _sl_notified[sl_notify_key] = now
                                            if "tp_price" in kwargs:
                                                await safe_send_notification(
                                                    bot, uid,
                                                    t['fixed_sl_tp'].format(symbol=sym, sl=sl_price, tp=tp_price)
                                                )
                                            else:
                                                await safe_send_notification(
                                                    bot, uid,
                                                    t['sl_set_only'].format(symbol=sym, sl_price=sl_price)
                                                )
                                    else:
                                        try:
                                            result = await set_trading_stop(uid, sym, sl_price=sl_price, side_hint=side, account_type=current_account_type, exchange=current_exchange)
                                            if result == "deep_loss":
                                                # Calculate move_pct for deep loss notification
                                                move_pct_local = (mark - entry) / entry * 100 if side == "Buy" else (entry - mark) / entry * 100
                                                logger.debug(f"[{uid}] {sym} deep_loss ATR: entry={entry}, mark={mark}, side={side}, move_pct={move_pct_local:.2f}%")
                                                await notify_deep_loss(sym, side, entry, mark, move_pct_local)
                                                continue
                                        except RuntimeError as e:
                                            if "no open positions" in str(e).lower():
                                                logger.debug(f"{sym}: Position closed before SL could be set")
                                                continue
                                            raise
                                        # Only notify if truly new position AND not in cooldown AND not already notified
                                        if should_notify:
                                            _sl_notified[sl_notify_key] = now
                                            await safe_send_notification(bot, uid, t['sl_auto_set'].format(price=sl_price))
                                except Exception as e:
                                    if "no open positions" not in str(e).lower():
                                        logger.error(f"Errors with SL/TP for {sym}: {e}")

                        active = get_active_positions(uid, account_type=current_account_type, exchange=current_exchange)

                        for ap in active:
                            sym = ap.get("symbol")
                            if not sym:
                                continue  # Skip invalid positions
                            # CRITICAL: Use current_account_type from loop as fallback, not "demo"
                            ap_account_type = ap.get("account_type") or current_account_type

                            if _skip_until.get((uid, sym), 0) > now:
                                continue

                            if sym not in open_syms:
                                logger.info(f"[{uid}] Position {sym} closed - detecting reason...")
                                # CRITICAL: Pass account_type AND exchange to get correct closed PnL
                                try:
                                    rec = await fetch_last_closed_pnl(uid, sym, account_type=ap_account_type, exchange=current_exchange)
                                except Exception as e:
                                    # Transient API error (rate limit, timeout) ‚Äî skip this position
                                    # to avoid removing it from DB when we can't verify it's truly closed
                                    logger.warning(f"[{uid}] {sym}: fetch_last_closed_pnl transient error, skipping: {e}")
                                    continue
                            
                                if rec is None:
                                    # No closed PnL record - clean up silently
                                    logger.debug(f"[{uid}] No closed PnL for {sym}, cleaning up")
                                    try:
                                        # Pass entry_price to avoid race condition
                                        remove_active_position(uid, sym, account_type=ap_account_type, entry_price=ap.get("entry_price"), exchange=current_exchange)
                                        reset_pyramid(uid, sym)
                                    finally:
                                        _atr_triggered.pop((uid, sym, ap_account_type), None)
                                        _atr_was_enabled.pop((uid, sym, ap_account_type), None)  # Clear ATR was enabled cache
                                        _atr_tp_removal_done.pop((uid, sym, ap_account_type), None)  # Clear TP removal cooldown
                                        _be_triggered.pop((uid, sym, ap_account_type), None)  # Clear BE cache
                                        _sl_notified.pop((uid, sym), None)
                                        _deep_loss_notified.pop((uid, sym), None)
                                        # Clear new position notification cache
                                        _new_position_notified.pop((uid, sym, ap_account_type), None)
                                        # Clear HL SL cache and fail cooldown
                                        _hl_sl_cache.pop((uid, sym), None)
                                        _hl_sl_fail_cooldown.pop((uid, sym), None)
                                    continue
                            
                                logger.info(f"[{uid}] Closed PnL for {sym}: entry={rec.get('avgEntryPrice')}, exit={rec.get('avgExitPrice')}, pnl={rec.get('closedPnl')}")


                                # Safe extraction with validation
                                raw_entry = rec.get("avgEntryPrice")
                                raw_exit = rec.get("avgExitPrice")
                                if not raw_entry or not raw_exit:
                                    logger.warning(f"[{uid}] Skipping {sym} closed PnL - missing entry/exit price")
                                    continue
                                entry_price = float(raw_entry)
                                exit_price  = float(raw_exit)
                                pos_side = ap.get("side", "Buy")
                                
                                # CRITICAL: Validate that closed PnL record matches our position
                                # Bybit API may return stale data from previous positions
                                db_entry_price = ap.get("entry_price")
                                if db_entry_price:
                                    price_diff_pct = abs(entry_price - db_entry_price) / db_entry_price * 100
                                    if price_diff_pct > 3.0:  # >3% difference means wrong record
                                        logger.warning(
                                            f"[{uid}] {sym}: Closed PnL entry price mismatch! "
                                            f"API={entry_price:.6f}, DB={db_entry_price:.6f}, diff={price_diff_pct:.1f}%. "
                                            f"Skipping - waiting for correct closed PnL record."
                                        )
                                        # Skip processing this iteration - wait for fresh data
                                        continue
                            
                                # Get strategy-specific SL/TP percentages for better detection
                                position_strategy = ap.get("strategy")
                                if position_strategy:
                                    strat_sl, strat_tp = resolve_sl_tp_pct(cfg, sym, strategy=position_strategy, user_id=uid, side=pos_side)
                                else:
                                    strat_sl = float(cfg.get("sl_percent") or DEFAULT_SL_PCT)
                                    strat_tp = float(cfg.get("tp_percent") or DEFAULT_TP_PCT)
                                
                                # Check if ATR trailing was activated for this position
                                atr_was_activated = bool(ap.get("atr_activated", 0))
                            
                                exit_reason, exit_order_type = await detect_exit_reason(
                                    uid, sym, 
                                    entry_price=entry_price, 
                                    exit_price=exit_price, 
                                    side=pos_side,
                                    sl_pct=strat_sl,
                                    tp_pct=strat_tp,
                                    atr_activated=atr_was_activated,
                                    account_type=ap_account_type
                                )
                                logger.info(f"[{uid}] Exit reason for {sym}: {exit_reason} (order_type={exit_order_type}, atr_activated={atr_was_activated})")
                                reason_text = format_exit_reason(exit_reason)  # Use formatted label with emoji

                                try:
                                    sig = fetch_signal_by_id(ap.get("signal_id")) or {}
                                    
                                    # Calculate PnL for deduplication check
                                    size_for_pnl = float(rec.get("closedSize") or ap.get("size") or 0.0)
                                    ap_side = ap.get("side") or "Buy"
                                    pnl_for_check = (exit_price - entry_price) * size_for_pnl * (1 if ap_side == "Buy" else -1)
                                    
                                    # DEDUPLICATION: Check if this closure was already processed
                                    # Key includes entry_price and pnl to identify unique trades
                                    closure_key = (uid, sym, round(entry_price, 4), round(pnl_for_check, 2))
                                    now_ts = int(time.time())
                                    CLOSURE_COOLDOWN = 86400  # 24 hours
                                    
                                    if closure_key in _processed_closures:
                                        last_processed = _processed_closures[closure_key]
                                        if now_ts - last_processed < CLOSURE_COOLDOWN:
                                            logger.debug(
                                                f"[{uid}] Skipping already processed closure: {sym} "
                                                f"entry={entry_price:.4f} pnl={pnl_for_check:.2f} "
                                                f"(processed {now_ts - last_processed}s ago)"
                                            )
                                            # Still try to remove the position from active_positions
                                            remove_active_position(uid, sym, account_type=ap_account_type, entry_price=entry_price, exchange=current_exchange)
                                            continue
                                    
                                    # NOTE: _processed_closures is set AFTER successful log_exit_and_remove_position
                                    # to allow retry on failure (moved from here to after line ~21185)
                                    
                                    # Cleanup old entries (keep last 24 hours only)
                                    if len(_processed_closures) > 1000:
                                        cutoff = now_ts - CLOSURE_COOLDOWN
                                        _processed_closures = {k: v for k, v in _processed_closures.items() if v > cutoff}
                                
                                    # Determine strategy: from position or fallback to signal detection
                                    # CRITICAL FIX: If position has signal_id but strategy is "manual",
                                    # it means position was detected after bot restart. Detect from signal!
                                    should_detect_from_signal = (
                                        not position_strategy or 
                                        (position_strategy == "manual" and ap.get("signal_id"))
                                    )
                                    if should_detect_from_signal and sig:
                                        raw_msg = sig.get("raw_data") or ""  # Column is 'raw_data' in DB
                                        # Use parsers for reliable strategy detection
                                        # CRITICAL: Check RSI_BB FIRST (most common signal type)
                                        if is_rsi_bb_signal(raw_msg):
                                            position_strategy = "rsi_bb"
                                        elif is_fibonacci_signal(raw_msg):
                                            position_strategy = "fibonacci"
                                        elif is_bitk_signal(raw_msg):
                                            position_strategy = "scryptomera"
                                        elif is_scalper_signal(raw_msg):
                                            position_strategy = "scalper"
                                        elif is_elcaro_signal(raw_msg):
                                            position_strategy = "elcaro"
                                        elif is_oi_signal(raw_msg):
                                            position_strategy = "oi"
                                        else:
                                            # Fallback to legacy keyword detection
                                            raw_upper = raw_msg.upper()
                                            if "DropsBot" in raw_msg or "DROP CATCH" in raw_msg or "TIGHTBTC" in raw_msg or "SCRYPTOMERA" in raw_upper:
                                                position_strategy = "scryptomera"
                                            elif "‚ö°" in raw_msg and "Scalper" in raw_msg:
                                                position_strategy = "scalper"
                                            elif "üöÄ Enliko" in raw_msg or "Enliko" in raw_msg or "ELCARO" in raw_upper:
                                                position_strategy = "elcaro"
                                            elif "Fibonacci" in raw_msg or "FIBONACCI EXTENSION" in raw_upper:
                                                position_strategy = "fibonacci"
                                            elif "OI SIGNAL" in raw_upper or "üéØ OI" in raw_msg:
                                                position_strategy = "oi"
                                    
                                    # Calculate trading fee (commission)
                                    # Bybit linear futures fee: taker 0.055%, maker 0.02%
                                    # HyperLiquid perpetual fee: taker 0.035%, maker 0.01%
                                    if current_exchange == 'hyperliquid':
                                        FEE_RATE = 0.00035  # 0.035% taker fee
                                    else:
                                        FEE_RATE = 0.00055  # 0.055% taker fee (Bybit)
                                    entry_value = entry_price * size_for_pnl
                                    exit_value = exit_price * size_for_pnl
                                    fee_paid = (entry_value + exit_value) * FEE_RATE
                                
                                    log_exit_and_remove_position(
                                        user_id=uid,
                                        signal_id=ap.get("signal_id"),
                                        symbol=sym,
                                        side=ap.get("side") or side,
                                        entry_price=entry_price,
                                        exit_price=exit_price,
                                        exit_reason=exit_reason,
                                        size=size_for_pnl,
                                        signal_source=("bitk" if (sig.get("raw_data") and ("DROP CATCH" in sig["raw_data"] or "TIGHTBTC" in sig["raw_data"])) else None),
                                        rsi=sig.get("rsi"), bb_hi=sig.get("bb_hi"), bb_lo=sig.get("bb_lo"),
                                        oi_prev=sig.get("oi_prev"), oi_now=sig.get("oi_now"), oi_chg=sig.get("oi_chg"),
                                        vol_from=sig.get("vol_from"), vol_to=sig.get("vol_to"),
                                        price_chg=sig.get("price_chg"), vol_delta=sig.get("vol_delta"),
                                        sl_price=exit_price if exit_reason in ("SL", "ATR_SL") else None,
                                        tp_price=exit_price if exit_reason=="TP" else None,
                                        timeframe=ap.get("timeframe"),
                                        entry_ts_ms=int(_parse_sqlite_ts_to_utc(ap.get("open_ts")) * 1000) if ap.get("open_ts") else None,
                                        exit_order_type=exit_order_type,
                                        strategy=position_strategy,
                                        account_type=ap_account_type,
                                        # Fix #2: Use saved SL/TP % from position open time
                                        applied_sl_pct=ap.get("applied_sl_pct"),
                                        applied_tp_pct=ap.get("applied_tp_pct"),
                                        # Fix #4: Save exchange
                                        exchange=ap.get("exchange") or current_exchange or "bybit",
                                        # Trading fee (commission)
                                        fee=fee_paid,
                                    )

                                    # Mark as processed ONLY after successful log_exit_and_remove_position
                                    _processed_closures[closure_key] = now_ts

                                    pnl_from_exch = rec.get("closedPnl")
                                    rate_from_exch = rec.get("closedPnlRate")  # ROE as decimal (0.05 = 5%)
                                    leverage = float(rec.get("leverage") or ap.get("leverage") or 10)
                                
                                    size_for_calc = float(rec.get("closedSize") or ap.get("size") or 0.0)
                                    pnl_calc, pct_calc = _calc_pnl(entry_price, exit_price, ap_side, size_for_calc)
                                
                                    # PnL value (prefer Bybit API)
                                    try:
                                        pnl_value = float(pnl_from_exch)
                                    except Exception:
                                        pnl_value = pnl_calc
                                
                                    # Percent value - show PRICE CHANGE %, not ROE
                                    # Our calc_qty formula doesn't use leverage, so showing ROE is misleading
                                    # We show the actual price change percentage instead
                                    pct_value = None
                                    if rate_from_exch is not None:
                                        try:
                                            # Bybit closedPnlRate is ROE - convert back to price change
                                            roe_pct = float(rate_from_exch) * 100.0
                                            # Price change = ROE / leverage
                                            pct_value = roe_pct / leverage if leverage > 0 else roe_pct
                                        except Exception:
                                            pass
                                
                                    # Fallback: use calculated price change directly (no leverage multiplication)
                                    if pct_value is None:
                                        pct_value = pct_calc  # Just price change %, NOT multiplied by leverage
                                    
                                    # CRITICAL: Ensure pct_value sign matches pnl_value sign
                                    # Sometimes Bybit API returns wrong sign for closedPnlRate
                                    if pnl_value > 0 and pct_value < 0:
                                        pct_value = abs(pct_value)
                                        logger.warning(f"[{uid}] {sym}: Fixed pct sign mismatch (pnl={pnl_value}, pct was negative)")
                                    elif pnl_value < 0 and pct_value > 0:
                                        pct_value = -abs(pct_value)
                                        logger.warning(f"[{uid}] {sym}: Fixed pct sign mismatch (pnl={pnl_value}, pct was positive)")
                                
                                    logger.info(f"[{uid}] PnL details for {sym}: pnl={pnl_value:.2f}, rate_from_api={rate_from_exch}, pct={pct_value:.2f}%, leverage={leverage}")
                                
                                    # Get strategy name for display (use already determined position_strategy)
                                    strategy_name = position_strategy or "unknown"
                                    
                                    strategy_display = {
                                        "scryptomera": "Scryptomera",
                                        "scalper": "Scalper", 
                                        "rsi_bb": "RSI+BB",
                                        "oi": "OI",
                                        "elcaro": "Enliko",
                                        "fibonacci": "Fibonacci",
                                        "webapp": "WebApp",
                                        "manual": "Manual",
                                        "unknown": "Unknown",
                                    }.get(strategy_name, strategy_name.title())
                                    
                                    # Format exchange and market type for display
                                    exchange_display = current_exchange.upper() if current_exchange else "BYBIT"
                                    market_type_display = {
                                        "demo": "Demo",
                                        "real": "Real",
                                        "testnet": "Testnet",
                                        "mainnet": "Mainnet",
                                        "paper": "Paper",
                                        "live": "Live"
                                    }.get(current_account_type, current_account_type.title())
                                
                                    # Deduplication: check if close notification already sent (prevents spam when remove_active_position fails)
                                    close_notify_key = (uid, sym, ap_account_type)
                                    now = int(time.time())
                                    CLOSE_NOTIFY_COOLDOWN = 3600  # 1 hour cooldown for same position close
                                    last_close_notify = _close_notified.get(close_notify_key, 0)
                                    
                                    if now - last_close_notify < CLOSE_NOTIFY_COOLDOWN:
                                        logger.debug(f"[{uid}] Skipping close notification for {sym} (already sent {now - last_close_notify}s ago)")
                                    else:
                                        _close_notified[close_notify_key] = now
                                        logger.info(f"[{uid}] Sending close notification for {sym}: reason={reason_text}, strategy={strategy_display}, pnl={pnl_value:.2f}, fee={fee_paid:.4f}")
                                        
                                        # Select strategy-specific close template
                                        close_template_key = {
                                            "oi": "oi_closed",
                                            "scryptomera": "scryptomera_closed",
                                            "scalper": "scalper_closed",
                                            "elcaro": "elcaro_closed",
                                            "fibonacci": "fibonacci_closed",
                                            "rsi_bb": "rsi_bb_closed",
                                        }.get(strategy_name, "position_closed")
                                        
                                        # Calculate net PnL (after fee)
                                        net_pnl = pnl_value - fee_paid
                                        
                                        close_message = t.get(close_template_key, t['position_closed']).format(
                                            symbol=sym,
                                            reason=reason_text,
                                            strategy=strategy_display,
                                            entry=float(entry_price),
                                            exit=float(exit_price),
                                            pnl=pnl_value,
                                            pct=pct_value,
                                            exchange=exchange_display,
                                            market_type=market_type_display,
                                            fee=fee_paid,
                                            net_pnl=net_pnl,
                                        )
                                        
                                        await safe_send_notification(
                                            bot, uid,
                                            close_message,
                                            parse_mode="Markdown"
                                        )
                                        
                                        # Send iOS/WebApp push notification (APNs)
                                        if notification_service:
                                            try:
                                                await notification_service.send_position_closed_notification(
                                                    user_id=uid,
                                                    position_data={
                                                        'symbol': sym,
                                                        'side': ap_side,
                                                        'entry_price': entry_price,
                                                        'exit_price': exit_price,
                                                        'quantity': size_for_pnl,
                                                        'pnl': pnl_value,
                                                        'pnl_percent': pct_value,
                                                        'strategy': strategy_display,
                                                        'close_reason': exit_reason,
                                                    },
                                                    t=t
                                                )
                                            except Exception as push_err:
                                                logger.warning(f"Failed to send push notification for {sym}: {push_err}")

                                except Exception as e:
                                    logger.error(f"[{uid}] {sym}: Error processing position closure: {e}", exc_info=True)
                                    if is_db_full_error(e):
                                        if once_per((uid, "db_full", sym), NOTICE_WINDOW):
                                            await safe_send_notification(
                                                bot, uid,
                                                f"Logs are temporarily not written (there is not enough space). On {sym}, I switch to silent mode for 1 hour."
                                            )
                                        _skip_until[(uid, sym)] = int(time.time()) + MUTE_TTL
                                    else:
                                        if once_per((uid, "position_closed_error", sym), 300):
                                            await safe_send_notification(bot, uid, t['position_closed_error'].format(symbol=sym, error=str(e)))
                                finally:
                               
                                    try:
                                        reset_pyramid(uid, sym)
                                    finally:
                                        _atr_triggered.pop((uid, sym, ap_account_type), None)
                                        _atr_was_enabled.pop((uid, sym, ap_account_type), None)  # Clear ATR was enabled cache
                                        _atr_tp_removal_done.pop((uid, sym, ap_account_type), None)  # Clear TP removal cooldown
                                        _be_triggered.pop((uid, sym, ap_account_type), None)  # Clear BE cache
                                        _sl_notified.pop((uid, sym), None)  # Clear SL notification cache
                                        _deep_loss_notified.pop((uid, sym), None)  # Clear deep loss notification cache
                                        _hl_sl_cache.pop((uid, sym), None)  # Clear HL SL cache
                                        _hl_sl_fail_cooldown.pop((uid, sym), None)  # Clear HL SL fail cooldown

                        active = get_active_positions(uid, account_type=current_account_type, exchange=current_exchange)
                        tf_map = { ap['symbol']: ap.get('timeframe','15m') for ap in active }  # Default 15m
                        strategy_map = { ap['symbol']: ap.get('strategy') for ap in active }
                        # Use current_account_type as fallback instead of hardcoded 'demo'
                        account_type_map = { ap['symbol']: ap.get('account_type') or current_account_type for ap in active }
                        db_syms = set(tf_map.keys())

                        for pos in open_positions:
                            sym        = pos["symbol"]
                            side       = pos["side"]
                            entry      = float(pos["avgPrice"])
                            raw_sl     = pos.get("stopLoss")
                            raw_tp     = pos.get("takeProfit")
                            current_sl = float(raw_sl) if raw_sl not in (None, "", 0, "0", 0.0) else None
                            current_tp = float(raw_tp) if raw_tp not in (None, "", 0, "0", 0.0) else None
                            
                            # HyperLiquid workaround: HL API doesn't return stopLoss in position data
                            # Use cached SL value if available (set by our set_tp_sl calls)
                            logger.info(f"[{uid}] {sym}: current_exchange={current_exchange}, raw_sl='{raw_sl}', current_sl={current_sl}")
                            if current_sl is None and current_exchange == "hyperliquid":
                                cached_sl = _hl_sl_cache.get((uid, sym))
                                if cached_sl is not None:
                                    current_sl = cached_sl
                                    logger.info(f"[{uid}] {sym} HL: Using cached SL = {current_sl}")
                                else:
                                    logger.info(f"[{uid}] {sym} HL: No cached SL found for key ({uid}, {sym}), cache has {len(_hl_sl_cache)} entries")
                            
                            # Log if position is not tracked in DB
                            if sym not in db_syms:
                                logger.debug(f"[{uid}] {sym}: Position not in active_positions DB, using default tf=15m")
                            
                            # Get DB entry for comparison
                            ap_for_sym = next((ap for ap in active if ap.get("symbol") == sym), None)
                            db_entry = float(ap_for_sym.get("entry_price") or 0) if ap_for_sym else 0
                            
                            # Sync entry_price if changed (DCA/averaging)
                            # This ensures SL is recalculated from the correct entry
                            entry_changed = False
                            if db_entry > 0 and entry > 0:
                                entry_diff_pct = abs(entry - db_entry) / db_entry * 100
                                if entry_diff_pct > 0.1:  # Entry changed by >0.1%
                                    try:
                                        pos_account_type = account_type_map.get(sym, current_account_type)
                                        if db.sync_position_entry_price(uid, sym, entry, pos_account_type, exchange=current_exchange):
                                            logger.info(f"[{uid}] {sym}: Entry synced {db_entry:.6f} ‚Üí {entry:.6f} (diff={entry_diff_pct:.2f}%)")
                                            entry_changed = True
                                    except Exception as e:
                                        logger.warning(f"[{uid}] {sym}: Failed to sync entry: {e}")

                            coin_cfg    = COIN_PARAMS.get(sym, COIN_PARAMS["DEFAULT"])
                        
                            # Get strategy for this position
                            pos_strategy = strategy_map.get(sym)
                        
                            # Fallback: try to determine strategy from signal if not in DB
                            if not pos_strategy:
                                if ap_for_sym and ap_for_sym.get("signal_id"):
                                    sig = fetch_signal_by_id(ap_for_sym["signal_id"])
                                    if sig:
                                        raw_msg = sig.get("raw_data") or ""  # Column is 'raw_data' in DB
                                        raw_upper = raw_msg.upper()
                                        if "SCRYPTOMERA" in raw_upper or "DROP CATCH" in raw_msg:
                                            pos_strategy = "scryptomera"
                                        elif "SCALPER" in raw_upper or "‚ö°" in raw_msg:
                                            pos_strategy = "scalper"
                                        elif "ELCARO" in raw_upper or "üî•" in raw_msg:
                                            pos_strategy = "elcaro"
                                        elif sig.get("source"):
                                            source = sig.get("source", "").lower()
                                            if "scryptomera" in source or "bitk" in source:
                                                pos_strategy = "scryptomera"
                                            elif "scalper" in source:
                                                pos_strategy = "scalper"
                                            elif "elcaro" in source:
                                                pos_strategy = "elcaro"
                                    
                                        # Update DB with detected strategy for future iterations
                                        if pos_strategy:
                                            logger.info(f"[{uid}] {sym}: Detected strategy={pos_strategy} from signal, updating DB")
                                            try:
                                                pos_account_type = account_type_map.get(sym, current_account_type)
                                                update_position_strategy(uid, sym, pos_strategy, account_type=pos_account_type, exchange=current_exchange)
                                            except Exception as e:
                                                logger.warning(f"[{uid}] Failed to update position strategy: {e}")
                        
                            # Get SL/TP from strategy settings if available, otherwise use global
                            if pos_strategy:
                                # Get context for this position
                                pos_context = get_user_trading_context(uid)
                                pos_acct = account_type_map.get(sym, pos_context["account_type"])
                                strat_params = get_strategy_trade_params(uid, cfg, sym, pos_strategy, side=side,
                                                                         exchange=pos_context["exchange"], account_type=pos_acct)
                                sl_pct = strat_params["sl_pct"]
                                tp_pct = strat_params["tp_pct"]
                                risk_pct_for_dca = strat_params["percent"]
                            else:
                                raw_user_sl = cfg.get("sl_percent", 0)
                                if 0 < raw_user_sl <= 50:
                                    sl_pct = raw_user_sl
                                else:
                                    sl_pct = coin_cfg.get("sl_pct", DEFAULT_SL_PCT)
                                raw_user_tp = cfg.get("tp_percent", 0)
                                if raw_user_tp > sl_pct:
                                    tp_pct = raw_user_tp
                                else:
                                    tp_pct = coin_cfg.get("tp_pct", DEFAULT_TP_PCT)
                                risk_pct_for_dca = float(cfg.get("percent", 1) or 0)

                            # CRITICAL FIX: Use applied_sl_pct/applied_tp_pct from position if saved
                            # This ensures SL/TP is calculated from the settings at position open time,
                            # not current user settings (which may have changed!)
                            if ap_for_sym:
                                applied_sl = ap_for_sym.get("applied_sl_pct")
                                applied_tp = ap_for_sym.get("applied_tp_pct")
                                if applied_sl is not None and applied_sl > 0:
                                    sl_pct = float(applied_sl)
                                    logger.debug(f"[{uid}] {sym}: Using applied_sl_pct={sl_pct} from position open time")
                                if applied_tp is not None and applied_tp > 0:
                                    tp_pct = float(applied_tp)
                                    logger.debug(f"[{uid}] {sym}: Using applied_tp_pct={tp_pct} from position open time")

                            tf          = tf_map.get(sym, "15m")  # Default to 15m if not in DB for more responsive ATR
                            tf_cfg      = TIMEFRAME_PARAMS.get(tf, TIMEFRAME_PARAMS["15m"])
                        
                            # Get account_type for this position from map (moved up for strategy settings)
                            pos_account_type = account_type_map.get(sym, current_account_type)
                        
                            # Get ATR params: priority is side-specific > strategy settings > timeframe defaults
                            if pos_strategy:
                                strat_settings = db.get_strategy_settings(uid, pos_strategy, exchange=current_exchange, account_type=pos_account_type)
                                side_prefix = "long" if side == "Buy" else "short"
                            
                                # Get side-specific ATR settings, fallback to general, then timeframe defaults
                                side_atr_periods = strat_settings.get(f"{side_prefix}_atr_periods")
                                side_atr_mult = strat_settings.get(f"{side_prefix}_atr_multiplier_sl")
                                side_atr_trigger = strat_settings.get(f"{side_prefix}_atr_trigger_pct")
                            
                                atr_periods = side_atr_periods if side_atr_periods is not None else (
                                    strat_settings.get("atr_periods") if strat_settings.get("atr_periods") is not None else tf_cfg["atr_periods"]
                                )
                                atr_mult_sl = side_atr_mult if side_atr_mult is not None else (
                                    strat_settings.get("atr_multiplier_sl") if strat_settings.get("atr_multiplier_sl") is not None else tf_cfg["atr_multiplier_sl"]
                                )
                                trigger_pct = side_atr_trigger if side_atr_trigger is not None else (
                                    strat_settings.get("atr_trigger_pct") if strat_settings.get("atr_trigger_pct") is not None else tf_cfg["atr_trigger_pct"]
                                )
                            
                                # ATR use_atr priority:
                                # 1. Current strategy settings with side prefix (so user can change ATR for open positions!)
                                # 2. Saved use_atr in position (fallback if strategy has no setting)
                                # 3. Global use_atr
                                # NOTE: pg_get_strategy_settings returns use_atr as {side}_use_atr (e.g., long_use_atr, short_use_atr)
                                side_use_atr = strat_settings.get(f"{side_prefix}_use_atr")
                                if side_use_atr is not None:
                                    position_use_atr = bool(side_use_atr)
                                    logger.debug(f"[{uid}] {sym}: ATR use_atr from strategy settings: {side_prefix}_use_atr={side_use_atr}")
                                else:
                                    # Fallback to saved use_atr from position
                                    saved_use_atr = ap_for_sym.get("use_atr") if ap_for_sym else None
                                    if saved_use_atr is not None:
                                        position_use_atr = bool(saved_use_atr)
                                        logger.debug(f"[{uid}] {sym}: ATR use_atr from position: {saved_use_atr}")
                                    else:
                                        position_use_atr = use_atr
                                        logger.debug(f"[{uid}] {sym}: ATR use_atr from global: {use_atr}")
                                
                                # Log side-specific settings resolution for debugging
                                logger.debug(f"[{uid}] {sym}: Side-specific ATR - side={side}, prefix={side_prefix}, "
                                            f"side_trigger={side_atr_trigger}, strat_trigger={strat_settings.get('atr_trigger_pct')}, tf_trigger={tf_cfg['atr_trigger_pct']}, final_trigger={trigger_pct}")
                            else:
                                atr_periods = tf_cfg["atr_periods"]
                                atr_mult_sl = tf_cfg["atr_multiplier_sl"]
                                trigger_pct = tf_cfg["atr_trigger_pct"]
                                # Check saved use_atr for positions without strategy, then global
                                saved_use_atr = ap_for_sym.get("use_atr") if ap_for_sym else None
                                if saved_use_atr is not None:
                                    position_use_atr = bool(saved_use_atr)
                                else:
                                    position_use_atr = use_atr  # Use global setting

                            # Log ATR params being used (INFO for production visibility)
                            logger.info(f"[{uid}] {sym}: ATR use_atr={position_use_atr} trigger={trigger_pct}% strategy={pos_strategy} side={side}")

                            # Get Break-Even (BE) params: priority is side-specific > strategy settings > global
                            if pos_strategy:
                                side_prefix = "long" if side == "Buy" else "short"
                                
                                # Get side-specific BE settings, fallback to general, then global
                                side_be_enabled = strat_settings.get(f"{side_prefix}_be_enabled")
                                side_be_trigger = strat_settings.get(f"{side_prefix}_be_trigger_pct")
                                
                                be_enabled = bool(side_be_enabled) if side_be_enabled is not None else (
                                    bool(strat_settings.get("be_enabled")) if strat_settings.get("be_enabled") is not None else bool(cfg.get("be_enabled", 0))
                                )
                                be_trigger_pct = float(side_be_trigger) if side_be_trigger is not None and side_be_trigger > 0 else (
                                    float(strat_settings.get("be_trigger_pct")) if strat_settings.get("be_trigger_pct") and strat_settings.get("be_trigger_pct") > 0 else float(cfg.get("be_trigger_pct", 1.0))
                                )
                                
                                logger.debug(f"[{uid}] {sym}: BE params - be_enabled={be_enabled}, be_trigger_pct={be_trigger_pct}")
                            else:
                                be_enabled = bool(cfg.get("be_enabled", 0))
                                be_trigger_pct = float(cfg.get("be_trigger_pct", 1.0))

                            mark     = float(pos["markPrice"])
                            move_pct = (mark - entry) / entry * 100 if side == "Buy" else (entry - mark) / entry * 100
                            key = (uid, sym, pos_account_type)

                            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            # DCA SETTINGS: Per-strategy/side with fallback to global
                            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            if pos_strategy and strat_settings:
                                side_prefix = "long" if side == "Buy" else "short"
                                
                                # Get side-specific DCA settings
                                side_dca_enabled = strat_settings.get(f"{side_prefix}_dca_enabled")
                                side_dca_pct_1 = strat_settings.get(f"{side_prefix}_dca_pct_1")
                                side_dca_pct_2 = strat_settings.get(f"{side_prefix}_dca_pct_2")
                                
                                # Fallback chain: side-specific > strategy-level > global
                                dca_enabled = bool(side_dca_enabled) if side_dca_enabled is not None else (
                                    bool(strat_settings.get("dca_enabled")) if strat_settings.get("dca_enabled") is not None else bool(cfg.get("dca_enabled", 0))
                                )
                                dca_pct_1 = float(side_dca_pct_1) if side_dca_pct_1 is not None and side_dca_pct_1 > 0 else (
                                    float(strat_settings.get("dca_pct_1")) if strat_settings.get("dca_pct_1") and strat_settings.get("dca_pct_1") > 0 else float(cfg.get("dca_pct_1", 10.0))
                                )
                                dca_pct_2 = float(side_dca_pct_2) if side_dca_pct_2 is not None and side_dca_pct_2 > 0 else (
                                    float(strat_settings.get("dca_pct_2")) if strat_settings.get("dca_pct_2") and strat_settings.get("dca_pct_2") > 0 else float(cfg.get("dca_pct_2", 25.0))
                                )
                                
                                logger.debug(f"[{uid}] {sym}: DCA params from strategy - dca_enabled={dca_enabled}, dca_pct_1={dca_pct_1}, dca_pct_2={dca_pct_2}")
                            else:
                                # Fallback to global settings
                                dca_enabled = bool(cfg.get("dca_enabled", 0))
                                dca_pct_1 = float(cfg.get("dca_pct_1", 10.0))
                                dca_pct_2 = float(cfg.get("dca_pct_2", 25.0))

                            # pos_account_type already defined above for strategy settings

                            # --- DCA –ø—Ä–∏ -dca_pct_1% –ø—Ä–æ—Ç–∏–≤ –Ω–∞—Å (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ DCA –≤–∫–ª—é—á—ë–Ω) ---
                            if dca_enabled and move_pct <= -dca_pct_1:
                                if not get_dca_flag(uid, sym, 10, account_type=pos_account_type, exchange=current_exchange):
                                    try:
                                        # Use strategy-specific percent if available
                                        if risk_pct_for_dca > 0:
                                            add_qty = await calc_qty(
                                                uid,
                                                sym,
                                                price=mark,
                                                risk_pct=risk_pct_for_dca,
                                                sl_pct=sl_pct,
                                                account_type=pos_account_type,
                                                exchange=current_exchange
                                            )
                                            # Check minimum order value (5 USDT for Bybit, 10 USDC for HL)
                                            min_notional = 10.0 if current_exchange == "hyperliquid" else 5.0
                                            order_value = add_qty * mark
                                            if order_value < min_notional:
                                                logger.info(f"{sym}: DCA order value ({order_value:.2f} USDT) below min {min_notional}, marking as done")
                                                set_dca_flag(uid, sym, 10, True, account_type=pos_account_type, exchange=current_exchange)  # Mark as done to avoid retry
                                            elif add_qty > 0:
                                                await _place_exchange_order(
                                                    user_id=uid,
                                                    symbol=sym,
                                                    side=side,
                                                    qty=add_qty,
                                                    account_type=pos_account_type,
                                                    exchange=current_exchange,
                                                )
                                                set_dca_flag(uid, sym, 10, True, account_type=pos_account_type, exchange=current_exchange)
                                                try:
                                                    await safe_send_notification(
                                                        bot, uid,
                                                        t.get(
                                                            'dca_10pct',
                                                            "DCA ‚àí{pct}%: –¥–æ–±–æ—Ä –ø–æ {symbol} qty={qty} @ {price}"
                                                        ).format(
                                                            pct=dca_pct_1,
                                                            symbol=sym,
                                                            qty=add_qty,
                                                            price=mark
                                                        )
                                                    )
                                                except Exception:
                                                    pass
                                    except Exception as e:
                                        logger.error(f"{sym}: DCA ‚àí{dca_pct_1}% failed for {uid}: {e}", exc_info=True)

                            # --- DCA –ø—Ä–∏ -dca_pct_2% –ø—Ä–æ—Ç–∏–≤ –Ω–∞—Å (—Ç–æ–ª—å–∫–æ –µ—Å–ª–∏ DCA –≤–∫–ª—é—á—ë–Ω) ---
                            if dca_enabled and move_pct <= -dca_pct_2:
                                if not get_dca_flag(uid, sym, 25, account_type=pos_account_type, exchange=current_exchange):
                                    try:
                                        # Use strategy-specific percent if available
                                        if risk_pct_for_dca > 0:
                                            add_qty = await calc_qty(
                                                uid,
                                                sym,
                                                price=mark,
                                                risk_pct=risk_pct_for_dca,
                                                sl_pct=sl_pct,
                                                account_type=pos_account_type,
                                                exchange=current_exchange
                                            )
                                            # Check minimum order value (5 USDT for Bybit, 10 USDC for HL)
                                            min_notional = 10.0 if current_exchange == "hyperliquid" else 5.0
                                            order_value = add_qty * mark
                                            if order_value < min_notional:
                                                logger.info(f"{sym}: DCA Leg2 order value ({order_value:.2f} USDT) below min {min_notional}, marking as done")
                                                set_dca_flag(uid, sym, 25, True, account_type=pos_account_type, exchange=current_exchange)  # Mark as done to avoid retry
                                            elif add_qty > 0:
                                                await _place_exchange_order(
                                                    user_id=uid,
                                                    symbol=sym,
                                                    side=side,
                                                    qty=add_qty,
                                                    account_type=pos_account_type,
                                                    exchange=current_exchange,
                                                )
                                                set_dca_flag(uid, sym, 25, True, account_type=pos_account_type, exchange=current_exchange)
                                                try:
                                                    await safe_send_notification(
                                                        bot, uid,
                                                        t.get(
                                                            'dca_25pct',
                                                            "DCA ‚àí{pct}%: –¥–æ–±–æ—Ä –ø–æ {symbol} qty={qty} @ {price}"
                                                        ).format(
                                                            pct=dca_pct_2,
                                                            symbol=sym,
                                                            qty=add_qty,
                                                            price=mark
                                                        )
                                                    )
                                                except Exception:
                                                    pass
                                    except Exception as e:
                                        logger.error(f"{sym}: DCA ‚àí{dca_pct_2}% failed for {uid}: {e}", exc_info=True)

                            # === BREAK-EVEN (BE) LOGIC ===
                            # Move SL to entry price when profit reaches be_trigger_pct
                            # This runs BEFORE ATR trailing and fixed SL logic
                            if be_enabled and move_pct >= be_trigger_pct and not _be_triggered.get(key, False):
                                # Position is in profit by at least be_trigger_pct - move SL to break-even
                                be_sl = entry  # Break-even = entry price
                                
                                # Check if current SL is worse than entry (not yet at break-even)
                                should_move_to_be = (
                                    current_sl is None or
                                    (side == "Buy" and current_sl < entry) or
                                    (side == "Sell" and current_sl > entry)
                                )
                                
                                if should_move_to_be:
                                    try:
                                        filt = await get_symbol_filters(uid, sym, exchange=current_exchange)
                                        tick = filt["tickSize"]
                                        # Quantize BE SL to valid price
                                        be_sl_quantized = quantize_up(be_sl, tick) if side == "Buy" else quantize(be_sl, tick)
                                        
                                        # Use is_be=True to skip price validation (SL = entry is intentional)
                                        await set_trading_stop(uid, sym, sl_price=be_sl_quantized, side_hint=side, is_be=True, account_type=pos_account_type, exchange=current_exchange)
                                        _be_triggered[key] = True
                                        
                                        # Update SL in database so it persists across bot restarts
                                        db.update_position_sltp(uid, sym, sl_price=be_sl_quantized, account_type=pos_account_type, exchange=current_exchange, respect_manual_override=False)
                                        
                                        logger.info(f"[BE-ACTIVATED] {sym} uid={uid} - SL moved to break-even @ {be_sl_quantized:.6f} (was {current_sl}, move_pct={move_pct:.2f}%)")
                                        
                                        # Notify user
                                        try:
                                            await safe_send_notification(
                                                bot, uid,
                                                t.get('be_moved_to_entry', "üîÑ Break-Even: {symbol} SL ‚Üí entry @ {price}").format(
                                                    symbol=sym,
                                                    price=be_sl_quantized
                                                )
                                            )
                                        except Exception:
                                            pass
                                    except RuntimeError as e:
                                        if "no open positions" not in str(e).lower():
                                            logger.warning(f"[{uid}] {sym}: Failed to set BE SL: {e}")
                                    except Exception as e:
                                        logger.error(f"[{uid}] {sym}: BE failed: {e}", exc_info=True)
                                else:
                                    # SL already at or better than entry
                                    _be_triggered[key] = True
                                    logger.debug(f"[BE-ALREADY] {sym} uid={uid} - SL already at/better than entry (sl={current_sl}, entry={entry})")

                            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            # PARTIAL TAKE PROFIT (–°–†–ï–ó –ú–ê–†–ñ–ò) LOGIC
                            # Close X% of position when profit reaches Y%
                            # This runs AFTER break-even and BEFORE fixed SL/TP logic
                            # Works for both strategy positions AND manual positions (uses "manual" strategy settings)
                            # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                            # For manual positions, load settings from "manual" strategy
                            ptp_strat_settings = strat_settings if (pos_strategy and strat_settings) else db.get_strategy_settings(uid, "manual", exchange=current_exchange, account_type=pos_account_type)
                            if ptp_strat_settings:
                                side_prefix = "long" if side == "Buy" else "short"
                                
                                # Get side-specific Partial TP settings
                                ptp_enabled = ptp_strat_settings.get(f"{side_prefix}_partial_tp_enabled")
                                if ptp_enabled is None:
                                    ptp_enabled = ptp_strat_settings.get("partial_tp_enabled", False)
                                ptp_enabled = bool(ptp_enabled)
                                
                                if ptp_enabled and move_pct > 0:  # Only when in profit
                                    # Get step 1 settings
                                    ptp_1_trigger = ptp_strat_settings.get(f"{side_prefix}_partial_tp_1_trigger_pct")
                                    if ptp_1_trigger is None:
                                        ptp_1_trigger = ptp_strat_settings.get("partial_tp_1_trigger_pct", 2.0)
                                    ptp_1_trigger = float(ptp_1_trigger) if ptp_1_trigger else 2.0
                                    
                                    ptp_1_close = ptp_strat_settings.get(f"{side_prefix}_partial_tp_1_close_pct")
                                    if ptp_1_close is None:
                                        ptp_1_close = ptp_strat_settings.get("partial_tp_1_close_pct", 30.0)
                                    ptp_1_close = float(ptp_1_close) if ptp_1_close else 30.0
                                    
                                    # Get step 2 settings
                                    ptp_2_trigger = ptp_strat_settings.get(f"{side_prefix}_partial_tp_2_trigger_pct")
                                    if ptp_2_trigger is None:
                                        ptp_2_trigger = ptp_strat_settings.get("partial_tp_2_trigger_pct", 5.0)
                                    ptp_2_trigger = float(ptp_2_trigger) if ptp_2_trigger else 5.0
                                    
                                    ptp_2_close = ptp_strat_settings.get(f"{side_prefix}_partial_tp_2_close_pct")
                                    if ptp_2_close is None:
                                        ptp_2_close = ptp_strat_settings.get("partial_tp_2_close_pct", 30.0)
                                    ptp_2_close = float(ptp_2_close) if ptp_2_close else 30.0
                                    
                                    pos_size = float(pos["size"])
                                    close_side = "Sell" if side == "Buy" else "Buy"
                                    
                                    # === STEP 1: Close ptp_1_close% at ptp_1_trigger% profit ===
                                    if move_pct >= ptp_1_trigger and not get_ptp_flag(uid, sym, 1, account_type=pos_account_type, exchange=current_exchange):
                                        try:
                                            close_qty = pos_size * (ptp_1_close / 100)
                                            # Get symbol filters for qty step
                                            filt = await get_symbol_filters(uid, sym, exchange=current_exchange)
                                            qty_step = float(filt.get("qtyStep", 0.001))
                                            close_qty = math.floor(close_qty / qty_step) * qty_step
                                            
                                            if close_qty > 0:
                                                # Pre-check notional to avoid ORDER_TOO_SMALL spam
                                                min_notional = 10.0 if current_exchange == "hyperliquid" else 5.0
                                                try:
                                                    if current_exchange == "hyperliquid":
                                                        cur_price = mark  # Already available from position data
                                                    else:
                                                        ticker = await _bybit_request(uid, "GET", "/v5/market/tickers", params={"category": "linear", "symbol": sym}, account_type=pos_account_type)
                                                        cur_price = float(ticker["list"][0]["lastPrice"])
                                                    notional_check = close_qty * cur_price
                                                    if notional_check < min_notional:
                                                        logger.info(f"[PTP-STEP1] {sym} uid={uid} - Partial qty notional ${notional_check:.2f} < ${min_notional} min, marking step done (qty too small)")
                                                        set_ptp_flag(uid, sym, 1, True, account_type=pos_account_type, exchange=current_exchange)
                                                        raise ValueError("PTP_SKIP_SMALL")
                                                except ValueError:
                                                    raise
                                                except Exception:
                                                    pass  # Continue with order if price check fails
                                                
                                                # Place market order to close partial position
                                                await _place_exchange_order(
                                                    user_id=uid,
                                                    symbol=sym,
                                                    side=close_side,
                                                    qty=close_qty,
                                                    account_type=pos_account_type,
                                                    exchange=current_exchange,
                                                    reduce_only=True,
                                                )
                                                set_ptp_flag(uid, sym, 1, True, account_type=pos_account_type, exchange=current_exchange)
                                                
                                                # Calculate realized PnL for notification
                                                pnl_realized = close_qty * entry * (move_pct / 100)
                                                
                                                logger.info(f"[PTP-STEP1] {sym} uid={uid} - Closed {ptp_1_close:.0f}% ({close_qty}) at +{move_pct:.2f}% profit")
                                                
                                                try:
                                                    await safe_send_notification(
                                                        bot, uid,
                                                        t.get('partial_tp_notification', 
                                                            "‚úÇÔ∏è <b>Partial TP Step {step}</b>\n\n"
                                                            "üìä {symbol}\n"
                                                            "üìâ Closed: {close_pct:.0f}% ({close_qty})\n"
                                                            "üìà Profit: +{profit_pct:.2f}%\n"
                                                            "üí∞ PnL: ~${pnl:.2f}"
                                                        ).format(
                                                            step=1,
                                                            symbol=sym,
                                                            close_pct=ptp_1_close,
                                                            close_qty=close_qty,
                                                            profit_pct=move_pct,
                                                            pnl=pnl_realized
                                                        ),
                                                        parse_mode="HTML"
                                                    )
                                                except Exception:
                                                    pass
                                                
                                                # Send push notification
                                                if notification_service:
                                                    try:
                                                        await notification_service.send_partial_tp_notification(
                                                            uid, sym, side, step=1, 
                                                            close_pct=ptp_1_close, profit_pct=move_pct, pnl=pnl_realized
                                                        )
                                                    except Exception as push_err:
                                                        logger.debug(f"PTP push failed: {push_err}")
                                        except ValueError as e:
                                            if "PTP_SKIP_SMALL" in str(e):
                                                pass  # Already handled - step marked done
                                            elif "ORDER_TOO_SMALL" in str(e):
                                                logger.info(f"[PTP-STEP1] {sym} uid={uid} - Order too small, marking step done: {e}")
                                                set_ptp_flag(uid, sym, 1, True, account_type=pos_account_type, exchange=current_exchange)
                                            else:
                                                logger.error(f"[{uid}] {sym}: Partial TP step 1 failed: {e}", exc_info=True)
                                        except Exception as e:
                                            logger.error(f"[{uid}] {sym}: Partial TP step 1 failed: {e}", exc_info=True)
                                    
                                    # === STEP 2: Close ptp_2_close% at ptp_2_trigger% profit ===
                                    if move_pct >= ptp_2_trigger and not get_ptp_flag(uid, sym, 2, account_type=pos_account_type, exchange=current_exchange):
                                        try:
                                            # Recalculate size (may have decreased from step 1)
                                            current_pos = next((p for p in open_positions if p["symbol"] == sym), None)
                                            if current_pos:
                                                current_size = float(current_pos["size"])
                                                close_qty = current_size * (ptp_2_close / 100)
                                                
                                                # Get symbol filters for qty step
                                                filt = await get_symbol_filters(uid, sym, exchange=current_exchange)
                                                qty_step = float(filt.get("qtyStep", 0.001))
                                                close_qty = math.floor(close_qty / qty_step) * qty_step
                                                
                                                if close_qty > 0:
                                                    # Pre-check notional to avoid ORDER_TOO_SMALL spam
                                                    min_notional = 10.0 if current_exchange == "hyperliquid" else 5.0
                                                    try:
                                                        if current_exchange == "hyperliquid":
                                                            cur_price = mark  # Already available from position data
                                                        else:
                                                            ticker = await _bybit_request(uid, "GET", "/v5/market/tickers", params={"category": "linear", "symbol": sym}, account_type=pos_account_type)
                                                            cur_price = float(ticker["list"][0]["lastPrice"])
                                                        notional_check = close_qty * cur_price
                                                        if notional_check < min_notional:
                                                            logger.info(f"[PTP-STEP2] {sym} uid={uid} - Partial qty notional ${notional_check:.2f} < ${min_notional} min, marking step done (qty too small)")
                                                            set_ptp_flag(uid, sym, 2, True, account_type=pos_account_type, exchange=current_exchange)
                                                            raise ValueError("PTP_SKIP_SMALL")
                                                    except ValueError:
                                                        raise
                                                    except Exception:
                                                        pass  # Continue with order if price check fails
                                                    
                                                    await _place_exchange_order(
                                                        user_id=uid,
                                                        symbol=sym,
                                                        side=close_side,
                                                        qty=close_qty,
                                                        account_type=pos_account_type,
                                                        exchange=current_exchange,
                                                        reduce_only=True,
                                                    )
                                                    set_ptp_flag(uid, sym, 2, True, account_type=pos_account_type, exchange=current_exchange)
                                                    
                                                    # Calculate realized PnL
                                                    pnl_realized = close_qty * entry * (move_pct / 100)
                                                    
                                                    logger.info(f"[PTP-STEP2] {sym} uid={uid} - Closed {ptp_2_close:.0f}% ({close_qty}) at +{move_pct:.2f}% profit")
                                                    
                                                    try:
                                                        await safe_send_notification(
                                                            bot, uid,
                                                            t.get('partial_tp_notification',
                                                                "‚úÇÔ∏è <b>Partial TP Step {step}</b>\n\n"
                                                                "üìä {symbol}\n"
                                                                "üìâ Closed: {close_pct:.0f}% ({close_qty})\n"
                                                                "üìà Profit: +{profit_pct:.2f}%\n"
                                                                "üí∞ PnL: ~${pnl:.2f}"
                                                            ).format(
                                                                step=2,
                                                                symbol=sym,
                                                                close_pct=ptp_2_close,
                                                                close_qty=close_qty,
                                                                profit_pct=move_pct,
                                                                pnl=pnl_realized
                                                            ),
                                                            parse_mode="HTML"
                                                        )
                                                    except Exception:
                                                        pass
                                                    
                                                    # Send push notification
                                                    if notification_service:
                                                        try:
                                                            await notification_service.send_partial_tp_notification(
                                                                uid, sym, side, step=2,
                                                                close_pct=ptp_2_close, profit_pct=move_pct, pnl=pnl_realized
                                                            )
                                                        except Exception as push_err:
                                                            logger.debug(f"PTP push failed: {push_err}")
                                        except ValueError as e:
                                            if "PTP_SKIP_SMALL" in str(e):
                                                pass  # Already handled - step marked done
                                            elif "ORDER_TOO_SMALL" in str(e):
                                                logger.info(f"[PTP-STEP2] {sym} uid={uid} - Order too small, marking step done: {e}")
                                                set_ptp_flag(uid, sym, 2, True, account_type=pos_account_type, exchange=current_exchange)
                                            else:
                                                logger.error(f"[{uid}] {sym}: Partial TP step 2 failed: {e}", exc_info=True)
                                        except Exception as e:
                                            logger.error(f"[{uid}] {sym}: Partial TP step 2 failed: {e}", exc_info=True)

                            if not position_use_atr:
                                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                                # ATR WAS DISABLED - RESTORE SL AND TP TO THEIR CORRECT POSITIONS
                                # When user disables ATR for open position, we need to:
                                # 1. Recalculate SL based on sl_pct from settings
                                # 2. Set TP based on tp_pct from settings
                                # 3. Clear ATR triggered state
                                # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
                                atr_was_on = _atr_was_enabled.get(key, False)
                                if atr_was_on:
                                    # ATR was enabled before, now disabled - need to restore SL/TP
                                    logger.info(f"[ATR-DISABLED] {sym} uid={uid} - ATR was disabled, restoring SL/TP")
                                    _atr_was_enabled[key] = False
                                    _atr_triggered.pop(key, None)  # Clear ATR triggered state
                                    
                                    # Get SL/TP percentages
                                    if ap_for_sym:
                                        applied_sl = ap_for_sym.get("applied_sl_pct")
                                        applied_tp = ap_for_sym.get("applied_tp_pct")
                                        if applied_sl is not None and applied_sl > 0:
                                            sl_pct = float(applied_sl)
                                        if applied_tp is not None and applied_tp > 0:
                                            tp_pct = float(applied_tp)
                                    else:
                                        sl_pct, tp_pct = resolve_sl_tp_pct(cfg, sym, strategy=pos_strategy, user_id=uid, side=side)
                                    
                                    # Calculate correct SL and TP positions
                                    sl_restore = round(
                                        entry * (1 - sl_pct/100) if side == "Buy"
                                        else entry * (1 + sl_pct/100),
                                        6
                                    )
                                    tp_restore = round(
                                        entry * (1 + tp_pct/100) if side == "Buy"
                                        else entry * (1 - tp_pct/100),
                                        6
                                    )
                                    
                                    try:
                                        # Restore both SL and TP
                                        await set_trading_stop(uid, sym, sl_price=sl_restore, tp_price=tp_restore, side_hint=side, account_type=pos_account_type, exchange=current_exchange)
                                        logger.info(f"[ATR-DISABLED] {sym} uid={uid} - Restored SL={sl_restore:.6f} (was {current_sl}), TP={tp_restore:.6f}")
                                        
                                        # Notify user
                                        try:
                                            await safe_send_notification(
                                                bot, uid,
                                                t.get('atr_disabled_restored', 
                                                    "üîÑ <b>ATR Disabled</b>\n\n"
                                                    "üìä {symbol}\n"
                                                    "üõ°Ô∏è SL restored: {sl_price:.4f}\n"
                                                    "üéØ TP restored: {tp_price:.4f}"
                                                ).format(
                                                    symbol=sym,
                                                    sl_price=sl_restore,
                                                    tp_price=tp_restore
                                                ),
                                                parse_mode="HTML"
                                            )
                                        except Exception:
                                            pass
                                    except RuntimeError as e:
                                        if "no open positions" not in str(e).lower():
                                            logger.warning(f"[{uid}] {sym}: Failed to restore SL/TP after ATR disabled: {e}")
                                    except Exception as e:
                                        logger.error(f"[{uid}] {sym}: ATR disable restore failed: {e}", exc_info=True)
                                    continue
                                
                                # CRITICAL FIX: Use applied_sl_pct/applied_tp_pct from position if available
                                # This ensures we use settings from position open time, not current user settings
                                if ap_for_sym:
                                    applied_sl = ap_for_sym.get("applied_sl_pct")
                                    applied_tp = ap_for_sym.get("applied_tp_pct")
                                    if applied_sl is not None and applied_sl > 0:
                                        sl_pct = float(applied_sl)
                                    if applied_tp is not None and applied_tp > 0:
                                        tp_pct = float(applied_tp)
                                else:
                                    # Fallback to current strategy settings if no applied values saved
                                    sl_pct, tp_pct = resolve_sl_tp_pct(cfg, sym, strategy=pos_strategy, user_id=uid, side=side)
                                
                                sl0 = round(
                                    entry * (1 - sl_pct/100) if side == "Buy"
                                    else entry * (1 + sl_pct/100),
                                    6
                                )
                                tp0 = round(
                                    entry * (1 + tp_pct/100) if side == "Buy"
                                    else entry * (1 - tp_pct/100),
                                    6
                                )

                                # CRITICAL FIX: If entry changed (DCA), recalculate SL from new entry
                                # This prevents SL from being too far from current entry after averaging
                                if entry_changed and current_sl is not None:
                                    # Check if SL needs recalculation
                                    sl_should_be = sl0
                                    sl_diff_pct = abs(current_sl - sl_should_be) / entry * 100 if entry > 0 else 0
                                    if sl_diff_pct > 0.3:  # SL off by more than 0.3%
                                        cand = _stricter_sl(side, sl_should_be, current_sl)
                                        if cand is not None:
                                            try:
                                                await set_trading_stop(uid, sym, sl_price=cand, side_hint=side, account_type=pos_account_type, exchange=current_exchange)
                                                logger.info(f"[{uid}] {sym}: SL recalculated after DCA: {current_sl:.6f} ‚Üí {cand:.6f}")
                                            except RuntimeError as e:
                                                if "no open positions" not in str(e).lower():
                                                    logger.warning(f"[{uid}] {sym}: Failed to recalc SL after DCA: {e}")
                                        continue

                                if current_sl is None or current_tp is None:
                                    kwargs = {}
                                    if current_sl is None:
                                        kwargs["sl_price"] = sl0
                                    if current_tp is None:
                                        if (side == "Buy" and tp0 > mark) or (side == "Sell" and tp0 < mark):
                                            kwargs["tp_price"] = tp0
                                    if kwargs:
                                        try:
                                            result = await set_trading_stop(uid, sym, **kwargs, side_hint=side, account_type=pos_account_type, exchange=current_exchange)
                                            if result is True:
                                                logger.info(f"[{uid}] {sym}: Fixed init ‚Üí {kwargs}")
                                                # CRITICAL FIX: Save applied_sl_pct/applied_tp_pct AND sl_price/tp_price to DB 
                                                # This prevents subsequent monitor cycles from recalculating SL/TP
                                                # AND ensures bot UI shows correct SL/TP values
                                                try:
                                                    db.update_position_applied_sltp(
                                                        user_id=uid,
                                                        symbol=sym,
                                                        account_type=pos_account_type,
                                                        applied_sl_pct=sl_pct if "sl_price" in kwargs else None,
                                                        applied_tp_pct=tp_pct if "tp_price" in kwargs else None,
                                                        sl_price=kwargs.get("sl_price"),
                                                        tp_price=kwargs.get("tp_price"),
                                                        exchange=current_exchange
                                                    )
                                                    logger.debug(f"[{uid}] {sym}: Saved applied_sl_pct={sl_pct}, applied_tp_pct={tp_pct}, sl_price={kwargs.get('sl_price')}, tp_price={kwargs.get('tp_price')} to DB")
                                                except Exception as e:
                                                    logger.warning(f"[{uid}] {sym}: Failed to save applied_sl_pct to DB: {e}")
                                            elif result == "deep_loss":
                                                logger.warning(f"[{uid}] {sym}: Position in deep loss, cannot set SL/TP")
                                            else:
                                                logger.debug(f"[{uid}] {sym}: SL/TP unchanged or skipped ‚Üí {kwargs}")
                                        except RuntimeError as e:
                                            if "no open positions" in str(e).lower():
                                                logger.debug(f"{sym}: Position already closed, skipping SL/TP update")
                                            else:
                                                raise
                                    continue
                           
                                # if move_pct >= trigger_pct:
                                #     be = entry
                                #     cand = _stricter_sl(side, be, current_sl)
                                #     if cand is not None:
                                #         await set_trading_stop(uid, sym, sl_price=cand, side_hint=side)
                                #         logger.info(f"{sym}: SL moved to breakeven {cand}")
                                #     continue
                           
                                # CRITICAL FIX: Only tighten SL if applied_sl_pct was not explicitly set
                                # When user sets SL manually on exchange, we saved applied_sl_pct from that SL
                                # Don't override their manually set SL with strategy defaults
                                has_applied_sl = ap_for_sym and ap_for_sym.get("applied_sl_pct") is not None and float(ap_for_sym.get("applied_sl_pct", 0)) > 0
                                
                                if not has_applied_sl:
                                    # No explicit SL saved - try to tighten based on strategy settings
                                    cand = _stricter_sl(side, sl0, current_sl)
                                    if cand is not None:
                                        try:
                                            await set_trading_stop(uid, sym, sl_price=cand, side_hint=side, account_type=pos_account_type, exchange=current_exchange)
                                            logger.info(f"{sym}: Fixed SL tightened to {cand}")
                                        except RuntimeError as e:
                                            if "no open positions" in str(e).lower():
                                                logger.debug(f"{sym}: Position already closed, skipping SL update")
                                            else:
                                                raise
                                else:
                                    # User has explicit applied_sl_pct - respect it, don't override
                                    logger.debug(f"[{uid}] {sym}: Respecting applied_sl_pct={ap_for_sym.get('applied_sl_pct')}%, not tightening SL")
                                continue
                        
                            if position_use_atr:
                                # Mark ATR as enabled for this position (for detecting when it gets disabled later)
                                _atr_was_enabled[key] = True
                                
                                # Log current ATR state (INFO level for production visibility)
                                logger.info(f"[ATR-CHECK] {sym} uid={uid} move_pct={move_pct:+.2f}% trigger={trigger_pct}% triggered={_atr_triggered.get(key, False)} sl={current_sl} tp={current_tp}")
                                
                                # CRITICAL FIX (Feb 11, 2026): Attempt TP removal when ATR is triggered
                                # and TP still exists on exchange. Bybit may return retCode 34040 ("not modified")
                                # meaning TP is internally cleared but position data still shows the old value.
                                # Use cooldown to avoid spamming API calls ‚Äî retry every 5 minutes.
                                if _atr_triggered.get(key, False) and current_tp is not None:
                                    last_tp_removal = _atr_tp_removal_done.get(key, 0)
                                    if time.time() - last_tp_removal > 300:  # 5 minute cooldown
                                        try:
                                            await remove_take_profit(uid, sym, side_hint=side, account_type=pos_account_type, exchange=current_exchange)
                                            _atr_tp_removal_done[key] = time.time()
                                            logger.info(f"[ATR-TP-REMOVE] {sym} uid={uid} - TP removal sent (was {current_tp:.6f}), ATR trailing manages exit")
                                        except Exception as e:
                                            logger.warning(f"[{uid}] {sym}: Failed to remove TP for ATR mode: {e}")
                                
                                if move_pct < trigger_pct and not _atr_triggered.get(key, False):
                                    # ATR waiting for trigger - position needs both SL AND TP as safety net
                                    logger.info(f"[ATR-WAIT] {sym} uid={uid} move_pct={move_pct:+.2f}% < trigger={trigger_pct}% - waiting, ensuring SL+TP set")
                                
                                    # Use strategy-specific SL% if available (already calculated above)
                                    base_sl = entry * (1 - sl_pct/100) if side == "Buy" else entry * (1 + sl_pct/100)

                                    tick = (await get_symbol_filters(uid, sym, exchange=current_exchange))["tickSize"]

                                    sl0 = quantize_up(base_sl, tick) if side == "Buy" else quantize(base_sl, tick)
                                    
                                    # Calculate TP as safety net (will be removed when ATR triggers)
                                    tp0 = round(
                                        entry * (1 + tp_pct/100) if side == "Buy" else entry * (1 - tp_pct/100), 6
                                    )
                                    
                                    # Build kwargs for set_trading_stop
                                    kwargs = {}
                                    
                                    # CRITICAL FIX: If entry changed (DCA), always recalculate SL
                                    # This prevents SL from being too far from current entry after averaging
                                    # Use epsilon comparison to avoid floating point issues
                                    sl_should_update = (
                                        current_sl is None
                                        or (side == "Buy"  and sl0 > current_sl and not _prices_equal(sl0, current_sl))
                                        or (side == "Sell" and sl0 < current_sl and not _prices_equal(sl0, current_sl))
                                        or entry_changed  # Force update if entry changed due to DCA
                                    )
                                    if sl_should_update:
                                        kwargs["sl_price"] = sl0
                                    
                                    # Set TP as safety net if not present (ATR-TP-REMOVE will clear it when ATR triggers)
                                    if current_tp is None:
                                        if (side == "Buy" and tp0 > mark) or (side == "Sell" and tp0 < mark):
                                            kwargs["tp_price"] = tp0
                                            logger.info(f"[ATR-WAIT-TP] {sym} uid={uid} - Setting safety TP={tp0:.6f} (tp_pct={tp_pct}%) until ATR triggers")
                                    
                                    if kwargs:
                                        try:
                                            sl_result = await set_trading_stop(uid, sym, **kwargs, side_hint=side, account_type=pos_account_type, exchange=current_exchange)
                                            if sl_result:
                                                parts = []
                                                if "sl_price" in kwargs:
                                                    parts.append(f"SL={kwargs['sl_price']}")
                                                if "tp_price" in kwargs:
                                                    parts.append(f"TP={kwargs['tp_price']}")
                                                reason = "DCA recalc" if entry_changed else "ATR-WAIT init"
                                                logger.info(f"[{uid}] {sym}: {reason} ‚Üí {', '.join(parts)}")
                                                # Update sl_price/tp_price in DB for UI display
                                                try:
                                                    db.update_position_applied_sltp(
                                                        user_id=uid, symbol=sym,
                                                        account_type=pos_account_type,
                                                        sl_price=kwargs.get("sl_price"),
                                                        tp_price=kwargs.get("tp_price"),
                                                        exchange=current_exchange
                                                    )
                                                except Exception as e:
                                                    logger.warning(f"[{uid}] {sym}: Failed to save ATR-WAIT SL/TP to DB: {e}")
                                            else:
                                                logger.debug(f"[{uid}] {sym}: ATR-WAIT set_trading_stop returned False for {kwargs}")
                                        except RuntimeError as e:
                                            if "no open positions" in str(e).lower():
                                                logger.debug(f"{sym}: Position already closed")
                                            else:
                                                raise
                                    continue

                                # CRITICAL FIX (Feb 11, 2026): Guard ATR-ACTIVATED to only log ONCE
                                # Previously fired every cycle (~20sec) causing log spam.
                                if not _atr_triggered.get(key, False):
                                    _atr_triggered[key] = True
                                    logger.info(f"[ATR-ACTIVATED] {sym} uid={uid} - ATR trailing now active (move={move_pct:+.2f}% >= trigger={trigger_pct}%)")
                                
                                # TP removal is now handled above (at line ~22497) on EVERY cycle
                                # when current_tp is not None. No duplicate handling needed here.

                                filt = await get_symbol_filters(uid, sym, exchange=current_exchange)
                                tick = filt["tickSize"]
                                try:
                                    atr_val = await calc_atr(sym, interval=ATR_INTERVAL, periods=atr_periods)
                                except Exception as e:
                                    logger.warning(f"{sym}: failed to count ATR: {e}")
                                    continue

                                logger.info(f"[ATR-TRAIL] {sym} side={side} mark={mark:.6f} entry={entry:.6f} move_pct={move_pct:.2f}% atr_val={atr_val:.6f} atr_mult={atr_mult_sl} current_sl={current_sl}")

                                if side == "Buy":
                                    cand_raw   = mark - atr_val * atr_mult_sl
                                    cand_ceil  = quantize_up(cand_raw, tick)
                                    max_allowed = quantize(mark - tick, tick)    
                                    atr_cand    = min(cand_ceil, max_allowed)

                                    new_sl = max(current_sl or -float("inf"), atr_cand)
                                    # Use epsilon comparison to avoid floating point issues
                                    should_trail = current_sl is None or (new_sl > current_sl and not _prices_equal(new_sl, current_sl))
                                    logger.info(f"[ATR-TRAIL] {sym} LONG: cand_raw={cand_raw:.6f} atr_cand={atr_cand:.6f} new_sl={new_sl:.6f} should_update={should_trail}")
                                    if should_trail:
                                        try:
                                            result = await set_trading_stop(uid, sym, sl_price=new_sl, side_hint=side, is_trailing=True, account_type=pos_account_type, exchange=current_exchange)
                                            logger.info(f"[ATR-TRAIL] {sym} LONG: SL updated {current_sl} -> {new_sl}, result={result}")
                                        except RuntimeError as e:
                                            if "no open positions" in str(e).lower():
                                                logger.debug(f"{sym}: Position closed, skipping ATR SL")
                                            else:
                                                raise

                                else:  
                                    cand_raw    = mark + atr_val * atr_mult_sl
                                    cand_floor  = quantize(cand_raw, tick)
                                    min_allowed = quantize_up(mark + tick, tick)        
                                    atr_cand     = max(cand_floor, min_allowed)

                                    new_sl = min(current_sl or float("inf"), atr_cand)
                                    # Use epsilon comparison to avoid floating point issues
                                    should_trail = current_sl is None or (new_sl < current_sl and not _prices_equal(new_sl, current_sl))
                                    logger.info(f"[ATR-TRAIL] {sym} SHORT: cand_raw={cand_raw:.6f} atr_cand={atr_cand:.6f} new_sl={new_sl:.6f} should_update={should_trail}")
                                    if should_trail:
                                        try:
                                            result = await set_trading_stop(uid, sym, sl_price=new_sl, side_hint=side, is_trailing=True, account_type=pos_account_type, exchange=current_exchange)
                                            logger.info(f"[ATR-TRAIL] {sym} SHORT: SL updated {current_sl} -> {new_sl}, result={result}")
                                        except RuntimeError as e:
                                            if "no open positions" in str(e).lower():
                                                logger.debug(f"{sym}: Position closed, skipping ATR SL")
                                            else:
                                                raise
                    
                        # Save current symbols for next iteration to prevent duplicate notifications
                        _open_syms_prev[cache_key] = open_syms
                        
                        # === STALE POSITION CLEANUP (every 5 minutes per user/account) ===
                        cleanup_key = f"{uid}:{current_exchange}:{current_account_type}"
                        cleanup_interval = 300  # 5 minutes
                        if now - _last_stale_cleanup.get(cleanup_key, 0) >= cleanup_interval:
                            _last_stale_cleanup[cleanup_key] = now
                            # Get DB positions for this account
                            db_positions = get_active_positions(uid, account_type=current_account_type, exchange=current_exchange)
                            # Find stale: in DB but not on exchange
                            for db_pos in db_positions:
                                db_sym = db_pos.get("symbol")
                                if db_sym not in open_syms:
                                    # Stale position - not on exchange anymore
                                    logger.info(f"[STALE-CLEANUP] {uid} {db_sym} - removing from DB (not on exchange)")
                                    try:
                                        remove_active_position(uid, db_sym, account_type=current_account_type, entry_price=db_pos.get("entry_price"), exchange=current_exchange)
                                        reset_pyramid(uid, db_sym)
                                        _atr_triggered.pop((uid, db_sym, current_account_type), None)
                                        _atr_was_enabled.pop((uid, db_sym, current_account_type), None)  # Clear ATR was enabled cache
                                        _be_triggered.pop((uid, db_sym, current_account_type), None)  # Clear BE cache
                                        _sl_notified.pop((uid, db_sym), None)
                                        _deep_loss_notified.pop((uid, db_sym), None)
                                        _hl_sl_cache.pop((uid, db_sym), None)  # Clear HL SL cache
                                        _hl_sl_fail_cooldown.pop((uid, db_sym), None)  # Clear HL SL fail cooldown
                                    except Exception as e:
                                        logger.warning(f"[STALE-CLEANUP] Failed to remove {db_sym} for {uid}: {e}")

                except Exception as e:
                    logger.error(f"Monitoring error for {uid}: {e}", exc_info=True)

            await asyncio.sleep(CHECK_INTERVAL)

        except Exception as e:
            logger.exception(f"Critical error in loop, restart after {CHECK_INTERVAL}s: {e}")
            await asyncio.sleep(CHECK_INTERVAL)


async def spot_tp_rebalance_loop(app: Application):
    """
    Background loop for spot trading monitoring:
    - Check Take Profit levels and auto-sell when targets reached
    - Check portfolio rebalancing needs
    
    Runs every 15 minutes.
    """
    bot = app.bot
    logger.info("Starting spot_tp_rebalance_loop")
    
    while True:
        try:
            await asyncio.sleep(900)  # Check every 15 minutes
            
            if GLOBAL_PAUSED:
                continue
            
            for uid in get_all_users():
                try:
                    cfg = get_user_config(uid)
                    spot_settings = cfg.get("spot_settings") or {}
                    
                    # Skip if spot trading is disabled in strategy settings
                    if not cfg.get("spot_enabled", 0):
                        continue
                    
                    # Check if user has API credentials
                    k, s = get_user_credentials(uid)
                    if not k or not s:
                        continue
                    
                    lang = cfg.get("lang", DEFAULT_LANG)
                    t = LANGS.get(lang, LANGS[DEFAULT_LANG])
                    account_type = spot_settings.get("trading_mode", "demo")
                    
                    # === Take Profit Monitoring ===
                    if spot_settings.get("tp_enabled"):
                        tp_levels = spot_settings.get("tp_levels", DEFAULT_SPOT_TP_LEVELS)
                        purchase_history = spot_settings.get("purchase_history", {})
                        sold_levels = spot_settings.get("sold_levels", {})  # Track which levels were hit
                        
                        balances = await fetch_spot_balance(uid, account_type=account_type)
                        
                        for coin, qty in balances.items():
                            if coin == "USDT" or qty < 0.00001:
                                continue
                            
                            symbol = f"{coin}USDT"
                            
                            # Get average purchase price from history
                            avg_price = purchase_history.get(coin, {}).get("avg_price", 0)
                            if avg_price <= 0:
                                continue
                            
                            try:
                                ticker = await get_spot_ticker(uid, symbol, account_type)
                                if not ticker:
                                    continue
                                    
                                current_price = float(ticker.get("lastPrice", 0))
                                if current_price <= 0:
                                    continue
                                
                                gain_pct = ((current_price - avg_price) / avg_price) * 100
                                
                                # Check each TP level
                                coin_sold_levels = sold_levels.get(coin, [])
                                
                                for i, level in enumerate(tp_levels):
                                    if i in coin_sold_levels:
                                        continue  # Already sold at this level
                                    
                                    if gain_pct >= level["gain_pct"]:
                                        # TP level reached! Sell partial
                                        sell_qty = qty * (level["sell_pct"] / 100.0)
                                        
                                        if sell_qty < 0.00001:
                                            continue
                                        
                                        try:
                                            result = await place_spot_order(
                                                user_id=uid,
                                                symbol=symbol,
                                                side="Sell",
                                                qty=sell_qty,
                                                order_type="Market",
                                                account_type=account_type,
                                            )
                                            
                                            # Mark level as sold
                                            if coin not in sold_levels:
                                                sold_levels[coin] = []
                                            sold_levels[coin].append(i)
                                            spot_settings["sold_levels"] = sold_levels
                                            db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
                                            
                                            usdt_received = sell_qty * current_price
                                            
                                            # Notify user
                                            msg = (
                                                f"üéØ <b>Take Profit Executed!</b>\n\n"
                                                f"üìà {coin} reached +{gain_pct:.1f}% gain\n"
                                                f"üí∞ Sold {sell_qty:.6f} {coin}\n"
                                                f"üíµ Received ~${usdt_received:.2f} USDT\n"
                                                f"üìä TP Level {i+1}/{len(tp_levels)}"
                                            )
                                            
                                            await safe_send_notification(bot, uid, msg, parse_mode="HTML")
                                            logger.info(f"TP executed for {uid}: {coin} +{gain_pct:.1f}%, sold {sell_qty}")
                                            
                                        except Exception as e:
                                            logger.error(f"TP sell error for {uid}/{coin}: {e}")
                                        
                                        break  # Only one level per check
                                
                            except Exception as e:
                                logger.error(f"TP check error for {uid}/{coin}: {e}")
                    
                    # === Auto Rebalance ===
                    if spot_settings.get("rebalance_enabled"):
                        portfolio = spot_settings.get("portfolio", "custom")
                        
                        if portfolio != "custom" and portfolio in SPOT_PORTFOLIOS:
                            target_allocation = SPOT_PORTFOLIOS[portfolio].get("coins", {})
                            
                            if target_allocation:
                                balances = await fetch_spot_balance(uid, account_type=account_type)
                                
                                # Calculate current portfolio value
                                total_value = 0.0
                                coin_values = {}
                                
                                for coin, qty in balances.items():
                                    if coin == "USDT":
                                        total_value += qty
                                        coin_values[coin] = qty
                                    elif qty > 0.00001:
                                        symbol = f"{coin}USDT"
                                        try:
                                            ticker = await get_spot_ticker(uid, symbol, account_type)
                                            if ticker:
                                                price = float(ticker.get("lastPrice", 0))
                                                value = qty * price
                                                total_value += value
                                                coin_values[coin] = value
                                        except Exception:
                                            pass
                                
                                if total_value < 10:  # Skip if portfolio too small
                                    continue
                                
                                # Calculate deviation from target
                                rebalance_threshold = spot_settings.get("rebalance_threshold", 5.0)  # 5% default
                                needs_rebalance = False
                                
                                for coin, target_pct in target_allocation.items():
                                    current_value = coin_values.get(coin, 0)
                                    current_pct = (current_value / total_value) * 100 if total_value > 0 else 0
                                    deviation = abs(current_pct - target_pct)
                                    
                                    if deviation > rebalance_threshold:
                                        needs_rebalance = True
                                        break
                                
                                if needs_rebalance:
                                    rebalance_msg_lines = [
                                        "‚öñÔ∏è <b>Portfolio Rebalance Suggestion</b>",
                                        "",
                                    ]
                                    
                                    for coin, target_pct in target_allocation.items():
                                        current_value = coin_values.get(coin, 0)
                                        current_pct = (current_value / total_value) * 100 if total_value > 0 else 0
                                        diff = target_pct - current_pct
                                        
                                        if abs(diff) > 1:
                                            arrow = "‚¨ÜÔ∏è" if diff > 0 else "‚¨áÔ∏è"
                                            rebalance_msg_lines.append(
                                                f"{arrow} {coin}: {current_pct:.1f}% ‚Üí {target_pct}% ({diff:+.1f}%)"
                                            )
                                    
                                    rebalance_msg_lines.append("")
                                    rebalance_msg_lines.append("<i>Use Buy Now to rebalance manually.</i>")
                                    
                                    try:
                                        await safe_send_notification(
                                            bot, uid,
                                            "\n".join(rebalance_msg_lines),
                                            parse_mode="HTML"
                                        )
                                    except Exception as e:
                                        logger.warning(f"Failed to notify rebalance for {uid}: {e}")
                    
                    # === Trailing TP Monitoring ===
                    trailing_config = spot_settings.get("trailing_tp", {})
                    if trailing_config.get("enabled"):
                        try:
                            sells = await check_spot_trailing_tp(uid, account_type=account_type)
                            
                            for sell in sells:
                                coin = sell.get("coin", "")
                                qty_sold = sell.get("qty_sold", 0)
                                usdt_received = sell.get("usdt_received", 0)
                                gain_pct = sell.get("gain_pct", 0)
                                peak_price = sell.get("peak_price", 0)
                                sell_price = sell.get("sell_price", 0)
                                
                                msg = (
                                    f"üìà <b>Trailing TP Triggered!</b>\n\n"
                                    f"ü™ô {coin}\n"
                                    f"üìä Final gain: +{gain_pct:.1f}%\n"
                                    f"üèîÔ∏è Peak: ${peak_price:.4f}\n"
                                    f"üí∞ Sold at: ${sell_price:.4f}\n"
                                    f"üì¶ Quantity: {qty_sold:.6f}\n"
                                    f"üíµ Received: ${usdt_received:.2f}"
                                )
                                
                                try:
                                    await safe_send_notification(bot, uid, msg, parse_mode="HTML")
                                except Exception as e:
                                    logger.warning(f"Failed to notify trailing TP for {uid}: {e}")
                                    
                        except Exception as e:
                            logger.error(f"Trailing TP check error for {uid}: {e}")
                    
                    # === Grid Bot Monitoring ===
                    grids = spot_settings.get("grids", {})
                    active_grids = [c for c, g in grids.items() if g.get("active")]
                    
                    if active_grids:
                        try:
                            events = await check_spot_grids(uid, account_type=account_type)
                            
                            for event in events:
                                event_type = event.get("type", "")
                                coin = event.get("coin", "")
                                
                                if event_type == "grid_buy_filled":
                                    buy_price = event.get("buy_price", 0)
                                    sell_placed = event.get("sell_placed", 0)
                                    qty = event.get("qty", 0)
                                    
                                    msg = (
                                        f"üî≤ <b>Grid Buy Filled</b>\n\n"
                                        f"ü™ô {coin}\n"
                                        f"üí∞ Bought at: ${buy_price:.4f}\n"
                                        f"üì¶ Quantity: {qty:.6f}\n"
                                        f"üìà Sell placed at: ${sell_placed:.4f}"
                                    )
                                    
                                elif event_type == "grid_sell_filled":
                                    sell_price = event.get("sell_price", 0)
                                    profit = event.get("profit", 0)
                                    total_profit = event.get("total_profit", 0)
                                    
                                    msg = (
                                        f"üî≤ <b>Grid Sell Filled</b>\n\n"
                                        f"ü™ô {coin}\n"
                                        f"üí∞ Sold at: ${sell_price:.4f}\n"
                                        f"‚úÖ Profit: +${profit:.2f}\n"
                                        f"üìä Total Grid Profit: +${total_profit:.2f}"
                                    )
                                else:
                                    continue
                                
                                try:
                                    await safe_send_notification(bot, uid, msg, parse_mode="HTML")
                                except Exception as e:
                                    logger.warning(f"Failed to notify grid event for {uid}: {e}")
                                    
                        except Exception as e:
                            logger.error(f"Grid check error for {uid}: {e}")
                    
                except Exception as e:
                    logger.error(f"TP/Rebalance error for user {uid}: {e}")
            
        except Exception as e:
            logger.exception(f"Critical error in spot_tp_rebalance_loop: {e}")
            await asyncio.sleep(60)


async def spot_auto_dca_loop(app: Application):
    """
    Background loop that executes automatic spot DCA for users who have:
    - auto_dca enabled
    - frequency set to daily/weekly/monthly
    - valid API credentials (Bybit or HyperLiquid)
    
    Runs every hour and checks if it's time for each user's DCA.
    
    Supports both Bybit and HyperLiquid exchanges.
    """
    bot = app.bot
    logger.info("Starting spot_auto_dca_loop (Bybit + HyperLiquid)")
    
    while True:
        try:
            await asyncio.sleep(3600)  # Check every hour
            
            if GLOBAL_PAUSED:
                continue
            
            now = int(time.time())
            
            for uid in get_all_users():
                try:
                    cfg = get_user_config(uid)
                    spot_settings = cfg.get("spot_settings") or {}
                    
                    # Skip if spot trading is disabled in strategy settings
                    if not cfg.get("spot_enabled", 0):
                        continue
                    
                    # Skip if auto_dca is not enabled
                    if not spot_settings.get("auto_dca"):
                        continue
                    
                    frequency = spot_settings.get("frequency", "manual")
                    if frequency == "manual":
                        continue
                    
                    # Detect user's exchange
                    user_exchange = db.get_exchange_type(uid) or "bybit"
                    
                    # Check if user has API credentials for their exchange
                    has_credentials = False
                    if user_exchange == "hyperliquid":
                        hl_creds = db.get_hl_credentials(uid)
                        if hl_creds:
                            # Check for any HL private key
                            has_credentials = bool(
                                hl_creds.get("hl_testnet_private_key") or
                                hl_creds.get("hl_mainnet_private_key") or
                                hl_creds.get("hl_private_key")
                            )
                    else:
                        k, s = get_user_credentials(uid)
                        has_credentials = bool(k and s)
                    
                    if not has_credentials:
                        continue
                    
                    # Check interval
                    interval = SPOT_DCA_INTERVALS.get(frequency)
                    if not interval:
                        continue
                    
                    # Get last execution time
                    last_exec = spot_settings.get("last_dca_ts", 0) or _spot_dca_last_exec.get(uid, 0)
                    
                    # Check if enough time has passed
                    if now - last_exec < interval:
                        continue
                    
                    # Time to execute DCA!
                    logger.info(f"Executing auto spot DCA for user {uid} (freq={frequency}, exchange={user_exchange})")
                    
                    lang = cfg.get("lang", DEFAULT_LANG)
                    t = LANGS.get(lang, LANGS[DEFAULT_LANG])
                    
                    coins = spot_settings.get("coins", SPOT_DCA_COINS)
                    base_amount = spot_settings.get("dca_amount", SPOT_DCA_DEFAULT_AMOUNT)
                    strategy = spot_settings.get("strategy", "fixed")
                    portfolio = spot_settings.get("portfolio", "custom")
                    allocation = spot_settings.get("allocation", {})
                    account_type = spot_settings.get("trading_mode", "demo")
                    
                    # Normalize account_type for HyperLiquid
                    if user_exchange == "hyperliquid":
                        if account_type in ("demo", "real"):
                            account_type = "testnet" if account_type == "demo" else "mainnet"
                    
                    # Get portfolio allocation if using preset
                    if portfolio != "custom" and portfolio in SPOT_PORTFOLIOS:
                        portfolio_info = SPOT_PORTFOLIOS[portfolio]
                        allocation = portfolio_info.get("coins", {})
                    
                    results = []
                    total_spent = 0.0
                    skipped = []
                    
                    for coin in coins:
                        try:
                            # Calculate amount based on allocation
                            if allocation and coin in allocation:
                                coin_pct = allocation[coin] / 100.0
                                coin_base_amount = base_amount * coin_pct
                            else:
                                coin_base_amount = base_amount / len(coins) if coins else base_amount
                            
                            # Apply smart DCA strategy multiplier
                            adjusted_amount = await calculate_smart_dca_amount(
                                base_amount=coin_base_amount,
                                strategy=strategy,
                                coin=coin,
                                spot_settings=spot_settings,
                                user_id=uid,
                                account_type=account_type,
                                exchange=user_exchange,
                            )
                            
                            if adjusted_amount <= 0:
                                skipped.append(coin)
                                continue
                            
                            result = await execute_spot_dca_buy(
                                uid, coin, adjusted_amount,
                                account_type=account_type,
                                exchange=user_exchange
                            )
                            if result.get("success"):
                                spent = result.get("usdt_spent", adjusted_amount)
                                results.append(f"‚úÖ {result.get('qty', 0):.6f} {coin} (${spent:.2f})")
                                total_spent += spent
                            elif result.get("error") == "SKIP":
                                # Silently skip - don't notify user
                                skipped.append(coin)
                            else:
                                # Only show real errors
                                results.append(f"‚ùå {coin}: {result.get('error', 'Error')}")
                        except Exception as e:
                            logger.error(f"Auto DCA buy error for {coin}: {e}")
                            results.append(f"‚ùå {coin}: {str(e)[:50]}")
                    
                    # Update last execution timestamp
                    spot_settings["last_dca_ts"] = now
                    spot_settings["total_invested"] = spot_settings.get("total_invested", 0.0) + total_spent
                    _spot_dca_last_exec[uid] = now
                    
                    db.set_user_field(uid, "spot_settings", json.dumps(spot_settings))
                    
                    # Notify user
                    if results:
                        strategy_info = SMART_DCA_STRATEGIES.get(strategy, {})
                        strategy_label = f"{strategy_info.get('emoji', 'üìä')} {strategy_info.get('name', 'Fixed')}"
                        
                        freq_labels = {
                            "daily": t.get("spot_freq_daily", "Daily"),
                            "weekly": t.get("spot_freq_weekly", "Weekly"),
                            "monthly": t.get("spot_freq_monthly", "Monthly"),
                        }
                        
                        msg_lines = [
                            f"üîÑ <b>Auto DCA Executed</b>",
                            f"",
                            f"üìÖ Frequency: {freq_labels.get(frequency, frequency)}",
                            f"üéØ Strategy: {strategy_label}",
                            f"üí∞ Total spent: ${total_spent:.2f}",
                            f"",
                        ]
                        msg_lines.extend(results)
                        
                        if skipped:
                            msg_lines.append(f"")
                            msg_lines.append(f"‚è≠Ô∏è Skipped: {', '.join(skipped)}")
                        
                        try:
                            await safe_send_notification(bot, uid, "\n".join(msg_lines), parse_mode="HTML")
                        except Exception as e:
                            logger.warning(f"Failed to notify user {uid} about auto DCA: {e}")
                    
                except Exception as e:
                    logger.error(f"Auto DCA error for user {uid}: {e}")
            
        except Exception as e:
            logger.exception(f"Critical error in spot_auto_dca_loop: {e}")
            await asyncio.sleep(60)  # Wait a minute before retrying


@log_calls
async def start_monitoring(app: Application):
    try:
        db.init_db()
    except Exception:
        pass
    
    # Set Menu Button to default commands menu (configured via BotFather)
    # Terminal access is available via keyboard button
    try:
        await app.bot.set_chat_menu_button(menu_button=MenuButtonCommands())
        logger.info("Menu button set to Commands menu (BotFather config)")
    except Exception as e:
        logger.warning(f"Failed to set menu button: {e}")
    
    # Start futures positions monitoring loop
    logger.info("Starting monitor_positions_loop task")
    task = asyncio.create_task(monitor_positions_loop(app), name="monitor_positions_loop")
    app.bot_data["monitor_task"] = task

    def _on_done(t: asyncio.Task):
        try:
            exc = t.exception() 
        except asyncio.CancelledError:
            logger.info("monitor_positions_loop cancelled")
            return
        if exc:
            logger.error("monitor_positions_loop crashed", exc_info=(type(exc), exc, exc.__traceback__))
        else:
            logger.info("monitor_positions_loop finished normally")

    task.add_done_callback(_on_done)
    
    # Start spot auto-DCA loop
    logger.info("Starting spot_auto_dca_loop task")
    spot_task = asyncio.create_task(spot_auto_dca_loop(app), name="spot_auto_dca_loop")
    app.bot_data["spot_dca_task"] = spot_task

    def _on_spot_done(t: asyncio.Task):
        try:
            exc = t.exception() 
        except asyncio.CancelledError:
            logger.info("spot_auto_dca_loop cancelled")
            return
        if exc:
            logger.error("spot_auto_dca_loop crashed", exc_info=(type(exc), exc, exc.__traceback__))
        else:
            logger.info("spot_auto_dca_loop finished normally")

    spot_task.add_done_callback(_on_spot_done)
    
    # Start spot TP/Rebalance monitoring loop
    logger.info("Starting spot_tp_rebalance_loop task")
    tp_task = asyncio.create_task(spot_tp_rebalance_loop(app), name="spot_tp_rebalance_loop")
    app.bot_data["spot_tp_task"] = tp_task

    def _on_tp_done(t: asyncio.Task):
        try:
            exc = t.exception() 
        except asyncio.CancelledError:
            logger.info("spot_tp_rebalance_loop cancelled")
            return
        if exc:
            logger.error("spot_tp_rebalance_loop crashed", exc_info=(type(exc), exc, exc.__traceback__))
        else:
            logger.info("spot_tp_rebalance_loop finished normally")

    tp_task.add_done_callback(_on_tp_done)
    
    # Start notification service loop for market alerts
    if notification_service:
        logger.info("Starting notification_service_loop task")
        notif_task = asyncio.create_task(notification_service.start_notification_loop(), name="notification_loop")
        app.bot_data["notification_task"] = notif_task

        def _on_notif_done(t: asyncio.Task):
            try:
                exc = t.exception() 
            except asyncio.CancelledError:
                logger.info("notification_loop cancelled")
                return
            if exc:
                logger.error("notification_loop crashed", exc_info=(type(exc), exc, exc.__traceback__))
            else:
                logger.info("notification_loop finished normally")

        notif_task.add_done_callback(_on_notif_done)

@with_texts
@log_calls
async def on_users_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    uid_admin = update.effective_user.id

    def T(key: str, **kw):
        s = ctx.t.get(key, key)
        return s.format(**kw) if kw else s

    if uid_admin != ADMIN_ID:
        await q.answer(T("not_allowed"), show_alert=True)
        return

    await q.answer()
    data = q.data or ""
    if data.startswith("users:page:"):
        try:
            page = int(data.split(":", 2)[2])
        except Exception:
            await q.answer(T("bad_page"), show_alert=True)
            return
        await show_users_page(ctx, ctx.bot, q.message.chat_id, page=page)
        return

    try:
        _, action, payload = data.split(":", 2)
        target_uid = int(payload)
    except Exception:
        await q.answer(T("bad_payload"), show_alert=True)
        return

    if action == "approve":
        set_user_field(target_uid, "is_allowed", 1)
        set_user_field(target_uid, "is_banned", 0)
        new_kb = InlineKeyboardMarkup([
            [InlineKeyboardButton(T("btn_blacklist"), callback_data=f"users:ban:{target_uid}")],
            [InlineKeyboardButton(T("btn_delete_user"), callback_data=f"users:del:{target_uid}")]
        ])
        try:
            await q.edit_message_reply_markup(reply_markup=new_kb)
        except Exception:
            pass
        await q.message.reply_text(T("moderation_approved", target=target_uid))
        try:
            await ctx.bot.send_message(target_uid, T("user_access_approved"))
        except Exception:
            pass

    elif action == "ban":
        set_user_field(target_uid, "is_banned", 1)
        set_user_field(target_uid, "is_allowed", 0)
        new_kb = InlineKeyboardMarkup([
            [InlineKeyboardButton(T("btn_delete_user"), callback_data=f"users:del:{target_uid}")]
        ])
        try:
            await q.edit_message_reply_markup(reply_markup=new_kb)
        except Exception:
            pass
        await q.message.reply_text(T("moderation_banned", target=target_uid))
        try:
            await ctx.bot.send_message(target_uid, T("banned"))
        except Exception:
            pass

    elif action == "del":
        try:
            db.delete_user(target_uid)
        except Exception as e:
            await q.message.reply_text(T("admin_user_delete_fail", target=target_uid, error=e))
            return
        try:
            await q.edit_message_text(T("admin_user_deleted", target=target_uid))
        except Exception:
            await q.message.reply_text(T("admin_user_deleted", target=target_uid))

    else:
        await q.answer(T("unknown_action"), show_alert=True)

@require_access
@with_texts
@log_calls
async def cancel_order(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    await update.message.reply_text(
        ctx.t['order_cancelled'],
        reply_markup=main_menu_keyboard(ctx, update=update)
    )
    return ConversationHandler.END

@require_access
@with_texts
@log_calls
async def cmd_update_tpsl(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    uid = update.effective_user.id
    positions = await fetch_open_positions(uid)
    if not positions:
        await update.message.reply_text(ctx.t['update_tpsl_no_positions'], reply_markup=main_menu_keyboard(ctx, update=update))
        return
    await update.message.reply_text(ctx.t['update_tpsl_prompt'], parse_mode='Markdown')
    ctx.user_data['mode'] = 'update_tpsl'

@require_access
@with_texts
@log_calls
async def on_coin_group_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    q = update.callback_query
    try:
        await q.answer()
    except Exception:
        pass

    data = (q.data or "").strip()
    try:
        prefix, raw = data.split(":", 1)
        if prefix != "coins":
            await q.answer("Bad payload", show_alert=True)
            return
    except Exception:
        await q.answer("Bad payload", show_alert=True)
        return

    group = raw.strip().upper()
    # TOP100 -> TOP migration
    if group == "TOP100":
        group = "TOP"
    valid = {"ALL", "TOP", "VOLATILE"}
    if group not in valid:
        await q.answer("Unknown group", show_alert=True)
        return

    set_user_field(q.from_user.id, "coins", group)
    ctx.user_data["coins"] = group

    labels = {
        "ALL":      ctx.t.get('group_all', 'ALL'),
        "TOP":      ctx.t.get('group_top', 'TOP'),
        "VOLATILE": ctx.t.get('group_volatile', 'VOLATILE'),
    }
    label = labels[group]

    try:
        await q.edit_message_text(ctx.t['group_set'].format(group=label))
    except Exception:
        await ctx.bot.send_message(q.from_user.id, ctx.t['group_set'].format(group=label))

    # –ø–æ–∫–∞–∑—ã–≤–∞–µ–º –º–µ–Ω—é
    await ctx.bot.send_message(
        chat_id=q.from_user.id,
        text=ctx.t['welcome'],
        reply_markup=main_menu_keyboard(ctx, update=update)
    )


def _fmt_bool_mark(t: dict, v: int | bool | None) -> str:
    return t.get('mark_yes', '‚úÖ') if v else t.get('mark_no', '‚ùå')

def _fmt_username(u, dash: str = "‚Äî") -> str:
    try:
        return f"@{u.username}" if u and getattr(u, "username", None) else dash
    except Exception:
        return dash

async def _fetch_user_public(bot, uid: int):
    try:
        return await bot.get_chat(uid)
    except Exception:
        return None


async def show_users_page(ctx: ContextTypes.DEFAULT_TYPE, bot, chat_id: int, page: int = 0):
    # Get translations manually since this is not a direct handler
    if hasattr(ctx, 't') and ctx.t:
        t = ctx.t
    else:
        lang = DEFAULT_LANG
        if hasattr(ctx, 'user_data') and ctx.user_data:
            lang = ctx.user_data.get('lang', DEFAULT_LANG)
        t = LANGS.get(lang, LANGS[DEFAULT_LANG])
    
    all_ids = sorted(set(get_all_users() or []))
    total = len(all_ids)
    if total == 0:
        await bot.send_message(chat_id, t['users_not_found'])
        return

    start = page * PAGE_SIZE
    end   = min(start + PAGE_SIZE, total)
    slice_ids = all_ids[start:end]
    pages_total = (total - 1) // PAGE_SIZE + 1

    await bot.send_message(chat_id, t['users_page_info'].format(page=page+1, pages=pages_total, total=total))

    for uid in slice_ids:
        cfg = get_user_config(uid) or {}
        allowed = _fmt_bool_mark(t, cfg.get("is_allowed", 0))
        banned  = _fmt_bool_mark(t, cfg.get("is_banned", 0))
        terms   = _fmt_bool_mark(t, cfg.get("terms_accepted", 0))
        lang    = cfg.get("lang", DEFAULT_LANG)
        percent = cfg.get("percent", 0)

        u = await _fetch_user_public(bot, uid)
        full_name = (f"{getattr(u,'first_name', '') or ''} {getattr(u,'last_name','') or ''}").strip() or t['dash']
        uname = _fmt_username(u, dash=t['dash'])

        text = t['user_card_html'].format(
            uid=uid,
            full_name=html.escape(full_name),
            uname=uname,
            lang=lang,
            allowed=allowed,
            banned=banned,
            terms=terms,
            percent=percent
        )

        if cfg.get("is_banned", 0):
            kb = InlineKeyboardMarkup([[InlineKeyboardButton(t['btn_delete_user'], callback_data=f"users:del:{uid}")]])
        else:
            kb = InlineKeyboardMarkup([[InlineKeyboardButton(t['btn_blacklist'], callback_data=f"users:ban:{uid}")]])

        await bot.send_message(chat_id, text, parse_mode="HTML", reply_markup=kb, disable_web_page_preview=True)

    nav_row = []
    if page > 0:
        nav_row.append(InlineKeyboardButton(t['btn_prev'], callback_data=f"users:page:{page-1}"))
    if end < total:
        nav_row.append(InlineKeyboardButton(t['btn_next'], callback_data=f"users:page:{page+1}"))
    if nav_row:
        await bot.send_message(chat_id, t['nav_caption'], reply_markup=InlineKeyboardMarkup([nav_row]))


@require_access
@with_texts
@log_calls
async def cmd_sync_history(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """
    Sync trade history from Bybit API.
    Usage: /sync_history [days] [account]
    Example: /sync_history 30 real
    """
    uid = update.effective_user.id
    t = ctx.t
    args = ctx.args or []
    
    days = 30  # default
    account = None  # auto-detect
    
    if len(args) >= 1:
        try:
            days = int(args[0])
        except ValueError:
            pass
    
    if len(args) >= 2 and args[1] in ("demo", "real", "both"):
        account = args[1]
    
    await update.message.reply_text(
        f"üîÑ Syncing trade history for last {days} days...\nThis may take a moment.",
        parse_mode="Markdown"
    )
    
    try:
        from sync_trade_history import sync_user_trades
        
        # Determine account types to sync
        if account == "both":
            account_types = ["demo", "real"]
        elif account:
            account_types = [account]
        else:
            trading_mode = db.get_trading_mode(uid) or "demo"
            account_types = ["demo", "real"] if trading_mode == "both" else [trading_mode]
        
        total_imported = 0
        total_skipped = 0
        all_strategies = {}
        
        for acc_type in account_types:
            stats = await sync_user_trades(uid, days, acc_type, dry_run=False)
            total_imported += stats["imported"]
            total_skipped += stats["skipped_exists"]
            
            for strat, count in stats.get("strategies_detected", {}).items():
                all_strategies[strat] = all_strategies.get(strat, 0) + count
        
        # Format result
        strategies_text = "\n".join([f"  ‚Ä¢ {s}: {c}" for s, c in all_strategies.items()]) or "  No strategies detected"
        
        result_text = f"""
‚úÖ *Sync Complete!*

üìä *Results:*
‚îú‚îÄ Imported: {total_imported} trades
‚îú‚îÄ Skipped (exist): {total_skipped}
‚îî‚îÄ Accounts: {", ".join(account_types)}

üìà *By Strategy:*
{strategies_text}
"""
        await update.message.reply_text(result_text, parse_mode="Markdown")
        
    except Exception as e:
        logger.error(f"[{uid}] Sync history error: {e}")
        await update.message.reply_text(
            f"‚ùå Sync failed: {str(e)}",
            parse_mode="Markdown"
        )


@with_texts
@log_calls
async def cmd_admin(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    if update.effective_user.id != ADMIN_ID:
        return
    t = ctx.t
    keyboard = [
        [InlineKeyboardButton(t.get('admin_users_management', 'üë• Users'), callback_data="admin:users_menu"),
         InlineKeyboardButton(t.get('admin_licenses', 'üîë Licenses'), callback_data="adm_lic:menu")],
        [InlineKeyboardButton("üìà Positions", callback_data="admin:positions_menu"),
         InlineKeyboardButton("üìä Trades", callback_data="admin:trades_menu")],
        [InlineKeyboardButton("üì° Signals", callback_data="admin:signals_menu"),
         InlineKeyboardButton(t.get('admin_reports', 'üìä Reports'), callback_data="admin:reports_menu")],
        [InlineKeyboardButton(t.get('admin_payments', 'üí≥ Payments'), callback_data="admin:payments_menu"),
         InlineKeyboardButton("üîß System", callback_data="admin:system_menu")],
        [InlineKeyboardButton("üö® Errors", callback_data="admin:errors_menu"),
         InlineKeyboardButton("üì¢ Broadcast", callback_data="admin:broadcast_menu")],
        [InlineKeyboardButton(t['admin_pause_all'],  callback_data="admin:pause"),
         InlineKeyboardButton(t['admin_resume_all'], callback_data="admin:resume")],
        [InlineKeyboardButton(t['admin_close_longs'],  callback_data="admin:close_longs"),
         InlineKeyboardButton(t['admin_close_shorts'], callback_data="admin:close_shorts")],
        [InlineKeyboardButton(t['admin_cancel_limits'], callback_data="admin:cancel_limits")],
        [InlineKeyboardButton(t.get('admin_search_user', 'üîç Find User'), callback_data="admin:search_user")],
    ]
    await update.message.reply_text(t['admin_panel'], reply_markup=InlineKeyboardMarkup(keyboard))

@with_texts
@log_calls
async def on_admin_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    t   = ctx.t
    q   = update.callback_query
    uid = update.effective_user.id
    await q.answer()
    if uid != ADMIN_ID:
        return
    try:
        _, cmd = q.data.split(":", 1)
    except Exception:
        return

    if cmd == "menu":
        # Back to main admin menu
        keyboard = [
            [InlineKeyboardButton(t.get('admin_users_management', 'üë• Users'), callback_data="admin:users_menu"),
             InlineKeyboardButton(t.get('admin_licenses', 'üîë Licenses'), callback_data="adm_lic:menu")],
            [InlineKeyboardButton("üìà Positions", callback_data="admin:positions_menu"),
             InlineKeyboardButton("üìä Trades", callback_data="admin:trades_menu")],
            [InlineKeyboardButton("üì° Signals", callback_data="admin:signals_menu"),
             InlineKeyboardButton(t.get('admin_reports', 'üìä Reports'), callback_data="admin:reports_menu")],
            [InlineKeyboardButton(t.get('admin_payments', 'üí≥ Payments'), callback_data="admin:payments_menu"),
             InlineKeyboardButton("üîß System", callback_data="admin:system_menu")],
            [InlineKeyboardButton("üö® Errors", callback_data="admin:errors_menu"),
             InlineKeyboardButton("üì¢ Broadcast", callback_data="admin:broadcast_menu")],
            [InlineKeyboardButton(t['admin_pause_all'],  callback_data="admin:pause"),
             InlineKeyboardButton(t['admin_resume_all'], callback_data="admin:resume")],
            [InlineKeyboardButton(t['admin_close_longs'],  callback_data="admin:close_longs"),
             InlineKeyboardButton(t['admin_close_shorts'], callback_data="admin:close_shorts")],
            [InlineKeyboardButton(t['admin_cancel_limits'], callback_data="admin:cancel_limits")],
            [InlineKeyboardButton(t.get('admin_search_user', 'üîç Find User'), callback_data="admin:search_user")],
        ]
        await q.edit_message_text(t['admin_panel'], reply_markup=InlineKeyboardMarkup(keyboard))

    elif cmd == "pause":
        global GLOBAL_PAUSED
        GLOBAL_PAUSED = True
        await q.edit_message_text(t['admin_pause_notice'])

    elif cmd == "resume":
        GLOBAL_PAUSED = False
        await q.edit_message_text(t['admin_resume_notice'])

    elif cmd == "users":
        await show_users_page(ctx, ctx.bot, q.message.chat_id, page=0)

    elif cmd == "users_menu":
        # Users management menu with filters
        keyboard = [
            [InlineKeyboardButton(t.get('admin_all_users', 'üë• All Users'), callback_data="admin:users_list:all:0")],
            [InlineKeyboardButton(t.get('admin_active_users', '‚úÖ Active'), callback_data="admin:users_list:active:0"),
             InlineKeyboardButton(t.get('admin_banned_users', 'üö´ Banned'), callback_data="admin:users_list:banned:0")],
            [InlineKeyboardButton("üíé Premium", callback_data="admin:users_list:premium:0"),
             InlineKeyboardButton("ü•à Basic", callback_data="admin:users_list:basic:0"),
             InlineKeyboardButton("üéÅ Trial", callback_data="admin:users_list:trial:0")],
            [InlineKeyboardButton(t.get('admin_no_license', '‚ùå No License'), callback_data="admin:users_list:no_license:0")],
            [InlineKeyboardButton(t.get('admin_search_user', 'üîç Find User'), callback_data="admin:search_user")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:menu")],
        ]
        await q.edit_message_text(
            t.get('admin_users_menu', 'üë• *User Management*\n\nSelect filter or search:'),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    elif cmd.startswith("users_list:"):
        # Show paginated users list with 3-column layout (like positions)
        parts = cmd.split(":")
        filter_type = parts[1] if len(parts) > 1 else "all"
        page = int(parts[2]) if len(parts) > 2 else 0
        
        users, total = get_users_paginated(page=page, per_page=8, filter_type=filter_type)
        total_pages = max(1, (total + 7) // 8)
        
        if not users:
            await q.edit_message_text(
                t.get('admin_no_users_found', 'No users found.'),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:users_menu")]
                ])
            )
            return
        
        # Build user list header
        filter_labels = {
            "all": "all", "active": "‚úÖ active", "banned": "üö´ banned",
            "premium": "ü§ù patron", "basic": "ü•à supporter", "trial": "üéÅ explorer",
            "no_license": "‚ùå no access"
        }
        header = f"üë• *Users ({filter_labels.get(filter_type, filter_type)})* ‚Äî Page {page + 1}/{total_pages}"
        header += f"\nüìä Total: {total} users\n"
        
        keyboard = []
        
        # 3-column layout for each user:
        # [Status+ID] ‚Üí opens user menu
        # [License type] ‚Üí info display  
        # [‚ùå Delete] ‚Üí quick delete action
        for u in users:
            status = "üö´" if u["is_banned"] else "‚úÖ" if u["is_allowed"] else "‚è≥"
            license_icon = {"premium": "ü§ù", "basic": "ü•à", "trial": "üéÅ", "enterprise": "üëë"}.get(u["license_type"], "‚ùå")
            days = f"{u['license_days_left']}d" if u.get("license_days_left") else ""
            
            # Column 1: Status + User ID ‚Üí opens full user card with all actions
            # Column 2: License type display  
            # Column 3: Quick delete button
            keyboard.append([
                InlineKeyboardButton(
                    f"{status} {u['user_id']}",
                    callback_data=f"admin:user:{u['user_id']}"
                ),
                InlineKeyboardButton(
                    f"{license_icon} {days}" if days else f"{license_icon}",
                    callback_data=f"admin:user:{u['user_id']}"
                ),
                InlineKeyboardButton(
                    "‚ùå",
                    callback_data=f"admin:quick_delete:{u['user_id']}:{filter_type}:{page}"
                )
            ])
        
        # Navigation row (Previous | Page/Total | Next)
        nav_row = []
        if page > 0:
            nav_row.append(InlineKeyboardButton("‚óÄÔ∏è Prev", callback_data=f"admin:users_list:{filter_type}:{page-1}"))
        nav_row.append(InlineKeyboardButton(f"{page + 1}/{total_pages}", callback_data="noop"))
        if page < total_pages - 1:
            nav_row.append(InlineKeyboardButton("Next ‚ñ∂Ô∏è", callback_data=f"admin:users_list:{filter_type}:{page+1}"))
        
        if nav_row:
            keyboard.append(nav_row)
        
        # Action row (refresh + search)
        keyboard.append([
            InlineKeyboardButton("üîÑ Refresh", callback_data=f"admin:users_list:{filter_type}:{page}"),
            InlineKeyboardButton("üîç Search", callback_data="admin:search_user")
        ])
        
        # Back to menu
        keyboard.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:users_menu")])
        
        await q.edit_message_text(
            header,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    elif cmd.startswith("quick_delete:"):
        # Quick delete confirmation
        parts = cmd.split(":")
        target_uid = int(parts[1])
        filter_type = parts[2] if len(parts) > 2 else "all"
        page = int(parts[3]) if len(parts) > 3 else 0
        
        await q.edit_message_text(
            f"‚ö†Ô∏è *Delete user {target_uid}?*\n\nThis will remove all user data!",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [
                    InlineKeyboardButton("‚úÖ Yes, Delete", callback_data=f"admin:confirm_delete:{target_uid}:{filter_type}:{page}"),
                    InlineKeyboardButton("‚ùå Cancel", callback_data=f"admin:users_list:{filter_type}:{page}")
                ]
            ])
        )

    elif cmd.startswith("confirm_delete:"):
        # Actually delete user
        parts = cmd.split(":")
        target_uid = int(parts[1])
        filter_type = parts[2] if len(parts) > 2 else "all"
        page = int(parts[3]) if len(parts) > 3 else 0
        
        try:
            delete_user(target_uid)
            await q.answer(f"üóë User {target_uid} deleted!", show_alert=True)
        except Exception as e:
            await q.answer(f"‚ùå Error: {e}", show_alert=True)
        
        # Refresh the list
        q.data = f"admin:users_list:{filter_type}:{page}"
        await on_admin_cb(update, ctx)

    elif cmd.startswith("quick_ban:"):
        # Quick ban from list (stays on same page)
        parts = cmd.split(":")
        target_uid = int(parts[1])
        filter_type = parts[2] if len(parts) > 2 else "all"
        page = int(parts[3]) if len(parts) > 3 else 0
        ban_user(target_uid)
        await q.answer(f"üö´ User {target_uid} banned!", show_alert=True)
        # Refresh the list
        q.data = f"admin:users_list:{filter_type}:{page}"
        await on_admin_cb(update, ctx)

    elif cmd.startswith("quick_unban:"):
        # Quick unban from list (stays on same page)
        parts = cmd.split(":")
        target_uid = int(parts[1])
        filter_type = parts[2] if len(parts) > 2 else "all"
        page = int(parts[3]) if len(parts) > 3 else 0
        allow_user(target_uid)
        await q.answer(f"‚úÖ User {target_uid} unbanned!", show_alert=True)
        # Refresh the list
        q.data = f"admin:users_list:{filter_type}:{page}"
        await on_admin_cb(update, ctx)

    elif cmd.startswith("user_card:"):
        # Show user card (from payment notifications etc.)
        target_uid = int(cmd.split(":")[1])
        await show_user_card(q, ctx, target_uid)

    elif cmd.startswith("user:"):
        # Show user card
        target_uid = int(cmd.split(":")[1])
        await show_user_card(q, ctx, target_uid)

    elif cmd == "search_user":
        # Ask for user ID
        ctx.user_data["mode"] = "admin_search_user"
        await q.edit_message_text(
            t.get('admin_enter_user_id', 'üîç Enter user ID to search:'),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get('btn_cancel', '‚ùå Cancel'), callback_data="admin:users_menu")]
            ])
        )

    elif cmd.startswith("ban:"):
        target_uid = int(cmd.split(":")[1])
        ban_user(target_uid)
        await q.answer(t.get('admin_user_banned', 'User banned!'), show_alert=True)
        await show_user_card(q, ctx, target_uid)

    elif cmd.startswith("unban:"):
        target_uid = int(cmd.split(":")[1])
        allow_user(target_uid)
        await q.answer(t.get('admin_user_unbanned', 'User unbanned!'), show_alert=True)
        await show_user_card(q, ctx, target_uid)

    elif cmd.startswith("approve:"):
        target_uid = int(cmd.split(":")[1])
        set_user_field(target_uid, "is_allowed", 1)
        await q.answer(t.get('admin_user_approved', 'User approved!'), show_alert=True)
        await show_user_card(q, ctx, target_uid)

    elif cmd.startswith("delete:"):
        target_uid = int(cmd.split(":")[1])
        # Confirm deletion
        await q.edit_message_text(
            t.get('admin_confirm_delete', '‚ö†Ô∏è *Confirm deletion*\n\nUser {uid} will be permanently deleted!').format(uid=target_uid),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get('admin_confirm_yes', '‚úÖ Yes, Delete'), callback_data=f"admin:confirm_delete:{target_uid}")],
                [InlineKeyboardButton(t.get('admin_confirm_no', '‚ùå Cancel'), callback_data=f"admin:user:{target_uid}")],
            ])
        )

    elif cmd.startswith("grant_lic:"):
        # Grant license to user: admin:grant_lic:uid:type:months
        parts = cmd.split(":")
        target_uid = int(parts[1])
        license_type = parts[2] if len(parts) > 2 else None
        months = int(parts[3]) if len(parts) > 3 else None
        
        if not license_type:
            # Select license type
            await q.edit_message_text(
                t.get('admin_select_license_type', 'Select license type for user {uid}:').format(uid=target_uid),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üíé Premium", callback_data=f"admin:grant_lic:{target_uid}:premium")],
                    [InlineKeyboardButton("ü•à Basic", callback_data=f"admin:grant_lic:{target_uid}:basic")],
                    [InlineKeyboardButton("üéÅ Trial (7d)", callback_data=f"admin:grant_lic:{target_uid}:trial:1")],
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data=f"admin:user:{target_uid}")],
                ])
            )
        elif not months and license_type != "trial":
            # Select period
            if license_type == "premium":
                keyboard = [
                    [InlineKeyboardButton("1 Month", callback_data=f"admin:grant_lic:{target_uid}:premium:1")],
                    [InlineKeyboardButton("3 Months", callback_data=f"admin:grant_lic:{target_uid}:premium:3")],
                    [InlineKeyboardButton("6 Months", callback_data=f"admin:grant_lic:{target_uid}:premium:6")],
                    [InlineKeyboardButton("12 Months", callback_data=f"admin:grant_lic:{target_uid}:premium:12")],
                ]
            else:
                keyboard = [
                    [InlineKeyboardButton("1 Month", callback_data=f"admin:grant_lic:{target_uid}:basic:1")],
                ]
            keyboard.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data=f"admin:grant_lic:{target_uid}")])
            await q.edit_message_text(
                t.get('admin_select_period', 'Select period:'),
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        else:
            # Grant license
            result = set_user_license(
                user_id=target_uid,
                license_type=license_type,
                period_months=months or 1,
                admin_id=uid,
                payment_type="admin_grant",
            )
            if result.get("success"):
                await q.answer(t.get('admin_license_granted_short', 'License granted!'), show_alert=True)
            else:
                await q.answer(f"Error: {result.get('error')}", show_alert=True)
            await show_user_card(q, ctx, target_uid)

    elif cmd.startswith("extend_lic:"):
        # Extend license: admin:extend_lic:uid or admin:extend_lic:uid:days
        parts = cmd.split(":")
        target_uid = int(parts[1])
        days = int(parts[2]) if len(parts) > 2 else None
        
        if not days:
            # Select days to extend
            await q.edit_message_text(
                t.get('admin_select_extend_days', 'Select days to extend for user {uid}:').format(uid=target_uid),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("7 days", callback_data=f"admin:extend_lic:{target_uid}:7"),
                     InlineKeyboardButton("14 days", callback_data=f"admin:extend_lic:{target_uid}:14")],
                    [InlineKeyboardButton("30 days", callback_data=f"admin:extend_lic:{target_uid}:30"),
                     InlineKeyboardButton("90 days", callback_data=f"admin:extend_lic:{target_uid}:90")],
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data=f"admin:user:{target_uid}")],
                ])
            )
        else:
            result = extend_license(target_uid, days, admin_id=uid)
            if result.get("success"):
                await q.answer(t.get('admin_license_extended_short', 'Extended by {days} days!').format(days=days), show_alert=True)
            else:
                await q.answer(f"Error: {result.get('error')}", show_alert=True)
            await show_user_card(q, ctx, target_uid)

    elif cmd.startswith("revoke_lic:"):
        target_uid = int(cmd.split(":")[1])
        result = revoke_license(target_uid, admin_id=uid)
        if result.get("success"):
            await q.answer(t.get('admin_license_revoked_short', 'License revoked!'), show_alert=True)
        else:
            await q.answer(f"Error: {result.get('error')}", show_alert=True)
        await show_user_card(q, ctx, target_uid)

    elif cmd.startswith("msg_user:"):
        # Send message to user
        target_uid = int(cmd.split(":")[1])
        ctx.user_data["admin_msg_target"] = target_uid
        ctx.user_data["mode"] = "admin_send_message"
        await q.edit_message_text(
            t.get('admin_enter_message', '‚úâÔ∏è Enter message to send to user {uid}:').format(uid=target_uid),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get('btn_cancel', '‚ùå Cancel'), callback_data=f"admin:user:{target_uid}")]
            ])
        )

    elif cmd in ("close_longs", "close_shorts"):
        side_to_close = "Buy" if cmd == "close_longs" else "Sell"
        type_label = t['type_longs'] if cmd == "close_longs" else t['type_shorts']
        count = 0
        for user in get_all_users():
            if GLOBAL_PAUSED:
                break
            positions = await fetch_open_positions(user)
            targets = [p for p in positions if p.get("side") == side_to_close]
            for p in targets:
                sym = p.get("symbol")
                qty = float(p.get("size", 0) or 0)
                if not sym or qty <= 0:
                    continue
                try:
                    await place_order(
                        user_id=user,
                        symbol=sym,
                        side=("Sell" if side_to_close == "Buy" else "Buy"),
                        orderType="Market",
                        qty=qty
                    )
                    count += 1
                except Exception:
                    pass
        await q.edit_message_text(t['admin_closed_total'].format(count=count, type=type_label))

    elif cmd == "cancel_limits":
        canceled = 0
        for user in get_all_users():
            if GLOBAL_PAUSED:
                break
            orders = await fetch_open_orders(user)
            for o in orders:
                if o.get("orderType") == "Limit":
                    try:
                        await _bybit_request(
                            user, "POST", "/v5/order/cancel",
                            body={"category": "linear", "orderId": o["orderId"], "symbol": o["symbol"]}
                        )
                        remove_pending_limit_order(user, o["orderId"], exchange="bybit")
                        canceled += 1
                    except Exception:
                        pass
        await q.edit_message_text(t['admin_canceled_limits_total'].format(count=canceled))

    # =====================================================
    # ERRORS MENU - Admin error management
    # =====================================================
    elif cmd == "errors_menu":
        stats = db.get_error_stats()
        pending = stats.get("pending", 0)
        by_type = stats.get("by_type", {})
        
        text = "üö® *Error Management*\n\n"
        text += f"üìä Pending errors: *{pending}*\n\n"
        
        if by_type:
            text += "*By Type:*\n"
            for etype, data in sorted(by_type.items(), key=lambda x: -x[1].get("total_occurrences", 0)):
                count = data.get("count", 0)
                total = data.get("total_occurrences", 0)
                text += f"‚Ä¢ {etype}: {count} ({total}x)\n"
        
        keyboard = [
            [InlineKeyboardButton("üìã View All Errors", callback_data="admin:errors_list:0")],
            [InlineKeyboardButton("üë• By User", callback_data="admin:errors_by_user")],
            [InlineKeyboardButton("‚úÖ Approve All", callback_data="admin:errors_approve_all")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd.startswith("errors_list:"):
        # Paginated list of errors
        page = int(cmd.split(":")[1]) if ":" in cmd else 0
        per_page = 5
        errors = db.get_pending_admin_errors(limit=50)
        total = len(errors)
        total_pages = max(1, (total + per_page - 1) // per_page)
        start = page * per_page
        end = start + per_page
        page_errors = errors[start:end]
        
        if not page_errors:
            text = "‚úÖ No pending errors!"
            keyboard = [[InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:errors_menu")]]
            await q.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            return
        
        text = f"üö® *Pending Errors* ({page + 1}/{total_pages})\n\n"
        keyboard = []
        
        for err in page_errors:
            user_id = err["user_id"]
            username = err.get("username") or err.get("first_name") or str(user_id)
            error_type = err["error_type"]
            count = err["occurrence_count"]
            last_seen = err["last_seen"]
            last_str = last_seen.strftime("%d.%m %H:%M") if last_seen else "?"
            
            text += f"*{error_type}* ({count}x)\n"
            text += f"‚îú User: `{username}` ({user_id})\n"
            text += f"‚îú Last: {last_str}\n"
            text += f"‚îî {err['error_message'][:80]}...\n\n"
            
            # Buttons for each error: Approve | Notify User
            keyboard.append([
                InlineKeyboardButton(f"‚úÖ #{err['id']}", callback_data=f"admin:err_approve:{err['id']}"),
                InlineKeyboardButton(f"üì® Notify", callback_data=f"admin:err_notify:{err['id']}:{user_id}"),
            ])
        
        # Pagination
        nav_row = []
        if page > 0:
            nav_row.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"admin:errors_list:{page - 1}"))
        nav_row.append(InlineKeyboardButton(f"{page + 1}/{total_pages}", callback_data="noop"))
        if page < total_pages - 1:
            nav_row.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"admin:errors_list:{page + 1}"))
        keyboard.append(nav_row)
        keyboard.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:errors_menu")])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd == "errors_by_user":
        # Show errors grouped by user
        stats = db.get_error_stats()
        top_users = stats.get("top_users", [])
        
        if not top_users:
            text = "‚úÖ No pending errors!"
            keyboard = [[InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:errors_menu")]]
            await q.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            return
        
        text = "üë• *Errors by User*\n\n"
        keyboard = []
        
        for u in top_users[:10]:
            user_id = u["user_id"]
            username = u.get("username") or u.get("first_name") or str(user_id)
            error_count = u["error_count"]
            total_occ = u["total_occurrences"]
            
            text += f"‚Ä¢ `{username}`: {error_count} errors ({total_occ}x)\n"
            keyboard.append([
                InlineKeyboardButton(f"üë§ {username}", callback_data=f"admin:user_errors:{user_id}"),
                InlineKeyboardButton("‚úÖ Approve All", callback_data=f"admin:approve_user:{user_id}"),
            ])
        
        keyboard.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:errors_menu")])
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd.startswith("user_errors:"):
        # Show errors for specific user
        user_id = int(cmd.split(":")[1])
        errors = db.get_admin_errors_by_user(user_id)
        
        if not errors:
            text = f"‚úÖ No pending errors for user {user_id}!"
            keyboard = [[InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:errors_by_user")]]
            await q.edit_message_text(text, reply_markup=InlineKeyboardMarkup(keyboard))
            return
        
        # Get username
        user = db.pg_get_user(user_id)
        username = user.get("username") or user.get("first_name") or str(user_id) if user else str(user_id)
        
        text = f"üö® *Errors for {username}*\n\n"
        keyboard = []
        
        for err in errors[:10]:
            error_type = err["error_type"]
            count = err["occurrence_count"]
            text += f"‚Ä¢ *{error_type}* ({count}x)\n"
            text += f"  {err['error_message'][:60]}...\n\n"
            
            keyboard.append([
                InlineKeyboardButton(f"‚úÖ Approve #{err['id']}", callback_data=f"admin:err_approve:{err['id']}"),
            ])
        
        keyboard.append([
            InlineKeyboardButton("‚úÖ Approve All", callback_data=f"admin:approve_user:{user_id}"),
            InlineKeyboardButton("üì® Notify User", callback_data=f"admin:notify_user:{user_id}"),
        ])
        keyboard.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:errors_by_user")])
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd.startswith("err_approve:"):
        # Approve single error
        error_id = int(cmd.split(":")[1])
        success = db.approve_admin_error(error_id)
        if success:
            await q.answer("‚úÖ Error approved!", show_alert=True)
        else:
            await q.answer("‚ùå Failed to approve", show_alert=True)
        # Refresh list
        await on_admin_cb(update, ctx)
    
    elif cmd.startswith("approve_user:"):
        # Approve all errors for user
        user_id = int(cmd.split(":")[1])
        count = db.approve_all_user_errors(user_id)
        await q.answer(f"‚úÖ Approved {count} errors!", show_alert=True)
        # Go back to errors by user
        cmd = "errors_by_user"
        q.data = "admin:errors_by_user"
        await on_admin_cb(update, ctx)
    
    elif cmd == "errors_approve_all":
        # Approve all pending errors
        errors = db.get_pending_admin_errors(limit=1000)
        count = 0
        for err in errors:
            if db.approve_admin_error(err["id"]):
                count += 1
        await q.answer(f"‚úÖ Approved {count} errors!", show_alert=True)
        q.data = "admin:errors_menu"
        await on_admin_cb(update, ctx)
    
    elif cmd.startswith("err_notify:"):
        # Notify user about error and mark as notified
        parts = cmd.split(":")
        error_id = int(parts[1])
        target_user_id = int(parts[2])
        
        # Get error details
        errors = db.get_admin_errors_by_user(target_user_id, include_approved=True)
        err = next((e for e in errors if e["id"] == error_id), None)
        
        if err:
            error_type = err["error_type"]
            
            # Build user-friendly message based on error type
            msg = "‚ö†Ô∏è *–í–∞–∂–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ*\n\n"
            
            if error_type == "INSUFFICIENT_BALANCE":
                msg += "üí∞ –ù–∞ –≤–∞—à–µ–º –∞–∫–∫–∞—É–Ω—Ç–µ –Ω–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ –¥–ª—è –æ—Ç–∫—Ä—ã—Ç–∏—è –ø–æ–∑–∏—Ü–∏–π.\n\n"
                msg += "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–ø–æ–ª–Ω–∏—Ç–µ –±–∞–ª–∞–Ω—Å –∏–ª–∏ —É–º–µ–Ω—å—à–∏—Ç–µ Entry% –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö —Å—Ç—Ä–∞—Ç–µ–≥–∏–π.\n\n"
                msg += f"üìä –ë–∏—Ä–∂–∞: {err.get('exchange', 'bybit').upper()}\n"
                msg += f"üéÆ –ê–∫–∫–∞—É–Ω—Ç: {err.get('account_type', 'demo')}"
            elif error_type == "API_KEY_EXPIRED":
                msg += "üîë –í–∞—à–∏ API –∫–ª—é—á–∏ —É—Å—Ç–∞—Ä–µ–ª–∏ –∏–ª–∏ –Ω–µ–¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã.\n\n"
                msg += "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –æ–±–Ω–æ–≤–∏—Ç–µ API –∫–ª—é—á–∏ –≤ –Ω–∞—Å—Ç—Ä–æ–π–∫–∞—Ö."
            elif error_type == "API_KEY_MISSING":
                msg += "üîë API –∫–ª—é—á–∏ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω—ã.\n\n"
                msg += "–ù–∞—Å—Ç—Ä–æ–π—Ç–µ API –∫–ª—é—á–∏ –¥–ª—è –Ω–∞—á–∞–ª–∞ —Ç–æ—Ä–≥–æ–≤–ª–∏."
            else:
                msg += f"–û–±–Ω–∞—Ä—É–∂–µ–Ω–∞ –ø—Ä–æ–±–ª–µ–º–∞: {error_type}\n\n"
                msg += "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤–∞—à–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞."
            
            try:
                await ctx.bot.send_message(target_user_id, msg, parse_mode="Markdown")
                db.mark_error_notified(error_id)
                await q.answer("üì® User notified!", show_alert=True)
            except Exception as e:
                await q.answer(f"‚ùå Failed to notify: {e}", show_alert=True)
        else:
            await q.answer("‚ùå Error not found", show_alert=True)
    
    elif cmd.startswith("notify_user:"):
        # Notify user about all their errors
        target_user_id = int(cmd.split(":")[1])
        errors = db.get_admin_errors_by_user(target_user_id)
        
        if not errors:
            await q.answer("No errors to notify about", show_alert=True)
            return
        
        # Group by error type
        error_types = set(e["error_type"] for e in errors)
        
        msg = "‚ö†Ô∏è *–í–∞–∂–Ω–æ–µ —É–≤–µ–¥–æ–º–ª–µ–Ω–∏–µ –æ—Ç –∞–¥–º–∏–Ω–∏—Å—Ç—Ä–∞—Ç–æ—Ä–∞*\n\n"
        msg += "–û–±–Ω–∞—Ä—É–∂–µ–Ω—ã —Å–ª–µ–¥—É—é—â–∏–µ –ø—Ä–æ–±–ª–µ–º—ã:\n\n"
        
        for etype in error_types:
            count = sum(1 for e in errors if e["error_type"] == etype)
            if etype == "INSUFFICIENT_BALANCE":
                msg += f"üí∞ –ù–µ–¥–æ—Å—Ç–∞—Ç–æ—á–Ω–æ —Å—Ä–µ–¥—Å—Ç–≤ ({count}x)\n"
            elif etype == "API_KEY_EXPIRED":
                msg += f"üîë –ü—Ä–æ–±–ª–µ–º–∞ —Å API –∫–ª—é—á–∞–º–∏ ({count}x)\n"
            else:
                msg += f"‚Ä¢ {etype} ({count}x)\n"
        
        msg += "\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø—Ä–æ–≤–µ—Ä—å—Ç–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏ –≤–∞—à–µ–≥–æ –∞–∫–∫–∞—É–Ω—Ç–∞."
        
        try:
            await ctx.bot.send_message(target_user_id, msg, parse_mode="Markdown")
            # Mark all as notified
            for err in errors:
                db.mark_error_notified(err["id"])
            await q.answer(f"üì® User notified about {len(errors)} errors!", show_alert=True)
        except Exception as e:
            await q.answer(f"‚ùå Failed to notify: {e}", show_alert=True)

    # =====================================================
    # POSITIONS MENU - Admin view all positions
    # =====================================================
    elif cmd == "positions_menu":
        dashboard = db.get_admin_dashboard()
        pos_data = dashboard.get("positions", {})
        
        text = "üìà *All Positions*\n\n"
        text += f"üìä *Total:* {pos_data.get('total', 0)}\n\n"
        
        if pos_data.get("by_account"):
            text += "*By Account:*\n"
            for acc, count in pos_data["by_account"].items():
                text += f"‚Ä¢ {acc}: {count}\n"
            text += "\n"
        
        if pos_data.get("by_strategy"):
            text += "*By Strategy:*\n"
            for strat, count in list(pos_data["by_strategy"].items())[:5]:
                text += f"‚Ä¢ {strat}: {count}\n"
        
        keyboard = [
            [InlineKeyboardButton("üìã List All", callback_data="admin:positions_list:0")],
            [InlineKeyboardButton("üéÆ Demo", callback_data="admin:positions_filter:demo:0"),
             InlineKeyboardButton("üí∞ Real", callback_data="admin:positions_filter:real:0")],
            [InlineKeyboardButton("üü† Bybit", callback_data="admin:positions_exchange:bybit:0"),
             InlineKeyboardButton("üî∑ HyperLiquid", callback_data="admin:positions_exchange:hyperliquid:0")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd.startswith("positions_list:") or cmd.startswith("positions_filter:") or cmd.startswith("positions_exchange:"):
        parts = cmd.split(":")
        page = int(parts[-1]) if parts[-1].isdigit() else 0
        
        # Parse filters
        account_type = None
        exchange = None
        if "filter" in cmd:
            account_type = parts[1] if len(parts) > 1 else None
        elif "exchange" in cmd:
            exchange = parts[1] if len(parts) > 1 else None
        
        per_page = 8
        positions, total = db.get_all_positions_admin(
            exchange=exchange,
            account_type=account_type,
            limit=per_page,
            offset=page * per_page
        )
        total_pages = max(1, (total + per_page - 1) // per_page)
        
        if not positions:
            await q.edit_message_text(
                "‚úÖ No positions found.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:positions_menu")]
                ])
            )
            return
        
        filter_label = account_type or exchange or "all"
        text = f"üìà *Positions ({filter_label})* ‚Äî Page {page + 1}/{total_pages}\n\n"
        
        keyboard = []
        for pos in positions:
            side_emoji = "üü¢" if pos["side"] == "Buy" else "üî¥"
            username = pos.get("username") or str(pos["user_id"])
            text += f"{side_emoji} `{username}` | {pos['symbol']} | ${pos['entry_price']:.2f}\n"
            
            # Button to view user or close position
            keyboard.append([
                InlineKeyboardButton(
                    f"üë§ {username[:12]}",
                    callback_data=f"admin:user:{pos['user_id']}"
                ),
                InlineKeyboardButton(
                    f"‚ùå Close",
                    callback_data=f"admin:close_pos:{pos['user_id']}:{pos['symbol']}:{filter_label}:{page}"
                )
            ])
        
        # Navigation
        nav_row = []
        base_cmd = cmd.rsplit(":", 1)[0]  # Remove page number
        if page > 0:
            nav_row.append(InlineKeyboardButton("‚óÄÔ∏è", callback_data=f"{base_cmd.replace('admin:', 'admin:')}:{page - 1}"))
        nav_row.append(InlineKeyboardButton(f"{page + 1}/{total_pages}", callback_data="noop"))
        if page < total_pages - 1:
            nav_row.append(InlineKeyboardButton("‚ñ∂Ô∏è", callback_data=f"{base_cmd.replace('admin:', 'admin:')}:{page + 1}"))
        if nav_row:
            keyboard.append(nav_row)
        
        keyboard.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:positions_menu")])
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd.startswith("close_pos:"):
        # Close position for user
        parts = cmd.split(":")
        target_uid = int(parts[1])
        symbol = parts[2]
        filter_label = parts[3] if len(parts) > 3 else "all"
        page = int(parts[4]) if len(parts) > 4 else 0
        
        db.pg_remove_active_position(target_uid, symbol)
        await q.answer(f"‚úÖ Position {symbol} removed for user {target_uid}", show_alert=True)
        
        # Refresh list
        q.data = f"admin:positions_list:{page}"
        await on_admin_cb(update, ctx)

    # =====================================================
    # TRADES MENU - Admin view all trades
    # =====================================================
    elif cmd == "trades_menu":
        dashboard = db.get_admin_dashboard()
        trades_data = dashboard.get("trades", {})
        
        text = "üìä *All Trades*\n\n"
        text += f"üìà *Total:* {trades_data.get('total', 0)}\n"
        text += f"‚úÖ *Wins:* {trades_data.get('wins', 0)} ({trades_data.get('winrate', 0):.1f}%)\n"
        text += f"üí∞ *Total PnL:* ${trades_data.get('total_pnl', 0):.2f}\n"
        text += f"üìä *Avg PnL:* ${trades_data.get('avg_pnl', 0):.2f}\n\n"
        text += f"üìÖ *Today:* {trades_data.get('today', 0)} trades (${trades_data.get('today_pnl', 0):.2f})\n"
        text += f"üìÜ *Week:* {trades_data.get('week', 0)} trades (${trades_data.get('week_pnl', 0):.2f})\n"
        
        keyboard = [
            [InlineKeyboardButton("üìã All Trades", callback_data="admin:trades_list:all:0")],
            [InlineKeyboardButton("‚úÖ Wins", callback_data="admin:trades_pnl:win:0"),
             InlineKeyboardButton("‚ùå Losses", callback_data="admin:trades_pnl:loss:0")],
            [InlineKeyboardButton("üéÆ Demo", callback_data="admin:trades_filter:demo:0"),
             InlineKeyboardButton("üí∞ Real", callback_data="admin:trades_filter:real:0")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd.startswith("trades_list:") or cmd.startswith("trades_filter:") or cmd.startswith("trades_pnl:"):
        parts = cmd.split(":")
        page = int(parts[-1]) if parts[-1].isdigit() else 0
        
        # Parse filters
        account_type = None
        pnl_filter = None
        filter_label = "all"
        
        if "filter" in cmd:
            account_type = parts[1]
            filter_label = account_type
        elif "pnl" in cmd:
            pnl_filter = parts[1]
            filter_label = pnl_filter
        
        per_page = 10
        trades, total = db.get_all_trades_admin(
            account_type=account_type,
            pnl_filter=pnl_filter,
            limit=per_page,
            offset=page * per_page
        )
        total_pages = max(1, (total + per_page - 1) // per_page)
        
        if not trades:
            await q.edit_message_text(
                "üì≠ No trades found.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:trades_menu")]
                ])
            )
            return
        
        text = f"üìä *Trades ({filter_label})* ‚Äî Page {page + 1}/{total_pages}\n\n"
        
        for trade in trades:
            pnl_emoji = "‚úÖ" if trade["pnl"] > 0 else "‚ùå" if trade["pnl"] < 0 else "‚ûñ"
            side_emoji = "üü¢" if trade["side"] == "Buy" else "üî¥"
            username = trade.get("username") or str(trade["user_id"])
            text += f"{pnl_emoji} {side_emoji} `{username}` | {trade['symbol']} | ${trade['pnl']:.2f}\n"
        
        # Navigation
        nav_row = []
        base_cmd = f"admin:{cmd.split(':')[0]}:{filter_label}"
        if page > 0:
            nav_row.append(InlineKeyboardButton("‚óÄÔ∏è", callback_data=f"{base_cmd}:{page - 1}"))
        nav_row.append(InlineKeyboardButton(f"{page + 1}/{total_pages}", callback_data="noop"))
        if page < total_pages - 1:
            nav_row.append(InlineKeyboardButton("‚ñ∂Ô∏è", callback_data=f"{base_cmd}:{page + 1}"))
        
        keyboard = []
        if nav_row:
            keyboard.append(nav_row)
        keyboard.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:trades_menu")])
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))

    # =====================================================
    # SIGNALS MENU - Admin view all signals
    # =====================================================
    elif cmd == "signals_menu":
        dashboard = db.get_admin_dashboard()
        signals_data = dashboard.get("signals", {})
        
        text = "üì° *Signals Management*\n\n"
        text += f"üìä *Total:* {signals_data.get('total', 0)}\n"
        text += f"üìÖ *Today:* {signals_data.get('today', 0)}\n\n"
        
        if signals_data.get("by_strategy"):
            text += "*By Strategy:*\n"
            for strat, count in signals_data["by_strategy"].items():
                text += f"‚Ä¢ {strat}: {count}\n"
        
        keyboard = [
            [InlineKeyboardButton("üìã All Signals", callback_data="admin:signals_list:all:0")],
            [InlineKeyboardButton("üü¢ Long", callback_data="admin:signals_side:Buy:0"),
             InlineKeyboardButton("üî¥ Short", callback_data="admin:signals_side:Sell:0")],
            [InlineKeyboardButton("üéØ OI", callback_data="admin:signals_strat:oi:0"),
             InlineKeyboardButton("üìà RSI", callback_data="admin:signals_strat:rsi_bb:0")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd.startswith("signals_list:") or cmd.startswith("signals_side:") or cmd.startswith("signals_strat:"):
        parts = cmd.split(":")
        page = int(parts[-1]) if parts[-1].isdigit() else 0
        
        # Parse filters
        side = None
        strategy = None
        filter_label = "all"
        
        if "side" in cmd:
            side = parts[1]
            filter_label = "Long" if side == "Buy" else "Short"
        elif "strat" in cmd:
            strategy = parts[1]
            filter_label = strategy
        
        per_page = 10
        signals, total = db.get_all_signals_admin(
            side=side,
            strategy=strategy,
            limit=per_page,
            offset=page * per_page
        )
        total_pages = max(1, (total + per_page - 1) // per_page)
        
        if not signals:
            await q.edit_message_text(
                "üì≠ No signals found.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:signals_menu")]
                ])
            )
            return
        
        text = f"üì° *Signals ({filter_label})* ‚Äî Page {page + 1}/{total_pages}\n\n"
        
        keyboard = []
        for sig in signals:
            side_emoji = "üü¢" if sig["side"] == "Buy" else "üî¥"
            text += f"{side_emoji} {sig['symbol']} | {sig['strategy']} | ${sig['entry_price']:.2f}\n"
            
            # Delete button
            keyboard.append([
                InlineKeyboardButton(
                    f"üóë #{sig['id']} {sig['symbol']}",
                    callback_data=f"admin:del_signal:{sig['id']}:{filter_label}:{page}"
                )
            ])
        
        # Navigation
        nav_row = []
        base_cmd = f"admin:{cmd.split(':')[0].replace('admin:', '')}:{filter_label}"
        if page > 0:
            nav_row.append(InlineKeyboardButton("‚óÄÔ∏è", callback_data=f"{base_cmd}:{page - 1}"))
        nav_row.append(InlineKeyboardButton(f"{page + 1}/{total_pages}", callback_data="noop"))
        if page < total_pages - 1:
            nav_row.append(InlineKeyboardButton("‚ñ∂Ô∏è", callback_data=f"{base_cmd}:{page + 1}"))
        if nav_row:
            keyboard.append(nav_row)
        
        keyboard.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:signals_menu")])
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd.startswith("del_signal:"):
        parts = cmd.split(":")
        signal_id = int(parts[1])
        filter_label = parts[2] if len(parts) > 2 else "all"
        page = int(parts[3]) if len(parts) > 3 else 0
        
        success = db.delete_signal_admin(signal_id)
        if success:
            await q.answer(f"‚úÖ Signal #{signal_id} deleted!", show_alert=True)
        else:
            await q.answer("‚ùå Failed to delete", show_alert=True)
        
        # Refresh list
        q.data = f"admin:signals_list:{filter_label}:{page}"
        await on_admin_cb(update, ctx)

    # =====================================================
    # SYSTEM MENU - Health monitoring
    # =====================================================
    elif cmd == "system_menu":
        health = db.get_system_health()
        activity = health.get("activity", {})
        db_info = health.get("database", {})
        
        status_emoji = "‚úÖ" if health.get("status") == "healthy" else "‚ö†Ô∏è"
        
        text = f"üîß *System Status* {status_emoji}\n\n"
        text += f"*Database:*\n"
        text += f"‚Ä¢ Connected: {'‚úÖ' if db_info.get('connected') else '‚ùå'}\n"
        text += f"‚Ä¢ Pool: {db_info.get('pool', {}).get('min_conn', 0)}-{db_info.get('pool', {}).get('max_conn', 0)} connections\n\n"
        
        text += f"*Last Hour Activity:*\n"
        text += f"‚Ä¢ Trades: {activity.get('trades_last_hour', 0)}\n"
        text += f"‚Ä¢ Signals: {activity.get('signals_last_hour', 0)}\n"
        text += f"‚Ä¢ Errors: {activity.get('errors_last_hour', 0)}\n"
        text += f"‚Ä¢ Active users (24h): {activity.get('active_users_24h', 0)}\n\n"
        
        text += f"üìÖ *Updated:* {health.get('timestamp', 'N/A')}"
        
        keyboard = [
            [InlineKeyboardButton("üîÑ Refresh", callback_data="admin:system_menu")],
            [InlineKeyboardButton("üóÑÔ∏è DB Tables", callback_data="admin:system_db_tables")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd == "system_db_tables":
        # Show database table stats
        text = "üóÑÔ∏è *Database Tables*\n\n"
        
        # Whitelist of allowed table names to prevent SQL injection
        ALLOWED_TABLES = {
            'users', 'trade_logs', 'active_positions', 'signals', 'pending_limit_orders',
            'user_licenses', 'user_strategy_settings', 'custom_strategies', 'payment_history',
            'elc_transactions', 'elc_wallets', 'login_tokens', 'email_users', 'session_tokens',
            'user_devices', 'user_activity_log', 'backtest_results', 'strategy_marketplace',
            'strategy_purchases', 'ton_payments', '_migrations'
        }
        
        with db.get_conn() as conn:
            cur = conn.cursor()
            cur.execute("""
                SELECT table_name 
                FROM information_schema.tables 
                WHERE table_schema = 'public' 
                ORDER BY table_name
            """)
            tables = [r[0] for r in cur.fetchall()]
            
            for table in tables[:20]:  # Limit to 20
                if table not in ALLOWED_TABLES:
                    continue  # Skip unknown tables for security
                cur.execute(f"SELECT COUNT(*) FROM {table}")
                count = cur.fetchone()[0]
                text += f"‚Ä¢ {table}: {count}\n"
        
        keyboard = [
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:system_menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))

    # =====================================================
    # BROADCAST MENU - Send messages to users
    # =====================================================
    elif cmd == "broadcast_menu":
        pending = db.get_pending_broadcasts()
        
        text = "üì¢ *Broadcast Messages*\n\n"
        text += f"üìã Pending broadcasts: {len(pending)}\n\n"
        
        if pending:
            text += "*Pending:*\n"
            for bc in pending[:5]:
                text += f"‚Ä¢ #{bc['id']}: {bc['message'][:50]}...\n"
        
        keyboard = [
            [InlineKeyboardButton("‚úèÔ∏è New Broadcast", callback_data="admin:broadcast_new")],
            [InlineKeyboardButton("üì® Send to All", callback_data="admin:broadcast_target:all")],
            [InlineKeyboardButton("üíé Premium Only", callback_data="admin:broadcast_target:premium"),
             InlineKeyboardButton("‚úÖ Active Only", callback_data="admin:broadcast_target:active")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))
    
    elif cmd == "broadcast_new" or cmd.startswith("broadcast_target:"):
        # Set mode to receive broadcast message
        target = "all"
        if "target:" in cmd:
            target = cmd.split(":")[1]
        
        ctx.user_data["mode"] = "admin_broadcast"
        ctx.user_data["broadcast_target"] = target
        
        target_labels = {
            "all": "all users",
            "premium": "Patron members",
            "active": "active members"
        }
        
        await q.edit_message_text(
            f"‚úèÔ∏è *–í–≤–µ–¥–∏—Ç–µ —Ç–µ–∫—Å—Ç —Å–æ–æ–±—â–µ–Ω–∏—è*\n\n"
            f"–ë—É–¥–µ—Ç –æ—Ç–ø—Ä–∞–≤–ª–µ–Ω–æ: {target_labels.get(target, target)}\n\n"
            f"–ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ Markdown –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="admin:broadcast_menu")]
            ])
        )

    # =====================================================
    # PAYMENTS MENU
    # =====================================================
    elif cmd == "payments_menu":
        stats = get_payment_stats()
        text = t.get('admin_payments_menu', 'üí≥ *Payments Management*') + "\n\n"
        text += f"üìä *Stats:*\n"
        text += f"‚Ä¢ Total payments: {stats['total_payments']}\n"
        text += f"‚Ä¢ Completed: {stats['completed']}\n"
        text += f"‚Ä¢ Pending: {stats['pending']}\n"
        text += f"‚Ä¢ Failed: {stats['failed']}\n"
        text += f"‚Ä¢ Total Stars: {stats['total_stars']}‚≠ê\n"
        text += f"‚Ä¢ Total TON: {stats['total_ton']:.2f} üíé\n"
        text += f"‚Ä¢ Unique payers: {stats['unique_payers']}\n"
        
        keyboard = [
            [InlineKeyboardButton(t.get('admin_all_payments', 'üìú All Payments'), callback_data="admin:payments_list:all:0")],
            [InlineKeyboardButton("‚úÖ Completed", callback_data="admin:payments_list:completed:0"),
             InlineKeyboardButton("‚è≥ Pending", callback_data="admin:payments_list:pending:0")],
            [InlineKeyboardButton("‚ùå Failed", callback_data="admin:payments_list:failed:0")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))

    elif cmd.startswith("payments_list:"):
        parts = cmd.split(":")
        status = parts[1] if len(parts) > 1 and parts[1] != "all" else None
        page = int(parts[2]) if len(parts) > 2 else 0
        
        payments, total = get_all_payments(status=status, limit=10, offset=page * 10)
        total_pages = (total + 9) // 10
        
        if not payments:
            await q.edit_message_text(
                t.get('admin_no_payments_found', 'No payments found.'),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:payments_menu")]
                ])
            )
            return
        
        lines = [f"üí≥ *Payments ({status or 'all'})* ‚Äî Page {page + 1}/{total_pages}\n"]
        for p in payments:
            status_emoji = "‚úÖ" if p["status"] == "completed" else "‚è≥" if p["status"] == "pending" else "‚ùå"
            curr_emoji = "‚≠ê" if p["currency"] == "XTR" else "üíé"
            lines.append(f"{status_emoji} `{p['user_id']}` | {p['amount']}{curr_emoji} | {p['license_type']} | {p['created_at'][:10]}")
        
        nav_row = []
        if page > 0:
            nav_row.append(InlineKeyboardButton("‚¨ÖÔ∏è", callback_data=f"admin:payments_list:{status or 'all'}:{page - 1}"))
        if page < total_pages - 1:
            nav_row.append(InlineKeyboardButton("‚û°Ô∏è", callback_data=f"admin:payments_list:{status or 'all'}:{page + 1}"))
        
        keyboard = []
        if nav_row:
            keyboard.append(nav_row)
        keyboard.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:payments_menu")])
        
        await q.edit_message_text("\n".join(lines), parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))

    # =====================================================
    # REPORTS MENU
    # =====================================================
    elif cmd == "reports_menu":
        keyboard = [
            [InlineKeyboardButton(t.get('admin_global_stats', 'üìä Global Stats'), callback_data="admin:global_stats:all:all")],
            [InlineKeyboardButton(t.get('admin_demo_stats', 'üéÆ Demo Stats'), callback_data="admin:global_stats:demo:all"),
             InlineKeyboardButton(t.get('admin_real_stats', 'üí∞ Real Stats'), callback_data="admin:global_stats:real:all")],
            [InlineKeyboardButton(t.get('admin_strategy_breakdown', 'üéØ By Strategy'), callback_data="admin:strategy_breakdown:all")],
            [InlineKeyboardButton(t.get('admin_top_traders', 'üèÜ Top Traders'), callback_data="admin:top_traders:all:all")],
            [InlineKeyboardButton(t.get('admin_user_report', 'üë§ User Report'), callback_data="admin:user_report_select")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:menu")],
        ]
        await q.edit_message_text(
            t.get('admin_reports_menu', 'üìä *Reports & Analytics*\n\nSelect report type:'),
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )

    elif cmd.startswith("global_stats:"):
        parts = cmd.split(":")
        account_type = parts[1] if len(parts) > 1 and parts[1] != "all" else None
        period = parts[2] if len(parts) > 2 else "all"
        
        stats = get_global_trade_stats(account_type=account_type, period=period)
        account_label = account_type.upper() if account_type else "ALL"
        period_label = period.title()
        
        text = f"üìä *Global Stats ‚Äî {account_label} ‚Äî {period_label}*\n\n"
        text += f"üë• Users: {stats['unique_users']}\n"
        text += f"üìà Total trades: {stats['total_trades']}\n"
        text += f"üìÇ Open positions: {stats['open_positions']} ({stats['users_with_open']} users)\n"
        text += f"‚úÖ Wins: {stats['wins']} ({stats['winrate']:.1f}%)\n"
        text += f"üí∞ Total PnL: ${stats['total_pnl']:.2f}\n"
        text += f"üìä Avg PnL%: {stats['avg_pnl_pct']:.2f}%\n"
        text += f"üìà Longs: {stats['long_count']} | üìâ Shorts: {stats['short_count']}\n"
        text += f"üíπ Profit Factor: {stats['profit_factor']:.2f}\n"
        
        # Period selector
        period_row = []
        for p, label in [("today", "Today"), ("week", "Week"), ("month", "Month"), ("all", "All")]:
            if p == period:
                label = f"[{label}]"
            period_row.append(InlineKeyboardButton(label, callback_data=f"admin:global_stats:{account_type or 'all'}:{p}"))
        
        keyboard = [
            period_row,
            [InlineKeyboardButton("üéÆ Demo", callback_data=f"admin:global_stats:demo:{period}"),
             InlineKeyboardButton("üí∞ Real", callback_data=f"admin:global_stats:real:{period}"),
             InlineKeyboardButton("üìä All", callback_data=f"admin:global_stats:all:{period}")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:reports_menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))

    elif cmd.startswith("strategy_breakdown:"):
        parts = cmd.split(":")
        account_type = parts[1] if len(parts) > 1 and parts[1] != "all" else None
        
        stats_by_strat = get_global_stats_by_strategy(period="all", account_type=account_type)
        account_label = account_type.upper() if account_type else "ALL"
        
        text = f"üéØ *Strategy Breakdown ‚Äî {account_label}*\n\n"
        
        for strat, stats in stats_by_strat.items():
            if strat == "all":
                continue
            if stats["total_trades"] > 0:
                text += f"*{strat.upper()}*\n"
                text += f"  Trades: {stats['total_trades']} | WR: {stats['winrate']:.1f}%\n"
                text += f"  PnL: ${stats['total_pnl']:.2f} | PF: {stats['profit_factor']:.2f}\n\n"
        
        keyboard = [
            [InlineKeyboardButton("üéÆ Demo", callback_data="admin:strategy_breakdown:demo"),
             InlineKeyboardButton("üí∞ Real", callback_data="admin:strategy_breakdown:real"),
             InlineKeyboardButton("üìä All", callback_data="admin:strategy_breakdown:all")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:reports_menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))

    elif cmd.startswith("top_traders:"):
        parts = cmd.split(":")
        account_type = parts[1] if len(parts) > 1 and parts[1] != "all" else "demo"
        period = parts[2] if len(parts) > 2 else "all"
        
        traders = get_top_traders(period=period, account_type=account_type, limit=10)
        account_label = account_type.upper()
        period_label = period.title()
        
        text = f"üèÜ *Top 10 Traders ‚Äî {account_label} ‚Äî {period_label}*\n\n"
        
        for i, tr in enumerate(traders, 1):
            medal = "ü•á" if i == 1 else "ü•à" if i == 2 else "ü•â" if i == 3 else f"{i}."
            text += f"{medal} `{tr['user_id']}` ‚Äî ${tr['total_pnl']:.2f} ({tr['trades']} trades, {tr['winrate']:.0f}% WR)\n"
        
        if not traders:
            text += "_No data_\n"
        
        period_row = []
        for p, label in [("today", "Today"), ("week", "Week"), ("month", "Month"), ("all", "All")]:
            if p == period:
                label = f"[{label}]"
            period_row.append(InlineKeyboardButton(label, callback_data=f"admin:top_traders:{account_type}:{p}"))
        
        keyboard = [
            period_row,
            [InlineKeyboardButton("üéÆ Demo", callback_data=f"admin:top_traders:demo:{period}"),
             InlineKeyboardButton("üí∞ Real", callback_data=f"admin:top_traders:real:{period}")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:reports_menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))

    elif cmd == "user_report_select":
        ctx.user_data["mode"] = "admin_user_report"
        await q.edit_message_text(
            t.get('admin_enter_user_for_report', 'üë§ Enter user ID for detailed report:'),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get('btn_cancel', '‚ùå Cancel'), callback_data="admin:reports_menu")]
            ])
        )

    elif cmd.startswith("user_report:"):
        target_uid = int(cmd.split(":")[1])
        report = get_user_usage_report(target_uid)
        
        if not report["user_info"]:
            await q.edit_message_text(
                t.get('admin_user_not_found', '‚ùå User {uid} not found.').format(uid=target_uid),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:reports_menu")]
                ])
            )
            return
        
        user = report["user_info"]
        demo = report["demo_stats"]
        real = report["real_stats"]
        
        text = f"üë§ *User Report ‚Äî {target_uid}*\n\n"
        text += f"üìä *Demo Trading:*\n"
        text += f"  Trades: {demo['total']} | WR: {demo['winrate']:.1f}%\n"
        text += f"  PnL: ${demo['total_pnl']:.2f} | PF: {demo['profit_factor']:.2f}\n"
        text += f"  Open: {demo['open_count']}\n\n"
        
        text += f"üí∞ *Real Trading:*\n"
        text += f"  Trades: {real['total']} | WR: {real['winrate']:.1f}%\n"
        text += f"  PnL: ${real['total_pnl']:.2f} | PF: {real['profit_factor']:.2f}\n"
        text += f"  Open: {real['open_count']}\n\n"
        
        text += f"üéØ *By Strategy (Demo):*\n"
        for strat, stats in report["demo_by_strategy"].items():
            text += f"  {strat}: {stats['total']} trades, {stats['winrate']:.1f}% WR\n"
        
        if report["real_by_strategy"]:
            text += f"\nüéØ *By Strategy (Real):*\n"
            for strat, stats in report["real_by_strategy"].items():
                text += f"  {strat}: {stats['total']} trades, {stats['winrate']:.1f}% WR\n"
        
        keyboard = [
            [InlineKeyboardButton(t.get('admin_view_user', 'üë§ User Card'), callback_data=f"admin:user:{target_uid}")],
            [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:reports_menu")],
        ]
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard))


async def show_user_card(q, ctx, target_uid: int):
    """Display user card with all information and actions."""
    t = ctx.t
    user = get_user_full_info(target_uid)
    
    if not user:
        await q.edit_message_text(
            t.get('admin_user_not_found', '‚ùå User {uid} not found.').format(uid=target_uid),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:users_menu")]
            ])
        )
        return
    
    # Build user card text
    import datetime
    
    status_emoji = "üö´" if user["is_banned"] else "‚úÖ" if user["is_allowed"] else "‚è≥"
    license_emoji = {"premium": "ü§ù", "basic": "ü•à", "trial": "üéÅ"}.get(user["current_license"], "‚ùå")
    
    # Format dates
    first_seen = datetime.datetime.fromtimestamp(user["first_seen_ts"]).strftime("%Y-%m-%d") if user["first_seen_ts"] else "‚Äî"
    last_seen = datetime.datetime.fromtimestamp(user["last_seen_ts"]).strftime("%Y-%m-%d %H:%M") if user["last_seen_ts"] else "‚Äî"
    license_expires = ""
    if user["license_expires"]:
        expires_dt = datetime.datetime.fromtimestamp(user["license_expires"])
        license_expires = expires_dt.strftime("%Y-%m-%d")
    
    # Strategies
    strategies = []
    if user["trade_oi"]: strategies.append("OI")
    if user["trade_rsi_bb"]: strategies.append("RSI")
    if user["trade_scryptomera"]: strategies.append("Scrypto")
    if user["trade_scalper"]: strategies.append("Scalp")
    if user["trade_elcaro"]: strategies.append("Enliko")
    strategies_str = ", ".join(strategies) if strategies else "‚Äî"
    
    card_text = t.get('admin_user_card', '''üë§ *User Card*

üìã *ID:* `{uid}`
{status_emoji} *Status:* {status}
üìù *Terms:* {terms}

{license_emoji} *License:* {license_type}
üìÖ *Expires:* {license_expires}
‚è≥ *Days Left:* {days_left}

üåê *Language:* {lang}
üìä *Trading Mode:* {trading_mode}
üí∞ *% per Trade:* {percent}%
ü™ô *Coins:* {coins}

üîå *API Keys:*
  Demo: {demo_api}
  Real: {real_api}

üìà *Strategies:* {strategies}

üìä *Statistics:*
  Positions: {positions}
  Trades: {trades}
  PnL: {pnl}
  Winrate: {winrate}%

üí≥ *Payments:*
  Total: {payments_count}
  Stars: {total_stars}‚≠ê

üìÖ *First Seen:* {first_seen}
üïê *Last Seen:* {last_seen}
''').format(
        uid=user["user_id"],
        status_emoji=status_emoji,
        status="Banned" if user["is_banned"] else "Active" if user["is_allowed"] else "Pending",
        terms="‚úÖ" if user["terms_accepted"] else "‚ùå",
        license_emoji=license_emoji,
        license_type=user["current_license"].title(),
        license_expires=license_expires or "‚Äî",
        days_left=user["license_days_left"] or "‚Äî",
        lang=user["lang"].upper(),
        trading_mode=user["trading_mode"],
        percent=user["percent"],
        coins=user["coins"],
        demo_api="‚úÖ" if user["has_demo_api"] else "‚ùå",
        real_api="‚úÖ" if user["has_real_api"] else "‚ùå",
        strategies=strategies_str,
        positions=user["positions_count"],
        trades=user["trades_count"],
        pnl=f"{user['total_pnl']:.2f}",
        winrate=f"{user['winrate']:.1f}",
        payments_count=user["payments_count"],
        total_stars=user["total_paid_stars"],
        first_seen=first_seen,
        last_seen=last_seen,
    )
    
    # Build action keyboard
    keyboard = []
    
    # License actions
    license_row = [
        InlineKeyboardButton(t.get('admin_btn_grant_lic', 'üéÅ Grant'), callback_data=f"adm_lic:grant_to_user:{target_uid}"),
    ]
    if user["current_license"] != "none" and user["license_days_left"]:
        license_row.append(InlineKeyboardButton(t.get('admin_btn_extend', '‚è≥ Extend'), callback_data=f"admin:extend_lic:{target_uid}"))
        license_row.append(InlineKeyboardButton(t.get('admin_btn_revoke', 'üö´ Revoke'), callback_data=f"admin:revoke_lic:{target_uid}"))
    keyboard.append(license_row)
    
    # User status actions
    status_row = []
    if user["is_banned"]:
        status_row.append(InlineKeyboardButton(t.get('admin_btn_unban', '‚úÖ Unban'), callback_data=f"admin:unban:{target_uid}"))
    else:
        status_row.append(InlineKeyboardButton(t.get('admin_btn_ban', 'üö´ Ban'), callback_data=f"admin:ban:{target_uid}"))
    if not user["is_allowed"]:
        status_row.append(InlineKeyboardButton(t.get('admin_btn_approve', '‚úÖ Approve'), callback_data=f"admin:approve:{target_uid}"))
    keyboard.append(status_row)
    
    # Other actions
    keyboard.append([
        InlineKeyboardButton(t.get('admin_btn_message', '‚úâÔ∏è Message'), callback_data=f"admin:msg_user:{target_uid}"),
        InlineKeyboardButton(t.get('admin_btn_delete', 'üóë Delete'), callback_data=f"admin:delete:{target_uid}"),
    ])
    
    # Back button
    keyboard.append([InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:users_menu")])
    
    await q.edit_message_text(
        card_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )

@require_access
@with_texts
@log_calls
async def text_handler(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    # Skip if no user context (e.g., channel posts)
    if not update.effective_user:
        return
    uid   = update.effective_user.id
    text  = (update.message.text or "").strip()
    mode  = ctx.user_data.get("mode") if ctx.user_data else None

    # Handle Sovereign Owner input (emission, burn, policy)
    if await handle_sovereign_input(update, ctx):
        return

    # Handle HyperLiquid private key input FIRST
    if await handle_hl_private_key(update, ctx):
        return
    
    # Handle HyperLiquid strategy parameter input
    if await handle_hl_strategy_param(update, ctx):
        return

    # Handle promo code entry
    if mode == "enter_promo":
        ctx.user_data.pop("mode", None)
        t = LANGS.get(ctx.user_data.get("lang", DEFAULT_LANG), LANGS[DEFAULT_LANG])
        
        result = use_promo_code(uid, text.strip().upper())
        
        if result.get("success"):
            await update.message.reply_text(
                t.get("promo_success", "üéâ Promo code applied!\n\n{plan} activated for {days} days.").format(
                    plan=result["license_type"].title(),
                    days=result["days"]
                ),
                reply_markup=get_subscribe_menu_keyboard(t)
            )
        else:
            error_key = {
                "invalid_code": "promo_invalid",
                "code_inactive": "promo_invalid",
                "code_expired": "promo_expired",
                "code_used_up": "promo_used",
                "already_used": "promo_already_used",
            }.get(result.get("error"), "promo_invalid")
            
            await update.message.reply_text(
                t.get(error_key, "‚ùå Invalid promo code."),
                reply_markup=get_subscribe_menu_keyboard(t)
            )
        return

    # Handle admin NFT minting (user ID input)
    if mode == "admin_mint_nft_user" and uid == ADMIN_ID:
        ctx.user_data.pop("mode", None)
        t = LANGS.get(ctx.user_data.get("lang", DEFAULT_LANG), LANGS[DEFAULT_LANG])
        
        try:
            target_uid = int(text.strip())
            tier = ctx.user_data.pop("admin_nft_tier", "bronze")
            
            result = admin_mint_license_nft(
                admin_id=uid,
                user_id=target_uid,
                tier=tier,
                valid_months=12
            )
            
            if result.get("success"):
                nft = result.get("nft", {})
                await update.message.reply_text(
                    f"‚úÖ *NFT Minted Successfully!*\n\n"
                    f"üé® Tier: {tier.title()}\n"
                    f"üë§ User: `{target_uid}`\n"
                    f"üÜî Token: `{nft.get('token_id', '')}`\n"
                    f"üîó TX: `{result.get('tx_hash', '')[:20]}...`",
                    parse_mode="Markdown",
                    reply_markup=get_admin_license_keyboard(t)
                )
                # Notify user
                try:
                    await ctx.bot.send_message(
                        target_uid,
                        f"üéâ *You received a License NFT!*\n\n"
                        f"üé® Tier: {tier.title()}\n"
                        f"üÜî Token: `{nft.get('token_id', '')}`\n\n"
                        f"This NFT represents your premium license on the blockchain!",
                        parse_mode="Markdown"
                    )
                except Exception as e:
                    logger.debug(f"Failed to notify user {target_uid} about NFT: {e}")
            else:
                await update.message.reply_text(
                    f"‚ùå Minting failed: {result.get('error', 'Unknown')}",
                    reply_markup=get_admin_license_keyboard(t)
                )
        except ValueError:
            await update.message.reply_text(
                t.get('admin_invalid_user_id', "‚ùå Invalid user ID. Enter a number."),
                reply_markup=get_admin_license_keyboard(t)
            )
        return

    # Handle admin license grant (user ID input)
    if mode == "admin_grant_user" and uid == ADMIN_ID:
        ctx.user_data.pop("mode", None)
        t = LANGS.get(ctx.user_data.get("lang", DEFAULT_LANG), LANGS[DEFAULT_LANG])
        
        try:
            target_uid = int(text.strip())
            plan = ctx.user_data.pop("admin_grant_type", "premium")
            period = ctx.user_data.pop("admin_grant_period", 1)
            
            result = set_user_license(
                user_id=target_uid,
                license_type=plan,
                period_months=period,
                admin_id=uid,
                payment_type="admin_grant",
            )
            
            if result.get("success"):
                # Notify the recipient user about the license grant
                try:
                    user_lang = db.get_user_field(target_uid, "lang") or DEFAULT_LANG
                    user_t = LANGS.get(user_lang, LANGS[DEFAULT_LANG])
                    end_date = result.get("end_date", "N/A")
                    await ctx.bot.send_message(
                        target_uid,
                        user_t.get("license_granted_notification", 
                            "üéâ Congratulations!\n\n"
                            "You have been granted a **{plan}** subscription for **{days} days**!\n\n"
                            "üìÖ Valid until: {end_date}\n\n"
                            "Thank you for using Enliko!"
                        ).format(plan=plan.title(), days=result["days"], end_date=end_date),
                        parse_mode="Markdown"
                    )
                    logger.info(f"[ADMIN] License granted notification sent to user {target_uid}")
                except Exception as e:
                    logger.warning(f"Failed to notify user {target_uid} about license grant: {e}")
                
                await update.message.reply_text(
                    t.get("admin_license_granted", "‚úÖ {plan} granted to user {uid} for {days} days.").format(
                        plan=plan.title(),
                        uid=target_uid,
                        days=result["days"]
                    ),
                    reply_markup=get_admin_license_keyboard(t)
                )
            else:
                await update.message.reply_text(
                    f"‚ùå Error: {result.get('error', 'Unknown')}",
                    reply_markup=get_admin_license_keyboard(t)
                )
        except ValueError:
            await update.message.reply_text(
                t.get('admin_invalid_user_id', "‚ùå Invalid user ID. Enter a number."),
                reply_markup=get_admin_license_keyboard(t)
            )
        return

    # Handle admin license request rejection (reason input)
    if mode == "admin_reject_request" and uid == ADMIN_ID:
        ctx.user_data.pop("mode", None)
        t = LANGS.get(ctx.user_data.get("lang", DEFAULT_LANG), LANGS[DEFAULT_LANG])
        
        request_id = ctx.user_data.pop("reject_request_id", None)
        if not request_id:
            await update.message.reply_text(
                "‚ùå Request not found.",
                reply_markup=get_admin_license_keyboard(t)
            )
            return
        
        reason = text.strip()
        if len(reason) < 3:
            await update.message.reply_text(
                "‚ùå Reason too short. Please provide a valid reason.",
                reply_markup=get_admin_license_keyboard(t)
            )
            return
        
        result = reject_license_request(request_id, uid, reason)
        
        if result.get("success"):
            # Notify user about rejection
            request = result.get("request", {})
            target_uid = request.get("user_id")
            if target_uid:
                try:
                    user_lang = db.get_user_field(target_uid, "lang") or DEFAULT_LANG
                    user_t = LANGS.get(user_lang, LANGS[DEFAULT_LANG])
                    await ctx.bot.send_message(
                        target_uid,
                        user_t.get("license_request_rejected", 
                            "‚ùå Your license request has been rejected.\n\n"
                            "**Reason:** {reason}"
                        ).format(reason=reason),
                        parse_mode="Markdown"
                    )
                except Exception as e:
                    logger.warning(f"Failed to notify user {target_uid} about rejection: {e}")
            
            await update.message.reply_text(
                f"‚úÖ Request #{request_id} rejected.\nReason: {reason}",
                reply_markup=get_admin_license_keyboard(t)
            )
        else:
            await update.message.reply_text(
                f"‚ùå Error: {result.get('error', 'Unknown')}",
                reply_markup=get_admin_license_keyboard(t)
            )
        return

    # Handle admin promo code creation
    if mode == "admin_promo_create" and uid == ADMIN_ID:
        ctx.user_data.pop("mode", None)
        t = LANGS.get(ctx.user_data.get("lang", DEFAULT_LANG), LANGS[DEFAULT_LANG])
        
        try:
            # Format: CODE:TYPE:DAYS:MAX_USES
            parts = text.strip().split(":")
            if len(parts) < 3:
                raise ValueError("Format: CODE:TYPE:DAYS:MAX_USES")
            
            code = parts[0].upper()
            license_type = parts[1].lower()
            days = int(parts[2])
            max_uses = int(parts[3]) if len(parts) > 3 else 1
            
            if license_type not in ["premium", "basic", "trial"]:
                raise ValueError("Type must be premium, basic, or trial")
            
            result = create_promo_code(
                code=code,
                license_type=license_type,
                period_days=days,
                max_uses=max_uses,
                admin_id=uid,
            )
            
            if result.get("success"):
                await update.message.reply_text(
                    t.get("admin_promo_created", "‚úÖ Promo code created: {code}\nType: {type}\nDays: {days}\nMax uses: {max}").format(
                        code=code,
                        type=license_type,
                        days=days,
                        max=max_uses
                    ),
                    reply_markup=get_admin_license_keyboard(t)
                )
            else:
                await update.message.reply_text(
                    f"‚ùå Error: {result.get('error', 'Unknown')}",
                    reply_markup=get_admin_license_keyboard(t)
                )
        except Exception as e:
            await update.message.reply_text(
                f"‚ùå Error: {e}\n\nFormat: `CODE:TYPE:DAYS:MAX_USES`",
                parse_mode="Markdown",
                reply_markup=get_admin_license_keyboard(t)
            )
        return

    # Handle admin user search
    if mode == "admin_search_user" and uid == ADMIN_ID:
        ctx.user_data.pop("mode", None)
        t = LANGS.get(ctx.user_data.get("lang", DEFAULT_LANG), LANGS[DEFAULT_LANG])
        
        try:
            target_uid = int(text.strip())
            user_info = get_user_full_info(target_uid)
            
            if user_info:
                # Found - show user card via callback simulation
                # Create a fake callback to reuse show_user_card
                keyboard = [
                    [InlineKeyboardButton(t.get('admin_view_card', 'üë§ View Card'), callback_data=f"admin:user:{target_uid}")],
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:users_menu")],
                ]
                await update.message.reply_text(
                    t.get('admin_user_found', '‚úÖ User {uid} found!').format(uid=target_uid),
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            else:
                await update.message.reply_text(
                    t.get('admin_user_not_found', '‚ùå User {uid} not found.').format(uid=target_uid),
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:users_menu")]
                    ])
                )
        except ValueError:
            await update.message.reply_text(
                t.get('admin_invalid_user_id', '‚ùå Invalid user ID. Enter a number.'),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:users_menu")]
                ])
            )
        return

    # Handle admin user report by ID
    if mode == "admin_user_report" and uid == ADMIN_ID:
        ctx.user_data.pop("mode", None)
        t = LANGS.get(ctx.user_data.get("lang", DEFAULT_LANG), LANGS[DEFAULT_LANG])
        
        try:
            target_uid = int(text.strip())
            keyboard = [[InlineKeyboardButton(t.get('admin_view_report', 'üìä View Report'), callback_data=f"admin:user_report:{target_uid}")]]
            await update.message.reply_text(
                t.get('admin_generating_report', 'üìä Generating report for user {uid}...').format(uid=target_uid),
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
        except ValueError:
            await update.message.reply_text(
                t.get('admin_invalid_user_id', '‚ùå Invalid user ID. Enter a number.'),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="admin:reports_menu")]
                ])
            )
        return

    # Handle admin send message to user
    if mode == "admin_send_message" and uid == ADMIN_ID:
        ctx.user_data.pop("mode", None)
        target_uid = ctx.user_data.pop("admin_msg_target", None)
        t = LANGS.get(ctx.user_data.get("lang", DEFAULT_LANG), LANGS[DEFAULT_LANG])
        
        if target_uid:
            try:
                await ctx.bot.send_message(
                    target_uid,
                    f"üì¢ *Message from Admin:*\n\n{text}",
                    parse_mode="Markdown"
                )
                keyboard = [[InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data=f"admin:user:{target_uid}")]]
                await update.message.reply_text(
                    t.get('admin_message_sent', '‚úÖ Message sent to user {uid}!').format(uid=target_uid),
                    reply_markup=InlineKeyboardMarkup(keyboard)
                )
            except Exception as e:
                await update.message.reply_text(
                    t.get('admin_message_failed', '‚ùå Failed to send message: {error}').format(error=str(e)),
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data=f"admin:user:{target_uid}")]
                    ])
                )
        return

    # Handle admin broadcast message
    if mode == "admin_broadcast" and uid == ADMIN_ID:
        ctx.user_data.pop("mode", None)
        target = ctx.user_data.pop("broadcast_target", "all")
        t = LANGS.get(ctx.user_data.get("lang", DEFAULT_LANG), LANGS[DEFAULT_LANG])
        
        # Get users based on target
        all_users = get_all_users()
        
        if target == "premium":
            users_to_notify = [u for u in all_users if get_user_field(u, "license_type") in ("premium", "lifetime") or get_user_field(u, "is_lifetime")]
        elif target == "active":
            users_to_notify = [u for u in all_users if get_user_field(u, "is_allowed") and not get_user_field(u, "is_banned")]
        else:
            users_to_notify = all_users
        
        # Send to all users
        sent_count = 0
        failed_count = 0
        
        status_msg = await update.message.reply_text(
            f"üì® Sending broadcast to {len(users_to_notify)} users...",
            parse_mode="Markdown"
        )
        
        for target_uid in users_to_notify:
            try:
                await ctx.bot.send_message(
                    target_uid,
                    f"üì¢ *Announcement*\n\n{text}",
                    parse_mode="Markdown"
                )
                sent_count += 1
            except Exception:
                failed_count += 1
            
            # Update status every 50 users
            if (sent_count + failed_count) % 50 == 0:
                try:
                    await status_msg.edit_text(
                        f"üì® Sending... {sent_count + failed_count}/{len(users_to_notify)}\n"
                        f"‚úÖ Sent: {sent_count}\n"
                        f"‚ùå Failed: {failed_count}"
                    )
                except Exception:
                    pass  # Ignore edit errors during broadcast
        
        # Final status
        await status_msg.edit_text(
            f"‚úÖ *Broadcast Complete!*\n\n"
            f"üì® Total users: {len(users_to_notify)}\n"
            f"‚úÖ Sent: {sent_count}\n"
            f"‚ùå Failed: {failed_count}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="admin:broadcast_menu")]
            ])
        )
        return

    if mode == "update_tpsl":
        try:
            parts = text.split()
            if len(parts) != 3:
                raise ValueError
            symbol, tp_str, sl_str = parts
            tp_price = float(tp_str.replace(",", "."))
            sl_price = float(sl_str.replace(",", "."))
        except ValueError:
            ctx.user_data.pop("mode", None)
            return await update.message.reply_text(
                ctx.t["invalid_tpsl_format"],
                reply_markup=main_menu_keyboard(ctx, update=update)
            )

        # Find position on correct account type
        cfg = get_user_config(uid) or {}
        trading_mode = cfg.get("trading_mode", "demo")
        pos = None
        pos_account_type = None
        
        # Check all possible account types based on trading_mode
        account_types_to_check = ["demo", "real"] if trading_mode == "both" else [trading_mode]
        for acc in account_types_to_check:
            positions = await fetch_open_positions(uid, account_type=acc)
            found_pos = next((p for p in positions if p.get("symbol") == symbol), None)
            if found_pos:
                pos = found_pos
                pos_account_type = acc
                break
        
        if not pos:
            return await update.message.reply_text(
                ctx.t["no_position_symbol"].format(symbol=symbol),
                reply_markup=main_menu_keyboard(ctx, update=update)
            )

        current_price = float(pos["markPrice"])
        side = pos["side"]  

        if side == "Buy":
            if not (sl_price < current_price < tp_price):
                return await update.message.reply_text(
                    ctx.t["invalid_tpsl_long"].format(current=current_price),
                    reply_markup=main_menu_keyboard(ctx, update=update)
                )
        else: 
            if not (tp_price < current_price < sl_price):
                return await update.message.reply_text(
                    ctx.t["invalid_tpsl_short"].format(current=current_price),
                    reply_markup=main_menu_keyboard(ctx, update=update)
                )
        await set_trading_stop(uid, symbol, tp_price=tp_price, sl_price=sl_price, side_hint=side, account_type=pos_account_type)
        ctx.user_data.pop("mode", None)
        return await update.message.reply_text(
            ctx.t["tpsl_set_success"].format(tp=tp_price, sl=sl_price, symbol=symbol),
            reply_markup=main_menu_keyboard(ctx, uid)
        )
    
    # Admin-only buttons
    if uid == ADMIN_ID:
        if text == ctx.t.get("button_licenses", "üé´ Licenses"):
            # Show license management menu
            await update.message.reply_text(
                ctx.t.get("admin_license_menu", "üé´ *License Management*"),
                parse_mode="Markdown",
                reply_markup=get_admin_license_keyboard(ctx.t)
            )
            return
        
        if text == ctx.t.get("button_admin", "üõ°Ô∏è Admin"):
            return await cmd_admin(update, ctx)
    
    # New API Settings button
    if text == ctx.t.get("button_api_settings", "üîë API"):
        return await cmd_api_settings(update, ctx)
    
    # Support / membership button
    if text in [ctx.t.get('button_subscribe', 'ü§ù SUPPORT US'), 
                "ü§ù Support", "ü§ù Patron", "ü§ù SUPPORT US",
                "üíé Premium", "üíé Subscribe", "üëë PREMIUM", "üëë VIP",
                "üëë –ü–†–ï–ú–ò–£–ú", "ü§ù –ü–û–î–î–ï–†–ñ–ê–¢–¨"]:
        return await cmd_subscribe(update, ctx)
    
    # Exchange button - QUICK TOGGLE between Bybit and HyperLiquid
    if text.startswith("üî∑ HL") or text.startswith("üî∑ HyperLiquid") or text.startswith("üü† Bybit"):
        current_exchange = get_exchange_type(uid)
        
        if current_exchange == "bybit":
            # Switch to HyperLiquid
            hl_creds = get_hl_credentials(uid)
            has_hl = (hl_creds.get("hl_private_key") or 
                      hl_creds.get("hl_mainnet_private_key") or 
                      hl_creds.get("hl_testnet_private_key"))
            
            if has_hl:
                set_exchange_type(uid, "hyperliquid")
                await update.message.reply_text(
                    "‚úÖ *Switched to HyperLiquid*",
                    parse_mode="Markdown",
                    reply_markup=main_menu_keyboard(ctx, user_id=uid)
                )
            else:
                await update.message.reply_text(
                    "‚ùå HyperLiquid –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.\n\n–ù–∞—Å—Ç—Ä–æ–π—Ç–µ –≤ üîó API Keys",
                    reply_markup=main_menu_keyboard(ctx, user_id=uid)
                )
        else:
            # Switch to Bybit
            set_exchange_type(uid, "bybit")
            await update.message.reply_text(
                "‚úÖ *Switched to Bybit*",
                parse_mode="Markdown",
                reply_markup=main_menu_keyboard(ctx, user_id=uid)
            )
        return
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  LEGACY SWITCH EXCHANGE (removed from menu, kept for deep links)  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # Note: Exchange switching is now done via API Settings (üîó API Keys)
    # These handlers are kept for backwards compatibility with old messages
    if text in ["üîÑ Bybit", "üîÑ Switch to Bybit"]:
        # Redirect to API settings
        return await cmd_api_settings(update, ctx)
    
    if text in ["üîÑ HyperLiquid", "üîÑ Switch to HL", "üîÑ HL"]:
        # Redirect to API settings
        return await cmd_api_settings(update, ctx)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  UNIFIED BUTTONS (work for both exchanges)  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    active_exchange = get_exchange_type(uid)
    
    # Balance - works for current exchange, shows directly with switcher if needed
    if text in ["üí∞ Balance", "üí∞ HL Balance", "üíé Portfolio", "üíé –ü–æ—Ä—Ç—Ñ–µ–ª—å",
                 ctx.t.get('button_balance', 'üíé Portfolio')]:
        # Get last viewed account for UI (persists user's selection)
        last_account = db.get_last_viewed_account(uid, active_exchange)
        
        if active_exchange == "hyperliquid":
            # HyperLiquid: use cmd_hl_balance
            return await cmd_hl_balance(update, ctx)
        else:
            # Bybit: show balance for last viewed account (switcher is inside show_balance_for_account)
            return await show_balance_for_account(update, ctx, last_account)
    
    # Positions - works for current exchange, shows directly with switcher if needed
    if text in ["üìä Positions", "üìä HL Positions", "üéØ Positions", "üìä –ü–æ–∑–∏—Ü–∏–∏", "üìä –ü–æ–∑–∏—Ü—ñ—ó",
                 "üéØ Posiciones", "üéØ Positionen", "üéØ Posizioni", "üéØ Pozice", "üéØ Pozicijos",
                 "üéØ Pozicionet", "üéØ Pozycje", "üéØ ◊§◊ï◊ñ◊ô◊¶◊ô◊ï◊™", "üéØ ÿßŸÑŸÖÿ±ÿßŸÉÿ≤", "üéØ Âª∫Áéâ", "üéØ ÊåÅ‰ªì",
                 ctx.t.get('button_positions', 'üéØ Positions')]:
        # Unified: Show positions for last viewed account (switcher inside show_positions_for_account)
        last_account = db.get_last_viewed_account(uid, active_exchange)
        return await show_positions_for_account(update, ctx, last_account, exchange=active_exchange)
    
    # Orders - works for current exchange, shows directly with switcher if needed
    if text in ["üìà Orders", "üìà HL Orders", "üìä Orders", "üìã Orders", "üìã –û—Ä–¥–µ—Ä–∞", "üìã –û—Ä–¥–µ—Ä–∏",
                 "üìä Auftr√§ge", "üìä Ordini", "üìä Ordres", "üìä P≈ô√≠kazy", "üìä Zlecenia", "üìä √ìrdenes",
                 "üìä ƒÆsakymai", "üìä ◊î◊ñ◊û◊†◊ï◊™", "üìä ÿßŸÑÿ£ŸàÿßŸÖÿ±", "üìä Ê≥®Êñá", "üìú Porosit√´ e mia", "üìú ÊàëÁöÑËÆ¢Âçï",
                 ctx.t.get('button_orders', 'üìä Orders')]:
        # Unified: Show orders for last viewed account (switcher inside show_orders_for_account)
        last_account = db.get_last_viewed_account(uid, active_exchange)
        return await show_orders_for_account(update, ctx, last_account, exchange=active_exchange)
    
    # History - works for current exchange
    if text in ["üìã History", "üìã HL History", "üìú History", "üìú –Ü—Å—Ç–æ—Ä—ñ—è", "üìú –ò—Å—Ç–æ—Ä–∏—è",
                 "üìã Historia", "üìã ÂéÜÂè≤", "üìú Cronologia", "üìú Historial", "üìú Historie",
                 "üìú Historique", "üìú Istorija", "üìú Verlauf", "üìú ◊î◊ô◊°◊ò◊ï◊®◊ô◊î", "üìú ÿßŸÑÿ≥ÿ¨ŸÑ", "üìú Â±•Ê≠¥",
                 ctx.t.get('button_history', 'üìú History')]:
        # Unified history for both Bybit and HyperLiquid (same UI with strategy/period/account filters)
        return await cmd_trade_stats(update, ctx)
    
    # Trade - works for current exchange
    if text in ["üéØ Trade", "üéØ HL Trade"]:
        if active_exchange == "hyperliquid":
            return await cmd_hl_trade(update, ctx)
        else:
            # Bybit quick trade - show order prompt
            await update.message.reply_text(
                "üéØ *Quick Trade*\n\n"
                "Send your order in format:\n"
                "`BTCUSDT long 10 10x`\n"
                "`ETHUSDT short 5% 20x`\n\n"
                "Or use /terminal for advanced trading.",
                parse_mode="Markdown"
            )
            return
    
    # Close All - works for current exchange  
    if text in ["‚ùå Close All", "‚ùå HL Close All"]:
        if active_exchange == "hyperliquid":
            return await cmd_hl_close_all(update, ctx)
        else:
            # Show positions with close buttons (user can close all from there)
            return await cmd_open_positions(update, ctx)
    
    # Market - works for all languages
    if text in ["üìâ Market", "üìà Market", "üìà –†—ã–Ω–æ–∫", "üìà –†–∏–Ω–æ–∫", "üìà Mercado", "üìà Markt",
                 "üìà March√©", "üìà Mercato", "üìà Trh", "üìà Rynek", "üìà Rinka", "üìà Tregu",
                 "üìà ◊©◊ï◊ß", "üìà ÿßŸÑÿ≥ŸàŸÇ", "üìà Â∏ÇÂ†¥", "üìà Â∏ÇÂú∫", ctx.t.get('button_market', 'üìà Market')]:
        return await cmd_market(update, ctx)
    
    # Settings - works for current exchange
    if text in ["‚öôÔ∏è Settings", "‚öôÔ∏è HL Settings", ctx.t.get('button_settings', '‚öôÔ∏è Settings')]:
        if active_exchange == "hyperliquid":
            return await cmd_hl_settings(update, ctx)
        else:
            return await cmd_show_config(update, ctx)
    
    # API Keys - unified API management
    if text in ["üîë API Keys", "üîë HL API", "üü† Bybit API", "üî∑ HL API", 
                "üîó Exchange", "üîó –ë–∏—Ä–∂–∞", "üîó API Keys", "üîó API", "üîó API –ö–ª—é—á–∏", "üîó API –ö–ª—é—á—ñ",
                "üîó B√∂rse", "üîë API Kl√≠ƒçe", "üîë API raktai", "üîë API„Ç≠„Éº", "üîë APIÂØÜÈí•",
                "üîë Chiavi API", "üîë Cl√©s API", "üîë Klucze API", "üîë √áel√´sat API",
                "üîë ◊û◊§◊™◊ó◊ï◊™ API", "üîë ŸÖŸÅÿßÿ™Ÿäÿ≠ API",
                ctx.t.get('button_api_keys', 'üîó Exchange')]:
        return await cmd_api_settings(update, ctx)
    
    # Strategies button
    if text in ["ü§ñ Strategies", "ü§ñ AI Bots", "ü§ñ AI –ë–æ—Ç—ã",
                ctx.t.get('button_strategies', 'ü§ñ AI Bots'), 
                ctx.t.get('button_strategy_settings', '‚öôÔ∏è Strategies')]:
        return await cmd_strategy_settings(update, ctx)
    
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    # ‚ñà‚ñà  LEGACY BUTTONS (for backward compatibility)  ‚ñà‚ñà
    # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
    
    # Terminal button - opens WebApp
    if text in ["üíª Terminal", "üíª –¢–µ—Ä–º–∏–Ω–∞–ª", ctx.t.get("button_terminal", "üíª Terminal")]:
        return await cmd_webapp(update, ctx)
    
    # WebApp button
    if text == ctx.t.get("button_webapp", "üåê WebApp"):
        return await cmd_webapp(update, ctx)
    
    # Spot button - shows spot portfolio directly (NEW!)
    if text in ["üíπ Spot", "üíπ –°–ø–æ—Ç", ctx.t.get("button_spot", "üíπ Spot")]:
        return await cmd_spot_portfolio(update, ctx)
    
    # Spot Settings button (legacy)
    if text == ctx.t.get("button_spot_settings", "üíπ Spot Settings"):
        return await cmd_spot_settings(update, ctx)
    
    # Handle spot text input (e.g., DCA amount)
    if ctx.user_data.get("spot_awaiting"):
        handled = await handle_spot_text_input(update, ctx)
        if handled:
            return
    
    # Legacy API buttons (for backward compatibility, redirect to new menu)
    if text == ctx.t.get("button_api", "üîë API") or text == ctx.t.get("button_secret", "üîí Secret"):
        return await cmd_api_settings(update, ctx)

    if text in [ctx.t.get("button_lang", "üåç Lang"), "üåê Language", "üåç Lang", "üåç –ú–æ–≤–∞", "üåç –Ø–∑—ã–∫",
                 "üåê Gjuha", "üåê Idioma", "üåê Jazyk", "üåê Jƒôzyk", "üåê Kalba", "üåê Langue",
                 "üåê Lingua", "üåê Sprache", "üåê ◊©◊§◊î", "üåê ÿßŸÑŸÑÿ∫ÿ©", "üåê Ë®ÄË™û", "üåê ËØ≠Ë®Ä"]:
        return await cmd_lang(update, ctx)

    # Dashboard button - opens WebApp
    if text in [ctx.t.get("button_dashboard", "üñ•Ô∏è Dashboard"), "üñ•Ô∏è Dashboard"]:
        return await cmd_webapp(update, ctx)

    # NOTE: Balance, Orders, Positions are handled in UNIFIED BUTTONS section above
    # (removed duplicates that were calling legacy cmd_account, cmd_openorders, cmd_open_positions)

    if text == ctx.t.get("button_stats", "üìä Statistics"):
        return await cmd_trade_stats(update, ctx)

    if text == ctx.t.get("button_market", "üìà Market"):
        return await cmd_market(update, ctx)

    if text == ctx.t.get("button_settings", "‚öôÔ∏è Settings"):
        return await cmd_show_config(update, ctx)

    if text == ctx.t.get("button_indicators", "üìä Indicators"):
        return await cmd_indicators(update, ctx)

    if text == ctx.t.get("button_limit_only", "üìù Limit Only"):
        return await cmd_toggle_limit(update, ctx)

    if text == ctx.t.get("button_toggle_oi", "üìä OI"):
        return await cmd_toggle_oi(update, ctx)

    if text == ctx.t.get("button_scryptomera", "üîÆ Scryptomera"):
        return await cmd_toggle_scryptomera(update, ctx)

    if text == ctx.t.get("button_scalper"):
        return await cmd_toggle_scalper(update, ctx)

    if text == ctx.t.get("button_elcaro"):
        return await cmd_toggle_elcaro(update, ctx)

    if text == ctx.t.get("button_fibonacci"):
        return await cmd_toggle_fibonacci(update, ctx)

    if text == ctx.t.get("button_strategy_settings", "‚öôÔ∏è Strategy Settings"):
        return await cmd_strategy_settings(update, ctx)

    if text == ctx.t.get("button_toggle_rsi_bb", "üìà RSI/BB"):
        return await cmd_toggle_rsi_bb(update, ctx)

    if text in [ctx.t.get("button_support", "üìû Support"), "üìû Support"]:
        return await cmd_support(update, ctx)

    if text in [ctx.t.get("button_coins", "ü™ô Coins"), "üéØ Coins"]:
        return await cmd_select_coin_group(update, ctx)

    if text in [ctx.t.get("button_toggle_atr", "üìè ATR"), "üìè ATR"]:
        return await cmd_toggle_atr(update, ctx)

    if text in [ctx.t.get("button_update_tpsl", "üéØ TP/SL"), "üéØ TP/SL"]:
        return await cmd_update_tpsl(update, ctx)

    # Handle new API key entry modes
    if mode and mode.startswith("enter_api_"):
        api_type = mode.replace("enter_api_", "")
        creds = get_all_user_credentials(uid)
        
        if api_type == "demo_key":
            set_user_credentials(uid, text, creds.get("demo_api_secret") or "", "demo")
            clear_expired_api_cache(uid, "demo")
            # Auto-enable Bybit trading when API key is set
            db.set_bybit_enabled(uid, True)
        elif api_type == "demo_secret":
            set_user_credentials(uid, creds.get("demo_api_key") or "", text, "demo")
            clear_expired_api_cache(uid, "demo")
            # Auto-enable Bybit trading when API secret is set
            if creds.get("demo_api_key"):
                db.set_bybit_enabled(uid, True)
        elif api_type == "real_key":
            set_user_credentials(uid, text, creds.get("real_api_secret") or "", "real")
            clear_expired_api_cache(uid, "real")
            # Auto-enable Bybit trading when Real API key is set
            db.set_bybit_enabled(uid, True)
        elif api_type == "real_secret":
            set_user_credentials(uid, creds.get("real_api_key") or "", text, "real")
            clear_expired_api_cache(uid, "real")
            # Auto-enable Bybit trading when Real API secret is set
            if creds.get("real_api_key"):
                db.set_bybit_enabled(uid, True)
        
        ctx.user_data.pop("mode", None)
        
        # Show updated API settings
        creds = get_all_user_credentials(uid)
        msg = format_api_settings_message(ctx.t, creds, uid)
        keyboard = get_api_settings_keyboard(ctx.t, creds, uid)
        await update.message.reply_text(
            ctx.t.get("api_key_saved", "‚úÖ Saved!") + "\n\n" + msg,
            reply_markup=keyboard,
            parse_mode="HTML"
        )
        return
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # BYBIT 2-STEP SETUP (new flow: key ‚Üí secret)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    
    if mode == "enter_bybit_demo":
        step = ctx.user_data.get("api_step", "key")
        
        if step == "key":
            # Save key, ask for secret
            ctx.user_data["bybit_demo_key"] = text
            ctx.user_data["api_step"] = "secret"
            await update.message.reply_text(
                "üß™ <b>Bybit Demo API Setup</b>\n\n"
                "‚úÖ API Key saved!\n\n"
                "Step 2/2: Now enter your <b>Demo API Secret</b>:",
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚ùå Cancel", callback_data="api:back")]
                ])
            )
            return
        elif step == "secret":
            # Save both and finalize
            api_key = ctx.user_data.pop("bybit_demo_key", "")
            ctx.user_data.pop("api_step", None)
            ctx.user_data.pop("mode", None)
            
            set_user_credentials(uid, api_key, text, "demo")
            clear_expired_api_cache(uid, "demo")
            db.set_bybit_enabled(uid, True)
            
            creds = get_all_user_credentials(uid)
            msg = format_api_settings_message(ctx.t, creds, uid)
            keyboard = get_api_settings_keyboard(ctx.t, creds, uid)
            await update.message.reply_text(
                "‚úÖ <b>Bybit Demo credentials saved!</b>\n\n" + msg,
                reply_markup=keyboard,
                parse_mode="HTML"
            )
            return
    
    if mode == "enter_bybit_real":
        step = ctx.user_data.get("api_step", "key")
        
        if step == "key":
            ctx.user_data["bybit_real_key"] = text
            ctx.user_data["api_step"] = "secret"
            await update.message.reply_text(
                "üíº <b>Bybit Real API Setup</b>\n\n"
                "‚úÖ API Key saved!\n\n"
                "Step 2/2: Now enter your <b>Real API Secret</b>:",
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("‚ùå Cancel", callback_data="api:back")]
                ])
            )
            return
        elif step == "secret":
            api_key = ctx.user_data.pop("bybit_real_key", "")
            ctx.user_data.pop("api_step", None)
            ctx.user_data.pop("mode", None)
            
            set_user_credentials(uid, api_key, text, "real")
            clear_expired_api_cache(uid, "real")
            db.set_bybit_enabled(uid, True)
            
            creds = get_all_user_credentials(uid)
            msg = format_api_settings_message(ctx.t, creds, uid)
            keyboard = get_api_settings_keyboard(ctx.t, creds, uid)
            await update.message.reply_text(
                "‚úÖ <b>Bybit Real credentials saved!</b>\n\n" + msg,
                reply_markup=keyboard,
                parse_mode="HTML"
            )
            return
    
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    # HYPERLIQUID SETUP (private key only)
    # ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ
    
    if mode == "enter_hl_testnet":
        ctx.user_data.pop("mode", None)
        
        # Validate key format (should be 66 chars hex starting with 0x)
        if not text.startswith("0x") or len(text) != 66:
            await update.message.reply_text(
                "‚ùå <b>Invalid private key format!</b>\n\n"
                "Private key should:\n"
                "‚Ä¢ Start with <code>0x</code>\n"
                "‚Ä¢ Be 66 characters long\n\n"
                "Please try again.",
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîÑ Try Again", callback_data="api:hl_setup_testnet")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="api:back")]
                ])
            )
            return
        
        try:
            # Derive wallet address from private key
            from eth_account import Account
            account = Account.from_key(text)
            wallet_address = account.address
            
            # Save credentials
            db.set_user_field(uid, "hl_testnet_private_key", text)
            db.set_user_field(uid, "hl_testnet_wallet_address", wallet_address)
            db.set_hl_enabled(uid, True)
            db.invalidate_user_cache(uid)
            
            creds = get_all_user_credentials(uid)
            msg = format_api_settings_message(ctx.t, creds, uid)
            keyboard = get_api_settings_keyboard(ctx.t, creds, uid)
            await update.message.reply_text(
                f"‚úÖ <b>HyperLiquid Testnet configured!</b>\n\n"
                f"üß™ API Wallet: <code>{wallet_address[:8]}...{wallet_address[-6:]}</code>\n\n"
                f"<i>Main wallet will be auto-discovered on first trade.</i>\n\n" + msg,
                reply_markup=keyboard,
                parse_mode="HTML"
            )
        except Exception as e:
            await update.message.reply_text(
                f"‚ùå <b>Error processing key:</b>\n<code>{str(e)[:100]}</code>",
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîÑ Try Again", callback_data="api:hl_setup_testnet")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="api:back")]
                ])
            )
        return
    
    if mode == "enter_hl_mainnet":
        ctx.user_data.pop("mode", None)
        
        # Validate key format
        if not text.startswith("0x") or len(text) != 66:
            await update.message.reply_text(
                "‚ùå <b>Invalid private key format!</b>\n\n"
                "Private key should:\n"
                "‚Ä¢ Start with <code>0x</code>\n"
                "‚Ä¢ Be 66 characters long\n\n"
                "Please try again.",
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîÑ Try Again", callback_data="api:hl_setup_mainnet")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="api:back")]
                ])
            )
            return
        
        try:
            from eth_account import Account
            account = Account.from_key(text)
            wallet_address = account.address
            
            db.set_user_field(uid, "hl_mainnet_private_key", text)
            db.set_user_field(uid, "hl_mainnet_wallet_address", wallet_address)
            db.set_hl_enabled(uid, True)
            db.invalidate_user_cache(uid)
            
            creds = get_all_user_credentials(uid)
            msg = format_api_settings_message(ctx.t, creds, uid)
            keyboard = get_api_settings_keyboard(ctx.t, creds, uid)
            await update.message.reply_text(
                f"‚úÖ <b>HyperLiquid Mainnet configured!</b>\n\n"
                f"üåê API Wallet: <code>{wallet_address[:8]}...{wallet_address[-6:]}</code>\n\n"
                f"‚ö†Ô∏è <b>REAL FUNDS!</b> Main wallet auto-discovered on first trade.\n\n" + msg,
                reply_markup=keyboard,
                parse_mode="HTML"
            )
        except Exception as e:
            await update.message.reply_text(
                f"‚ùå <b>Error processing key:</b>\n<code>{str(e)[:100]}</code>",
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîÑ Try Again", callback_data="api:hl_setup_mainnet")],
                    [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="api:back")]
                ])
            )
        return

    # Legacy API modes (backward compatibility)
    if mode == "enter_api":
        set_user_credentials(uid, text, "", "demo")
        clear_expired_api_cache(uid, "demo")
        ctx.user_data.pop("mode", None)
        return await update.message.reply_text(ctx.t.get("api_saved", "API saved"), reply_markup=main_menu_keyboard(ctx, update=update))

    if mode == "enter_secret":
        creds = get_all_user_credentials(uid)
        set_user_credentials(uid, creds.get("demo_api_key") or "", text, "demo")
        clear_expired_api_cache(uid, "demo")
        ctx.user_data.pop("mode", None)
        return await update.message.reply_text(ctx.t.get("secret_saved", "Secret saved"), reply_markup=main_menu_keyboard(ctx, update=update))

    # Handle global setting input
    global_setting = ctx.user_data.get("global_setting_mode")
    if global_setting:
        try:
            value = float(text.replace(",", ".").strip())
            
            if global_setting in ("percent", "sl_percent", "tp_percent"):
                if value <= 0 or value > 100:
                    raise ValueError("Value must be between 0 and 100")
            elif global_setting == "leverage":
                if value < 1 or value > 100 or int(value) != value:
                    raise ValueError("Leverage must be integer between 1 and 100")
                value = int(value)
            # ATR settings validation
            elif global_setting == "atr_trigger_pct":
                if value < 0.1 or value > 50:
                    raise ValueError("ATR Trigger must be between 0.1 and 50")
            elif global_setting == "atr_step_pct":
                if value < 0.1 or value > 20:
                    raise ValueError("ATR Step must be between 0.1 and 20")
            elif global_setting == "atr_periods":  # Fixed: was atr_period
                if value < 1 or value > 100 or int(value) != value:
                    raise ValueError("ATR Period must be integer between 1 and 100")
                value = int(value)
            elif global_setting == "atr_multiplier_sl":  # Fixed: was atr_multiplier
                if value < 0.1 or value > 10:
                    raise ValueError("ATR Multiplier must be between 0.1 and 10")
            # Break-Even settings validation
            elif global_setting == "be_trigger_pct":
                if value < 0.1 or value > 50:
                    raise ValueError("BE Trigger must be between 0.1 and 50")
            
            logger.info(f"[GLOBAL-SETTING] uid={uid} saving {global_setting}={value}")
            set_user_field(uid, global_setting, value)
            ctx.user_data.pop("global_setting_mode", None)
            
            param_names = {
                "percent": "Entry %",
                "sl_percent": "SL %",
                "tp_percent": "TP %",
                "leverage": "Leverage",
                "atr_trigger_pct": "ATR Trigger %",
                "atr_step_pct": "ATR Step %",
                "atr_periods": "ATR Period",  # Fixed
                "atr_multiplier_sl": "ATR Multiplier",  # Fixed
                "be_trigger_pct": "BE Trigger %",
            }
            
            # Check if ATR setting - go back to ATR menu
            if global_setting.startswith("atr_"):
                await update.message.reply_text(
                    f"‚úÖ {param_names.get(global_setting, global_setting)} ‚Üí *{value}*\n\nUpdated successfully!",
                    parse_mode="Markdown"
                )
                return
            
            # Check if BE setting - go back to BE menu
            if global_setting.startswith("be_"):
                await update.message.reply_text(
                    f"‚úÖ {param_names.get(global_setting, global_setting)} ‚Üí *{value}*\n\nUpdated successfully!",
                    parse_mode="Markdown"
                )
                return
            
            # Get updated config for settings display
            cfg = get_user_config(uid)
            sl_val = cfg.get('sl_percent', cfg.get('sl_pct', 3))
            tp_val = cfg.get('tp_percent', cfg.get('tp_pct', 6))
            ladder_enabled = cfg.get('limit_ladder_enabled', 0)
            ladder_count = cfg.get('limit_ladder_count', 3)
            ladder_status = "‚úÖ" if ladder_enabled else "‚ùå"
            order_type = cfg.get('global_order_type', 'market')
            order_emoji = "‚ö°" if order_type == "market" else "üéØ"
            order_label = "Market" if order_type == "market" else "Limit"
            trading_mode = get_trading_mode(uid) or "demo"
            mode_emoji = {"demo": "üß™", "real": "üí∞", "both": "üîÑ"}.get(trading_mode, "üß™")
            mode_label = {"demo": "Demo", "real": "Real", "both": "Both"}.get(trading_mode, "Demo")
            
            lines = [ctx.t.get('global_settings_header', 'üåê *Global Trading Settings*')]
            lines.append(f"\n‚úÖ {param_names.get(global_setting, global_setting)} ‚Üí *{value}*\n")
            lines.append(f"üìä Entry %: *{cfg.get('percent', 1)}%*")
            lines.append(f"üõë SL %: *{sl_val}%*")
            lines.append(f"üéØ TP %: *{tp_val}%*")
            lines.append(f"üéö Leverage: *{cfg.get('leverage', 10)}x*")
            lines.append(f"{order_emoji} Order type: *{order_label}*")
            lines.append(f"{mode_emoji} Account: *{mode_label}*")
            lines.append("")
            lines.append(f"üìà {ctx.t.get('limit_ladder', 'Limit Ladder')}: {ladder_status} (*{ladder_count}* orders)")
            
            buttons = [
                [InlineKeyboardButton(ctx.t.get('param_percent', 'üìä Entry %'), callback_data="global_param:percent")],
                [InlineKeyboardButton(ctx.t.get('param_sl', 'üõë Stop-Loss %'), callback_data="global_param:sl_percent")],
                [InlineKeyboardButton(ctx.t.get('param_tp', 'üéØ Take-Profit %'), callback_data="global_param:tp_percent")],
                [InlineKeyboardButton(ctx.t.get('param_leverage', 'üéö Leverage'), callback_data="global_param:leverage")],
                [InlineKeyboardButton(f"{order_emoji} Order: {order_label}", callback_data="global_param:order_type")],
                [InlineKeyboardButton(f"{mode_emoji} Account: {mode_label}", callback_data="global_param:trading_mode")],
                [InlineKeyboardButton(f"{ladder_status} {ctx.t.get('limit_ladder', 'üìà Limit Ladder')}", callback_data="global_ladder:toggle")],
                [InlineKeyboardButton(ctx.t.get('limit_ladder_settings', '‚öôÔ∏è Ladder Settings'), callback_data="global_ladder:settings")],
                [InlineKeyboardButton(ctx.t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="strat_set:back")],
            ]
            
            await update.message.reply_text(
                "\n".join(lines),
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(buttons)
            )
            return
        except ValueError as e:
            await update.message.reply_text(
                ctx.t.get('invalid_value', '‚ùå Invalid value: {error}').format(error=str(e))
            )
            return

    # Handle ladder setting input
    ladder_setting = ctx.user_data.get("ladder_setting_mode")
    if ladder_setting:
        try:
            value = float(text.replace(",", ".").strip())
            if value <= 0 or value > 100:
                raise ValueError("Value must be between 0 and 100")
            
            param_type = ladder_setting["type"]  # "pct_entry" or "pct_deposit"
            leg_idx = ladder_setting["leg"]
            
            cfg = get_user_config(uid)
            ladder_settings = cfg.get("limit_ladder_settings", [])
            
            # Ensure list has enough elements
            while len(ladder_settings) <= leg_idx:
                ladder_settings.append({"pct_from_entry": 1.0, "pct_of_deposit": 5.0})
            
            if param_type == "pct_entry":
                ladder_settings[leg_idx]["pct_from_entry"] = value
            else:
                ladder_settings[leg_idx]["pct_of_deposit"] = value
            
            set_user_field(uid, "limit_ladder_settings", json.dumps(ladder_settings))
            ctx.user_data.pop("ladder_setting_mode", None)
            
            # Return to ladder settings menu
            cfg = get_user_config(uid)
            ladder_count = cfg.get('limit_ladder_count', 3)
            ladder_settings = cfg.get('limit_ladder_settings', [])
            
            if not ladder_settings:
                ladder_settings = [
                    {"pct_from_entry": 1.0, "pct_of_deposit": 5.0},
                    {"pct_from_entry": 2.0, "pct_of_deposit": 7.0},
                    {"pct_from_entry": 3.0, "pct_of_deposit": 10.0},
                ]
            
            lines = [ctx.t.get('limit_ladder_header', 'üìà *Limit Ladder Settings*')]
            lines.append(f"\n‚úÖ Order {leg_idx+1} updated!\n")
            lines.append(f"üìä {ctx.t.get('ladder_count', 'Number of orders')}: *{ladder_count}*")
            lines.append("")
            for i, leg in enumerate(ladder_settings[:ladder_count], 1):
                pct_entry = leg.get('pct_from_entry', 1.0)
                pct_deposit = leg.get('pct_of_deposit', 5.0)
                lines.append(f"üìâ *Order {i}*: -{pct_entry}% @ {pct_deposit}% deposit")
            
            buttons = [
                [InlineKeyboardButton(f"üìä {ctx.t.get('ladder_count', 'Count')}: {ladder_count}", callback_data="global_ladder:count")],
            ]
            for i in range(min(ladder_count, 5)):
                leg = ladder_settings[i] if i < len(ladder_settings) else {"pct_from_entry": 1.0, "pct_of_deposit": 5.0}
                pct_entry = leg.get('pct_from_entry', 1.0)
                pct_deposit = leg.get('pct_of_deposit', 5.0)
                buttons.append([
                    InlineKeyboardButton(f"üìâ #{i+1}: -{pct_entry}%", callback_data=f"global_ladder:pct_entry:{i}"),
                    InlineKeyboardButton(f"üí∞ #{i+1}: {pct_deposit}%", callback_data=f"global_ladder:pct_deposit:{i}"),
                ])
            buttons.append([InlineKeyboardButton(ctx.t.get('btn_back', '‚¨ÖÔ∏è Back'), callback_data="strat_set:global")])
            
            await update.message.reply_text(
                "\n".join(lines),
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(buttons)
            )
            return
        except ValueError as e:
            await update.message.reply_text(
                ctx.t.get('invalid_value', '‚ùå Invalid value: {error}').format(error=str(e))
            )
            return

    # Handle strategy setting input
    strat_mode = ctx.user_data.get("strat_setting_mode")
    
    # If not in user_data, try to recover from DB (survives bot restarts)
    if not strat_mode:
        pending = db.get_pending_input(uid)
        if pending and pending.get("input_type") == "strat_setting":
            data = pending.get("input_data", "")
            if ":" in data:
                parts = data.split(":", 1)
                strat_mode = {"strategy": parts[0], "param": parts[1]}
                ctx.user_data["strat_setting_mode"] = strat_mode  # Restore to user_data
                logger.info(f"[TEXT_HANDLER] Recovered strat_setting_mode from DB: uid={uid}, data={data}")
    
    if strat_mode:
        strategy = strat_mode.get("strategy")
        param = strat_mode.get("param")
        logger.info(f"[TEXT_HANDLER] strat_setting_mode: uid={uid}, strategy={strategy}, param={param}, text={text}")
        try:
            value = float(text.replace(",", ".").strip())
            
            # Import MAX_ENTRY_PERCENT for validation
            from coin_params import MAX_ENTRY_PERCENT
            
            # Different validation for different params
            # Entry % (percent) - MAX 3% for risk management
            if param in ("percent", "long_percent", "short_percent"):
                if value <= 0 or value > MAX_ENTRY_PERCENT:
                    raise ValueError(f"Entry % must be between 0.1 and {MAX_ENTRY_PERCENT}% (risk management limit)")
            # SL/TP/ATR % - standard 0-100 range
            elif param in ("sl_percent", "tp_percent", "atr_trigger_pct", "atr_step_pct",
                         "long_sl_percent", "long_tp_percent", "long_atr_trigger_pct", "long_atr_step_pct",
                         "short_sl_percent", "short_tp_percent", "short_atr_trigger_pct", "short_atr_step_pct"):
                if value <= 0 or value > 100:
                    raise ValueError("Value must be between 0 and 100")
            elif param == "min_quality":
                if value < 0 or value > 100:
                    raise ValueError("Min quality must be between 0 and 100")
                value = int(value)
            elif param in ("atr_periods", "long_atr_periods", "short_atr_periods"):
                if value < 1 or value > 50 or int(value) != value:
                    raise ValueError("ATR periods must be integer between 1 and 50")
                value = int(value)
            elif param in ("atr_multiplier_sl", "long_atr_multiplier_sl", "short_atr_multiplier_sl"):
                if value <= 0 or value > 10:
                    raise ValueError("ATR multiplier must be between 0 and 10")
            elif param in ("leverage", "long_leverage", "short_leverage"):
                if value < 1 or value > 100 or int(value) != value:
                    raise ValueError("Leverage must be integer between 1 and 100")
                value = int(value)
            elif param in ("long_partial_tp_1_close_pct", "short_partial_tp_1_close_pct"):
                # Validate Step 1 close % - must leave room for Step 2
                if value <= 0 or value >= 100:
                    raise ValueError("Step 1 must be between 0 and 99%")
                # Get Step 2 to validate total doesn't exceed 100%
                context = get_user_trading_context(uid)
                strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
                side = "long" if param.startswith("long_") else "short"
                step2_close = strat_settings.get(f"{side}_partial_tp_2_close_pct") or 30.0
                if value + step2_close > 100:
                    max_step1 = 100 - step2_close
                    raise ValueError(f"Step 1 can't exceed {max_step1:.0f}% (100% - Step 2 {step2_close:.0f}%)")
            elif param in ("long_partial_tp_2_close_pct", "short_partial_tp_2_close_pct"):
                # Validate Step 2 close % doesn't exceed remaining after Step 1
                # Step 1 + Step 2 must be <= 100%
                if value <= 0 or value > 100:
                    raise ValueError("Value must be between 0 and 100")
                # Get Step 1 close % to validate
                context = get_user_trading_context(uid)
                strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
                side = "long" if param.startswith("long_") else "short"
                step1_close = strat_settings.get(f"{side}_partial_tp_1_close_pct") or 30.0
                max_step2 = 100 - step1_close
                if value > max_step2:
                    raise ValueError(f"Step 2 can't exceed {max_step2:.0f}% (100% - Step 1 {step1_close:.0f}%)")
            else:
                if value <= 0 or value > 100:
                    raise ValueError("Value must be between 0 and 100")
            
            # Get context for saving - save to 'default' (applies to all accounts via fallback)
            context = get_user_trading_context(uid)
            
            # Save setting to 'default' account_type
            db.set_strategy_setting(uid, strategy, param, value,
                                   context["exchange"])  # account_type='default' by default
            
            logger.info(f"[{uid}] Strategy {strategy} param {param}={value} saved to default (fallback for all accounts)")
            ctx.user_data.pop("strat_setting_mode", None)
            db.clear_pending_input(uid)  # Clear from DB too
            
            display_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
            param_name = {
                "percent": "Entry %",
                "sl_percent": "SL %",
                "tp_percent": "TP %",
                "atr_periods": "ATR Periods",
                "atr_multiplier_sl": "ATR Multiplier",
                "atr_trigger_pct": "ATR Trigger %",
                "atr_step_pct": "ATR Step %",
                "leverage": "Leverage",
                "min_quality": "Min Quality %",
                # LONG
                "long_percent": "LONG Entry %",
                "long_sl_percent": "LONG SL %",
                "long_tp_percent": "LONG TP %",
                "long_leverage": "LONG Leverage",
                "long_atr_periods": "LONG ATR Periods",
                "long_atr_multiplier_sl": "LONG ATR Multiplier",
                "long_atr_trigger_pct": "LONG ATR Trigger %",
                "long_atr_step_pct": "LONG ATR Step %",
                # SHORT
                "short_percent": "SHORT Entry %",
                "short_sl_percent": "SHORT SL %",
                "short_tp_percent": "SHORT TP %",
                "short_leverage": "SHORT Leverage",
                "short_atr_periods": "SHORT ATR Periods",
                "short_atr_multiplier_sl": "SHORT ATR Multiplier",
                "short_atr_trigger_pct": "SHORT ATR Trigger %",
                "short_atr_step_pct": "SHORT ATR Step %",
            }.get(param, param)
            
            # Determine which keyboard to return to based on param
            global_cfg = db.get_user_config(uid)  # For fallback display
            if param.startswith("long_"):
                strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
                reply_kb = get_strategy_side_keyboard(strategy, "long", ctx.t, strat_settings, global_cfg)
            elif param.startswith("short_"):
                strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
                reply_kb = get_strategy_side_keyboard(strategy, "short", ctx.t, strat_settings, global_cfg)
            else:
                strat_settings = db.get_strategy_settings(uid, strategy, context["exchange"], context["account_type"])
                reply_kb = get_strategy_param_keyboard(strategy, ctx.t, strat_settings)
            
            # Show confirmation and return to appropriate settings menu
            await update.message.reply_text(
                ctx.t.get('strat_setting_saved', '‚úÖ {name} {param} set to {value}').format(
                    name=display_name, param=param_name, value=value
                ),
                reply_markup=reply_kb
            )
            return
        except (ValueError, TypeError) as e:
            # Show error but stay in input mode
            # Determine the correct cancel callback based on param prefix
            if param.startswith("long_"):
                cancel_callback = f"strat_side:{strategy}:long"
            elif param.startswith("short_"):
                cancel_callback = f"strat_side:{strategy}:short"
            else:
                cancel_callback = f"strat_set:{strategy}"
            return await update.message.reply_text(
                ctx.t.get('invalid_number', '‚ùå Invalid number. Enter a value between 0 and 100.'),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(ctx.t.get('btn_cancel', '‚ùå Cancel'), callback_data=cancel_callback)]
                ])
            )

    # Handle DCA setting input
    dca_mode = ctx.user_data.get("dca_setting_mode")
    if dca_mode:
        try:
            value = float(text.replace(",", ".").strip())
            if value <= 0 or value > 100:
                raise ValueError("Value must be between 0 and 100")
            
            set_user_field(uid, dca_mode, value)
            ctx.user_data.pop("dca_setting_mode", None)
            
            leg_name = "Leg 1" if dca_mode == "dca_pct_1" else "Leg 2"
            
            # Return to DCA settings menu
            return await update.message.reply_text(
                ctx.t.get('dca_setting_saved', '‚úÖ DCA {leg} set to {value}%').format(
                    leg=leg_name, value=value
                ),
                reply_markup=get_dca_settings_keyboard(ctx.t)
            )
        except (ValueError, TypeError):
            return await update.message.reply_text(
                ctx.t.get('invalid_number', '‚ùå Invalid number. Enter a value between 0 and 100.'),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(ctx.t.get('btn_cancel', '‚ùå Cancel'), callback_data="strat_set:dca")]
                ])
            )

    if mode == "select_coins":
        coins = [c.strip().upper() for c in text.split(",") if c.strip()]
        set_user_field(uid, "coins", ",".join(coins))
        ctx.user_data.pop("mode", None)
        return await update.message.reply_text(
            ctx.t["coins_set_success"].format(coins=", ".join(coins) if coins else "ALL"),
            reply_markup=main_menu_keyboard(ctx, update=update)
        )
    return await update.message.reply_text(ctx.t.get("fallback", "Command not recognized."),
                                           reply_markup=main_menu_keyboard(ctx, update=update))


# =====================================================
# COMMUNITY SUPPORT & MEMBERSHIP HANDLERS
# =====================================================

def get_subscribe_menu_keyboard(t: dict) -> InlineKeyboardMarkup:
    """Main membership menu keyboard."""
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(t.get("btn_premium", "ü§ù Patron"), callback_data="sub:plan:premium")],
        [InlineKeyboardButton(t.get("btn_basic", "ü•à Supporter"), callback_data="sub:plan:basic")],
        [InlineKeyboardButton(t.get("btn_trial", "üéÅ Free Access"), callback_data="sub:plan:trial")],
        [
            InlineKeyboardButton(t.get("btn_enter_promo", "üéü Invite"), callback_data="sub:promo"),
            InlineKeyboardButton(t.get("btn_my_subscription", "üìã My Status"), callback_data="sub:my"),
        ],
        [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="back:main")],
    ])


def get_premium_period_keyboard(t: dict) -> InlineKeyboardMarkup:
    """Patron tier period selection keyboard."""
    from services.oxapay_service import LICENSE_PRICES_USD
    prices = LICENSE_PRICES_USD.get("premium", {})
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(
            f"ü§ù 1 Month ‚Äî ${prices.get('1m', 100):.0f}",
            callback_data="sub:period:premium:1m"
        )],
        [InlineKeyboardButton(
            f"ü§ù 3 Months ‚Äî ${prices.get('3m', 270):.0f} (10% off)",
            callback_data="sub:period:premium:3m"
        )],
        [InlineKeyboardButton(
            f"ü§ù 6 Months ‚Äî ${prices.get('6m', 480):.0f} (20% off)",
            callback_data="sub:period:premium:6m"
        )],
        [InlineKeyboardButton(
            f"ü§ù 1 Year ‚Äî ${prices.get('1y', 840):.0f} (30% off)",
            callback_data="sub:period:premium:1y"
        )],
        [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="sub:menu")],
    ])


def get_basic_period_keyboard(t: dict) -> InlineKeyboardMarkup:
    """Supporter tier period selection keyboard."""
    from services.oxapay_service import LICENSE_PRICES_USD
    prices = LICENSE_PRICES_USD.get("basic", {})
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(
            f"ü•à 1 Month ‚Äî ${prices.get('1m', 50):.0f}",
            callback_data="sub:period:basic:1m"
        )],
        [InlineKeyboardButton(
            f"ü•à 3 Months ‚Äî ${prices.get('3m', 135):.0f} (10% off)",
            callback_data="sub:period:basic:3m"
        )],
        [InlineKeyboardButton(
            f"ü•à 6 Months ‚Äî ${prices.get('6m', 240):.0f} (20% off)",
            callback_data="sub:period:basic:6m"
        )],
        [InlineKeyboardButton(
            f"ü•à 1 Year ‚Äî ${prices.get('1y', 420):.0f} (30% off)",
            callback_data="sub:period:basic:1y"
        )],
        [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="sub:menu")],
    ])


def get_payment_method_keyboard(t: dict, plan: str, duration: str) -> InlineKeyboardMarkup:
    """Contribution method selection - Crypto (OxaPay) or ELC Token."""
    from services.oxapay_service import LICENSE_PRICES_USD
    prices = LICENSE_PRICES_USD.get(plan, {})
    usd_price = prices.get(duration, 0)
    
    return InlineKeyboardMarkup([
        # Primary: Contribute with Crypto via OxaPay
        [InlineKeyboardButton(
            f"üíö Contribute ${usd_price:.0f} in Crypto",
            callback_data=f"sub:crypto:{plan}:{duration}"
        )],
        # Alternative: Contribute with ELC tokens
        [InlineKeyboardButton(
            f"ü™ô Contribute {usd_price:.0f} ELC",
            callback_data=f"sub:elc:{plan}:{duration}"
        )],
        [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data=f"sub:plan:{plan}")],
    ])


# =====================================================
# SOVEREIGN OWNER CONTROLS (Monetary Authority)
# =====================================================

@log_calls
async def cmd_sovereign(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """
    SOVEREIGN OWNER COMMAND: Full monetary control panel.
    Only available to the sovereign owner (SOVEREIGN_OWNER_ID).
    """
    uid = update.effective_user.id
    
    if not is_sovereign_owner(uid):
        t = get_texts(uid)
        await update.message.reply_text(t.get("unauthorized_admin", "‚ùå Unauthorized. This command is only for the Sovereign Owner."))
        return
    
    # Get comprehensive dashboard
    dashboard = await get_owner_dashboard(uid)
    
    if not dashboard:
        t = get_texts(uid)
        await update.message.reply_text(t.get("error_loading_dashboard", "‚ùå Error loading dashboard."))
        return
    
    treasury = dashboard["treasury"]
    global_stats = dashboard["global"]
    
    text = f"""üèõÔ∏è *SOVEREIGN MONETARY CONTROL PANEL*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üëë *{SOVEREIGN_OWNER_NAME}*
üéñÔ∏è {dashboard['owner_title']}

üìä *SUPPLY METRICS*
‚îú Current Supply: *{treasury['current_supply']:,.0f} ELC*
‚îú Max Supply: *{treasury['max_supply']:,.0f} ELC*
‚îú Utilization: *{treasury['supply_utilization']*100:.2f}%*
‚îî Circulating: *{treasury['current_supply'] - treasury['treasury_balance']:,.0f} ELC*

üè¶ *TREASURY*
‚îú Treasury Balance: *{treasury['treasury_balance']:,.0f} ELC*
‚îú Liquidity Pool: *{treasury['liquidity_pool']:,.0f} ELC*
‚îî Fees Collected: *{treasury['total_fees_collected']:,.2f} ELC*

üìà *RESERVES*
‚îú Total Value: *${treasury['total_reserve_value']:,.0f}*
‚îú Reserve Ratio: *{treasury['reserve_ratio']*100:.1f}%*
‚îî Status: {'‚úÖ Healthy' if treasury['reserve_ratio'] >= 1.0 else '‚ö†Ô∏è Under-collateralized'}

üíé *STAKING*
‚îú Total Staked: *{treasury['total_staked']:,.0f} ELC*
‚îú Current APY: *{treasury['staking_apy']*100:.1f}%*
‚îî Rewards Distributed: *{treasury['total_rewards_distributed']:,.2f} ELC*

üîó *BLOCKCHAIN*
‚îú Chain: *{CHAIN_NAME}*
‚îú Chain ID: *{CHAIN_ID}*
‚îú Wallets: *{global_stats['total_wallets']:,}*
‚îú Transactions: *{global_stats['total_transactions']:,}*
‚îî Block Height: *{global_stats['block_height']:,}*

‚ö° *STATUS:* {'üî¥ PAUSED' if treasury['is_paused'] else 'üü¢ ACTIVE'}
üìä *Emission Events:* {dashboard['emission_count']}
"""

    keyboard = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("üíµ Emit Tokens", callback_data="sovereign:emit"),
            InlineKeyboardButton("üî• Burn Tokens", callback_data="sovereign:burn")
        ],
        [
            InlineKeyboardButton("üìä Set APY", callback_data="sovereign:set_apy"),
            InlineKeyboardButton("üí∞ Set Fees", callback_data="sovereign:set_fees")
        ],
        [
            InlineKeyboardButton("üéÅ Distribute Rewards", callback_data="sovereign:distribute"),
            InlineKeyboardButton("üí∏ Treasury Transfer", callback_data="sovereign:transfer")
        ],
        [
            InlineKeyboardButton("‚ùÑÔ∏è Freeze Wallet", callback_data="sovereign:freeze"),
            InlineKeyboardButton("üîì Unfreeze Wallet", callback_data="sovereign:unfreeze")
        ],
        [
            InlineKeyboardButton("‚è∏Ô∏è Pause Protocol" if not treasury['is_paused'] else "‚ñ∂Ô∏è Resume Protocol", 
                               callback_data="sovereign:pause" if not treasury['is_paused'] else "sovereign:resume"),
        ],
        [InlineKeyboardButton("üîÑ Refresh", callback_data="sovereign:refresh")]
    ])
    
    await update.message.reply_text(text, parse_mode="Markdown", reply_markup=keyboard)


async def on_sovereign_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle sovereign owner callbacks."""
    q = update.callback_query
    await q.answer()
    
    uid = update.effective_user.id
    
    if not is_sovereign_owner(uid):
        t = get_texts(uid)
        await q.edit_message_text(t.get("unauthorized", "‚ùå Unauthorized."))
        return
    
    data = q.data  # sovereign:xxx
    parts = data.split(":")
    action = parts[1] if len(parts) > 1 else ""
    
    if action == "refresh":
        dashboard = await get_owner_dashboard(uid)
        treasury = dashboard["treasury"]
        global_stats = dashboard["global"]
        
        text = f"""üèõÔ∏è *SOVEREIGN MONETARY CONTROL PANEL*
‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ

üëë *{SOVEREIGN_OWNER_NAME}*

üìä Supply: *{treasury['current_supply']:,.0f}* / {treasury['max_supply']:,.0f} ELC
üè¶ Treasury: *{treasury['treasury_balance']:,.0f} ELC*
üìà Reserves: *${treasury['total_reserve_value']:,.0f}* ({treasury['reserve_ratio']*100:.1f}%)
üíé Staked: *{treasury['total_staked']:,.0f} ELC* @ {treasury['staking_apy']*100:.1f}% APY
üîó Wallets: *{global_stats['total_wallets']:,}* | TXs: *{global_stats['total_transactions']:,}*

‚ö° *STATUS:* {'üî¥ PAUSED' if treasury['is_paused'] else 'üü¢ ACTIVE'}
"""
        
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("üíµ Emit", callback_data="sovereign:emit"),
                InlineKeyboardButton("üî• Burn", callback_data="sovereign:burn"),
                InlineKeyboardButton("üìä APY", callback_data="sovereign:set_apy")
            ],
            [
                InlineKeyboardButton("üéÅ Rewards", callback_data="sovereign:distribute"),
                InlineKeyboardButton("üí∏ Transfer", callback_data="sovereign:transfer"),
                InlineKeyboardButton("‚ùÑÔ∏è Freeze", callback_data="sovereign:freeze")
            ],
            [
                InlineKeyboardButton("‚è∏Ô∏è Pause" if not treasury['is_paused'] else "‚ñ∂Ô∏è Resume", 
                                   callback_data="sovereign:pause" if not treasury['is_paused'] else "sovereign:resume"),
                InlineKeyboardButton("üîÑ Refresh", callback_data="sovereign:refresh")
            ]
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "emit":
        ctx.user_data["sovereign_mode"] = "emit"
        await q.edit_message_text(
            "üíµ *TOKEN EMISSION*\n\n"
            "Enter the amount of ELC to emit and reason:\n"
            "Format: `amount reason`\n\n"
            "Example: `1000000 Liquidity expansion Q1 2026`\n\n"
            "‚ö†Ô∏è This will increase total supply!",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="sovereign:refresh")]
            ])
        )
    
    elif action == "burn":
        ctx.user_data["sovereign_mode"] = "burn"
        dashboard = await get_owner_dashboard(uid)
        treasury_balance = dashboard["treasury"]["treasury_balance"]
        
        await q.edit_message_text(
            f"üî• *TOKEN BURN*\n\n"
            f"Treasury Balance: *{treasury_balance:,.0f} ELC*\n\n"
            "Enter amount and reason:\n"
            "Format: `amount reason`\n\n"
            "Example: `500000 Supply reduction for stability`\n\n"
            "‚ö†Ô∏è This will decrease total supply!",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="sovereign:refresh")]
            ])
        )
    
    elif action == "set_apy":
        ctx.user_data["sovereign_mode"] = "set_apy"
        await q.edit_message_text(
            "üìä *SET STAKING APY*\n\n"
            "Current APY: 12%\n"
            "Range: 5% - 25%\n\n"
            "Enter new APY (number only):\n"
            "Example: `15` for 15% APY",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="sovereign:refresh")]
            ])
        )
    
    elif action == "distribute":
        result = await distribute_staking_rewards(uid)
        
        if result["success"]:
            await q.edit_message_text(
                f"‚úÖ *REWARDS DISTRIBUTED*\n\n"
                f"üí∞ Total: *{result['distributed']:,.2f} ELC*\n"
                f"üë• Recipients: *{result['recipients']}*\n"
                f"üìä Daily Rate: *{result['daily_rate']*100:.4f}%*\n"
                f"üìà APY: *{result['apy']*100:.1f}%*",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("¬´ Back", callback_data="sovereign:refresh")]
                ])
            )
        else:
            await q.edit_message_text(f"‚ùå Error: {result.get('message', 'Unknown')}")
    
    elif action == "transfer":
        ctx.user_data["sovereign_mode"] = "transfer"
        await q.edit_message_text(
            "üí∏ *TREASURY TRANSFER*\n\n"
            "Transfer ELC from treasury to a user.\n\n"
            "Format: `user_id amount reason`\n"
            "Example: `123456789 10000 Partner bonus`",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="sovereign:refresh")]
            ])
        )
    
    elif action == "freeze":
        ctx.user_data["sovereign_mode"] = "freeze"
        await q.edit_message_text(
            "‚ùÑÔ∏è *FREEZE WALLET*\n\n"
            "Enter user ID to freeze:\n"
            "Format: `user_id reason`\n\n"
            "Example: `123456789 Suspicious activity`",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="sovereign:refresh")]
            ])
        )
    
    elif action == "unfreeze":
        ctx.user_data["sovereign_mode"] = "unfreeze"
        await q.edit_message_text(
            "üîì *UNFREEZE WALLET*\n\n"
            "Enter user ID to unfreeze:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="sovereign:refresh")]
            ])
        )
    
    elif action in ("pause", "resume"):
        is_pause = action == "pause"
        result = await set_monetary_policy(uid, is_paused=is_pause)
        
        if result["success"]:
            status = "‚è∏Ô∏è PAUSED" if is_pause else "‚ñ∂Ô∏è RESUMED"
            await q.edit_message_text(
                f"‚úÖ Protocol {status}\n\n"
                f"{'‚ö†Ô∏è All transactions are now blocked!' if is_pause else '‚úÖ Normal operations restored.'}",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("¬´ Back", callback_data="sovereign:refresh")]
                ])
            )


async def handle_sovereign_input(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> bool:
    """Handle sovereign mode text inputs. Returns True if handled."""
    uid = update.effective_user.id
    
    if not is_sovereign_owner(uid):
        return False
    
    mode = ctx.user_data.get("sovereign_mode")
    if not mode:
        return False
    
    text = update.message.text.strip()
    
    if mode == "emit":
        try:
            parts = text.split(maxsplit=1)
            amount = float(parts[0])
            reason = parts[1] if len(parts) > 1 else "Manual emission"
            
            result = await emit_tokens(uid, amount, reason)
            
            if result["success"]:
                await update.message.reply_text(
                    f"‚úÖ *TOKEN EMISSION SUCCESSFUL*\n\n"
                    f"üíµ Amount: *{amount:,.0f} ELC*\n"
                    f"üìù Reason: {reason}\n"
                    f"üìä New Supply: *{result['new_supply']:,.0f} ELC*\n"
                    f"üîó TX: `{result['tx_hash'][:20]}...`",
                    parse_mode="Markdown"
                )
            else:
                await update.message.reply_text(f"‚ùå Error: {result['error']}")
        except Exception as e:
            await update.message.reply_text(f"‚ùå Invalid format: {e}")
        
        ctx.user_data.pop("sovereign_mode", None)
        return True
    
    elif mode == "burn":
        try:
            parts = text.split(maxsplit=1)
            amount = float(parts[0])
            reason = parts[1] if len(parts) > 1 else "Manual burn"
            
            result = await burn_tokens(uid, amount, reason)
            
            if result["success"]:
                await update.message.reply_text(
                    f"‚úÖ *TOKEN BURN SUCCESSFUL*\n\n"
                    f"üî• Amount: *{amount:,.0f} ELC*\n"
                    f"üìù Reason: {reason}\n"
                    f"üìä New Supply: *{result['new_supply']:,.0f} ELC*\n"
                    f"üîó TX: `{result['tx_hash'][:20]}...`",
                    parse_mode="Markdown"
                )
            else:
                await update.message.reply_text(f"‚ùå Error: {result['error']}")
        except Exception as e:
            await update.message.reply_text(f"‚ùå Invalid format: {e}")
        
        ctx.user_data.pop("sovereign_mode", None)
        return True
    
    elif mode == "set_apy":
        try:
            apy = float(text) / 100  # Convert from percent
            
            result = await set_monetary_policy(uid, staking_apy=apy)
            
            if result["success"]:
                changes = result.get("changes", {})
                apy_change = changes.get("staking_apy", {})
                await update.message.reply_text(
                    f"‚úÖ *STAKING APY UPDATED*\n\n"
                    f"üìâ Old: {apy_change.get('old', 0)*100:.1f}%\n"
                    f"üìà New: {apy_change.get('new', apy)*100:.1f}%",
                    parse_mode="Markdown"
                )
            else:
                await update.message.reply_text(f"‚ùå Error: {result.get('error', 'Unknown')}")
        except Exception as e:
            await update.message.reply_text(f"‚ùå Invalid format: {e}")
        
        ctx.user_data.pop("sovereign_mode", None)
        return True
    
    elif mode == "transfer":
        try:
            parts = text.split(maxsplit=2)
            target_uid = int(parts[0])
            amount = float(parts[1])
            reason = parts[2] if len(parts) > 2 else "Treasury transfer"
            
            result = await transfer_from_treasury(uid, target_uid, amount, reason)
            
            if result["success"]:
                await update.message.reply_text(
                    f"‚úÖ *TREASURY TRANSFER SUCCESSFUL*\n\n"
                    f"üë§ To: User `{target_uid}`\n"
                    f"üí∞ Amount: *{amount:,.0f} ELC*\n"
                    f"üìù Reason: {reason}\n"
                    f"üè¶ Remaining: *{result['remaining_treasury']:,.0f} ELC*",
                    parse_mode="Markdown"
                )
            else:
                await update.message.reply_text(f"‚ùå Error: {result['error']}")
        except Exception as e:
            await update.message.reply_text(f"‚ùå Invalid format: {e}")
        
        ctx.user_data.pop("sovereign_mode", None)
        return True
    
    elif mode == "freeze":
        try:
            parts = text.split(maxsplit=1)
            target_uid = int(parts[0])
            reason = parts[1] if len(parts) > 1 else "Frozen by owner"
            
            target_wallet = await get_elc_wallet(target_uid)
            result = await freeze_wallet(uid, target_wallet.address, reason)
            
            if result["success"]:
                await update.message.reply_text(
                    f"‚úÖ *WALLET FROZEN*\n\n"
                    f"üë§ User: `{target_uid}`\n"
                    f"üìç Address: `{result['address'][:20]}...`\n"
                    f"üìù Reason: {reason}",
                    parse_mode="Markdown"
                )
            else:
                await update.message.reply_text(f"‚ùå Error: {result['error']}")
        except Exception as e:
            await update.message.reply_text(f"‚ùå Invalid format: {e}")
        
        ctx.user_data.pop("sovereign_mode", None)
        return True
    
    elif mode == "unfreeze":
        try:
            target_uid = int(text.strip())
            target_wallet = await get_elc_wallet(target_uid)
            result = await unfreeze_wallet(uid, target_wallet.address)
            
            if result["success"]:
                await update.message.reply_text(
                    f"‚úÖ *WALLET UNFROZEN*\n\n"
                    f"üë§ User: `{target_uid}`\n"
                    f"üìç Address: `{result['address'][:20]}...`",
                    parse_mode="Markdown"
                )
            else:
                await update.message.reply_text(f"‚ùå Error: {result['error']}")
        except Exception as e:
            await update.message.reply_text(f"‚ùå Invalid format: {e}")
        
        ctx.user_data.pop("sovereign_mode", None)
        return True
    
    return False


# =====================================================
# ELC WALLET MANAGEMENT
# =====================================================

@log_calls
@require_access
async def cmd_wallet(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show user's ELC wallet - OPTIMIZED with parallel fetching."""
    uid = update.effective_user.id
    t = ctx.t
    
    # OPTIMIZED: Fetch all wallet data in parallel
    wallet, balance_info, transactions = await asyncio.gather(
        get_elc_wallet(uid),
        blockchain.get_total_balance(uid),
        blockchain.get_transaction_history(uid, limit=5),
        return_exceptions=True
    )
    
    # Handle exceptions
    if isinstance(wallet, Exception):
        await update.message.reply_text(f"‚ùå Error loading wallet: {wallet}")
        return
    if isinstance(balance_info, Exception):
        balance_info = {"available": 0, "staked": 0, "pending_rewards": 0, "total": 0}
    if isinstance(transactions, Exception):
        transactions = []
    
    text = t.get("wallet_header", "ü™ô *Enliko Coin (ELC) Wallet*")
    text += f"\n\nüìç *Address:*\n`{wallet.address}`"
    text += f"\n\nüí∞ *Available:* {balance_info['available']:.2f} ELC"
    text += f"\nüîí *Staked:* {balance_info['staked']:.2f} ELC"
    text += f"\nüéÅ *Rewards:* {balance_info['pending_rewards']:.2f} ELC"
    text += f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
    text += f"\nüíé *Total:* {balance_info['total']:.2f} ELC (~${balance_info['total']:.2f})"
    
    # Recent transactions
    if transactions:
        text += f"\n\nüìú *Recent Transactions:*"
        for tx in transactions[:5]:
            icon = "üì•" if tx.to_address == wallet.address else "üì§"
            text += f"\n{icon} {tx.tx_type.value}: {tx.amount:.2f} ELC"
    
    text += "\n\nüí° *1 ELC = 1 USDT*"
    
    keyboard = InlineKeyboardMarkup([
        [
            InlineKeyboardButton("üí≥ Deposit", callback_data="wallet:deposit"),
            InlineKeyboardButton("üí∏ Withdraw", callback_data="wallet:withdraw")
        ],
        [
            InlineKeyboardButton("üìä Stake ELC (12% APY)", callback_data="wallet:stake"),
            InlineKeyboardButton("üìú History", callback_data="wallet:history")
        ],
        [InlineKeyboardButton("üîÑ Refresh", callback_data="wallet:refresh")],
    ])
    
    await update.message.reply_text(text, parse_mode="Markdown", reply_markup=keyboard)


@with_texts
async def on_wallet_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle wallet callbacks - OPTIMIZED with parallel fetching."""
    q = update.callback_query
    await q.answer()
    
    uid = update.effective_user.id
    t = ctx.t
    data = q.data  # wallet:xxx
    
    parts = data.split(":")
    action = parts[1] if len(parts) > 1 else ""
    
    if action == "refresh":
        # OPTIMIZED: Refresh wallet display with parallel fetching
        wallet, balance_info, transactions = await asyncio.gather(
            get_elc_wallet(uid),
            blockchain.get_total_balance(uid),
            blockchain.get_transaction_history(uid, limit=5),
            return_exceptions=True
        )
        
        # Handle exceptions
        if isinstance(wallet, Exception):
            await q.edit_message_text(f"‚ùå Error: {wallet}")
            return
        if isinstance(balance_info, Exception):
            balance_info = {"available": 0, "staked": 0, "pending_rewards": 0, "total": 0}
        if isinstance(transactions, Exception):
            transactions = []
        
        text = t.get("wallet_header", "ü™ô *Enliko Coin (ELC) Wallet*")
        text += f"\n\nüìç *Address:*\n`{wallet.address}`"
        text += f"\n\nüí∞ *Available:* {balance_info['available']:.2f} ELC"
        text += f"\nüîí *Staked:* {balance_info['staked']:.2f} ELC"
        text += f"\nüéÅ *Rewards:* {balance_info['pending_rewards']:.2f} ELC"
        text += f"\n‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ"
        text += f"\nüíé *Total:* {balance_info['total']:.2f} ELC (~${balance_info['total']:.2f})"
        
        if transactions:
            text += f"\n\nüìú *Recent Transactions:*"
            for tx in transactions[:5]:
                icon = "üì•" if tx.to_address == wallet.address else "üì§"
                text += f"\n{icon} {tx.tx_type.value}: {tx.amount:.2f} ELC"
        
        text += "\n\nüí° *1 ELC = 1 USDT*"
        
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("üí≥ Deposit", callback_data="wallet:deposit"),
                InlineKeyboardButton("üí∏ Withdraw", callback_data="wallet:withdraw")
            ],
            [
                InlineKeyboardButton("üìä Stake ELC (12% APY)", callback_data="wallet:stake"),
                InlineKeyboardButton("üìú History", callback_data="wallet:history")
            ],
            [InlineKeyboardButton("üîÑ Refresh", callback_data="wallet:refresh")],
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "deposit":
        # Show deposit options
        wallet = await get_elc_wallet(uid)
        balance = await get_elc_balance(uid)
        
        text = t.get("wallet_deposit_header", "üí≥ *Deposit ELC Tokens*")
        text += f"\n\nüí∞ *Current Balance:* {balance:.2f} ELC"
        text += "\n\nü™ô *Ways to get ELC:*"
        text += "\n\n1Ô∏è‚É£ *Buy with Crypto:*"
        text += "\nPay with USDT, BTC, ETH and get ELC 1:1"
        text += "\n\n2Ô∏è‚É£ *Earn Rewards:*"
        text += "\n‚Ä¢ Referral bonuses"
        text += "\n‚Ä¢ Trading achievements"
        text += "\n‚Ä¢ Staking rewards (12% APY)"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üí≥ Buy ELC with Crypto", callback_data="wallet:buy_crypto")],
            [InlineKeyboardButton("üéÅ Get 100 ELC (Demo)", callback_data="wallet:demo_deposit")],
            [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:refresh")],
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "demo_deposit":
        # Demo deposit - give 100 ELC for testing
        success, message = await deposit_elc(uid, 100.0, "Demo deposit")
        
        if success:
            new_balance = await get_elc_balance(uid)
            await q.edit_message_text(
                f"‚úÖ *Demo Deposit Successful!*\n\nü™ô +100 ELC credited\nüí∞ New Balance: {new_balance:.2f} ELC\n\n{message}",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:refresh")]
                ])
            )
        else:
            await q.edit_message_text(
                f"‚ùå Deposit failed: {message}",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:deposit")]
                ])
            )
    
    elif action == "buy_soon" or action == "buy_crypto":
        # Redirect to OxaPay buy ELC flow
        balance = await get_elc_balance(uid)
        
        text = "üíé *Buy ELC Tokens*\n\n"
        text += f"üí∞ *Current Balance:* {balance:.2f} ELC\n\n"
        text += "ü™ô *ELC Token:*\n"
        text += "‚Ä¢ 1 ELC = $1 USD (stable)\n"
        text += "‚Ä¢ Use for community contributions\n"
        text += "‚Ä¢ 12% APY staking rewards\n"
        text += "‚Ä¢ Future governance rights\n\n"
        text += "*Select amount:*"
        
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("50 ELC ($50)", callback_data="wallet:buy:50"),
                InlineKeyboardButton("100 ELC ($100)", callback_data="wallet:buy:100")
            ],
            [
                InlineKeyboardButton("250 ELC ($250)", callback_data="wallet:buy:250"),
                InlineKeyboardButton("500 ELC ($500)", callback_data="wallet:buy:500")
            ],
            [InlineKeyboardButton("üíµ Custom Amount", callback_data="wallet:buy:custom")],
            [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:deposit")],
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "buy":
        # Process ELC purchase with OxaPay
        amount_str = parts[2] if len(parts) > 2 else "50"
        
        if amount_str == "custom":
            await q.edit_message_text(
                "üíé *Custom ELC Purchase*\n\nEnter the amount of ELC you want to buy (in USD):\n\nMinimum: $10\nMaximum: $10,000",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:buy_crypto")]
                ])
            )
            # Set pending input for custom amount
            db.set_user_field(uid, "pending_input", "wallet:buy_custom")
            return
        
        try:
            amount = int(amount_str)
        except ValueError:
            amount = 50
        
        if amount < 10:
            await q.answer("‚ùå Minimum purchase is $10", show_alert=True)
            return
        
        # Show crypto payment options
        text = f"üíé *Purchase {amount} ELC*\n\n"
        text += f"üíµ *Amount:* ${amount} USD\n"
        text += f"ü™ô *You'll receive:* {amount} ELC\n\n"
        text += "*Select payment method:*"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üí≥ USDT (TRC20)", callback_data=f"wallet:pay:{amount}:USDT:TRC20")],
            [InlineKeyboardButton("üí≥ USDT (BEP20)", callback_data=f"wallet:pay:{amount}:USDT:BEP20")],
            [InlineKeyboardButton("‚Çø Bitcoin", callback_data=f"wallet:pay:{amount}:BTC:Bitcoin")],
            [InlineKeyboardButton("Œû Ethereum", callback_data=f"wallet:pay:{amount}:ETH:ERC20")],
            [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:buy_crypto")],
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "pay":
        # Create OxaPay payment for ELC purchase
        amount = int(parts[2]) if len(parts) > 2 else 50
        currency = parts[3] if len(parts) > 3 else "USDT"
        network = parts[4] if len(parts) > 4 else "TRC20"
        
        try:
            from services.oxapay_service import create_payment_for_elc
            
            await q.edit_message_text("‚è≥ Creating payment...", parse_mode="Markdown")
            
            result = await create_payment_for_elc(uid, amount, currency, network)
            
            if result.get("success"):
                payment_data = result.get("data", {})
                address = payment_data.get("address", "")
                amount_crypto = payment_data.get("amount", 0)
                payment_id = payment_data.get("payment_id", "")
                
                text = f"üí≥ *Payment Invoice*\n\n"
                text += f"üíé *Buying:* {amount} ELC\n"
                text += f"üíµ *Price:* ${amount} USD\n"
                text += f"üí≤ *Pay:* {amount_crypto} {currency}\n"
                text += f"üîó *Network:* {network}\n\n"
                text += f"üìç *Send to:*\n`{address}`\n\n"
                text += f"‚è∞ *Expires in:* 30 minutes\n\n"
                text += "‚ö†Ô∏è Send the exact amount shown above!"
                
                keyboard = InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîç Check Payment", callback_data=f"wallet:check:{payment_id}")],
                    [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data=f"wallet:buy:{amount}")],
                ])
                
                await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
            else:
                await q.edit_message_text(
                    f"‚ùå Failed to create payment: {result.get('error', 'Unknown error')}",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:buy_crypto")]
                    ])
                )
        except ImportError:
            await q.edit_message_text(
                "‚ùå Payment service not available",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:deposit")]
                ])
            )
        except Exception as e:
            logger.error(f"Payment creation error: {e}")
            await q.edit_message_text(
                f"‚ùå Error: {str(e)}",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:buy_crypto")]
                ])
            )
    
    elif action == "check":
        # Check payment status
        payment_id = parts[2] if len(parts) > 2 else ""
        
        try:
            from services.oxapay_service import check_payment_status
            
            result = await check_payment_status(payment_id)
            status = result.get("status", "unknown")
            
            if status == "confirmed":
                amount = result.get("amount", 0)
                new_balance = await get_elc_balance(uid)
                
                await q.edit_message_text(
                    f"‚úÖ *Payment Confirmed!*\n\nü™ô +{amount} ELC credited\nüí∞ New Balance: {new_balance:.2f} ELC\n\nThank you! üöÄ",
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:refresh")]
                    ])
                )
            elif status == "pending":
                await q.answer("‚è≥ Payment pending... Please wait for blockchain confirmation.", show_alert=True)
            elif status == "expired":
                await q.edit_message_text(
                    "‚ùå *Payment Expired*\n\nThe invoice has expired. Please create a new payment.",
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üîÑ Try Again", callback_data="wallet:buy_crypto")],
                        [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:refresh")]
                    ])
                )
            else:
                await q.answer(f"Status: {status}", show_alert=True)
        except Exception as e:
            logger.error(f"Payment check error: {e}")
            await q.answer(f"Error checking status: {str(e)}", show_alert=True)
    
    elif action == "buy_elc":
        # Show ELC purchase options
        elc_balance = get_elc_balance(uid)
        trc_balance = await get_elc_balance(uid)
        
        text = t.get("wallet_buy_elc_header", "üíé *Buy ENLIKO (ELC) Tokens*")
        text += "\n\n‚≠ê *ENLIKO is the Super Token!*"
        text += "\n‚Ä¢ 1 ELC = 1 USD (stable price)"
        text += "\n‚Ä¢ Use for all platform payments"
        text += "\n‚Ä¢ Future governance rights"
        text += "\n‚Ä¢ Exclusive holder benefits"
        text += f"\n\nüí∞ *Your ELC Balance:* {elc_balance.get('available', 0):.2f} ELC"
        text += f"\nüîí *Staked:* {elc_balance.get('staked', 0):.2f} ELC"
        text += f"\nüíé *Total:* {elc_balance.get('total', 0):.2f} ELC"
        text += f"\n\nü™ô *ELC Balance:* {trc_balance:.2f} ELC"
        text += "\n\nüí° *Ways to get ELC:*"
        text += "\n1Ô∏è‚É£ Convert ELC to ELC (1:1)"
        text += "\n2Ô∏è‚É£ Buy with USDT on TON"
        text += "\n3Ô∏è‚É£ Earn through platform rewards"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üîÑ Convert ELC ‚Üí ELC", callback_data="wallet:wallet_info")],
            [InlineKeyboardButton("üíµ Buy with USDT (TON)", callback_data="wallet:buy_elc_usdt")],
            [InlineKeyboardButton("üéÅ Get Demo ELC", callback_data="wallet:demo_elc")],
            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:refresh")],
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "wallet_info":
        # Convert ELC to ELC (1:1)
        trc_balance = await get_elc_balance(uid)
        
        if trc_balance < 10:
            await q.answer(t.get("elc_min_convert", "‚ùå Minimum 10 ELC required for conversion"), show_alert=True)
            return
        
        text = t.get("wallet_convert_header", "üîÑ *Convert ELC to ELC*")
        text += f"\n\nüí∞ Your ELC Balance: {trc_balance:.2f} ELC"
        text += "\n\nüìä *Conversion Rate:* 1 ELC = 1 ELC"
        text += "\nüí∏ *Fee:* 0%"
        text += "\n\n*Select amount to convert:*"
        
        # Quick convert buttons
        amounts = [10, 50, 100, 500]
        buttons = []
        for amt in amounts:
            if trc_balance >= amt:
                buttons.append(InlineKeyboardButton(f"{amt} ELC Token", callback_data=f"wallet:deposit:{amt}"))
        
        keyboard_buttons = [buttons[i:i+2] for i in range(0, len(buttons), 2)]
        if trc_balance >= 10:
            keyboard_buttons.append([InlineKeyboardButton(f"üîÑ All ({trc_balance:.0f} ELC)", callback_data=f"wallet:deposit:{int(trc_balance)}")])
        keyboard_buttons.append([InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:buy_elc")])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard_buttons))
    
    elif action == "do_convert":
        # Execute ELC conversion
        amount = int(parts[2]) if len(parts) > 2 else 0
        
        if amount < 10:
            await q.answer(t.get("elc_min_convert", "‚ùå Minimum 10 ELC required for conversion"), show_alert=True)
            return
        
        trc_balance = await get_elc_balance(uid)
        if trc_balance < amount:
            await q.answer(t.get("payment_elc_insufficient", "‚ùå Insufficient ELC balance").split("\n")[0], show_alert=True)
            return
        
        # Deduct ELC
        success, msg = await pay_with_elc(uid, amount, f"Convert to ELC")
        
        if success:
            # Add ELC
            new_elc_balance = add_elc_balance(uid, amount, f"Converted from {amount} ELC")
            
            await q.edit_message_text(
                f"‚úÖ *Deposit Successful!*\n\n"
                f"ü™ô Added: {amount} ELC\n"
                f"üíé New ELC Balance: {new_elc_balance.get('available', 0):.2f} ELC",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:buy_elc")]
                ])
            )
        else:
            await q.edit_message_text(
                f"‚ùå Conversion failed: {msg}",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:buy_elc")]
                ])
            )
    
    elif action == "demo_elc":
        # Demo ELC deposit for testing
        new_balance = add_elc_balance(uid, 100, "Demo ELC deposit")
        
        await q.edit_message_text(
            f"‚úÖ *Demo ELC Credited!*\n\n"
            f"üíé +100 ELC added to your balance\n"
            f"üí∞ New Balance: {new_balance.get('available', 0):.2f} ELC",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:buy_elc")]
            ])
        )
    
    elif action == "buy_elc_usdt":
        # Buy ELC with USDT via OxaPay
        text = t.get("wallet_buy_elc_usdt", "üíµ *Buy ELC with USDT*")
        text += "\n\nüåê *Payment via OxaPay*"
        text += "\nüí∞ *Rate:* 1 USDT = 1 ELC"
        text += "\nüí∏ *Fee:* 0.5%"
        text += "\nüìç *Networks:* TRC20, BEP20, ERC20"
        text += "\n\nüí° *Select amount to buy:*"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üíµ 50 USDT ‚Üí 49.75 ELC", callback_data="wallet:buy_elc_amount:50")],
            [InlineKeyboardButton("üíµ 100 USDT ‚Üí 99.5 ELC", callback_data="wallet:buy_elc_amount:100")],
            [InlineKeyboardButton("üíµ 200 USDT ‚Üí 199 ELC", callback_data="wallet:buy_elc_amount:200")],
            [InlineKeyboardButton("üíµ 500 USDT ‚Üí 497.5 ELC", callback_data="wallet:buy_elc_amount:500")],
            [InlineKeyboardButton("‚úèÔ∏è Custom Amount", callback_data="wallet:buy_elc_custom")],
            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:buy_elc")]
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "buy_elc_amount":
        # Create OxaPay payment for ELC purchase
        usdt_amount = int(parts[2]) if len(parts) > 2 else 100
        elc_amount = usdt_amount * 0.995  # 0.5% fee
        
        await q.edit_message_text("‚è≥ Creating payment invoice...", parse_mode="Markdown")
        
        try:
            from services.oxapay_service import oxapay_service
            
            # Create payment via OxaPay for ELC purchase
            invoice = await oxapay_service.create_elc_purchase(
                user_id=uid,
                usdt_amount=usdt_amount
            )
            
            if not invoice:
                raise Exception("Failed to create payment invoice")
            
            address = invoice.get("address", "")
            payment_id = invoice.get("payment_id", "")
            pay_url = invoice.get("pay_url", "")
            
            text = f"üíµ *Buy {elc_amount:.2f} ELC*\n\n"
            text += f"üí∞ *Amount:* {usdt_amount} USDT\n"
            text += f"ü™ô *You receive:* {elc_amount:.2f} ELC\n"
            text += f"üìç *Network:* TRC20\n\n"
            
            if address:
                text += f"üìã *Send exactly {usdt_amount} USDT to:*\n"
                text += f"`{address}`\n\n"
            
            text += f"üÜî Payment ID: `{payment_id}`\n"
            text += f"‚è≥ Expires in 30 minutes\n\n"
            text += "‚úÖ ELC will be credited automatically after confirmation!"
            
            keyboard_buttons = []
            if pay_url:
                keyboard_buttons.append([InlineKeyboardButton("üîó Open Payment Page", url=pay_url)])
            keyboard_buttons.extend([
                [InlineKeyboardButton("üîÑ Check Status", callback_data=f"wallet:check_elc_payment:{payment_id}")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:buy_elc_usdt")]
            ])
            
            await q.edit_message_text(text, parse_mode="Markdown", reply_markup=InlineKeyboardMarkup(keyboard_buttons))
            
        except Exception as e:
            logger.error(f"ELC purchase error: {e}")
            await q.edit_message_text(
                f"‚ùå Failed to create payment: {e}",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:buy_elc_usdt")]
                ])
            )
    
    elif action == "buy_elc_custom":
        # Custom amount input
        ctx.user_data["mode"] = "buy_elc_custom"
        await q.edit_message_text(
            "üíµ *Enter USDT amount to buy ELC*\n\n"
            "Send the amount in USDT (minimum 10):\n"
            "Example: `100`",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get("btn_cancel", "‚ùå Cancel"), callback_data="wallet:buy_elc_usdt")]
            ])
        )
    
    elif action == "check_elc_payment":
        # Check ELC purchase payment status
        payment_id = parts[2] if len(parts) > 2 else ""
        
        await q.answer("‚è≥ Checking payment status...")
        
        try:
            from services.oxapay_service import oxapay_service
            result = await oxapay_service.check_payment_status(payment_id)
            status = result.get("status", "unknown").lower()
            
            if status == "confirmed":
                await q.edit_message_text(
                    "‚úÖ *Payment Confirmed!*\n\n"
                    "Your ELC has been credited to your wallet.\n"
                    "Check your balance with /wallet",
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üíº My Wallet", callback_data="wallet:refresh")]
                    ])
                )
            elif status == "confirming":
                await q.answer("‚è≥ Payment detected, waiting for confirmations...", show_alert=True)
            elif status == "expired":
                await q.edit_message_text(
                    "‚ùå Payment expired. Please create a new payment.",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:buy_elc_usdt")]
                    ])
                )
            else:
                await q.answer(f"‚è≥ Status: {status}. Please complete the transfer.", show_alert=True)
                
        except Exception as e:
            logger.error(f"Check ELC payment error: {e}")
            await q.answer(f"Error: {e}", show_alert=True)
    
    elif action == "withdraw":
        balance = await get_elc_balance(uid)
        
        text = t.get("wallet_withdraw_header", "üí∏ *Withdraw ELC*")
        text += f"\n\nüí∞ Available: {balance:.2f} ELC"
        text += "\n\nüìù Withdrawal converts ELC to USDT 1:1"
        text += "\n‚Ä¢ Minimum: 10 ELC"
        text += "\n‚Ä¢ Fee: 0%"
        text += "\n‚Ä¢ Processing: Instant"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üí∏ Withdraw to USDT", callback_data="wallet:withdraw_usdt")],
            [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:refresh")],
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "withdraw_usdt":
        # Withdrawal flow
        balance = await get_elc_balance(uid)
        
        if balance < 10:
            await q.answer("‚ùå Minimum withdrawal: 10 ELC", show_alert=True)
            return
        
        text = "üí∏ *Withdraw ELC to USDT*\n\n"
        text += f"üí∞ *Available:* {balance:.2f} ELC\n"
        text += "üí± *Rate:* 1 ELC = 1 USDT\n"
        text += "üí∏ *Fee:* 2%\n\n"
        text += "üìß *Contact support* to process withdrawal:\n"
        text += "@EnlikoSupport\n\n"
        text += "_Minimum: 10 ELC_"
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üìß Contact Support", url="https://t.me/EnlikoSupport")],
                [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="wallet:withdraw")]
            ])
        )
    
    elif action == "stake":
        wallet = await get_elc_wallet(uid)
        balance_info = await blockchain.get_total_balance(uid)
        
        text = t.get("wallet_stake_header", "üìä *ELC Staking*")
        text += "\n\nüî• *Earn 12% APY on your ELC!*"
        text += f"\n\nüí∞ Available to stake: {balance_info['available']:.2f} ELC"
        text += f"\nüîí Currently staked: {balance_info['staked']:.2f} ELC"
        text += f"\nüéÅ Pending rewards: {balance_info['pending_rewards']:.2f} ELC"
        text += "\n\n‚Ä¢ No lock period"
        text += "\n‚Ä¢ Instant unstaking"
        text += "\n‚Ä¢ Daily reward distribution"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üîí Stake All", callback_data="wallet:stake_all")],
            [InlineKeyboardButton("üîì Unstake All", callback_data="wallet:unstake_all")],
            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:refresh")],
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "stake_all":
        balance = await get_elc_balance(uid)
        if balance < 1:
            await q.answer(t.get("elc_min_stake", "‚ùå Minimum 1 ELC required for staking"), show_alert=True)
            return
        
        success, tx, message = await blockchain.stake(uid, balance)
        if success:
            await q.answer(f"‚úÖ Staked {balance:.2f} ELC successfully!", show_alert=True)
            # Refresh stake view
            await on_wallet_cb(update, ctx)
        else:
            await q.answer(f"‚ùå Staking failed: {message}", show_alert=True)
    
    elif action == "unstake_all":
        wallet = await get_elc_wallet(uid)
        if wallet.staked_balance < 1:
            await q.answer("‚ùå No staked ELC to unstake", show_alert=True)
            return
        
        success, tx, message = await blockchain.unstake(uid, wallet.staked_balance)
        if success:
            await q.answer(f"‚úÖ Unstaked {wallet.staked_balance:.2f} ELC successfully!", show_alert=True)
            # Refresh stake view
            await on_wallet_cb(update, ctx)
        else:
            await q.answer(f"‚ùå Unstaking failed: {message}", show_alert=True)
    
    elif action == "history":
        transactions = await blockchain.get_transaction_history(uid, limit=20)
        wallet = await get_elc_wallet(uid)
        
        text = t.get("wallet_history_header", "üìú *Transaction History*")
        text += f"\n\nüìç Wallet: `{wallet.address[:20]}...`"
        
        if not transactions:
            text += "\n\nNo transactions yet."
        else:
            for tx in transactions:
                icon = "üì•" if tx.to_address == wallet.address else "üì§"
                status_icon = "‚úÖ" if tx.status.value == "confirmed" else "‚è≥"
                date_str = tx.timestamp.strftime("%m/%d %H:%M")
                text += f"\n\n{icon} *{tx.tx_type.value.upper()}*"
                text += f"\n   Amount: {tx.amount:.2f} ELC"
                text += f"\n   {date_str} {status_icon}"
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="wallet:refresh")]
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)


@require_access
@with_texts
async def cmd_subscribe(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show subscription menu."""
    uid = update.effective_user.id
    t = ctx.t
    
    license_info = get_user_license(uid)
    
    header = t.get("subscribe_menu_header", "üíé *Subscription Plans*")
    info = t.get("subscribe_menu_info", "Choose your plan to unlock trading features:")
    
    # Show current license status if any
    if license_info["is_active"]:
        import datetime
        expires_dt = datetime.datetime.fromtimestamp(license_info["expires"])
        status = f"\n\n‚úÖ Current: {license_info['license_type'].title()} (expires {expires_dt.strftime('%Y-%m-%d')})"
    else:
        status = ""
    
    await update.message.reply_text(
        f"{header}\n\n{info}{status}",
        parse_mode="Markdown",
        reply_markup=get_subscribe_menu_keyboard(t)
    )


@with_texts
async def on_subscribe_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle subscription menu callbacks."""
    q = update.callback_query
    await q.answer()
    
    uid = update.effective_user.id
    t = ctx.t
    data = q.data  # sub:xxx:yyy
    
    parts = data.split(":")
    action = parts[1] if len(parts) > 1 else ""
    
    if action == "menu":
        # Back to main subscription menu
        await q.edit_message_text(
            f"{t.get('subscribe_menu_header', 'üíé *Subscription Plans*')}\n\n{t.get('subscribe_menu_info', 'Choose your plan:')}",
            parse_mode="Markdown",
            reply_markup=get_subscribe_menu_keyboard(t)
        )
    
    elif action == "plan":
        plan = parts[2] if len(parts) > 2 else ""
        
        if plan == "premium":
            await q.edit_message_text(
                f"{t.get('premium_title', 'üíé *PREMIUM PLAN*')}\n\n{t.get('premium_desc', 'Full access to all features')}",
                parse_mode="Markdown",
                reply_markup=get_premium_period_keyboard(t)
            )
        
        elif plan == "basic":
            await q.edit_message_text(
                f"{t.get('basic_title', 'ü•à *BASIC PLAN*')}\n\n{t.get('basic_desc', 'Demo + limited real trading')}",
                parse_mode="Markdown",
                reply_markup=get_basic_period_keyboard(t)
            )
        
        elif plan == "trial":
            # Check if user already used trial
            license_history = get_license_history(uid)
            used_trial = any(l["license_type"] == "trial" for l in license_history)
            
            if used_trial:
                await q.edit_message_text(
                    t.get("trial_already_used", "‚ö†Ô∏è You have already used your free trial."),
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                    ])
                )
            else:
                await q.edit_message_text(
                    f"{t.get('trial_title', 'üéÅ *TRIAL PLAN*')}\n\n{t.get('trial_desc', 'Free demo access for 7 days')}",
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get("trial_activate", "üéÅ Activate Free Trial"), callback_data="sub:activate:trial")],
                        [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                    ])
                )
    
    elif action == "activate":
        plan = parts[2] if len(parts) > 2 else ""
        if plan == "trial":
            # Check again for trial usage
            license_history = get_license_history(uid)
            used_trial = any(l["license_type"] == "trial" for l in license_history)
            
            if used_trial:
                await q.edit_message_text(
                    t.get("trial_already_used", "‚ö†Ô∏è You have already used your free trial."),
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                    ])
                )
            else:
                # Activate trial
                result = set_user_license(
                    user_id=uid,
                    license_type="trial",
                    period_months=1,  # Will be 7 days
                    payment_type="trial",
                    amount=0,
                    currency="FREE",
                    notes="Free trial activation"
                )
                
                if result.get("success"):
                    await q.edit_message_text(
                        t.get("trial_activated", "üéâ Trial activated! You have 7 days of full demo access."),
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                        ])
                    )
                else:
                    await q.edit_message_text(
                        t.get("payment_failed", "‚ùå Payment failed: {error}").format(error=result.get("error", "Unknown")),
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                        ])
                    )
    
    elif action == "period":
        # User selected period, show payment options
        plan = parts[2] if len(parts) > 2 else ""
        duration = parts[3] if len(parts) > 3 else "1m"
        
        from services.oxapay_service import LICENSE_PRICES_USD
        prices = LICENSE_PRICES_USD.get(plan, {})
        usd_price = prices.get(duration, 0)
        
        duration_text = {
            "1m": "1 month", "3m": "3 months", "6m": "6 months", "1y": "1 year"
        }.get(duration, duration)
        
        # Get user's ELC balance
        user_balance = await get_elc_balance(uid)
        
        text = t.get("payment_select_method_new", "üí≥ *Select Payment Method*")
        text += f"\n\nüì¶ *Plan:* {plan.title()}\n‚è∞ *Duration:* {duration_text}"
        text += f"\nüí∞ *Price:* ${usd_price:.0f}"
        text += f"\n\nü™ô *Your ELC Balance:* {user_balance:.2f} ELC"
        
        if user_balance >= usd_price:
            text += "\n\n‚úÖ You can pay with ELC tokens!"
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=get_payment_method_keyboard(t, plan, duration)
        )
    
    elif action == "elc":
        # ELC Token payment flow - simplified
        plan = parts[2] if len(parts) > 2 else ""
        duration = parts[3] if len(parts) > 3 else "1m"
        
        from services.oxapay_service import LICENSE_PRICES_USD
        prices = LICENSE_PRICES_USD.get(plan, {})
        usd_price = prices.get(duration, 0)
        
        duration_text = {
            "1m": "1 month", "3m": "3 months", "6m": "6 months", "1y": "1 year"
        }.get(duration, duration)
        
        # Map duration to months for license
        duration_to_months = {"1m": 1, "3m": 3, "6m": 6, "1y": 12}
        period_months = duration_to_months.get(duration, 1)
        
        # Check ELC balance
        user_balance = await get_elc_balance(uid)
        
        if user_balance < usd_price:
            needed = usd_price - user_balance
            await q.edit_message_text(
                t.get("payment_insufficient_elc", "‚ùå *Insufficient ELC Balance*\n\nYou need {needed:.2f} more ELC.\n\nYour balance: {balance:.2f} ELC\nRequired: {price:.0f} ELC\n\nüí° Pay with crypto instead or buy ELC tokens.").format(
                    needed=needed, balance=user_balance, price=usd_price
                ),
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üí≥ Pay with Crypto", callback_data=f"sub:crypto:{plan}:{duration}")],
                    [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data=f"sub:period:{plan}:{duration}")]
                ])
            )
            return
        
        # Process ELC payment
        description = f"{plan.title()} License ({duration_text})"
        success, message = await pay_with_elc(uid, usd_price, description)
        
        if success:
            # Activate license
            result = set_user_license(
                user_id=uid,
                license_type=plan,
                period_months=period_months,
                payment_type="ELC",
                amount=usd_price,
                currency="ELC",
                notes=f"Paid with ELC tokens. {message}"
            )
            
            if result.get("success"):
                new_balance = await get_elc_balance(uid)
                await q.edit_message_text(
                    t.get("payment_success_elc", "‚úÖ *Payment Successful!*\n\nü™ô Paid: {amount:.0f} ELC\nüì¶ Plan: {plan}\n‚è∞ Duration: {duration}\n\nüí∞ New Balance: {balance:.2f} ELC\n\nThank you for using Enliko! üöÄ").format(
                        amount=usd_price, plan=plan.title(), duration=duration_text, balance=new_balance
                    ),
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="sub:menu")]
                    ])
                )
                
                # Notify admin
                try:
                    username = update.effective_user.username or ""
                    await notify_admin_payment(ctx.bot, uid, username, plan, period_months, usd_price, "ELC", "Confirmed")
                except Exception as e:
                    logger.debug(f"Failed to notify admin: {e}")
            else:
                # Payment went through but license activation failed - refund
                await reward_elc(uid, usd_price, "License activation failed - refund")
                await q.edit_message_text(
                    t.get("payment_failed", "‚ùå Payment failed: {error}").format(error=result.get("error", "Unknown")),
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data="sub:menu")]
                    ])
                )
        else:
            await q.edit_message_text(
                t.get("payment_failed", "‚ùå Payment failed: {error}").format(error=message),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "¬´ Back"), callback_data=f"sub:period:{plan}:{duration}")]
                ])
            )
    
    elif action == "elc_confirm":
        # Execute blockchain payment
        plan = parts[2] if len(parts) > 2 else ""
        period = int(parts[3]) if len(parts) > 3 else 1
        period_text = f"{period} month{'s' if period > 1 else ''}"
        
        t = get_texts(uid)
        await q.edit_message_text(t.get("processing_blockchain", "‚è≥ Processing blockchain transaction..."), parse_mode="Markdown")
        
        # Call blockchain service
        result = purchase_license_with_elc(
            user_id=uid,
            license_type=plan,
            months=period,
            wallet_address=None,  # Will use default ELCARO_{uid}
            mint_nft=True
        )
        
        if result.get("success"):
            # Success - show details
            tx_hash = result.get("tx_hash", "")[:16] + "..."
            nft_tier = result.get("nft_tier", "").title() if result.get("nft_tier") else "N/A"
            valid_until = result.get("valid_until_str", "")
            new_balance = result.get("new_elc_balance", 0)
            discount = result.get("discount_applied", 0)
            
            discount_text = f"\nüíé Discount applied: {discount:.0f}%" if discount > 0 else ""
            nft_text = f"\nüé® NFT Tier: {nft_tier}" if result.get("nft_token_id") else ""
            
            # Notify admin
            try:
                await q.get_bot().send_message(
                    ADMIN_ID,
                    f"üîó *Blockchain License Purchase*\n\n"
                    f"üë§ User: `{uid}`\n"
                    f"üì¶ Plan: {plan.title()}\n"
                    f"‚è∞ Period: {period_text}\n"
                    f"üí∞ Amount: {result.get('amount_paid', 0):.0f} ELC\n"
                    f"üîó TX: `{result.get('tx_hash', '')}`\n"
                    f"üé® NFT: {result.get('nft_token_id', 'None')}",
                    parse_mode="Markdown"
                )
            except Exception as e:
                logger.debug(f"Failed to notify admin about blockchain purchase: {e}")
            
            await q.edit_message_text(
                t.get("payment_success_blockchain",
                    "‚úÖ *Blockchain Payment Successful!*\n\n"
                    "üíé Paid: {amount:.0f} ELC\n"
                    "üì¶ Plan: {plan}\n"
                    "‚è∞ Valid Until: {valid_until}{discount}{nft}\n\n"
                    "üîó TX: `{tx_hash}`\n"
                    "üí∞ New Balance: {balance:.2f} ELC\n\n"
                    "Your license is now recorded on the blockchain! üéâ"
                ).format(
                    amount=result.get("amount_paid", 0),
                    plan=plan.title(),
                    valid_until=valid_until,
                    discount=discount_text,
                    nft=nft_text,
                    tx_hash=tx_hash,
                    balance=new_balance
                ),
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîó View Blockchain Records", callback_data="sub:my_blockchain")],
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                ])
            )
        else:
            # Payment failed
            error_msg = result.get("message", result.get("error", "Unknown error"))
            duration_str = "1y" if period == 12 else f"{period}m"
            await q.edit_message_text(
                t.get("payment_failed", "‚ùå Payment failed: {error}").format(error=error_msg),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data=f"sub:period:{plan}:{duration_str}")]
                ])
            )
    
    elif action == "ton":
        # TON blockchain payment flow (USDT Jetton on TON)
        plan = parts[2] if len(parts) > 2 else ""
        period = int(parts[3]) if len(parts) > 3 else 1
        period_text = f"{period} month{'s' if period > 1 else ''}"
        
        # Get price
        prices = LICENSE_PRICES.get(plan, {})
        elc_price = prices.get("elc", {}).get(period, 0)
        usdt_amount = elc_price  # 1:1 ELC = USD
        
        # Generate payment ID
        payment_id = f"TON-{uid}-{plan}_{period}m-{int(time.time())}"
        
        # Platform wallet address from environment
        use_testnet = os.getenv("TON_USE_TESTNET", "true").lower() == "true"
        if use_testnet:
            platform_wallet = os.getenv("TON_TESTNET_WALLET", "")
        else:
            platform_wallet = os.getenv("TON_MAINNET_WALLET", "")
        
        if not platform_wallet:
            await q.edit_message_text(
                "‚ùå TON payment not configured. Please contact support.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                ])
            )
            return
        
        # Create payment links
        ton_link = f"ton://transfer/{platform_wallet}?text={payment_id}"
        tonkeeper_link = f"https://app.tonkeeper.com/transfer/{platform_wallet}?text={payment_id}"
        
        # Save pending payment in DB
        try:
            from core.db_postgres import get_conn
            with get_conn() as conn:
                cur = conn.cursor()
                cur.execute("""
                    INSERT INTO ton_payments (user_id, payment_id, plan_id, amount_usdt, platform_wallet, expires_at)
                    VALUES (%s, %s, %s, %s, %s, NOW() + INTERVAL '1 hour')
                    ON CONFLICT (payment_id) DO NOTHING
                """, (uid, payment_id, f"{plan}_{period}m", usdt_amount, platform_wallet))
                conn.commit()
        except Exception as e:
            logger.error(f"Failed to save TON payment: {e}")
        
        text = t.get("ton_payment_instructions",
            "üíé *Pay with TON/USDT*\n\n"
            "üì¶ *Plan:* {plan}\n"
            "‚è∞ *Period:* {period}\n"
            "üí∞ *Price:* ${amount:.0f} USDT\n\n"
            "üìã *Instructions:*\n"
            "1Ô∏è‚É£ Open Tonkeeper or any TON wallet\n"
            "2Ô∏è‚É£ Send exactly **${amount:.0f} USDT (jUSDT)** to:\n"
            "`{wallet}`\n\n"
            "3Ô∏è‚É£ Add this comment/memo:\n"
            "`{payment_id}`\n\n"
            "4Ô∏è‚É£ After payment, click 'Verify Payment'\n\n"
            "‚è≥ Payment expires in 1 hour"
        ).format(
            plan=plan.title(),
            period=period_text,
            amount=usdt_amount,
            wallet=platform_wallet,
            payment_id=payment_id
        )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üì± Open Tonkeeper", url=tonkeeper_link)],
            [InlineKeyboardButton("‚úÖ Verify Payment", callback_data=f"sub:ton_verify:{payment_id}")],
            [InlineKeyboardButton("üìã Copy Wallet", callback_data=f"sub:crypto_copy:{platform_wallet[:30]}")],
            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data=f"sub:period:{plan}:{period}m")]
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "ton_verify":
        # TON payments deprecated - redirect to OxaPay
        t = get_texts(uid)
        text = (
            "‚ö†Ô∏è *TON Payments Deprecated*\n\n"
            "We have migrated to OxaPay for all crypto payments.\n\n"
            "‚úÖ **Benefits:**\n"
            "‚Ä¢ 20+ cryptocurrencies supported\n"
            "‚Ä¢ USDT, BTC, ETH, SOL, TON and more\n"
            "‚Ä¢ Automatic payment confirmation\n"
            "‚Ä¢ Lower fees (0.5%)\n\n"
            "üëâ Use the new payment system below:"
        )
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üí≥ Pay with Crypto (OxaPay)", callback_data="sub:crypto:basic:1m")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
            ])
        )
    
    elif action == "my_blockchain":
        # Show user's blockchain license records
        records = get_user_blockchain_licenses(uid)
        nfts = get_user_license_nfts(uid)
        
        if not records and not nfts:
            text = "üîó *Your Blockchain Records*\n\n_No blockchain records found._\n\nüí° Purchase a license with ELC to get blockchain verification!"
        else:
            text = "üîó *Your Blockchain Records*\n\n"
            
            if records:
                text += "üìú *License Purchases:*\n"
                for r in records[:5]:
                    import datetime
                    valid = datetime.datetime.fromtimestamp(r.get('end_timestamp', 0)).strftime('%Y-%m-%d')
                    status = "‚úÖ" if r.get('end_timestamp', 0) > time.time() else "‚è∞"
                    text += f"{status} {r.get('license_type', '').title()} - {r.get('amount_paid', 0):.0f} ELC - Valid: {valid}\n"
                    text += f"   TX: `{r.get('tx_hash', '')[:20]}...`\n"
                text += "\n"
            
            if nfts:
                text += "üé® *License NFTs:*\n"
                for n in nfts[:5]:
                    text += f"‚Ä¢ {n.get('tier', '').title()} NFT - {n.get('license_type', '')}\n"
                    text += f"   Token: `{n.get('token_id', '')}`\n"
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÑ Refresh", callback_data="sub:my_blockchain")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
            ])
        )
    
    elif action == "request":
        # User wants to request a license (admin approval)
        text = t.get("license_request_header", "üì© *Request a License*")
        text += "\n\n" + t.get("license_request_info", 
            "Don't have enough tokens? Request a license for admin approval!\n\n"
            "Choose the plan you'd like to request:"
        )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üíé Premium 1 month", callback_data="sub:request_type:premium:1")],
            [InlineKeyboardButton("üíé Premium 3 months", callback_data="sub:request_type:premium:3")],
            [InlineKeyboardButton("ü•à Basic 1 month", callback_data="sub:request_type:basic:1")],
            [InlineKeyboardButton("ü•à Basic 3 months", callback_data="sub:request_type:basic:3")],
            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "request_type":
        # User selected a request type
        plan = parts[2] if len(parts) > 2 else "basic"
        period = int(parts[3]) if len(parts) > 3 else 1
        prices = LICENSE_PRICES.get(plan, {})
        elc_price = prices.get("elc", {}).get(period, 0)
        period_text = f"{period} month{'s' if period > 1 else ''}"
        
        # Check if user already has pending requests
        user_requests = get_user_license_requests(uid, status="pending")
        if user_requests:
            await q.edit_message_text(
                t.get("license_request_pending", 
                    "‚è≥ You already have a pending request.\n\n"
                    "Please wait for admin approval or contact support."
                ),
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                ])
            )
            return
        
        text = t.get("license_request_confirm", "üì© *Confirm License Request*")
        text += f"\n\nüì¶ *Plan:* {plan.title()}"
        text += f"\n‚è∞ *Period:* {period_text}"
        text += f"\nüí∞ *Value:* ~${elc_price:.0f}"
        text += "\n\n" + t.get("license_request_note",
            "‚ö†Ô∏è After submitting, an admin will review your request.\n"
            "You'll be notified once approved."
        )
        
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("‚úÖ Submit Request", callback_data=f"sub:submit_request:{plan}:{period}")],
            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:request")]
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "submit_request":
        # Submit the license request
        plan = parts[2] if len(parts) > 2 else "basic"
        period = int(parts[3]) if len(parts) > 3 else 1
        prices = LICENSE_PRICES.get(plan, {})
        elc_price = prices.get("elc", {}).get(period, 0)
        
        result = create_license_request(
            user_id=uid,
            license_type=plan,
            period_months=period,
            payment_method="admin_request",
            amount=elc_price,
            currency="ELC",
            notes=f"User requested via bot"
        )
        
        if result.get("success"):
            request_id = result.get("request_id")
            
            # Notify admin
            try:
                username = update.effective_user.username or "N/A"
                await q.get_bot().send_message(
                    ADMIN_ID,
                    f"üì© *New License Request*\n\n"
                    f"üë§ User: `{uid}` (@{username})\n"
                    f"üì¶ Plan: {plan.title()}\n"
                    f"‚è∞ Period: {period} month(s)\n"
                    f"üí∞ Value: ~${elc_price:.0f}\n"
                    f"üÜî Request ID: #{request_id}\n\n"
                    f"Use /admin ‚Üí Licenses ‚Üí Pending to review.",
                    parse_mode="Markdown"
                )
            except Exception as e:
                logger.debug(f"Failed to notify admin about license request: {e}")
            
            await q.edit_message_text(
                t.get("license_request_submitted",
                    "‚úÖ *Request Submitted!*\n\n"
                    "Your license request has been sent to admin for approval.\n"
                    "You'll receive a notification once it's processed.\n\n"
                    "üÜî Request ID: #{request_id}"
                ).format(request_id=request_id),
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                ])
            )
        else:
            await q.edit_message_text(
                t.get("license_request_failed", "‚ùå Request failed: {error}").format(error=result.get("error", "Unknown")),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                ])
            )
    
    elif action == "verify_ton":
        # TON payments deprecated - redirect to ELC
        await q.edit_message_text(
            t.get("payment_ton_not_configured", "‚ùå TON payments are deprecated. Use ELC tokens."),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get("wallet_btn_deposit", "üì• Deposit"), callback_data="wallet:deposit")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
            ])
        )
    
    elif action == "my":
        # Show user's subscription status
        try:
            license_info = get_user_license(uid)
            
            if license_info and license_info.get("is_active"):
                import datetime
                expires_ts = license_info.get("expires", 0)
                if expires_ts:
                    expires_dt = datetime.datetime.fromtimestamp(expires_ts)
                    expires_str = expires_dt.strftime("%Y-%m-%d")
                else:
                    expires_str = "N/A"
                plan_name = (license_info.get("license_type") or "unknown").title()
                days_left = license_info.get("days_left", 0)
                # Use HTML to avoid Markdown parsing issues with underscores
                text = f"üìã <b>Current Plan:</b> {plan_name}\n‚è∞ <b>Expires:</b> {expires_str}\nüìÖ <b>Days Left:</b> {days_left}"
            else:
                text = t.get("my_subscription_none", "‚ùå No active subscription.\n\nUse /subscribe to purchase a plan.")
            
            # Get payment history
            payments = get_user_payments(uid, limit=5)
            if payments:
                history_lines = []
                for p in payments:
                    import datetime
                    created_at = p.get("created_at", 0)
                    if created_at:
                        dt = datetime.datetime.fromtimestamp(created_at)
                        date_str = dt.strftime('%Y-%m-%d')
                    else:
                        date_str = "N/A"
                    license_type = (p.get('license_type') or 'unknown').title()
                    # Replace underscores to avoid Markdown issues
                    payment_type = (p.get('payment_type') or 'unknown').replace('_', ' ').title()
                    history_lines.append(f"‚Ä¢ {date_str}: {license_type} ({payment_type})")
                text += f"\n\nüìú <b>Payment History:</b>\n" + "\n".join(history_lines)
            
            await q.edit_message_text(
                text,
                parse_mode="HTML",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                ])
            )
        except Exception as e:
            logger.error(f"[{uid}] Error in my subscription: {e}")
            await q.edit_message_text(
                t.get("my_subscription_error", "‚ùå Error loading subscription info. Please try again."),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                ])
            )
    
    elif action == "promo":
        # Ask user to enter promo code
        ctx.user_data["mode"] = "enter_promo"
        await q.edit_message_text(
            t.get("promo_enter", "üéü Enter your promo code:"),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
            ])
        )
    
    elif action == "crypto":
        # Direct crypto payment via OxaPay - select currency
        plan = parts[2] if len(parts) > 2 else ""
        duration = parts[3] if len(parts) > 3 else "1m"
        
        from services.oxapay_service import LICENSE_PRICES_USD
        
        # Get price for selected plan/duration
        price_usd = LICENSE_PRICES_USD.get(plan, {}).get(duration, 0)
        if not price_usd:
            await q.answer(t.get("invalid_plan", "Invalid plan or duration"), show_alert=True)
            return
        
        duration_text = {
            "1m": "1 month", "3m": "3 months", "6m": "6 months", "1y": "1 year"
        }.get(duration, duration)
        
        text = t.get("crypto_select_currency",
            "üí≥ *Crypto Payment*\n\n"
            "üì¶ *Plan:* {plan}\n"
            "‚è∞ *Duration:* {duration}\n"
            "üí∞ *Price:* ${price:.2f} USD\n\n"
            "Select payment currency:"
        ).format(plan=plan.title(), duration=duration_text, price=price_usd)
        
        # Popular currencies for payment - network names match OxaPay API
        keyboard = InlineKeyboardMarkup([
            [
                InlineKeyboardButton("üíµ USDT (TRC20)", callback_data=f"sub:crypto_create:{plan}:{duration}:USDT:Tron"),
                InlineKeyboardButton("üíµ USDT (BEP20)", callback_data=f"sub:crypto_create:{plan}:{duration}:USDT:BSC"),
            ],
            [
                InlineKeyboardButton("üíµ USDT (TON)", callback_data=f"sub:crypto_create:{plan}:{duration}:USDT:The Open Network"),
                InlineKeyboardButton("üíµ USDT (ERC20)", callback_data=f"sub:crypto_create:{plan}:{duration}:USDT:Ethereum"),
            ],
            [
                InlineKeyboardButton("‚Çø Bitcoin", callback_data=f"sub:crypto_create:{plan}:{duration}:BTC:Bitcoin"),
                InlineKeyboardButton("Œû Ethereum", callback_data=f"sub:crypto_create:{plan}:{duration}:ETH:Ethereum"),
            ],
            [
                InlineKeyboardButton("üíé TON", callback_data=f"sub:crypto_create:{plan}:{duration}:TON:The Open Network"),
                InlineKeyboardButton("‚óé Solana", callback_data=f"sub:crypto_create:{plan}:{duration}:SOL:Solana"),
            ],
            [
                InlineKeyboardButton("üî∂ BNB", callback_data=f"sub:crypto_create:{plan}:{duration}:BNB:BSC"),
                InlineKeyboardButton("‚ö° TRX", callback_data=f"sub:crypto_create:{plan}:{duration}:TRX:Tron"),
            ],
            [
                InlineKeyboardButton("üêï DOGE", callback_data=f"sub:crypto_create:{plan}:{duration}:DOGE:Dogecoin"),
                InlineKeyboardButton("ü™ô LTC", callback_data=f"sub:crypto_create:{plan}:{duration}:LTC:Litecoin"),
            ],
            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data=f"sub:period:{plan}:{duration}")]
        ])
        
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
    
    elif action == "crypto_create":
        # Create OxaPay payment invoice
        plan = parts[2] if len(parts) > 2 else ""
        duration = parts[3] if len(parts) > 3 else "1m"
        currency = parts[4] if len(parts) > 4 else "USDT"
        network = parts[5] if len(parts) > 5 else "TRC20"
        
        await q.answer(t.get("creating_payment", "‚è≥ Creating payment invoice..."))
        
        try:
            from services.oxapay_service import oxapay_service
            
            # Create payment via OxaPay (returns dict)
            invoice = await oxapay_service.create_white_label_payment(
                user_id=uid,
                plan=plan,
                duration=duration,
                pay_currency=currency,
                network=network,
            )
            
            address = invoice.get("address") or invoice.get("pay_url")
            if not invoice or not address:
                await q.edit_message_text(
                    t.get("payment_creation_failed", "‚ùå Failed to create payment. Please try again."),
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton(t.get("btn_retry", "üîÑ Retry"), callback_data=f"sub:crypto:{plan}:{duration}")],
                        [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                    ])
                )
                return
            
            payment_id = invoice.get("payment_id") or invoice.get("track_id")
            amount_crypto = invoice.get("amount_crypto") or invoice.get("pay_amount")
            amount_usd = invoice.get("amount_usd", 0)
            
            # Format amount display
            if amount_crypto:
                amount_display = f"{float(amount_crypto):.8f}".rstrip('0').rstrip('.') + f" {currency}"
            else:
                amount_display = f"${amount_usd:.2f}"
            
            duration_text = {
                "1m": "1 month", "3m": "3 months", "6m": "6 months", "1y": "1 year"
            }.get(duration, duration)
            
            text = t.get("crypto_payment_invoice",
                "üí≥ *Crypto Payment Invoice*\n\n"
                "üì¶ *Plan:* {plan}\n"
                "‚è∞ *Duration:* {duration}\n"
                "üí∞ *Amount:* {amount}\n"
                "üîó *Network:* {network}\n\n"
                "üìã *Payment Address:*\n"
                "`{address}`\n\n"
                "‚è± *Expires in:* 60 minutes\n\n"
                "‚ö†Ô∏è Send exact amount to this address.\n"
                "After payment, click Check to verify.\n\n"
                "üö´ *All cryptocurrency payments are final and non-refundable.*"
            ).format(
                plan=plan.title(),
                duration=duration_text,
                amount=amount_display,
                network=network,
                address=address
            )
            
            keyboard = InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get("btn_check_payment", "‚úÖ Check Payment"), callback_data=f"sub:crypto_check:{payment_id}")],
                [InlineKeyboardButton(t.get("btn_copy_address", "üìã Copy Address"), callback_data=f"sub:crypto_copy:{address[:30]}")],
                [InlineKeyboardButton(t.get("btn_new_currency", "üîÑ Different Currency"), callback_data=f"sub:crypto:{plan}:{duration}")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
            ])
            
            # Try to send with QR code image
            qr_url = f"https://api.qrserver.com/v1/create-qr-code/?size=300x300&data={currency.lower()}:{address}?amount={amount_crypto or amount_usd}"
            
            try:
                # Delete old message and send photo with QR
                await q.message.delete()
                await ctx.bot.send_photo(
                    chat_id=uid,
                    photo=qr_url,
                    caption=text,
                    parse_mode="Markdown",
                    reply_markup=keyboard
                )
            except Exception as e:
                # Fallback to text only
                logger.warning(f"Failed to send QR photo: {e}")
                await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
                
        except Exception as e:
            logger.error(f"OxaPay payment creation error: {e}")
            await q.edit_message_text(
                t.get("payment_error", "‚ùå Payment service error. Please try again later.\n\nError: {error}").format(error=str(e)[:100]),
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_retry", "üîÑ Retry"), callback_data=f"sub:crypto:{plan}:{duration}")],
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                ])
            )
    
    elif action == "crypto_check":
        # Check OxaPay payment status
        payment_id = parts[2] if len(parts) > 2 else ""
        
        await q.answer(t.get("checking_payment", "Checking payment status..."))
        
        try:
            from services.oxapay_service import oxapay_service
            
            result = await oxapay_service.check_payment_status(payment_id)
            status = result.get("status", "unknown").lower()
            
            if status == "confirmed":
                try:
                    await q.edit_message_caption(
                        caption=t.get("crypto_payment_confirmed",
                            "‚úÖ *Payment Confirmed!*\n\n"
                            "Your subscription has been activated.\n"
                            "Thank you for using Enliko!"
                        ),
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                        ])
                    )
                except Exception:
                    await q.edit_message_text(
                        text=t.get("crypto_payment_confirmed",
                            "‚úÖ *Payment Confirmed!*\n\n"
                            "Your subscription has been activated.\n"
                            "Thank you for using Enliko!"
                        ),
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                        ])
                    )
            elif status == "confirming":
                await q.answer(t.get("crypto_payment_confirming", "‚è≥ Payment detected, waiting for confirmations..."), show_alert=True)
            elif status == "expired":
                try:
                    await q.edit_message_caption(
                        caption=t.get("crypto_payment_expired", "‚ùå Payment expired. Please create a new payment."),
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                        ])
                    )
                except Exception:
                    await q.edit_message_text(
                        text=t.get("crypto_payment_expired", "‚ùå Payment expired. Please create a new payment."),
                        parse_mode="Markdown",
                        reply_markup=InlineKeyboardMarkup([
                            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="sub:menu")]
                        ])
                    )
            else:
                await q.answer(t.get("crypto_payment_pending", "‚è≥ Payment not yet received. Please complete the transfer."), show_alert=True)
                
        except Exception as e:
            logger.error(f"Crypto payment check error: {e}")
            await q.answer(f"Error checking payment: {e}", show_alert=True)
    
    elif action == "crypto_copy":
        # Copy address to clipboard (just show alert)
        address = parts[2] if len(parts) > 2 else ""
        await q.answer(f"üìã {address}...", show_alert=True)


async def verify_ton_payment(wallet_address: str, memo: str, expected_amount: float) -> bool:
    """
    DEPRECATED: TON payments no longer supported.
    All payments now use ELC tokens via the blockchain module.
    """
    logger.warning("verify_ton_payment is deprecated. Use ELC payments instead.")
    return False


async def notify_admin_payment(bot, uid: int, username: str, plan: str, period: int, 
                                amount: float, currency: str, status: str, charge_id: str = None):
    """Send payment notification to admin with action buttons."""
    import datetime
    
    user_info = f"üë§ User: {uid}"
    if username:
        user_info += f" (@{username})"
    
    period_text = f"{period} month{'s' if period > 1 else ''}"
    
    text = f"üí≥ *Payment {status}*\n\n"
    text += f"{user_info}\n"
    text += f"üì¶ Plan: *{plan.title()}*\n"
    text += f"‚è∞ Period: *{period_text}*\n"
    text += f"üí∞ Amount: *{amount} {currency}*\n"
    text += f"üïê Time: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}"
    if charge_id:
        text += f"\nüßæ Charge ID: `{charge_id}`"
    
    # Admin action buttons
    buttons = [
        [
            InlineKeyboardButton("‚úÖ Confirm", callback_data=f"adm_pay:confirm:{uid}:{plan}:{period}"),
            InlineKeyboardButton("üîÑ Change Plan", callback_data=f"adm_pay:change:{uid}")
        ],
        [
            InlineKeyboardButton("‚è≥ Extend", callback_data=f"adm_pay:extend:{uid}"),
            InlineKeyboardButton("üö´ Revoke", callback_data=f"adm_pay:revoke:{uid}")
        ],
        [
            InlineKeyboardButton("üö´ Ban User", callback_data=f"adm_pay:ban:{uid}"),
            InlineKeyboardButton("üóë Delete User", callback_data=f"adm_pay:delete:{uid}")
        ],
        [InlineKeyboardButton("üë§ User Card", callback_data=f"admin:user_card:{uid}")]
    ]
    
    try:
        await bot.send_message(
            ADMIN_ID,
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
    except Exception as e:
        logger.error(f"Failed to notify admin about payment: {e}")


@with_texts
async def on_admin_payment_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle admin payment action callbacks."""
    q = update.callback_query
    await q.answer()
    
    admin_uid = update.effective_user.id
    if admin_uid != ADMIN_ID:
        return
    
    t = ctx.t
    data = q.data  # adm_pay:action:uid:...
    parts = data.split(":")
    action = parts[1] if len(parts) > 1 else ""
    target_uid = int(parts[2]) if len(parts) > 2 else 0
    
    if action == "confirm":
        # Already confirmed via automatic processing
        plan = parts[3] if len(parts) > 3 else "premium"
        period = int(parts[4]) if len(parts) > 4 else 1
        await q.edit_message_text(
            f"‚úÖ Payment for user {target_uid} already processed.\n\nPlan: {plan.title()}\nPeriod: {period} months"
        )
    
    elif action == "change":
        # Show plan selection for this user
        buttons = [
            [InlineKeyboardButton("üíé Premium 1m", callback_data=f"adm_pay:grant:{target_uid}:premium:1")],
            [InlineKeyboardButton("üíé Premium 3m", callback_data=f"adm_pay:grant:{target_uid}:premium:3")],
            [InlineKeyboardButton("üíé Premium 6m", callback_data=f"adm_pay:grant:{target_uid}:premium:6")],
            [InlineKeyboardButton("üíé Premium 12m", callback_data=f"adm_pay:grant:{target_uid}:premium:12")],
            [InlineKeyboardButton("ü•à Basic 1m", callback_data=f"adm_pay:grant:{target_uid}:basic:1")],
            [InlineKeyboardButton("üéÅ Trial", callback_data=f"adm_pay:grant:{target_uid}:trial:1")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Cancel", callback_data=f"admin:user_card:{target_uid}")]
        ]
        await q.edit_message_text(
            f"üîÑ *Change Plan for User {target_uid}*\n\nSelect new plan:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
    
    elif action == "grant":
        plan = parts[3] if len(parts) > 3 else "premium"
        period = int(parts[4]) if len(parts) > 4 else 1
        result = set_user_license(
            user_id=target_uid,
            license_type=plan,
            period_months=period,
            payment_type="admin_grant",
            amount=0,
            currency="FREE",
            admin_id=admin_uid,
            notes=f"Admin granted after payment review"
        )
        if result.get("success"):
            import datetime
            expires_dt = datetime.datetime.fromtimestamp(result["expires"])
            await q.edit_message_text(
                f"‚úÖ License granted to user {target_uid}!\n\nPlan: {plan.title()}\nExpires: {expires_dt.strftime('%Y-%m-%d')}"
            )
            # Notify user
            try:
                await ctx.bot.send_message(
                    target_uid,
                    f"üéâ Your {plan.title()} license has been activated!\n\nExpires: {expires_dt.strftime('%Y-%m-%d')}"
                )
            except Exception:
                pass
        else:
            await q.edit_message_text(f"‚ùå Failed to grant license: {result.get('error')}")
    
    elif action == "extend":
        buttons = [
            [InlineKeyboardButton("7 days", callback_data=f"adm_pay:do_extend:{target_uid}:7")],
            [InlineKeyboardButton("14 days", callback_data=f"adm_pay:do_extend:{target_uid}:14")],
            [InlineKeyboardButton("30 days", callback_data=f"adm_pay:do_extend:{target_uid}:30")],
            [InlineKeyboardButton("90 days", callback_data=f"adm_pay:do_extend:{target_uid}:90")],
            [InlineKeyboardButton("‚¨ÖÔ∏è Cancel", callback_data=f"admin:user_card:{target_uid}")]
        ]
        await q.edit_message_text(
            f"‚è≥ *Extend License for User {target_uid}*\n\nSelect days to add:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
    
    elif action == "do_extend":
        days = int(parts[3]) if len(parts) > 3 else 30
        result = extend_license(target_uid, days, admin_id=admin_uid)
        if result.get("success"):
            await q.edit_message_text(f"‚úÖ License extended by {days} days for user {target_uid}!")
        else:
            await q.edit_message_text(f"‚ùå Failed to extend: {result.get('error')}")
    
    elif action == "revoke":
        result = revoke_license(target_uid, admin_id=admin_uid)
        if result.get("success"):
            await q.edit_message_text(f"‚úÖ License revoked for user {target_uid}!")
        else:
            await q.edit_message_text(f"‚ùå Failed to revoke: {result.get('error')}")
    
    elif action == "ban":
        set_user_field(target_uid, "is_banned", 1)
        await q.edit_message_text(f"üö´ User {target_uid} has been banned!")
    
    elif action == "delete":
        buttons = [
            [InlineKeyboardButton("‚úÖ Yes, Delete", callback_data=f"adm_pay:do_delete:{target_uid}")],
            [InlineKeyboardButton("‚ùå Cancel", callback_data=f"admin:user_card:{target_uid}")]
        ]
        await q.edit_message_text(
            f"‚ö†Ô∏è *Confirm deletion of user {target_uid}*\n\nThis action cannot be undone!",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(buttons)
        )
    
    elif action == "do_delete":
        try:
            delete_user(target_uid)
            await q.edit_message_text(f"üóë User {target_uid} has been deleted!")
        except Exception as e:
            await q.edit_message_text(f"‚ùå Failed to delete user: {e}")


@with_texts
async def on_pre_checkout_query(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle pre-checkout query for Telegram Stars payments."""
    query = update.pre_checkout_query
    # Always approve - Telegram handles the actual payment
    await query.answer(ok=True)


@with_texts
async def on_successful_payment(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle successful Telegram Stars payment."""
    uid = update.effective_user.id
    t = ctx.t
    username = update.effective_user.username or ""
    
    payment = update.message.successful_payment
    payload = payment.invoice_payload  # "license:premium:1"
    charge_id = payment.telegram_payment_charge_id
    
    parts = payload.split(":")
    if parts[0] == "license" and len(parts) >= 3:
        plan = parts[1]
        period = int(parts[2])
        
        # Grant license
        result = set_user_license(
            user_id=uid,
            license_type=plan,
            period_months=period,
            payment_type="stars",
            amount=payment.total_amount,
            currency="XTR",
            telegram_charge_id=charge_id,
        )
        
        if result.get("success"):
            import datetime
            expires_dt = datetime.datetime.fromtimestamp(result["expires"])
            await update.message.reply_text(
                t.get("payment_success", "üéâ Payment successful!\n\n{plan} activated until {expires}.").format(
                    plan=plan.title(),
                    expires=expires_dt.strftime("%Y-%m-%d")
                )
            )
            # Notify admin about successful payment
            await notify_admin_payment(
                ctx.bot, uid, username, plan, period,
                payment.total_amount, "‚≠ê Stars", "‚úÖ SUCCESSFUL", charge_id
            )
        else:
            await update.message.reply_text(
                t.get("payment_failed", "‚ùå Payment failed: {error}").format(error=result.get("error", "Unknown"))
            )
            # Notify admin about failed payment
            await notify_admin_payment(
                ctx.bot, uid, username, plan, period,
                payment.total_amount, "‚≠ê Stars", "‚ùå FAILED", charge_id
            )


# =====================================================
# ADMIN LICENSE MANAGEMENT
# =====================================================

def get_admin_license_keyboard(t: dict) -> InlineKeyboardMarkup:
    """Admin license management keyboard with blockchain."""
    # Get pending requests count
    stats = get_license_request_stats()
    pending_count = stats.get("pending", 0)
    pending_label = f"üîî Pending ({pending_count})" if pending_count > 0 else "üì¨ Pending"
    
    # Get blockchain stats
    bc_stats = get_blockchain_license_stats()
    nft_count = bc_stats.get("total_nfts", 0)
    
    return InlineKeyboardMarkup([
        [InlineKeyboardButton(pending_label, callback_data="adm_lic:pending")],
        [InlineKeyboardButton(t.get("admin_users_management", "üë• Users"), callback_data="admin:users_menu")],
        [InlineKeyboardButton(t.get("admin_btn_grant_license", "üéÅ Grant License"), callback_data="adm_lic:grant")],
        [InlineKeyboardButton(t.get("admin_btn_view_licenses", "üìã View Licenses"), callback_data="adm_lic:list")],
        [
            InlineKeyboardButton(f"üîó Blockchain ({bc_stats.get('total_licenses', 0)})", callback_data="adm_lic:blockchain"),
            InlineKeyboardButton(f"üé® NFTs ({nft_count})", callback_data="adm_lic:nfts")
        ],
        [InlineKeyboardButton(t.get("admin_btn_create_promo", "üéü Promo"), callback_data="adm_lic:promo_create"),
         InlineKeyboardButton(t.get("admin_btn_view_promos", "üìã Promos"), callback_data="adm_lic:promo_list")],
        [InlineKeyboardButton(t.get("admin_btn_expiring_soon", "‚ö†Ô∏è Expiring Soon"), callback_data="adm_lic:expiring")],
        [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="admin:menu")],
    ])


@with_texts
async def on_admin_license_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle admin license management callbacks."""
    q = update.callback_query
    await q.answer()
    
    uid = update.effective_user.id
    if uid != ADMIN_ID:
        return
    
    t = ctx.t
    data = q.data  # adm_lic:xxx
    parts = data.split(":")
    action = parts[1] if len(parts) > 1 else ""
    
    if action == "menu":
        await q.edit_message_text(
            t.get("admin_license_menu", "üîë *License Management*"),
            parse_mode="Markdown",
            reply_markup=get_admin_license_keyboard(t)
        )
    
    elif action == "blockchain":
        # Show blockchain license statistics
        stats = get_blockchain_license_stats()
        
        text = "üîó *Blockchain License Statistics*\n\n"
        text += f"üìä *Overview:*\n"
        text += f"‚îú Total Licenses: *{stats.get('total_licenses', 0)}*\n"
        text += f"‚îú Unique Users: *{stats.get('unique_users', 0)}*\n"
        text += f"‚îú Active Licenses: *{stats.get('active_licenses', 0)}*\n"
        text += f"‚îî Total Revenue: *{stats.get('total_revenue_elc', 0):.0f} ELC*\n\n"
        
        text += f"üé® *NFT Breakdown:*\n"
        nft = stats.get("nft_breakdown", {})
        text += f"‚îú üíé Diamond: {nft.get('diamond', 0)}\n"
        text += f"‚îú üèÜ Platinum: {nft.get('platinum', 0)}\n"
        text += f"‚îú ü•á Gold: {nft.get('gold', 0)}\n"
        text += f"‚îú ü•à Silver: {nft.get('silver', 0)}\n"
        text += f"‚îî ü•â Bronze: {nft.get('bronze', 0)}\n"
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üé® Mint NFT", callback_data="adm_lic:mint_nft")],
                [InlineKeyboardButton("üìú View All Records", callback_data="adm_lic:bc_records")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:menu")]
            ])
        )
    
    elif action == "bc_records":
        # Show recent blockchain records
        from core.db_postgres import execute
        records = execute("""
            SELECT * FROM license_blockchain_records
            ORDER BY created_at DESC LIMIT 15
        """)
        
        if not records:
            text = "üìú *Blockchain Records*\n\n_No records found._"
        else:
            text = "üìú *Recent Blockchain Records*\n\n"
            for r in records:
                import datetime
                dt = datetime.datetime.fromtimestamp(r.get('created_at', 0)).strftime('%m-%d %H:%M')
                status = "‚úÖ" if r.get('end_timestamp', 0) > time.time() else "‚è∞"
                text += f"{status} `{r.get('user_id')}` | {r.get('license_type', '')[:3]} | {r.get('amount_paid', 0):.0f} ELC | {dt}\n"
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîÑ Refresh", callback_data="adm_lic:bc_records")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:blockchain")]
            ])
        )
    
    elif action == "nfts":
        # Show all NFTs
        nfts = get_all_license_nfts(limit=20)
        
        if not nfts:
            text = "üé® *License NFTs*\n\n_No NFTs minted yet._"
        else:
            text = "üé® *License NFTs*\n\n"
            tier_icons = {"diamond": "üíé", "platinum": "üèÜ", "gold": "ü•á", "silver": "ü•à", "bronze": "ü•â"}
            for n in nfts:
                icon = tier_icons.get(n.get('tier', ''), "üé®")
                valid = "‚úÖ" if n.get('valid_until', 0) > time.time() else "‚è∞"
                text += f"{icon} `{n.get('token_id', '')[:8]}` | User {n.get('owner_id')} | {valid}\n"
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üé® Mint NFT", callback_data="adm_lic:mint_nft")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:menu")]
            ])
        )
    
    elif action == "mint_nft":
        # Show NFT minting options
        text = "üé® *Mint License NFT*\n\n"
        text += "Select NFT tier to mint:\n\n"
        text += "üíé *Diamond* - Lifetime/Special\n"
        text += "üèÜ *Platinum* - Enterprise tier\n"
        text += "ü•á *Gold* - Premium 6-12 months\n"
        text += "ü•à *Silver* - Premium 1-3 months\n"
        text += "ü•â *Bronze* - Basic tier\n"
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üíé Diamond", callback_data="adm_lic:mint_tier:diamond"),
                 InlineKeyboardButton("üèÜ Platinum", callback_data="adm_lic:mint_tier:platinum")],
                [InlineKeyboardButton("ü•á Gold", callback_data="adm_lic:mint_tier:gold"),
                 InlineKeyboardButton("ü•à Silver", callback_data="adm_lic:mint_tier:silver")],
                [InlineKeyboardButton("ü•â Bronze", callback_data="adm_lic:mint_tier:bronze")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:nfts")]
            ])
        )
    
    elif action == "mint_tier":
        # Store tier and ask for user ID
        tier = parts[2] if len(parts) > 2 else "bronze"
        ctx.user_data["admin_nft_tier"] = tier
        ctx.user_data["mode"] = "admin_mint_nft_user"
        
        tier_names = {"diamond": "üíé Diamond", "platinum": "üèÜ Platinum", "gold": "ü•á Gold", "silver": "ü•à Silver", "bronze": "ü•â Bronze"}
        
        await q.edit_message_text(
            f"üé® *Mint {tier_names.get(tier, tier)} NFT*\n\nEnter user ID to mint NFT for:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚ùå Cancel", callback_data="adm_lic:mint_nft")]
            ])
        )
    
    elif action == "do_mint":
        # Execute NFT minting
        target_uid = int(parts[2]) if len(parts) > 2 else 0
        tier = parts[3] if len(parts) > 3 else "bronze"
        
        result = admin_mint_license_nft(
            admin_id=uid,
            user_id=target_uid,
            tier=tier,
            valid_months=12
        )
        
        if result.get("success"):
            nft = result.get("nft", {})
            await q.edit_message_text(
                f"‚úÖ *NFT Minted Successfully!*\n\n"
                f"üé® Tier: {tier.title()}\n"
                f"üë§ User: `{target_uid}`\n"
                f"üÜî Token: `{nft.get('token_id', '')}`\n"
                f"üîó TX: `{result.get('tx_hash', '')[:20]}...`",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:nfts")]
                ])
            )
            
            # Notify user
            try:
                await q.get_bot().send_message(
                    target_uid,
                    f"üéâ *You received a License NFT!*\n\n"
                    f"üé® Tier: {tier.title()}\n"
                    f"üÜî Token: `{nft.get('token_id', '')}`\n\n"
                    f"This NFT represents your premium license on the blockchain!",
                    parse_mode="Markdown"
                )
            except Exception as e:
                logger.debug(f"Failed to notify user {target_uid} about NFT: {e}")
        else:
            await q.edit_message_text(
                f"‚ùå Minting failed: {result.get('error', 'Unknown')}",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:mint_nft")]
                ])
            )
    
    elif action == "grant":
        # Show license type selection
        await q.edit_message_text(
            t.get("admin_grant_select_type", "Select license type:"),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üíé Premium", callback_data="adm_lic:grant_type:premium")],
                [InlineKeyboardButton("ü•à Basic", callback_data="adm_lic:grant_type:basic")],
                [InlineKeyboardButton("üéÅ Trial", callback_data="adm_lic:grant_type:trial")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:menu")],
            ])
        )
    
    elif action == "grant_type":
        plan = parts[2] if len(parts) > 2 else "premium"
        ctx.user_data["admin_grant_type"] = plan
        
        # Show period selection
        if plan == "premium":
            keyboard = [
                [InlineKeyboardButton("1 Month", callback_data="adm_lic:grant_period:1")],
                [InlineKeyboardButton("3 Months", callback_data="adm_lic:grant_period:3")],
                [InlineKeyboardButton("6 Months", callback_data="adm_lic:grant_period:6")],
                [InlineKeyboardButton("12 Months", callback_data="adm_lic:grant_period:12")],
            ]
        else:
            keyboard = [
                [InlineKeyboardButton("1 Month", callback_data="adm_lic:grant_period:1")],
            ]
        keyboard.append([InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:grant")])
        
        await q.edit_message_text(
            t.get("admin_grant_select_period", "Select period:"),
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    elif action == "grant_period":
        period = int(parts[2]) if len(parts) > 2 else 1
        ctx.user_data["admin_grant_period"] = period
        ctx.user_data["mode"] = "admin_grant_user"
        
        await q.edit_message_text(
            t.get("admin_grant_enter_user", "Enter user ID:"),
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:menu")]
            ])
        )
    
    elif action == "list":
        # Show all active licenses
        licenses = get_all_active_licenses()
        
        if not licenses:
            text = "No active licenses found."
        else:
            lines = []
            for lic in licenses[:20]:  # Limit to 20
                lines.append(f"‚Ä¢ User {lic['user_id']}: {lic['license_type'].title()} ({lic['days_left']}d left)")
            text = "üìã *Active Licenses:*\n\n" + "\n".join(lines)
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:menu")]
            ])
        )
    
    elif action == "expiring":
        # Show licenses expiring in 3 days
        expiring = get_expiring_licenses(days=3)
        
        if not expiring:
            text = "No licenses expiring soon."
        else:
            lines = []
            for lic in expiring:
                lines.append(f"‚Ä¢ User {lic['user_id']}: {lic['license_type'].title()} ({lic['days_left']}d left)")
            text = "‚ö†Ô∏è *Expiring Soon:*\n\n" + "\n".join(lines)
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:menu")]
            ])
        )
    
    elif action == "promo_create":
        ctx.user_data["mode"] = "admin_promo_create"
        await q.edit_message_text(
            "Enter promo code details:\n`CODE:TYPE:DAYS:MAX_USES`\n\nExample: `LAUNCH50:premium:30:100`",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:menu")]
            ])
        )
    
    elif action == "promo_list":
        promos = get_promo_codes(active_only=False)
        
        if not promos:
            text = "No promo codes found."
        else:
            lines = []
            for p in promos[:15]:
                status = "‚úÖ" if p["is_active"] else "‚ùå"
                lines.append(f"{status} `{p['code']}`: {p['license_type']} {p['period_days']}d ({p['current_uses']}/{p['max_uses'] or '‚àû'})")
            text = "üéü *Promo Codes:*\n\n" + "\n".join(lines)
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:menu")]
            ])
        )
    
    elif action == "pending":
        # Show pending license requests
        requests = get_pending_license_requests(limit=20)
        stats = get_license_request_stats()
        
        text = f"üì¨ *Pending License Requests*\n\n"
        text += f"üìä Stats: {stats['pending']} pending | {stats['approved']} approved | {stats['rejected']} rejected\n\n"
        
        if not requests:
            text += "_No pending requests._"
            keyboard = [[InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:menu")]]
        else:
            keyboard = []
            for req in requests[:10]:
                user_label = f"@{req['username']}" if req.get('username') else f"User {req['user_id']}"
                req_label = f"üîî {user_label}: {req['license_type'].title()} ({req['period_months']}m)"
                keyboard.append([InlineKeyboardButton(req_label, callback_data=f"adm_lic:req_view:{req['id']}")])
            keyboard.append([InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:menu")])
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    elif action == "req_view":
        # View a specific license request
        request_id = int(parts[2]) if len(parts) > 2 else 0
        request = get_license_request(request_id)
        
        if not request:
            await q.edit_message_text(
                "‚ùå Request not found.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:pending")]
                ])
            )
            return
        
        import datetime
        created_dt = datetime.datetime.fromtimestamp(request['created_at']).strftime("%Y-%m-%d %H:%M")
        user_label = f"@{request['username']}" if request.get('username') else f"ID: {request['user_id']}"
        
        text = f"üìã *License Request #{request_id}*\n\n"
        text += f"üë§ User: {user_label}\n"
        text += f"üì¶ Plan: *{request['license_type'].title()}*\n"
        text += f"‚è∞ Period: *{request['period_months']} month(s)*\n"
        text += f"üí∞ Amount: {request['amount']} {request['currency']}\n"
        text += f"üí≥ Payment: {request['payment_method']}\n"
        text += f"üìÖ Requested: {created_dt}\n"
        text += f"üìå Status: *{request['status'].upper()}*\n"
        if request.get('notes'):
            text += f"üìù Notes: {request['notes']}\n"
        
        keyboard = [
            [
                InlineKeyboardButton("‚úÖ Approve", callback_data=f"adm_lic:req_approve:{request_id}"),
                InlineKeyboardButton("‚ùå Reject", callback_data=f"adm_lic:req_reject:{request_id}")
            ],
            [InlineKeyboardButton("üë§ User Card", callback_data=f"admin:user:{request['user_id']}")],
            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data="adm_lic:pending")]
        ]
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    elif action == "req_approve":
        # Approve a license request
        request_id = int(parts[2]) if len(parts) > 2 else 0
        result = approve_license_request(request_id, admin_id=uid)
        
        if result.get("success"):
            request = result.get("request", {})
            await q.answer("‚úÖ License request approved!", show_alert=True)
            
            # Notify user
            try:
                import datetime
                expires_dt = datetime.datetime.fromtimestamp(result["license_info"]["expires"])
                await ctx.bot.send_message(
                    request["user_id"],
                    f"üéâ *Your license request has been approved!*\n\n"
                    f"üì¶ Plan: *{request['license_type'].title()}*\n"
                    f"üìÖ Expires: {expires_dt.strftime('%Y-%m-%d')}\n\n"
                    f"You can now use all features of your plan!",
                    parse_mode="Markdown"
                )
            except Exception as e:
                logger.warning(f"Failed to notify user about approval: {e}")
            
            # Go back to pending list
            q.data = "adm_lic:pending"
            await on_admin_license_cb(update, ctx)
        else:
            await q.answer(f"‚ùå Error: {result.get('error')}", show_alert=True)
    
    elif action == "req_reject":
        # Show rejection reason input
        request_id = int(parts[2]) if len(parts) > 2 else 0
        ctx.user_data["mode"] = "admin_reject_request"
        ctx.user_data["reject_request_id"] = request_id
        
        await q.edit_message_text(
            "‚ùå *Reject License Request*\n\nEnter rejection reason (or send 'skip' for no reason):",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚¨ÖÔ∏è Cancel", callback_data=f"adm_lic:req_view:{request_id}")]
            ])
        )
    
    elif action == "req_do_reject":
        # Perform rejection (called after reason is entered)
        request_id = int(parts[2]) if len(parts) > 2 else 0
        reason = parts[3] if len(parts) > 3 else "No reason provided"
        
        result = reject_license_request(request_id, admin_id=uid, reason=reason)
        
        if result.get("success"):
            request = result.get("request", {})
            await q.answer("‚ùå License request rejected!", show_alert=True)
            
            # Notify user
            try:
                await ctx.bot.send_message(
                    request["user_id"],
                    f"‚ùå *Your license request has been rejected.*\n\n"
                    f"üì¶ Plan: {request['license_type'].title()}\n"
                    f"üìù Reason: {reason}\n\n"
                    f"Contact support if you have questions.",
                    parse_mode="Markdown"
                )
            except Exception:
                pass
            
            # Go back to pending list
            q.data = "adm_lic:pending"
            await on_admin_license_cb(update, ctx)
        else:
            await q.answer(f"‚ùå Error: {result.get('error')}", show_alert=True)
    
    elif action == "grant_to_user":
        # Direct grant to specific user (from user card)
        target_uid = int(parts[2]) if len(parts) > 2 else 0
        ctx.user_data["admin_grant_target_user"] = target_uid
        
        keyboard = [
            [InlineKeyboardButton("üíé Premium", callback_data=f"adm_lic:grant_user_type:{target_uid}:premium")],
            [InlineKeyboardButton("ü•à Basic", callback_data=f"adm_lic:grant_user_type:{target_uid}:basic")],
            [InlineKeyboardButton("üéÅ Trial", callback_data=f"adm_lic:grant_user_type:{target_uid}:trial")],
            [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data=f"admin:user:{target_uid}")]
        ]
        
        await q.edit_message_text(
            f"üéÅ *Grant License to User {target_uid}*\n\nSelect license type:",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    elif action == "grant_user_type":
        # Grant license type to specific user
        target_uid = int(parts[2]) if len(parts) > 2 else 0
        plan = parts[3] if len(parts) > 3 else "premium"
        
        if plan == "trial":
            # Grant trial directly
            result = set_user_license(
                user_id=target_uid,
                license_type="trial",
                period_months=1,
                admin_id=uid,
                payment_type="admin_grant",
                notes="Admin granted trial"
            )
            if result.get("success"):
                await q.answer("‚úÖ Trial license granted!", show_alert=True)
                # Notify user
                try:
                    await ctx.bot.send_message(
                        target_uid,
                        "üéÅ *Trial License Activated!*\n\n"
                        "You have 7 days of full demo access.\n\n"
                        "Use /subscribe to upgrade to Premium or Basic.",
                        parse_mode="Markdown"
                    )
                except Exception:
                    pass
            else:
                await q.answer(f"‚ùå Error: {result.get('error')}", show_alert=True)
            
            # Go back to user card
            await show_user_card(q, ctx, target_uid)
        else:
            # Show period selection
            keyboard = [
                [InlineKeyboardButton("1 Month", callback_data=f"adm_lic:grant_user_period:{target_uid}:{plan}:1")],
                [InlineKeyboardButton("3 Months", callback_data=f"adm_lic:grant_user_period:{target_uid}:{plan}:3")],
                [InlineKeyboardButton("6 Months", callback_data=f"adm_lic:grant_user_period:{target_uid}:{plan}:6")],
                [InlineKeyboardButton("12 Months", callback_data=f"adm_lic:grant_user_period:{target_uid}:{plan}:12")],
                [InlineKeyboardButton(t.get("btn_back", "‚¨ÖÔ∏è Back"), callback_data=f"adm_lic:grant_to_user:{target_uid}")]
            ]
            
            await q.edit_message_text(
                f"üéÅ *Grant {plan.title()} to User {target_uid}*\n\nSelect period:",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(keyboard)
            )
    
    elif action == "grant_user_period":
        # Grant license with period to specific user
        target_uid = int(parts[2]) if len(parts) > 2 else 0
        plan = parts[3] if len(parts) > 3 else "premium"
        period = int(parts[4]) if len(parts) > 4 else 1
        
        result = set_user_license(
            user_id=target_uid,
            license_type=plan,
            period_months=period,
            admin_id=uid,
            payment_type="admin_grant",
            notes=f"Admin granted {plan} {period}m"
        )
        
        if result.get("success"):
            import datetime
            expires_dt = datetime.datetime.fromtimestamp(result["expires"])
            await q.answer("‚úÖ License granted!", show_alert=True)
            
            # Notify user
            try:
                await ctx.bot.send_message(
                    target_uid,
                    f"üéâ *{plan.title()} License Activated!*\n\n"
                    f"üìÖ Expires: {expires_dt.strftime('%Y-%m-%d')}\n\n"
                    f"Enjoy all your premium features!",
                    parse_mode="Markdown"
                )
            except Exception:
                pass
        else:
            await q.answer(f"‚ùå Error: {result.get('error')}", show_alert=True)
        
        # Go back to user card
        await show_user_card(q, ctx, target_uid)


# ========================
# HyperLiquid DEX Commands
# ========================

# Global dict to track users waiting for HyperLiquid input
# Structure: {uid: {"step": "private_key"|"wallet_address", "testnet": bool, "private_key": str (for step 2)}}
_hl_awaiting_input = {}
_awaiting_hl_param = {}  # {uid: {strategy, param}}

# Legacy alias for backward compatibility
_hl_awaiting_key = _hl_awaiting_input

# HyperLiquid requires premium license
HYPERLIQUID_LICENSE_TYPES = ["premium", "vip", "enterprise"]


def require_premium_for_hl(func):
    """Decorator that requires premium license for HyperLiquid features"""
    @wraps(func)
    @with_texts
    async def _wrap(update, ctx, *args, **kw):
        uid = getattr(getattr(update, "effective_user", None), "id", None)
        if uid is None:
            return await func(update, ctx, *args, **kw)

        t = ctx.t

        # Admin always has access
        if uid == ADMIN_ID:
            return await func(update, ctx, *args, **kw)

        license_info = get_user_license(uid)
        
        if not license_info["is_active"] or license_info["license_type"] not in HYPERLIQUID_LICENSE_TYPES:
            msg = t.get(
                "hl_premium_required", 
                "üîê <b>Premium Required</b>\n\n"
                "HyperLiquid DEX trading is available only for Premium users.\n\n"
                "‚ú® <b>Benefits of Premium:</b>\n"
                "‚Ä¢ Trade on HyperLiquid DEX\n"
                "‚Ä¢ Trade on both exchanges simultaneously\n"
                "‚Ä¢ Advanced DCA & Pyramid strategies\n"
                "‚Ä¢ Priority support\n\n"
                "Use /subscribe to upgrade your account."
            )
            try:
                if update.callback_query:
                    await update.callback_query.answer("üîê Premium required for HyperLiquid", show_alert=True)
                    await update.callback_query.edit_message_text(msg, parse_mode="HTML")
                else:
                    await ctx.bot.send_message(uid, msg, parse_mode="HTML")
            except Exception:
                pass
            return
        
        return await func(update, ctx, *args, **kw)
    return _wrap


@require_premium_for_hl
@with_texts
@log_calls
async def cmd_hyperliquid(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Main HyperLiquid menu"""
    uid = update.effective_user.id
    t = ctx.t
    
    hl_creds = get_hl_credentials(uid)
    is_configured = bool(hl_creds.get("hl_private_key"))
    is_enabled = hl_creds.get("hl_enabled", False)
    exchange = get_exchange_type(uid)
    network = "Testnet" if hl_creds.get("hl_testnet") else "Mainnet"
    
    if is_configured:
        addr = hl_creds.get("hl_address", "")[:10] + "..." if hl_creds.get("hl_address") else "N/A"
        status_text = f"""
üîó *HyperLiquid DEX*

üìä *Status:* {'‚úÖ Connected' if is_enabled else '‚ö†Ô∏è Disabled'}
üåê *Network:* {network}
üëõ *Wallet:* `{addr}`
üîÑ *Active Exchange:* {exchange.upper()}

Select an action:
"""
        buttons = [
            [InlineKeyboardButton("üí∞ Balance", callback_data="hl:balance"),
             InlineKeyboardButton("üìà Positions", callback_data="hl:positions")],
            [InlineKeyboardButton("üîÑ Switch to HL" if exchange == "bybit" else "üîÑ Switch to Bybit", 
                                callback_data="hl:switch")],
            [InlineKeyboardButton("üåê Testnet" if not hl_creds.get("hl_testnet") else "üåê Mainnet",
                                callback_data="hl:network")],
            [InlineKeyboardButton("üîë Update Key", callback_data="hl:setkey"),
             InlineKeyboardButton("‚ùå Disconnect", callback_data="hl:disconnect")],
        ]
    else:
        status_text = """
üîó *HyperLiquid DEX*

Connect your HyperLiquid account to trade on DEX!

‚ö° *Benefits:*
‚Ä¢ True decentralized trading
‚Ä¢ No KYC required
‚Ä¢ Lower fees
‚Ä¢ Self-custody

To connect, you need your ETH private key.
‚ö†Ô∏è *IMPORTANT:* Use a dedicated trading wallet, NOT your main wallet!

Select network to start:
"""
        buttons = [
            [InlineKeyboardButton("üåê Mainnet", callback_data="hl:mainnet"),
             InlineKeyboardButton("üß™ Testnet", callback_data="hl:testnet")],
        ]
    
    await update.message.reply_text(
        status_text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(buttons)
    )


@require_premium_for_hl
@with_texts
@log_calls
async def cmd_hl_setkey(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Command to set HyperLiquid private key"""
    uid = update.effective_user.id
    _hl_awaiting_input[uid] = {"step": "private_key", "testnet": False}
    
    await update.message.reply_text(
        "üî∑ *HyperLiquid Mainnet Setup (Step 1/2)*\n\n"
        "*Step 1:* Send your *API Wallet Private Key*\n\n"
        "üí° *How to get it:*\n"
        "1. Go to app.hyperliquid.xyz/API\n"
        "2. Create an API Wallet (give it a name)\n"
        "3. Click 'Generate' to create private key\n"
        "4. Copy the private key and send it here\n\n"
        "‚ö†Ô∏è *Security:* API Wallet can trade but cannot withdraw!\n\n"
        "Send /cancel to abort.",
        parse_mode="Markdown"
    )


@require_premium_for_hl
@with_texts
@log_calls
async def cmd_hl_balance(update: Update, ctx: ContextTypes.DEFAULT_TYPE, network: str = None):
    """Show HyperLiquid balance with network switcher"""
    uid = update.effective_user.id
    t = ctx.t
    
    hl_creds = get_hl_credentials(uid)
    
    # Check if any HL key is configured
    has_any_key = bool(hl_creds.get("hl_private_key") or 
                       hl_creds.get("hl_testnet_private_key") or 
                       hl_creds.get("hl_mainnet_private_key"))
    if not has_any_key:
        await update.message.reply_text(
            "‚ùå HyperLiquid not configured. Use üîë HL API to set up.",
            parse_mode="Markdown"
        )
        return
    
    # Determine which network to use
    if network is None:
        _tm = get_trading_mode(uid)
        is_testnet = _tm in ("demo", "testnet")
    else:
        is_testnet = (network == "testnet")
    
    # Get credentials for specific network (multitenancy pattern)
    if is_testnet:
        private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
    else:
        private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
    
    if not private_key:
        await update.message.reply_text(
            f"‚ùå HyperLiquid {'Testnet' if is_testnet else 'Mainnet'} not configured.",
            parse_mode="Markdown"
        )
        return
    
    adapter = None
    try:
        # Get wallet address for balance queries (may differ from API key address)
        if is_testnet:
            wallet_address = hl_creds.get("hl_testnet_wallet_address") or hl_creds.get("hl_wallet_address")
        else:
            wallet_address = hl_creds.get("hl_mainnet_wallet_address") or hl_creds.get("hl_wallet_address")
        
        adapter = HLAdapter(
            private_key=private_key,
            testnet=is_testnet
            # main_wallet_address auto-discovered via userRole API
        )
        await adapter.initialize()  # Trigger auto-discovery
        
        result = await adapter.get_balance()
        
        show_switcher = db.should_show_hl_network_switcher(uid)
        
        # Build keyboard
        keyboard_rows = []
        if show_switcher:
            current = "testnet" if is_testnet else "mainnet"
            keyboard_rows.append([
                InlineKeyboardButton("üß™ Testnet" + (" ‚úì" if current == "testnet" else ""), callback_data="hl_bal:testnet"),
                InlineKeyboardButton("üåê Mainnet" + (" ‚úì" if current == "mainnet" else ""), callback_data="hl_bal:mainnet")
            ])
        keyboard_rows.append([InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data="menu:main")])
        keyboard = InlineKeyboardMarkup(keyboard_rows)
        
        network_label = "üß™ Testnet" if is_testnet else "üåê Mainnet"
        
        if result.get("success"):
            data = result.get("data", {})
            equity = float(data.get("equity", 0))
            available = float(data.get("available", 0))
            margin_used = float(data.get("margin_used", 0))
            total_notional = float(data.get("total_notional", 0))
            unrealized_pnl = float(data.get("unrealized_pnl", 0))
            position_value = float(data.get("position_value", 0))
            num_positions = int(data.get("num_positions", 0))
            currency = data.get("currency", "USDC")
            
            pnl_emoji = "üü¢" if unrealized_pnl >= 0 else "üî¥"
            
            # Calculate margin level if margin used > 0
            margin_level = ""
            if margin_used > 0:
                level_pct = (equity / margin_used) * 100
                margin_level = f"\nüìê *Margin Level:* {level_pct:.1f}%"
            
            # Get SPOT balance
            spot_section = ""
            try:
                spot_result = await adapter.get_spot_balance()
                if spot_result.get("success"):
                    spot_data = spot_result.get("data", {})
                    spot_tokens = spot_data.get("tokens", [])
                    spot_total = float(spot_data.get("total_usd_value", 0))
                    
                    if spot_tokens:
                        spot_section = f"\n\nüõí *Spot Balance:* ${spot_total:,.2f}"
                        for tok in spot_tokens[:5]:  # Max 5 tokens to display
                            token_name = tok.get("token", "?")
                            token_total = tok.get("total", 0)
                            token_usd = tok.get("usd_value", 0)
                            spot_section += f"\n  ‚Ä¢ {token_name}: {token_total:,.4f} (${token_usd:,.2f})"
                        if equity == 0 and spot_total > 0:
                            spot_section += f"\n\n‚ö†Ô∏è _–î–µ–Ω—å–≥–∏ –Ω–∞ Spot! –ü–µ—Ä–µ–≤–µ–¥–∏ –Ω–∞ Perp –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏._"
            except Exception as spot_err:
                logger.debug(f"Spot balance fetch error: {spot_err}")
            
            text = f"""
üí∞ *HyperLiquid Balance* {network_label}

üíé *Perp Equity:* ${equity:,.2f} {currency}
‚úÖ *Available for Trading:* ${available:,.2f} {currency}
üìä *Margin Used:* ${margin_used:,.2f} {currency}{margin_level}

üì¶ *Positions:*
  ‚Ä¢ Active: {num_positions} positions
  ‚Ä¢ Notional Value: ${total_notional:,.2f}
  ‚Ä¢ Position Value: ${position_value:,.2f}

{pnl_emoji} *Unrealized PnL:* ${unrealized_pnl:,.2f} {currency}{spot_section}
"""
            await update.message.reply_text(text, parse_mode="Markdown", reply_markup=keyboard)
        else:
            await update.message.reply_text(
                t.get('error_fetch_balance', '‚ùå Error fetching balance: {error}').format(error=result.get('error', 'Unknown error')),
                parse_mode="Markdown",
                reply_markup=keyboard
            )
    except Exception as e:
        logger.error(f"HL balance error: {e}")
        await update.message.reply_text(t.get('error_occurred', '‚ùå Error: {error}').format(error=str(e)), parse_mode="Markdown")
    finally:
        if adapter:
            await adapter.close()


@require_premium_for_hl
@with_texts
@log_calls
async def cmd_hl_positions(update: Update, ctx: ContextTypes.DEFAULT_TYPE, network: str = None):
    """Show HyperLiquid positions with optional network switcher"""
    uid = update.effective_user.id
    t = ctx.t
    
    hl_creds = get_hl_credentials(uid)
    
    # Check if any HL key is configured
    has_any_key = bool(hl_creds.get("hl_private_key") or 
                       hl_creds.get("hl_testnet_private_key") or 
                       hl_creds.get("hl_mainnet_private_key"))
    if not has_any_key:
        await update.message.reply_text(
            "‚ùå HyperLiquid not configured. Use üîë HL API to set up.",
            parse_mode="Markdown"
        )
        return
    
    # Determine which network to use
    if network is None:
        _tm = get_trading_mode(uid)
        is_testnet = _tm in ("demo", "testnet")
    else:
        is_testnet = (network == "testnet")
    
    # Get credentials for specific network
    if is_testnet:
        private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
    else:
        private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
    
    if not private_key:
        await update.message.reply_text(
            f"‚ùå HyperLiquid {'Testnet' if is_testnet else 'Mainnet'} not configured.",
            parse_mode="Markdown"
        )
        return
    
    # Get wallet address for queries
    if is_testnet:
        wallet_address = hl_creds.get("hl_testnet_wallet_address") or hl_creds.get("hl_wallet_address")
    else:
        wallet_address = hl_creds.get("hl_mainnet_wallet_address") or hl_creds.get("hl_wallet_address")
    
    adapter = None
    try:
        adapter = HLAdapter(
            private_key=private_key,
            testnet=is_testnet
            # main_wallet_address auto-discovered via userRole API
        )
        await adapter.initialize()  # Trigger auto-discovery
        
        result = await adapter.fetch_positions()
        show_switcher = db.should_show_hl_network_switcher(uid)
        
        # Build keyboard
        keyboard_rows = []
        if show_switcher:
            current = "testnet" if is_testnet else "mainnet"
            keyboard_rows.append([
                InlineKeyboardButton("üß™ Testnet" + (" ‚úì" if current == "testnet" else ""), callback_data="hl_pos:testnet"),
                InlineKeyboardButton("üåê Mainnet" + (" ‚úì" if current == "mainnet" else ""), callback_data="hl_pos:mainnet")
            ])
        keyboard_rows.append([InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data="menu:main")])
        keyboard = InlineKeyboardMarkup(keyboard_rows)
        
        # fetch_positions returns Bybit-compatible format: retCode, result.list
        if result.get("retCode") == 0:
            positions = result.get("result", {}).get("list", [])
            network_label = "üß™ Testnet" if is_testnet else "üåê Mainnet"
            
            if not positions:
                text = f"üìà *HyperLiquid Positions* {network_label}\n\nüì≠ No open positions."
                await update.message.reply_text(text, parse_mode="Markdown", reply_markup=keyboard)
                return
            
            lines = [f"üìà *HyperLiquid Positions* {network_label}\n"]
            
            for pos in positions[:10]:
                symbol = pos.get("symbol", "?")
                side = pos.get("side", "?")
                size = float(pos.get("size", 0))
                entry = float(pos.get("entryPrice", 0))
                pnl = float(pos.get("unrealisedPnl", 0))
                leverage = pos.get("leverage", "?")
                
                side_emoji = "üü¢ LONG" if side == "Buy" else "üî¥ SHORT"
                pnl_emoji = "+" if pnl >= 0 else ""
                
                lines.append(
                    f"{side_emoji} *{symbol}* {leverage}x\n"
                    f"   Size: {size} | Entry: ${entry:,.4f}\n"
                    f"   PnL: {pnl_emoji}${pnl:,.2f}\n"
                )
            
            await update.message.reply_text("\n".join(lines), parse_mode="Markdown", reply_markup=keyboard)
        else:
            await update.message.reply_text(
                t.get('error_generic', 'Error: {msg}').format(msg=f"Failed to fetch positions: {result.get('retMsg', 'Unknown error')}"),
                parse_mode="Markdown"
            )
    except Exception as e:
        logger.error(f"HL positions error: {e}")
        await update.message.reply_text(t.get('error_occurred', '‚ùå Error: {error}').format(error=str(e)), parse_mode="Markdown")
    finally:
        if adapter:
            await adapter.close()


@require_premium_for_hl
@with_texts  
@log_calls
async def cmd_hl_switch(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Switch active exchange"""
    uid = update.effective_user.id
    
    current = get_exchange_type(uid)
    new_exchange = "hyperliquid" if current == "bybit" else "bybit"
    
    # Check if HL is configured before switching to it
    if new_exchange == "hyperliquid":
        hl_creds = get_hl_credentials(uid)
        if not hl_creds.get("hl_private_key"):
            await update.message.reply_text(
                "‚ùå Cannot switch to HyperLiquid - not configured.\n"
                "Use /hl to set up first.",
                parse_mode="Markdown"
            )
            return
    
    set_exchange_type(uid, new_exchange)
    
    # Log activity for cross-platform sync
    try:
        from services.sync_service import sync_service
        import asyncio
        asyncio.create_task(sync_service.sync_exchange_switch(
            user_id=uid,
            source="telegram",
            old_exchange=current,
            new_exchange=new_exchange
        ))
    except Exception as e:
        logger.warning(f"Failed to log exchange switch activity: {e}")
    
    await update.message.reply_text(
        f"‚úÖ Switched to *{new_exchange.upper()}*\n\n"
        f"All new trades will execute on {new_exchange.upper()}.",
        parse_mode="Markdown"
    )


@require_premium_for_hl
@with_texts
@log_calls
async def cmd_hl_orders(update: Update, ctx: ContextTypes.DEFAULT_TYPE, network: str = None):
    """Show HyperLiquid open orders with optional network switcher"""
    uid = update.effective_user.id
    t = ctx.t
    
    hl_creds = get_hl_credentials(uid)
    
    # Check if any HL key is configured
    has_any_key = bool(hl_creds.get("hl_private_key") or 
                       hl_creds.get("hl_testnet_private_key") or 
                       hl_creds.get("hl_mainnet_private_key"))
    if not has_any_key:
        await update.message.reply_text(
            "‚ùå HyperLiquid not configured. Use üîë HL API to set up.",
            parse_mode="Markdown"
        )
        return
    
    # Determine which network to use
    if network is None:
        _tm = get_trading_mode(uid)
        is_testnet = _tm in ("demo", "testnet")
    else:
        is_testnet = (network == "testnet")
    
    # Get credentials for specific network
    if is_testnet:
        private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
        wallet_address = hl_creds.get("hl_testnet_wallet_address") or hl_creds.get("hl_wallet_address")
    else:
        private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
        wallet_address = hl_creds.get("hl_mainnet_wallet_address") or hl_creds.get("hl_wallet_address")
    
    if not private_key:
        await update.message.reply_text(
            f"‚ùå HyperLiquid {'Testnet' if is_testnet else 'Mainnet'} not configured.",
            parse_mode="Markdown"
        )
        return
    
    adapter = None
    try:
        adapter = HLAdapter(
            private_key=private_key,
            testnet=is_testnet
            # main_wallet_address auto-discovered via userRole API
        )
        await adapter.initialize()  # Trigger auto-discovery
        
        result = await adapter.fetch_open_orders()
        show_switcher = db.should_show_hl_network_switcher(uid)
        
        # Build keyboard
        keyboard_rows = []
        if show_switcher:
            current = "testnet" if is_testnet else "mainnet"
            keyboard_rows.append([
                InlineKeyboardButton("üß™ Testnet" + (" ‚úì" if current == "testnet" else ""), callback_data="hl_ord:testnet"),
                InlineKeyboardButton("üåê Mainnet" + (" ‚úì" if current == "mainnet" else ""), callback_data="hl_ord:mainnet")
            ])
        keyboard_rows.append([InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data="menu:main")])
        keyboard = InlineKeyboardMarkup(keyboard_rows)
        
        network_label = "üß™ Testnet" if is_testnet else "üåê Mainnet"
        
        if result.get("success"):
            orders = result.get("data", [])
            if not orders:
                text = f"üìà *HyperLiquid Orders* {network_label}\n\nüì≠ No open orders."
                await update.message.reply_text(text, parse_mode="Markdown", reply_markup=keyboard)
                return
            
            lines = [f"üìà *HyperLiquid Open Orders* {network_label}\n"]
            
            for order in orders[:10]:
                symbol = order.get("symbol", "?")
                side = order.get("side", "?")
                size = float(order.get("size", 0))
                price = float(order.get("price", 0))
                order_type = order.get("order_type", "?")
                
                side_emoji = "üü¢ BUY" if side == "Buy" else "üî¥ SELL"
                
                lines.append(
                    f"{side_emoji} *{symbol}*\n"
                    f"   {order_type} | Size: {size} @ ${price:,.4f}\n"
                )
            
            await update.message.reply_text("\n".join(lines), parse_mode="Markdown", reply_markup=keyboard)
        else:
            await update.message.reply_text(
                t.get('error_fetch_orders', '‚ùå Error fetching orders: {error}').format(error=result.get('error', 'Unknown error')),
                parse_mode="Markdown"
            )
    except Exception as e:
        logger.error(f"HL orders error: {e}")
        await update.message.reply_text(t.get('error_occurred', '‚ùå Error: {error}').format(error=str(e)), parse_mode="Markdown")
    finally:
        if adapter:
            await adapter.close()


@require_premium_for_hl
@with_texts
@log_calls
async def cmd_hl_trade(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show HyperLiquid trade menu"""
    uid = update.effective_user.id
    
    hl_creds = get_hl_credentials(uid)
    if not hl_creds.get("hl_private_key"):
        await update.message.reply_text(
            "‚ùå HyperLiquid not configured. Use üîë HL API to set up.",
            parse_mode="Markdown"
        )
        return
    
    network = "üß™ Testnet" if hl_creds.get("hl_testnet") else "üåê Mainnet"
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("üü¢ Buy BTC", callback_data="hl_trade:buy_BTC"),
         InlineKeyboardButton("üî¥ Sell BTC", callback_data="hl_trade:sell_BTC")],
        [InlineKeyboardButton("üü¢ Buy ETH", callback_data="hl_trade:buy_ETH"),
         InlineKeyboardButton("üî¥ Sell ETH", callback_data="hl_trade:sell_ETH")],
        [InlineKeyboardButton("üìù Custom Trade", callback_data="hl_trade:custom")],
        [InlineKeyboardButton("‚ùå Close", callback_data="hl_trade:close")],
    ])
    
    await update.message.reply_text(
        f"üéØ *HyperLiquid Trade* {network}\n\n"
        "Select a quick trade or custom trade:",
        parse_mode="Markdown",
        reply_markup=keyboard
    )


@require_premium_for_hl
@with_texts
@log_calls
async def cmd_hl_close_all(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Close all HyperLiquid positions"""
    uid = update.effective_user.id
    
    hl_creds = get_hl_credentials(uid)
    has_hl = (hl_creds.get("hl_private_key") or
              hl_creds.get("hl_testnet_private_key") or
              hl_creds.get("hl_mainnet_private_key"))
    if not has_hl:
        await update.message.reply_text(
            "‚ùå HyperLiquid not configured. Use üîë HL API to set up.",
            parse_mode="Markdown"
        )
        return
    
    keyboard = InlineKeyboardMarkup([
        [InlineKeyboardButton("‚úÖ Yes, Close All", callback_data="hl_close:confirm")],
        [InlineKeyboardButton("‚ùå Cancel", callback_data="hl_close:cancel")],
    ])
    
    await update.message.reply_text(
        "‚ö†Ô∏è *Close All Positions?*\n\n"
        "This will market close ALL your open positions on HyperLiquid.\n\n"
        "Are you sure?",
        parse_mode="Markdown",
        reply_markup=keyboard
    )


@log_calls
async def on_hl_close_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle HyperLiquid close all positions confirmation callbacks"""
    q = update.callback_query
    await q.answer()
    
    uid = q.from_user.id
    data = q.data
    
    # hl_close:confirm or hl_close:cancel
    action = data.split(":")[1] if ":" in data else ""
    
    if action == "cancel":
        try:
            await q.delete_message()
        except Exception:
            pass
        await ctx.bot.send_message(
            chat_id=uid,
            text="‚ùå Cancelled. Positions not closed.",
            reply_markup=main_menu_keyboard(ctx, user_id=uid)
        )
        return
    
    if action != "confirm":
        return
    
    # Confirm - close all positions
    hl_creds = get_hl_credentials(uid)
    # Determine network from trading_mode, NOT from hl_testnet flag
    trading_mode = get_trading_mode(uid)
    is_testnet = trading_mode in ("demo", "testnet", "both")
    # For 'both' mode, default to testnet (safer); user can switch network in HL menu
    
    # Use canonical credential helper
    from core.account_utils import get_hl_credentials_for_account
    _acc = "testnet" if is_testnet else "mainnet"
    private_key, is_testnet, _ = get_hl_credentials_for_account(hl_creds, _acc)
    
    if not private_key:
        await q.edit_message_text(
            f"‚ùå HyperLiquid {'Testnet' if is_testnet else 'Mainnet'} not configured.",
            parse_mode="Markdown"
        )
        return
    
    adapter = None
    try:
        adapter = HLAdapter(
            private_key=private_key,
            testnet=is_testnet
            # main_wallet_address auto-discovered via userRole API
        )
        await adapter.initialize()  # Trigger auto-discovery
        
        # Get positions first
        positions_result = await adapter.fetch_positions()
        positions = positions_result.get("result", {}).get("list", [])
        
        if not positions:
            await q.edit_message_text(
                "üì≠ No open positions to close.",
                parse_mode="Markdown"
            )
            return
        
        # Close each position
        closed_count = 0
        failed_count = 0
        
        for pos in positions:
            try:
                coin = pos.get("coin") or pos.get("symbol", "").replace("USDT", "")
                size = float(pos.get("size") or pos.get("szi") or 0)
                side = pos.get("side", "Buy")
                
                if abs(size) <= 0:
                    continue
                
                # market_close needs is_buy=True to close a short (Buy to close), is_buy=False to close a long (Sell to close)
                is_buy = side != "Buy"  # Opposite direction to close
                
                result = await adapter._client.market_close(
                    coin=coin,
                    sz=abs(size),
                    slippage=0.02  # 2% slippage for closing
                )
                
                if result.get("status") == "ok":
                    closed_count += 1
                    logger.info(f"[{uid}] Closed HL position: {coin} {side} size={size}")
                else:
                    failed_count += 1
                    logger.warning(f"[{uid}] Failed to close HL position {coin}: {result}")
            except Exception as pos_err:
                failed_count += 1
                logger.error(f"[{uid}] Error closing HL position: {pos_err}")
        
        # Report results
        network_label = "üß™ Testnet" if is_testnet else "üåê Mainnet"
        if closed_count > 0 and failed_count == 0:
            text = f"‚úÖ Closed {closed_count} position(s) on HyperLiquid {network_label}."
        elif closed_count > 0 and failed_count > 0:
            text = f"‚ö†Ô∏è Closed {closed_count} position(s), {failed_count} failed on HyperLiquid {network_label}."
        else:
            text = f"‚ùå Failed to close positions on HyperLiquid {network_label}."
        
        try:
            await q.delete_message()
        except Exception:
            pass
        
        await ctx.bot.send_message(
            chat_id=uid,
            text=text,
            reply_markup=main_menu_keyboard(ctx, user_id=uid)
        )
        
    except Exception as e:
        logger.error(f"[{uid}] HL close all failed: {e}")
        await q.edit_message_text(
            f"‚ùå Error closing positions: {str(e)}",
            parse_mode="Markdown"
        )
    finally:
        if adapter:
            await adapter.close()


@require_premium_for_hl
@with_texts
@log_calls
async def cmd_hl_history(update: Update, ctx: ContextTypes.DEFAULT_TYPE, network: str = None):
    """Show HyperLiquid trade history ‚Äî delegates to unified cmd_trade_stats.
    
    Legacy function kept for backward compatibility. The unified cmd_trade_stats
    now handles both Bybit and HyperLiquid with the same UI (strategy filters,
    period filters, account type switcher, pagination).
    """
    return await cmd_trade_stats(update, ctx)


@require_premium_for_hl
@with_texts
@log_calls  
async def cmd_hl_clear(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Clear HyperLiquid credentials"""
    uid = update.effective_user.id
    
    clear_hl_credentials(uid)
    set_exchange_type(uid, "bybit")
    
    await update.message.reply_text(
        "‚úÖ HyperLiquid credentials cleared.\n"
        "Switched back to Bybit.",
        parse_mode="Markdown"
    )


@with_texts
@log_calls
async def cmd_hl_settings(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show HyperLiquid API settings menu."""
    uid = update.effective_user.id
    t = ctx.t
    
    hl_creds = get_hl_credentials(uid)
    
    # Check separate testnet and mainnet keys
    has_testnet_key = bool(hl_creds.get("hl_testnet_private_key"))
    has_mainnet_key = bool(hl_creds.get("hl_mainnet_private_key"))
    testnet_wallet = hl_creds.get("hl_testnet_wallet_address", "")
    mainnet_wallet = hl_creds.get("hl_mainnet_wallet_address", "")
    
    # Fallback to legacy key
    if not has_testnet_key and not has_mainnet_key:
        legacy_key = hl_creds.get("hl_private_key")
        legacy_wallet = hl_creds.get("hl_wallet_address", "")
        if legacy_key:
            if hl_creds.get("hl_testnet"):
                has_testnet_key = True
                testnet_wallet = legacy_wallet
            else:
                has_mainnet_key = True
                mainnet_wallet = legacy_wallet
    
    # Auto-discover main wallets for display
    testnet_main_wallet = None
    mainnet_main_wallet = None
    
    if has_testnet_key:
        try:
            from hl_adapter import HLAdapter
            adapter = HLAdapter(
                private_key=hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key"),
                testnet=True
            )
            await adapter.initialize()
            testnet_main_wallet = adapter._main_wallet_address
            await adapter.close()
        except Exception as e:
            logger.debug(f"Failed to discover testnet main wallet: {e}")
    
    if has_mainnet_key:
        try:
            from hl_adapter import HLAdapter
            adapter = HLAdapter(
                private_key=hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key"),
                testnet=False
            )
            await adapter.initialize()
            mainnet_main_wallet = adapter._main_wallet_address
            await adapter.close()
        except Exception as e:
            logger.debug(f"Failed to discover mainnet main wallet: {e}")
    
    # Build status message
    msg = "üî∑ <b>HyperLiquid API Settings</b>\n\n"
    
    # Show testnet status
    if has_testnet_key:
        api_short = f"{testnet_wallet[:8]}...{testnet_wallet[-6:]}" if len(testnet_wallet) > 14 else testnet_wallet
        msg += f"üß™ <b>Testnet:</b> ‚úÖ Configured\n"
        msg += f"   API Wallet: <code>{api_short}</code>\n"
        if testnet_main_wallet:
            main_short = f"{testnet_main_wallet[:8]}...{testnet_main_wallet[-6:]}"
            msg += f"   Main Wallet: <code>{main_short}</code>\n"
        msg += "\n"
    else:
        msg += f"üß™ <b>Testnet:</b> ‚ùå Not configured\n\n"
    
    # Show mainnet status
    if has_mainnet_key:
        api_short = f"{mainnet_wallet[:8]}...{mainnet_wallet[-6:]}" if len(mainnet_wallet) > 14 else mainnet_wallet
        msg += f"üåê <b>Mainnet:</b> ‚úÖ Configured\n"
        msg += f"   API Wallet: <code>{api_short}</code>\n"
        if mainnet_main_wallet:
            main_short = f"{mainnet_main_wallet[:8]}...{mainnet_main_wallet[-6:]}"
            msg += f"   Main Wallet: <code>{main_short}</code>\n"
        msg += "\n"
    else:
        msg += f"üåê <b>Mainnet:</b> ‚ùå Not configured\n\n"
    
    if has_testnet_key or has_mainnet_key:
        msg += "‚úÖ <b>Status:</b> Ready to trade"
    else:
        msg += "‚ùå <b>Status:</b> Setup required\n\n"
        msg += "Choose network to configure:"
    
    # Build keyboard
    keyboard = []
    
    # Always show setup buttons for unconfigured networks
    setup_row = []
    if not has_mainnet_key:
        setup_row.append(InlineKeyboardButton("üåê Setup Mainnet", callback_data="hl_api:setup_mainnet"))
    if not has_testnet_key:
        setup_row.append(InlineKeyboardButton("üß™ Setup Testnet", callback_data="hl_api:setup_testnet"))
    if setup_row:
        keyboard.append(setup_row)
    
    # Show management buttons if any key is configured
    if has_testnet_key or has_mainnet_key:
        keyboard.append([
            InlineKeyboardButton("üß™ Test Connection", callback_data="hl_api:test")
        ])
        
        # Clear buttons for each configured network
        clear_row = []
        if has_testnet_key:
            clear_row.append(InlineKeyboardButton("üóë Clear Testnet", callback_data="hl_api:clear_testnet"))
        if has_mainnet_key:
            clear_row.append(InlineKeyboardButton("üóë Clear Mainnet", callback_data="hl_api:clear_mainnet"))
        if clear_row:
            keyboard.append(clear_row)
    
    keyboard.append([
        InlineKeyboardButton(t.get("button_back", "üîô Back"), callback_data="hl_api:back")
    ])
    
    await update.message.reply_text(
        msg,
        parse_mode="HTML",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


@with_texts
@log_calls
async def cmd_exchange_status(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Show current exchange status with quick mode switch"""
    uid = update.effective_user.id
    t = ctx.t
    
    status = get_exchange_status(uid)
    active = status.get("active_exchange", "bybit")
    
    bybit_info = status.get("bybit", {})
    hl_info = status.get("hyperliquid", {})
    
    keyboard = []
    
    if active == "hyperliquid":
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ‚ñà‚ñà  HYPERLIQUID STATUS  ‚ñà‚ñà
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        is_testnet = hl_info.get("testnet", False)
        wallet = hl_info.get("wallet", "")
        wallet_short = f"{wallet[:8]}...{wallet[-6:]}" if len(wallet) > 20 else wallet
        
        text = "üî∑ *HyperLiquid*\n\n"
        
        if hl_info.get("configured"):
            text += f"üåê Network: {'üß™ Testnet' if is_testnet else 'üí∞ Mainnet'}\n"
            text += f"üìç Wallet: `{wallet_short}`\n"
            if hl_info.get("vault"):
                text += f"üè¶ Vault: Configured\n"
            
            # Quick network switch buttons
            keyboard.append([
                InlineKeyboardButton("üß™ Testnet" + (" ‚úì" if is_testnet else ""), callback_data="hl:testnet"),
                InlineKeyboardButton("üí∞ Mainnet" + ("" if is_testnet else " ‚úì"), callback_data="hl:mainnet")
            ])
        else:
            text += "‚ùå Not configured\n\n_Press üîë API Keys to set up_"
        
        # Switch to Bybit
        if bybit_info.get("configured"):
            keyboard.append([InlineKeyboardButton("üîÑ Switch to üü† Bybit", callback_data="exchange:set_bybit")])
        
    else:
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        # ‚ñà‚ñà  BYBIT STATUS - use shared builder  ‚ñà‚ñà
        # ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        text, inline_keyboard = _build_bybit_status_keyboard(uid, t)
        keyboard = list(inline_keyboard.inline_keyboard)  # Extract list for modification (tuple ‚Üí list)
    
    keyboard.append([InlineKeyboardButton(t.get("button_back", "¬´ –ù–∞–∑–∞–¥"), callback_data="menu:main")])
    
    # Send message with InlineKeyboard for actions
    await update.message.reply_text(
        text, 
        parse_mode="Markdown", 
        reply_markup=InlineKeyboardMarkup(keyboard)
    )
    
    # ALSO update ReplyKeyboard to reflect current exchange state
    await ctx.bot.send_message(
        chat_id=uid,
        text="‚¨áÔ∏è",
        reply_markup=main_menu_keyboard(ctx, user_id=uid)
    )


@with_texts
@log_calls
async def cmd_switch_exchange(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Switch between Bybit and HyperLiquid"""
    uid = update.effective_user.id
    t = ctx.t
    
    status = get_exchange_status(uid)
    current = status.get("active_exchange", "bybit")
    hl_configured = status.get("hyperliquid", {}).get("configured", False)
    bybit_configured = status.get("bybit", {}).get("configured", False)
    bybit_enabled = db.is_bybit_enabled(uid)
    hl_enabled = db.is_hl_enabled(uid)
    
    keyboard = []
    
    # Bybit option
    bybit_status = "‚úÖ" if bybit_enabled else "‚ùå"
    if current == "bybit":
        keyboard.append([InlineKeyboardButton(f"üü† Bybit {bybit_status} ‚úì (current)", callback_data="exchange:noop")])
    else:
        if bybit_configured:
            keyboard.append([InlineKeyboardButton(f"üü† Switch to Bybit {bybit_status}", callback_data="exchange:set_bybit")])
        else:
            keyboard.append([InlineKeyboardButton("üü† Setup Bybit API", callback_data="exchange:noop")])
    
    # HyperLiquid option
    hl_status = "‚úÖ" if hl_enabled else "‚ùå"
    if hl_configured:
        if current == "hyperliquid":
            keyboard.append([InlineKeyboardButton(f"üî∑ HyperLiquid {hl_status} ‚úì (current)", callback_data="exchange:noop")])
        else:
            keyboard.append([InlineKeyboardButton(f"üî∑ Switch to HyperLiquid {hl_status}", callback_data="exchange:set_hl")])
    else:
        keyboard.append([InlineKeyboardButton("üî∑ Setup HyperLiquid", callback_data="exchange:setup_hl")])
    
    # Settings button for enable/disable
    keyboard.append([InlineKeyboardButton("‚öôÔ∏è Exchange Settings (Enable/Disable)", callback_data="exchange:settings")])
    keyboard.append([InlineKeyboardButton(t.get("button_back", "üîô Back"), callback_data="main_menu")])
    
    text = (
        "üîÑ *Switch Exchange*\n\n"
        f"*Active:* {'üî∑ HyperLiquid' if current == 'hyperliquid' else 'üü† Bybit'}\n\n"
        f"*Status:*\n"
        f"‚Ä¢ üü† Bybit: {bybit_status} {'enabled' if bybit_enabled else 'disabled'}\n"
        f"‚Ä¢ üî∑ HyperLiquid: {hl_status} {'enabled' if hl_enabled else 'disabled'}\n\n"
        "_Select exchange or go to Settings to enable/disable._"
    )
    
    await update.message.reply_text(
        text,
        parse_mode="Markdown",
        reply_markup=InlineKeyboardMarkup(keyboard)
    )


@with_texts
@log_calls
async def cmd_webapp(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Open WebApp in Telegram or browser with auto-login"""
    t = ctx.t
    uid = update.effective_user.id
    
    # Get webapp URL from env, fallback to ngrok file, then localhost
    webapp_url = WEBAPP_URL
    
    # Generate auto-login token
    import time
    cache_bust = int(time.time())
    try:
        from webapp.services import telegram_auth
        token, _ = telegram_auth.generate_login_token(uid)
        login_url = f"{webapp_url}/api/auth/token-login?token={token}&_t={cache_bust}"
    except Exception as e:
        logging.warning(f"Failed to generate login token: {e}")
        login_url = f"{webapp_url}?_t={cache_bust}"
    
    # Check if ngrok (free tier has warning page that breaks WebApp)
    is_ngrok = "ngrok" in webapp_url
    webapp_url_with_start = f"{webapp_url}/terminal?start={uid}&_t={cache_bust}"
    
    if is_ngrok:
        # For ngrok, use regular URL buttons (WebAppInfo shows blank due to ngrok warning)
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üåê Open WebApp", url=login_url)],
            [InlineKeyboardButton(t.get("button_back", "üîô Back"), callback_data="main_menu")]
        ])
    else:
        # For production HTTPS, use WebAppInfo for native Telegram experience
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üì± Open in Telegram", web_app=WebAppInfo(url=webapp_url_with_start))],
            [InlineKeyboardButton("üîó Open in Browser", url=login_url)],
            [InlineKeyboardButton(t.get("button_back", "üîô Back"), callback_data="main_menu")]
        ])
    
    text = (
        "üåê *Trading WebApp*\n\n"
        "Access your trading dashboard:\n\n"
        "‚Ä¢ üìä View positions and orders\n"
        "‚Ä¢ üí∞ Check balances\n"
        "‚Ä¢ ‚öôÔ∏è Manage settings\n"
        "‚Ä¢ üìà Trading statistics\n\n"
        "_Tap the button below to open_"
    )
    
    await update.message.reply_text(
        text,
        parse_mode="Markdown",
        reply_markup=keyboard,
        disable_web_page_preview=True
    )


@log_calls
async def on_hl_api_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle HyperLiquid API settings callbacks"""
    q = update.callback_query
    await q.answer()
    
    uid = q.from_user.id
    data = q.data
    
    if data == "hl_api:setup_mainnet":
        _hl_awaiting_input[uid] = {"step": "private_key", "testnet": False}
        await q.edit_message_text(
            "üåê <b>HyperLiquid Mainnet Setup (Step 1/2)</b>\n\n"
            "<b>Step 1:</b> Send your <b>API Wallet Private Key</b>\n\n"
            "üí° <b>How to get it:</b>\n"
            "1. Go to app.hyperliquid.xyz/API\n"
            "2. Create an API Wallet (give it a name)\n"
            "3. Click 'Generate' to create private key\n"
            "4. Copy the private key and send it here\n\n"
            "‚ö†Ô∏è <b>Security:</b> API Wallet can trade but cannot withdraw!\n\n"
            "Send /cancel to abort.",
            parse_mode="HTML"
        )
    
    elif data == "hl_api:setup_testnet":
        _hl_awaiting_input[uid] = {"step": "private_key", "testnet": True}
        await q.edit_message_text(
            "üß™ <b>HyperLiquid Testnet Setup (Step 1/2)</b>\n\n"
            "<b>Step 1:</b> Send your <b>API Wallet Private Key</b>\n\n"
            "üí° <b>How to get it:</b>\n"
            "1. Go to app.hyperliquid.xyz/API\n"
            "2. Create an API Wallet (give it a name)\n"
            "3. Click 'Generate' to create private key\n"
            "4. Copy the private key and send it here\n\n"
            "‚ö†Ô∏è <b>Security:</b> API Wallet can trade but cannot withdraw!\n\n"
            "Send /cancel to abort.",
            parse_mode="HTML"
        )
    
    elif data == "hl_api:test":
        # Test HyperLiquid connection - test both testnet and mainnet if configured
        hl_creds = get_hl_credentials(uid)
        
        results = []
        
        # Test Testnet
        testnet_key = hl_creds.get("hl_testnet_private_key") or (
            hl_creds.get("hl_private_key") if hl_creds.get("hl_testnet") else None
        )
        if testnet_key:
            try:
                from hl_adapter import HLAdapter
                adapter = HLAdapter(private_key=testnet_key, testnet=True)
                await adapter.initialize()
                balance_data = await adapter.get_balance()
                await adapter.close()
                
                balance = balance_data.get("data", {}).get("equity", 0) if isinstance(balance_data, dict) else 0
                api_wallet = adapter._client._api_wallet_address or "?"
                main_wallet = adapter._client._main_wallet_address or api_wallet
                
                results.append(f"üß™ <b>Testnet:</b> ‚úÖ\n   API: <code>{api_wallet[:8]}...{api_wallet[-4:]}</code>\n   Main: <code>{main_wallet[:8]}...{main_wallet[-4:]}</code>\n   Balance: ${balance:.2f}")
            except Exception as e:
                results.append(f"üß™ <b>Testnet:</b> ‚ùå {str(e)[:50]}")
        
        # Test Mainnet
        mainnet_key = hl_creds.get("hl_mainnet_private_key") or (
            hl_creds.get("hl_private_key") if not hl_creds.get("hl_testnet") else None
        )
        if mainnet_key:
            try:
                from hl_adapter import HLAdapter
                adapter = HLAdapter(private_key=mainnet_key, testnet=False)
                await adapter.initialize()
                balance_data = await adapter.get_balance()
                await adapter.close()
                
                balance = balance_data.get("data", {}).get("equity", 0) if isinstance(balance_data, dict) else 0
                api_wallet = adapter._client._api_wallet_address or "?"
                main_wallet = adapter._client._main_wallet_address or api_wallet
                
                results.append(f"üåê <b>Mainnet:</b> ‚úÖ\n   API: <code>{api_wallet[:8]}...{api_wallet[-4:]}</code>\n   Main: <code>{main_wallet[:8]}...{main_wallet[-4:]}</code>\n   Balance: ${balance:.2f}")
            except Exception as e:
                results.append(f"üåê <b>Mainnet:</b> ‚ùå {str(e)[:50]}")
        
        if not results:
            await q.edit_message_text(
                "‚ùå No HyperLiquid credentials configured.\n\nUse Setup buttons to configure.",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üîô Back", callback_data="hl_api:back")]
                ])
            )
            return
        
        await q.edit_message_text(
            f"üî∑ <b>HyperLiquid Connection Test</b>\n\n" + "\n\n".join(results),
            parse_mode="HTML",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô Back", callback_data="hl_api:back")]
            ])
        )
    
    elif data == "hl_api:clear":
        clear_hl_credentials(uid)
        await q.edit_message_text(
            "‚úÖ All HyperLiquid credentials cleared.\n\n"
            "Use üî∑ HL API to setup again.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô Back", callback_data="hl_api:back")]
            ])
        )
    
    elif data == "hl_api:clear_testnet":
        clear_hl_credentials(uid, account_type="testnet")
        await q.edit_message_text(
            "‚úÖ HyperLiquid Testnet credentials cleared.\n\n"
            "Use üî∑ HL API to setup again.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô Back", callback_data="hl_api:back")]
            ])
        )
    
    elif data == "hl_api:clear_mainnet":
        clear_hl_credentials(uid, account_type="mainnet")
        await q.edit_message_text(
            "‚úÖ HyperLiquid Mainnet credentials cleared.\n\n"
            "Use üî∑ HL API to setup again.",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô Back", callback_data="hl_api:back")]
            ])
        )
    
    elif data == "hl_api:back":
        # Return to main API settings menu
        creds = get_all_user_credentials(uid)
        t = getattr(ctx, 't', None) or LANGS.get(db.get_user_lang(uid), LANGS['en'])
        msg = format_api_settings_message(t, creds, uid)
        keyboard = get_api_settings_keyboard(t, creds, uid)
        try:
            await q.edit_message_text(msg, reply_markup=keyboard, parse_mode="HTML")
        except BadRequest:
            pass
    
    elif data == "hl_api:testnet":
        # Switch to testnet
        db.set_user_field(uid, "hl_testnet", True)
        await q.answer("üß™ Switched to Testnet", show_alert=False)
        # Refresh HL settings
        await _refresh_hl_settings_inline(q, uid, ctx)
    
    elif data == "hl_api:mainnet":
        # Switch to mainnet
        db.set_user_field(uid, "hl_testnet", False)
        await q.answer("üåê Switched to Mainnet", show_alert=False)
        # Refresh HL settings
        await _refresh_hl_settings_inline(q, uid, ctx)
    
    elif data == "hl_api:set_key":
        # Determine which network to set key for based on current setting
        hl_creds = get_hl_credentials(uid)
        is_testnet = hl_creds.get("hl_testnet", False)
        _hl_awaiting_input[uid] = {"step": "private_key", "testnet": is_testnet}
        network = "Testnet" if is_testnet else "Mainnet"
        network_emoji = "üß™" if is_testnet else "üåê"
        await q.edit_message_text(
            f"{network_emoji} <b>HyperLiquid {network} Setup (Step 1/2)</b>\n\n"
            "<b>Step 1:</b> Send your <b>API Wallet Private Key</b>\n\n"
            "üí° <b>How to get it:</b>\n"
            "1. Go to app.hyperliquid.xyz/API\n"
            "2. Create an API Wallet (give it a name)\n"
            "3. Click 'Generate' to create private key\n"
            "4. Copy the private key and send it here\n\n"
            "‚ö†Ô∏è <b>Security:</b> API Wallet can trade but cannot withdraw!\n\n"
            "Send /cancel to abort.",
            parse_mode="HTML"
        )


async def _refresh_hl_settings_inline(q, uid: int, ctx):
    """Refresh HL settings message inline"""
    from db import get_hl_credentials
    hl_creds = get_hl_credentials(uid)
    
    is_testnet = hl_creds.get("hl_testnet", False)
    network = "üß™ Testnet" if is_testnet else "üåê Mainnet"
    
    # Get correct wallet for current network
    if is_testnet:
        wallet = hl_creds.get("hl_testnet_wallet_address", "")
    else:
        wallet = hl_creds.get("hl_mainnet_wallet_address", "")
    
    # Fallback to legacy
    if not wallet:
        wallet = hl_creds.get("hl_wallet_address", "")
    
    wallet_display = f"{wallet[:8]}...{wallet[-6:]}" if wallet and len(wallet) > 14 else (wallet or "Not set")
    
    # Check if key exists for current network
    if is_testnet:
        has_key = bool(hl_creds.get("hl_testnet_private_key"))
    else:
        has_key = bool(hl_creds.get("hl_mainnet_private_key"))
    
    # Fallback to legacy
    if not has_key:
        has_key = bool(hl_creds.get("hl_private_key"))
    
    key_status = "‚úÖ" if has_key else "‚ùå"
    
    # Get API wallet address (derived from private key)
    if is_testnet:
        api_key = hl_creds.get("hl_testnet_private_key")
    else:
        api_key = hl_creds.get("hl_mainnet_private_key")
    
    if not api_key:
        api_key = hl_creds.get("hl_private_key")
    
    api_wallet = ""
    if api_key:
        try:
            from eth_account import Account
            api_wallet = Account.from_key(api_key).address
        except Exception as e:
            logger.warning(f"Failed to derive API wallet address: {e}")
    
    api_wallet_display = f"{api_wallet[:8]}...{api_wallet[-6:]}" if api_wallet and len(api_wallet) > 14 else "Not set"
    
    hl_msg = f"""üî∑ <b>HyperLiquid Settings</b>

<b>Network:</b> {network}
<b>Main Wallet:</b> <code>{wallet_display}</code>
<b>API Wallet:</b> <code>{api_wallet_display}</code>
<b>Status:</b> {key_status}

üí° <b>Setup requires 2 things:</b>
1. API Wallet Private Key (for signing orders)
2. Main Wallet Address (where your funds are)

Use the buttons below to configure:"""
    
    hl_buttons = [
        [
            InlineKeyboardButton("‚úÖ Testnet" if is_testnet else "üß™ Testnet", callback_data="hl_api:testnet"),
            InlineKeyboardButton("üåê Mainnet" if is_testnet else "‚úÖ Mainnet", callback_data="hl_api:mainnet"),
        ],
        [InlineKeyboardButton("üîß Setup API Wallet", callback_data="hl_api:set_key")],
        [InlineKeyboardButton("üîÑ Test Connection", callback_data="hl_api:test")],
        [InlineKeyboardButton("‚¨ÖÔ∏è Back to API Settings", callback_data="hl_api:back")],
    ]
    
    try:
        await q.edit_message_text(hl_msg, reply_markup=InlineKeyboardMarkup(hl_buttons), parse_mode="HTML")
    except BadRequest:
        pass


@log_calls
@require_access
async def on_deep_loss_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle deep loss position actions: close, enable DCA, or ignore"""
    q = update.callback_query
    await q.answer()
    
    uid = q.from_user.id
    t = ctx.t
    data = q.data  # Format: deep_loss:action:symbol
    
    parts = data.split(":")
    if len(parts) != 3:
        return
    
    _, action, symbol = parts
    
    if action == "close":
        # Close the position
        try:
            # Get position info
            positions = await fetch_open_positions(uid)
            pos = next((p for p in positions if p.get("symbol") == symbol), None)
            
            if not pos:
                await q.edit_message_text(
                    t.get('position_already_closed', "‚ùå –ü–æ–∑–∏—Ü–∏—è {symbol} —É–∂–µ –∑–∞–∫—Ä—ã—Ç–∞.").format(symbol=symbol),
                    parse_mode="HTML"
                )
                return
            
            side = pos.get("side")
            size = float(pos.get("size", 0))
            close_side = "Sell" if side == "Buy" else "Buy"
            
            # Place close order
            await place_order(
                user_id=uid,
                symbol=symbol,
                side=close_side,
                orderType="Market",
                qty=size,
                reduceOnly=True
            )
            
            await q.edit_message_text(
                t.get('deep_loss_closed', 
                    "‚úÖ –ü–æ–∑–∏—Ü–∏—è {symbol} –∑–∞–∫—Ä—ã—Ç–∞.\n\n"
                    "–£–±—ã—Ç–æ–∫ –∑–∞—Ñ–∏–∫—Å–∏—Ä–æ–≤–∞–Ω. –ò–Ω–æ–≥–¥–∞ –ª—É—á—à–µ –ø—Ä–∏–Ω—è—Ç—å –Ω–µ–±–æ–ª—å—à–æ–π —É–±—ã—Ç–æ–∫, —á–µ–º –Ω–∞–¥–µ—è—Ç—å—Å—è –Ω–∞ —Ä–∞–∑–≤–æ—Ä–æ—Ç."
                ).format(symbol=symbol),
                parse_mode="HTML"
            )
            
        except Exception as e:
            logger.error(f"Error closing deep loss position {symbol} for {uid}: {e}")
            await q.edit_message_text(
                t.get('deep_loss_close_error', "‚ùå –û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–∫—Ä—ã—Ç–∏–∏ –ø–æ–∑–∏—Ü–∏–∏: {error}").format(error=str(e)[:100]),
                parse_mode="HTML"
            )
    
    elif action == "dca":
        # Enable DCA for this symbol
        try:
            cfg = get_user_config(uid)
            
            # Check if DCA is already enabled globally
            dca_enabled = cfg.get("dca_enabled", 0)
            
            if dca_enabled:
                await q.edit_message_text(
                    t.get('dca_already_enabled',
                        "‚úÖ DCA –¥–æ–±–æ—Ä —É–∂–µ –≤–∫–ª—é—á–µ–Ω!\n\n"
                        "üìä <b>{symbol}</b>\n"
                        "–ë–æ—Ç –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è—Ç—å –∫ –ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–∏ –ø—Ä–æ—Å–∞–¥–∫–µ:\n"
                        "‚Ä¢ -10% ‚Üí –¥–æ–±–æ—Ä\n"
                        "‚Ä¢ -25% ‚Üí –¥–æ–±–æ—Ä\n\n"
                        "–≠—Ç–æ –ø–æ–º–æ–∂–µ—Ç —É—Å—Ä–µ–¥–Ω–∏—Ç—å —Ü–µ–Ω—É –≤—Ö–æ–¥–∞."
                    ).format(symbol=symbol),
                    parse_mode="HTML"
                )
            else:
                # Enable DCA globally
                set_user_field(uid, "dca_enabled", True)  # Use True for boolean column
                
                await q.edit_message_text(
                    t.get('dca_enabled_for_symbol',
                        "‚úÖ DCA –¥–æ–±–æ—Ä –≤–∫–ª—é—á–µ–Ω!\n\n"
                        "üìä <b>{symbol}</b>\n"
                        "–ë–æ—Ç –±—É–¥–µ—Ç –∞–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–∏ –¥–æ–±–∞–≤–ª—è—Ç—å –∫ –ø–æ–∑–∏—Ü–∏–∏ –ø—Ä–∏ –ø—Ä–æ—Å–∞–¥–∫–µ:\n"
                        "‚Ä¢ -10% ‚Üí –¥–æ–±–æ—Ä (—É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ)\n"
                        "‚Ä¢ -25% ‚Üí –¥–æ–±–æ—Ä (—É—Å—Ä–µ–¥–Ω–µ–Ω–∏–µ)\n\n"
                        "‚ö†Ô∏è DCA —Ç—Ä–µ–±—É–µ—Ç –¥–æ—Å—Ç–∞—Ç–æ—á–Ω—ã–π –±–∞–ª–∞–Ω—Å –¥–ª—è –¥–æ–±–æ—Ä–æ–≤.\n"
                        "–ù–∞—Å—Ç—Ä–æ–∏—Ç—å –ø–∞—Ä–∞–º–µ—Ç—Ä—ã: /strategy_settings"
                    ).format(symbol=symbol),
                    parse_mode="HTML"
                )
                
        except Exception as e:
            logger.error(f"Error enabling DCA for {symbol} for {uid}: {e}")
            await q.edit_message_text(
                t.get('dca_enable_error', "‚ùå –û—à–∏–±–∫–∞: {error}").format(error=str(e)[:100]),
                parse_mode="HTML"
            )
    
    elif action == "ignore":
        await q.edit_message_text(
            t.get('deep_loss_ignored',
                "üîá –ü–æ–Ω—è–ª, –ø–æ–∑–∏—Ü–∏—è {symbol} –æ—Å—Ç–∞–≤–ª–µ–Ω–∞ –±–µ–∑ –∏–∑–º–µ–Ω–µ–Ω–∏–π.\n\n"
                "‚ö†Ô∏è –ü–æ–º–Ω–∏—Ç–µ: –±–µ–∑ —Å—Ç–æ–ø-–ª–æ—Å—Å–∞ —Ä–∏—Å–∫ –ø–æ—Ç–µ—Ä—å –Ω–µ–æ–≥—Ä–∞–Ω–∏—á–µ–Ω.\n"
                "–í—ã –º–æ–∂–µ—Ç–µ –∑–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é –≤—Ä—É—á–Ω—É—é —á–µ—Ä–µ–∑ /positions"
            ).format(symbol=symbol),
            parse_mode="HTML"
        )


@log_calls
async def on_exchange_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle exchange switching callbacks"""
    q = update.callback_query
    await q.answer()
    
    uid = q.from_user.id
    data = q.data
    
    if data == "exchange:set_bybit":
        set_exchange_type(uid, "bybit")
        # Delete the inline message
        try:
            await q.delete_message()
        except Exception:
            pass
        # Send confirmation WITH updated keyboard in ONE message
        t = get_texts(uid)
        await ctx.bot.send_message(
            chat_id=uid,
            text="‚úÖ *Switched to Bybit*\n\nAll trading operations will now use Bybit.",
            parse_mode="Markdown",
            reply_markup=main_menu_keyboard(ctx, user_id=uid)
        )
    
    elif data == "exchange:set_hl":
        # Check if HL is configured - check BOTH legacy and multitenancy fields
        hl_creds = get_hl_credentials(uid)
        has_legacy = hl_creds.get("hl_wallet_address") or hl_creds.get("hl_private_key")
        has_mainnet = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_mainnet_wallet_address")
        has_testnet = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_testnet_wallet_address")
        
        if not has_legacy and not has_mainnet and not has_testnet:
            await q.edit_message_text(
                "‚ùå *HyperLiquid not configured*\n\n"
                "Please setup HyperLiquid first.",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üî∑ Setup HyperLiquid", callback_data="exchange:setup_hl")]
                ])
            )
            return
        
        set_exchange_type(uid, "hyperliquid")
        # Delete the inline message
        try:
            await q.delete_message()
        except Exception:
            pass
        # Send confirmation WITH updated keyboard in ONE message
        t = get_texts(uid)
        await ctx.bot.send_message(
            chat_id=uid,
            text="‚úÖ *Switched to HyperLiquid*\n\nAll trading operations will now use HyperLiquid DEX.",
            parse_mode="Markdown",
            reply_markup=main_menu_keyboard(ctx, user_id=uid)
        )
    
    elif data == "exchange:setup_hl":
        # Redirect to HyperLiquid setup
        keyboard = InlineKeyboardMarkup([
            [InlineKeyboardButton("üåê Mainnet", callback_data="hl:mainnet"),
             InlineKeyboardButton("üß™ Testnet", callback_data="hl:testnet")],
        ])
        await q.edit_message_text(
            "üî∑ *HyperLiquid Setup*\n\n"
            "Select network:\n\n"
            "‚Ä¢ *Mainnet* - Real trading with real funds\n"
            "‚Ä¢ *Testnet* - Practice with test funds\n\n"
            "After selecting, send your private key.",
            parse_mode="Markdown",
            reply_markup=keyboard
        )
    
    elif data == "exchange:switch":
        # Quick switch between configured exchanges
        current = get_exchange_type(uid)
        if current == "bybit":
            hl_creds = get_hl_credentials(uid)
            # Check BOTH legacy and multitenancy fields
            has_legacy = hl_creds.get("hl_wallet_address") or hl_creds.get("hl_private_key")
            has_mainnet = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_mainnet_wallet_address")
            has_testnet = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_testnet_wallet_address")
            
            if has_legacy or has_mainnet or has_testnet:
                set_exchange_type(uid, "hyperliquid")
                # Delete the inline message
                try:
                    await q.delete_message()
                except Exception:
                    pass
                # Send confirmation WITH updated keyboard in ONE message
                t = get_texts(uid)
                await ctx.bot.send_message(
                    chat_id=uid,
                    text="‚úÖ *Switched to HyperLiquid*\n\nAll trading operations will now use HyperLiquid DEX.",
                    parse_mode="Markdown",
                    reply_markup=main_menu_keyboard(ctx, user_id=uid)
                )
            else:
                await q.edit_message_text(
                    "‚ùå HyperLiquid not configured. Setup first.",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("üî∑ Setup HyperLiquid", callback_data="exchange:setup_hl")]
                    ])
                )
        else:
            set_exchange_type(uid, "bybit")
            # Delete the inline message
            try:
                await q.delete_message()
            except Exception:
                pass
            # Send confirmation WITH updated keyboard in ONE message
            t = get_texts(uid)
            await ctx.bot.send_message(
                chat_id=uid,
                text="‚úÖ *Switched to Bybit*\n\nAll trading operations will now use Bybit.",
                parse_mode="Markdown",
                reply_markup=main_menu_keyboard(ctx, user_id=uid)
            )
    
    elif data == "exchange:noop":
        pass  # Do nothing, already on this exchange
    
    elif data == "exchange:toggle_bybit":
        # Toggle Bybit enabled status
        current_enabled = db.is_bybit_enabled(uid)
        db.set_bybit_enabled(uid, not current_enabled)
        new_status = "‚úÖ enabled" if not current_enabled else "‚ùå disabled"
        
        await q.edit_message_text(
            f"üü† *Bybit Trading: {new_status}*\n\n"
            f"{'Bybit will now receive trading signals.' if not current_enabled else 'Bybit will NOT receive trading signals. Only HyperLiquid will be used.'}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô Back to Exchange Settings", callback_data="exchange:settings")]
            ])
        )
    
    elif data == "exchange:toggle_hl":
        # Toggle HyperLiquid enabled status
        current_enabled = db.is_hl_enabled(uid)
        db.set_hl_enabled(uid, not current_enabled)
        new_status = "‚úÖ enabled" if not current_enabled else "‚ùå disabled"
        
        await q.edit_message_text(
            f"üî∑ *HyperLiquid Trading: {new_status}*\n\n"
            f"{'HyperLiquid will now receive trading signals.' if not current_enabled else 'HyperLiquid will NOT receive trading signals. Only Bybit will be used.'}",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("üîô Back to Exchange Settings", callback_data="exchange:settings")]
            ])
        )
    
    elif data == "exchange:settings":
        # Show exchange settings menu with toggle buttons
        bybit_enabled = db.is_bybit_enabled(uid)
        hl_enabled = db.is_hl_enabled(uid)
        current_exchange = get_exchange_type(uid)
        
        # Check if credentials are configured
        creds = get_all_user_credentials(uid) or {}
        hl_creds = db.get_hl_credentials(uid) or {}
        
        bybit_configured = bool(creds.get("demo_api_key") or creds.get("real_api_key"))
        hl_configured = bool(
            hl_creds.get("hl_testnet_private_key") or 
            hl_creds.get("hl_mainnet_private_key") or 
            hl_creds.get("hl_private_key")
        )
        
        bybit_status = "‚úÖ ON" if bybit_enabled else "‚ùå OFF"
        hl_status = "‚úÖ ON" if hl_enabled else "‚ùå OFF"
        
        text = (
            "‚öôÔ∏è *Exchange Settings*\n\n"
            f"*Active Exchange:* {'üî∑ HyperLiquid' if current_exchange == 'hyperliquid' else 'üü† Bybit'}\n\n"
            "*Trading Status:*\n"
            f"‚Ä¢ üü† Bybit: {bybit_status} {'(configured)' if bybit_configured else '(not configured)'}\n"
            f"‚Ä¢ üî∑ HyperLiquid: {hl_status} {'(configured)' if hl_configured else '(not configured)'}\n\n"
            "_Toggle trading on each exchange below._\n"
            "_‚ö†Ô∏è Even if API keys are set, you can disable trading on an exchange._"
        )
        
        keyboard = []
        
        # Bybit toggle button
        if bybit_configured:
            bybit_btn_text = f"üü† Bybit: {'‚úÖ ON ‚Üí Turn OFF' if bybit_enabled else '‚ùå OFF ‚Üí Turn ON'}"
            keyboard.append([InlineKeyboardButton(bybit_btn_text, callback_data="exchange:toggle_bybit")])
        else:
            keyboard.append([InlineKeyboardButton("üü† Bybit: ‚ö†Ô∏è Not configured", callback_data="api:settings")])
        
        # HyperLiquid toggle button
        if hl_configured:
            hl_btn_text = f"üî∑ HyperLiquid: {'‚úÖ ON ‚Üí Turn OFF' if hl_enabled else '‚ùå OFF ‚Üí Turn ON'}"
            keyboard.append([InlineKeyboardButton(hl_btn_text, callback_data="exchange:toggle_hl")])
        else:
            keyboard.append([InlineKeyboardButton("üî∑ HyperLiquid: ‚ö†Ô∏è Not configured", callback_data="api:hl_settings")])
        
        keyboard.append([InlineKeyboardButton("‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ‚îÄ", callback_data="noop")])
        keyboard.append([InlineKeyboardButton("üîë API Settings", callback_data="api:settings")])
        keyboard.append([InlineKeyboardButton("üìà Strategy Settings", callback_data="strat_set:back")])
        keyboard.append([InlineKeyboardButton("üîô Back", callback_data="main_menu")])
        
        await q.edit_message_text(
            text,
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup(keyboard)
        )
    
    elif data == "exchange:toggle_bybit":
        # Toggle Bybit trading enabled/disabled
        current = db.is_bybit_enabled(uid)
        new_val = not current
        db.set_bybit_enabled(uid, new_val)
        
        status = "‚úÖ ON" if new_val else "‚ùå OFF"
        await q.answer(f"Bybit Trading: {status}", show_alert=False)
        
        # Refresh exchange settings menu
        # Recursively handle exchange:settings
        q.data = "exchange:settings"
        return await on_exchange_callback(update, ctx)
    
    elif data == "exchange:toggle_hl":
        # Toggle HyperLiquid trading enabled/disabled
        current = db.is_hl_enabled(uid)
        new_val = not current
        db.set_hl_enabled(uid, new_val)
        
        status = "‚úÖ ON" if new_val else "‚ùå OFF"
        await q.answer(f"HyperLiquid Trading: {status}", show_alert=False)
        
        # Refresh exchange settings menu
        q.data = "exchange:settings"
        return await on_exchange_callback(update, ctx)
    
    elif data == "main_menu":
        t = get_texts(uid)
        # Delete the inline message and send new message with main menu keyboard
        try:
            await q.message.delete()
        except Exception:
            pass
        # Send fresh main menu
        await ctx.bot.send_message(
            chat_id=uid,
            text=t.get("main_menu_welcome", "üè† *Main Menu*\n\nUse buttons below to navigate."),
            parse_mode="Markdown",
            reply_markup=main_menu_keyboard(ctx, user_id=uid)
        )
        return


def _build_bybit_status_keyboard(uid: int, t: dict) -> tuple[str, InlineKeyboardMarkup]:
    """Build Bybit status text and keyboard.
    
    SIMPLIFIED: Trading mode is now per-strategy in ‚öôÔ∏è Strategies menu.
    This screen only shows exchange status and links to API Keys settings.
    
    Returns: (text, keyboard)
    """
    status = get_exchange_status(uid)
    bybit_info = status.get("bybit", {})
    hl_info = status.get("hyperliquid", {})
    bybit_enabled = db.is_bybit_enabled(uid)
    
    text = "üü† *Bybit*\n\n"
    keyboard = []
    
    if bybit_info.get("configured"):
        has_demo = bybit_info.get("demo", False)
        has_real = bybit_info.get("real", False)
        
        # Show configured accounts
        text += f"üß™ Demo: {'‚úÖ Configured' if has_demo else '‚ùå Not set'}\n"
        text += f"üíº Real: {'‚úÖ Configured' if has_real else '‚ùå Not set'}\n\n"
        
        # Show trading status
        text += f"üìä Trading: {'üü¢ ON' if bybit_enabled else 'üî¥ OFF'}\n\n"
        
        # Info about per-strategy mode
        text += "_üí° Trading mode (Demo/Real/Both) is configured per-strategy in ‚öôÔ∏è Strategies menu_"
        
        # Link to API Keys for detailed settings
        keyboard.append([InlineKeyboardButton("üîë API Keys Settings", callback_data="api:settings")])
    else:
        text += "‚ùå Not configured\n\n_Press üîë API Keys to set up_"
        keyboard.append([InlineKeyboardButton("üîë Setup API Keys", callback_data="api:settings")])
    
    # Switch to HyperLiquid
    if hl_info.get("configured"):
        keyboard.append([InlineKeyboardButton("üîÑ Switch to üî∑ HyperLiquid", callback_data="exchange:set_hl")])
    
    keyboard.append([InlineKeyboardButton(t.get("button_back", "‚Üê –ù–∞–∑–∞–¥"), callback_data="main_menu")])
    
    return text, InlineKeyboardMarkup(keyboard)


@log_calls
@with_texts
async def on_bybit_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle Bybit callbacks - now redirects to strategy settings for mode changes.
    
    DEPRECATED: Mode switching moved to per-strategy settings.
    These handlers remain for backwards compatibility with old cached buttons.
    """
    q = update.callback_query
    await q.answer()
    
    uid = q.from_user.id
    data = q.data
    t = ctx.t
    
    # All mode switches now redirect to strategies menu
    if data in ("bybit:mode_demo", "bybit:mode_real", "bybit:mode_both"):
        await q.edit_message_text(
            "‚ÑπÔ∏è *Trading mode –Ω–∞—Å—Ç—Ä–∞–∏–≤–∞–µ—Ç—Å—è —Ç–µ–ø–µ—Ä—å –¥–ª—è –∫–∞–∂–¥–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –æ—Ç–¥–µ–ª—å–Ω–æ.*\n\n"
            "–ù–∞–∂–º–∏—Ç–µ –∫–Ω–æ–ø–∫—É üéÆ/üíµ/üîÄ –Ω–∞–ø—Ä–æ—Ç–∏–≤ –Ω—É–∂–Ω–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –≤ –º–µ–Ω—é *‚öôÔ∏è Strategies*.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚öôÔ∏è Open Strategies", callback_data="strat_set:back")],
                [InlineKeyboardButton(t.get("button_back", "‚Üê –ù–∞–∑–∞–¥"), callback_data="main_menu")]
            ])
        )
        return
    
    elif data in ("bybit:confirm_real", "bybit:confirm_both"):
        # Legacy confirmation - still enable live trading and redirect
        set_live_enabled(uid, True)
        logger.info(f"[{uid}] User confirmed REAL trading via legacy handler - live_enabled=True")
        await q.edit_message_text(
            "‚úÖ *Real —Ç–æ—Ä–≥–æ–≤–ª—è –ø–æ–¥—Ç–≤–µ—Ä–∂–¥–µ–Ω–∞!*\n\n"
            "–¢–µ–ø–µ—Ä—å –Ω–∞—Å—Ç—Ä–æ–π—Ç–µ —Ä–µ–∂–∏–º –¥–ª—è –∫–∞–∂–¥–æ–π —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –≤ –º–µ–Ω—é *‚öôÔ∏è Strategies*.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚öôÔ∏è Open Strategies", callback_data="strat_set:back")],
                [InlineKeyboardButton(t.get("button_back", "‚Üê –ù–∞–∑–∞–¥"), callback_data="main_menu")]
            ])
        )
        return
    
    elif data in ("bybit:cancel_real", "bybit:back_to_menu"):
        # User cancelled - go back to exchange status
        text, keyboard = _build_bybit_status_keyboard(uid, t)
        await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)


@log_calls
@with_texts
async def on_hl_balance_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle HyperLiquid balance network switching callbacks (hl_bal:testnet, hl_bal:mainnet)"""
    q = update.callback_query
    await q.answer()
    
    uid = q.from_user.id
    data = q.data
    t = ctx.t
    
    # hl_bal:testnet or hl_bal:mainnet
    network = data.split(":")[1]
    is_testnet = (network == "testnet")
    
    hl_creds = get_hl_credentials(uid)
    
    # Get credentials for specific network
    if is_testnet:
        private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
    else:
        private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
    
    if not private_key:
        await q.edit_message_text(
            f"‚ùå HyperLiquid {'Testnet' if is_testnet else 'Mainnet'} not configured.",
            parse_mode="Markdown"
        )
        return
    
    adapter = None
    try:
        # Get wallet address for balance queries
        if is_testnet:
            wallet_address = hl_creds.get("hl_testnet_wallet_address") or hl_creds.get("hl_wallet_address")
        else:
            wallet_address = hl_creds.get("hl_mainnet_wallet_address") or hl_creds.get("hl_wallet_address")
        
        adapter = HLAdapter(
            private_key=private_key,
            testnet=is_testnet
            # main_wallet_address auto-discovered via userRole API
        )
        await adapter.initialize()  # Trigger auto-discovery
        
        result = await adapter.get_balance()
        show_switcher = db.should_show_hl_network_switcher(uid)
        
        # Build keyboard
        keyboard_rows = []
        if show_switcher:
            keyboard_rows.append([
                InlineKeyboardButton("üß™ Testnet" + (" ‚úì" if is_testnet else ""), callback_data="hl_bal:testnet"),
                InlineKeyboardButton("üåê Mainnet" + (" ‚úì" if not is_testnet else ""), callback_data="hl_bal:mainnet")
            ])
        keyboard_rows.append([InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data="menu:main")])
        keyboard = InlineKeyboardMarkup(keyboard_rows)
        
        network_label = "üß™ Testnet" if is_testnet else "üåê Mainnet"
        
        if result.get("success"):
            data = result.get("data", {})
            equity = float(data.get("equity", 0))
            available = float(data.get("available", 0))
            margin_used = float(data.get("margin_used", 0))
            total_notional = float(data.get("total_notional", 0))
            unrealized_pnl = float(data.get("unrealized_pnl", 0))
            position_value = float(data.get("position_value", 0))
            num_positions = int(data.get("num_positions", 0))
            currency = data.get("currency", "USDC")
            
            pnl_emoji = "üü¢" if unrealized_pnl >= 0 else "üî¥"
            
            # Calculate margin level if margin used > 0
            margin_level = ""
            if margin_used > 0:
                level_pct = (equity / margin_used) * 100
                margin_level = f"\nüìê *Margin Level:* {level_pct:.1f}%"
            
            # Get SPOT balance
            spot_section = ""
            try:
                spot_result = await adapter.get_spot_balance()
                if spot_result.get("success"):
                    spot_data = spot_result.get("data", {})
                    spot_tokens = spot_data.get("tokens", [])
                    spot_total = float(spot_data.get("total_usd_value", 0))
                    
                    if spot_tokens:
                        spot_section = f"\n\nüõí *Spot Balance:* ${spot_total:,.2f}"
                        for tok in spot_tokens[:5]:
                            token_name = tok.get("token", "?")
                            token_total = tok.get("total", 0)
                            token_usd = tok.get("usd_value", 0)
                            spot_section += f"\n  ‚Ä¢ {token_name}: {token_total:,.4f} (${token_usd:,.2f})"
                        if equity == 0 and spot_total > 0:
                            spot_section += f"\n\n‚ö†Ô∏è _–î–µ–Ω—å–≥–∏ –Ω–∞ Spot! –ü–µ—Ä–µ–≤–µ–¥–∏ –Ω–∞ Perp –¥–ª—è —Ç–æ—Ä–≥–æ–≤–ª–∏._"
            except Exception as spot_err:
                logger.debug(f"Spot balance fetch error: {spot_err}")
            
            text = f"""
üí∞ *HyperLiquid Balance* {network_label}

üíé *Perp Equity:* ${equity:,.2f} {currency}
‚úÖ *Available for Trading:* ${available:,.2f} {currency}
üìä *Margin Used:* ${margin_used:,.2f} {currency}{margin_level}

üì¶ *Positions:*
  ‚Ä¢ Active: {num_positions} positions
  ‚Ä¢ Notional Value: ${total_notional:,.2f}
  ‚Ä¢ Position Value: ${position_value:,.2f}

{pnl_emoji} *Unrealized PnL:* ${unrealized_pnl:,.2f} {currency}{spot_section}
"""
            await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
        else:
            await q.edit_message_text(
                f"‚ùå Error fetching balance: {result.get('error', 'Unknown error')}",
                parse_mode="Markdown",
                reply_markup=keyboard
            )
    except Exception as e:
        logger.error(f"HL balance callback error: {e}")
        await q.edit_message_text(f"‚ùå Error: {str(e)}", parse_mode="Markdown")
    finally:
        if adapter:
            await adapter.close()


@log_calls
@with_texts
async def on_hl_positions_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle HyperLiquid positions network switch callbacks"""
    q = update.callback_query
    await q.answer()
    
    uid = q.from_user.id
    data = q.data
    t = ctx.t
    
    # hl_pos:testnet or hl_pos:mainnet
    network = data.split(":")[1]
    is_testnet = (network == "testnet")
    
    hl_creds = get_hl_credentials(uid)
    
    # Get credentials for specific network
    if is_testnet:
        private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
        wallet_address = hl_creds.get("hl_testnet_wallet_address") or hl_creds.get("hl_wallet_address")
    else:
        private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
        wallet_address = hl_creds.get("hl_mainnet_wallet_address") or hl_creds.get("hl_wallet_address")
    
    if not private_key:
        await q.edit_message_text(
            f"‚ùå HyperLiquid {'Testnet' if is_testnet else 'Mainnet'} not configured.",
            parse_mode="Markdown"
        )
        return
    
    adapter = None
    try:
        adapter = HLAdapter(
            private_key=private_key,
            testnet=is_testnet
            # main_wallet_address auto-discovered via userRole API
        )
        await adapter.initialize()  # Trigger auto-discovery
        
        result = await adapter.fetch_positions()
        show_switcher = db.should_show_hl_network_switcher(uid)
        
        # Build keyboard
        keyboard_rows = []
        if show_switcher:
            keyboard_rows.append([
                InlineKeyboardButton("üß™ Testnet" + (" ‚úì" if is_testnet else ""), callback_data="hl_pos:testnet"),
                InlineKeyboardButton("üåê Mainnet" + (" ‚úì" if not is_testnet else ""), callback_data="hl_pos:mainnet")
            ])
        keyboard_rows.append([InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data="menu:main")])
        keyboard = InlineKeyboardMarkup(keyboard_rows)
        
        network_label = "üß™ Testnet" if is_testnet else "üåê Mainnet"
        
        if result.get("retCode") == 0:
            positions = result.get("result", {}).get("list", [])
            
            if not positions:
                text = f"üìà *HyperLiquid Positions* {network_label}\n\nüì≠ No open positions."
                await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
                return
            
            lines = [f"üìà *HyperLiquid Positions* {network_label}\n"]
            
            for pos in positions[:10]:
                symbol = pos.get("symbol", "?")
                side = pos.get("side", "?")
                size = float(pos.get("size", 0))
                entry = float(pos.get("entryPrice", 0))
                pnl = float(pos.get("unrealisedPnl", 0))
                leverage = pos.get("leverage", "?")
                
                side_emoji = "üü¢ LONG" if side == "Buy" else "üî¥ SHORT"
                pnl_emoji = "+" if pnl >= 0 else ""
                
                lines.append(
                    f"{side_emoji} *{symbol}* {leverage}x\n"
                    f"   Size: {size} | Entry: ${entry:,.4f}\n"
                    f"   PnL: {pnl_emoji}${pnl:,.2f}\n"
                )
            
            await q.edit_message_text("\n".join(lines), parse_mode="Markdown", reply_markup=keyboard)
        else:
            await q.edit_message_text(
                f"‚ùå Failed to fetch positions: {result.get('retMsg', 'Unknown error')}",
                parse_mode="Markdown"
            )
    except Exception as e:
        logger.error(f"HL positions callback error: {e}")
        await q.edit_message_text(f"‚ùå Error: {str(e)}", parse_mode="Markdown")
    finally:
        if adapter:
            await adapter.close()


@log_calls
@with_texts
async def on_hl_orders_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle HyperLiquid orders network switch callbacks"""
    q = update.callback_query
    await q.answer()
    
    uid = q.from_user.id
    data = q.data
    t = ctx.t
    
    # hl_ord:testnet or hl_ord:mainnet
    network = data.split(":")[1]
    is_testnet = (network == "testnet")
    
    hl_creds = get_hl_credentials(uid)
    
    # Get credentials for specific network
    if is_testnet:
        private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
        wallet_address = hl_creds.get("hl_testnet_wallet_address") or hl_creds.get("hl_wallet_address")
    else:
        private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
        wallet_address = hl_creds.get("hl_mainnet_wallet_address") or hl_creds.get("hl_wallet_address")
    
    if not private_key:
        await q.edit_message_text(
            f"‚ùå HyperLiquid {'Testnet' if is_testnet else 'Mainnet'} not configured.",
            parse_mode="Markdown"
        )
        return
    
    adapter = None
    try:
        adapter = HLAdapter(
            private_key=private_key,
            testnet=is_testnet
            # main_wallet_address auto-discovered via userRole API
        )
        await adapter.initialize()  # Trigger auto-discovery
        
        result = await adapter.fetch_open_orders()
        show_switcher = db.should_show_hl_network_switcher(uid)
        
        # Build keyboard
        keyboard_rows = []
        if show_switcher:
            keyboard_rows.append([
                InlineKeyboardButton("üß™ Testnet" + (" ‚úì" if is_testnet else ""), callback_data="hl_ord:testnet"),
                InlineKeyboardButton("üåê Mainnet" + (" ‚úì" if not is_testnet else ""), callback_data="hl_ord:mainnet")
            ])
        keyboard_rows.append([InlineKeyboardButton(t.get('btn_back', 'üîô Back'), callback_data="menu:main")])
        keyboard = InlineKeyboardMarkup(keyboard_rows)
        
        network_label = "üß™ Testnet" if is_testnet else "üåê Mainnet"
        
        if result.get("success"):
            orders = result.get("data", [])
            
            if not orders:
                text = f"üìà *HyperLiquid Orders* {network_label}\n\nüì≠ No open orders."
                await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)
                return
            
            lines = [f"üìà *HyperLiquid Open Orders* {network_label}\n"]
            
            for order in orders[:10]:
                symbol = order.get("symbol", "?")
                side = order.get("side", "?")
                size = float(order.get("size", 0))
                price = float(order.get("price", 0))
                order_type = order.get("order_type", "?")
                
                side_emoji = "üü¢ BUY" if side == "Buy" else "üî¥ SELL"
                
                lines.append(
                    f"{side_emoji} *{symbol}*\n"
                    f"   {order_type} | Size: {size} @ ${price:,.4f}\n"
                )
            
            await q.edit_message_text("\n".join(lines), parse_mode="Markdown", reply_markup=keyboard)
        else:
            await q.edit_message_text(
                f"‚ùå Failed to fetch orders: {result.get('error', 'Unknown error')}",
                parse_mode="Markdown"
            )
    except Exception as e:
        logger.error(f"HL orders callback error: {e}")
        await q.edit_message_text(f"‚ùå Error: {str(e)}", parse_mode="Markdown")
    finally:
        if adapter:
            await adapter.close()


@log_calls
@with_texts
async def on_hl_history_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle HyperLiquid history network switching callbacks (hl_hist:testnet, hl_hist:mainnet).
    Now delegates to unified stats flow ‚Äî same UI as Bybit History.
    """
    q = update.callback_query
    await q.answer()

    uid = q.from_user.id
    data = q.data
    t = ctx.t

    # hl_hist:testnet or hl_hist:mainnet ‚Üí use unified stats with selected account_type
    network = data.split(":")[1]  # "testnet" or "mainnet"
    account_type = network  # directly usable as account_type

    logger.info(f"[{uid}] HL history callback ‚Üí unified stats, account_type={account_type}")

    # Render unified stats view (same as Bybit)
    user_exchange = db.get_exchange_type(uid) or "hyperliquid"
    stats = get_trade_stats(uid, strategy=None, period="all", account_type=account_type, exchange=user_exchange)

    period_label = t.get('stats_period_all', 'All time')

    unrealized_pnl = 0.0
    try:
        unrealized_pnl = await get_unrealized_pnl(uid, strategy=None, account_type=account_type)
    except Exception:
        pass

    text = await format_trade_stats(stats, t, strategy_name="all", period_label=period_label, unrealized_pnl=unrealized_pnl, uid=uid, account_type=account_type, period="all", api_pnl=None)
    keyboard = get_stats_keyboard(t, current_strategy="all", current_period="all", current_account=account_type, exchange=user_exchange)

    await q.edit_message_text(text, parse_mode="Markdown", reply_markup=keyboard)


@log_calls
@with_texts
async def on_hl_callback(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle HyperLiquid callbacks"""
    q = update.callback_query
    await q.answer()
    
    uid = q.from_user.id
    data = q.data
    
    if data == "hl:mainnet":
        # Check if user already has HL configured - just switch network
        hl_creds = get_hl_credentials(uid)
        if hl_creds.get("hl_private_key"):
            # Already configured, just switch to mainnet
            set_hl_credentials(uid, 
                private_key=hl_creds.get("hl_private_key"),
                testnet=False
            )
            # Auto-enable HL trading
            set_hl_enabled(uid, True)
            # Delete inline message
            try:
                await q.delete_message()
            except Exception:
                pass
            # Send confirmation WITH keyboard in ONE message
            await ctx.bot.send_message(
                chat_id=uid,
                text="üåê *Switched to Mainnet*\n\n‚ö†Ô∏è Now trading with real funds!",
                parse_mode="Markdown",
                reply_markup=main_menu_keyboard(ctx, user_id=uid)
            )
            return
        
        # New setup - 2-step flow
        _hl_awaiting_input[uid] = {"step": "private_key", "testnet": False}
        await q.edit_message_text(
            "üåê *HyperLiquid Mainnet Setup (Step 1/2)*\n\n"
            "*Step 1:* Send your *API Wallet Private Key*\n\n"
            "üí° *How to get it:*\n"
            "1. Go to app.hyperliquid.xyz/API\n"
            "2. Create an API Wallet (give it a name)\n"
            "3. Click 'Generate' to create private key\n"
            "4. Copy the private key and send it here\n\n"
            "‚ö†Ô∏è *Security:* API Wallet can trade but cannot withdraw!\n\n"
            "Send /cancel to abort.",
            parse_mode="Markdown"
        )
    
    elif data == "hl:testnet":
        # Check if user already has HL configured - just switch network
        hl_creds = get_hl_credentials(uid)
        if hl_creds.get("hl_private_key"):
            # Already configured, just switch to testnet
            set_hl_credentials(uid, 
                private_key=hl_creds.get("hl_private_key"),
                testnet=True
            )
            # Auto-enable HL trading
            set_hl_enabled(uid, True)
            # Delete inline message
            try:
                await q.delete_message()
            except Exception:
                pass
            # Send confirmation WITH keyboard in ONE message
            await ctx.bot.send_message(
                chat_id=uid,
                text="üß™ *Switched to Testnet*\n\nSafe for practice trading!",
                parse_mode="Markdown",
                reply_markup=main_menu_keyboard(ctx, user_id=uid)
            )
            return
        
        # New setup - 2-step flow
        _hl_awaiting_input[uid] = {"step": "private_key", "testnet": True}
        await q.edit_message_text(
            "üß™ *HyperLiquid Testnet Setup (Step 1/2)*\n\n"
            "*Step 1:* Send your *API Wallet Private Key*\n\n"
            "üí° *How to get it:*\n"
            "1. Go to app.hyperliquid.xyz/API\n"
            "2. Create an API Wallet (give it a name)\n"
            "3. Click 'Generate' to create private key\n"
            "4. Copy the private key and send it here\n\n"
            "‚ö†Ô∏è *Security:* API Wallet can trade but cannot withdraw!\n\n"
            "Send /cancel to abort.",
            parse_mode="Markdown"
        )
    
    elif data == "hl:balance":
        hl_creds = get_hl_credentials(uid)
        is_testnet = hl_creds.get("hl_testnet", False)
        
        # Get correct private key and wallet_address for network (multitenancy)
        if is_testnet:
            hl_private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
            wallet_address = hl_creds.get("hl_testnet_wallet_address") or hl_creds.get("hl_wallet_address")
        else:
            hl_private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
            wallet_address = hl_creds.get("hl_mainnet_wallet_address") or hl_creds.get("hl_wallet_address")
        
        if not hl_private_key:
            await q.edit_message_text(
                f"‚ùå HyperLiquid {'Testnet' if is_testnet else 'Mainnet'} not configured.",
                parse_mode="Markdown"
            )
            return
        
        adapter = None
        try:
            adapter = HLAdapter(
                private_key=hl_private_key,
                testnet=is_testnet
                # main_wallet_address auto-discovered via userRole API
            )
            await adapter.initialize()  # Trigger auto-discovery
            result = await adapter.get_balance()
            
            if result.get("success"):
                data_balance = result.get("data", {})
                equity = float(data_balance.get("equity", 0))
                available = float(data_balance.get("available", 0))
                unrealized_pnl = float(data_balance.get("unrealized_pnl", 0))
                
                pnl_emoji = "üü¢" if unrealized_pnl >= 0 else "üî¥"
                network = "üß™ Testnet" if is_testnet else "üåê Mainnet"
                
                await q.edit_message_text(
                    f"üí∞ *HyperLiquid Balance* {network}\n\n"
                    f"üíé *Equity:* ${equity:,.2f}\n"
                    f"üíµ *Available:* ${available:,.2f}\n"
                    f"{pnl_emoji} *Unrealized PnL:* ${unrealized_pnl:,.2f}",
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="hl:menu")]
                    ])
                )
            else:
                await q.edit_message_text(f"‚ùå Error: {result.get('error')}")
        except Exception as e:
            await q.edit_message_text(f"‚ùå Error: {str(e)}")
        finally:
            if adapter:
                await adapter.close()
    
    elif data == "hl:positions":
        hl_creds = get_hl_credentials(uid)
        is_testnet = hl_creds.get("hl_testnet", False)
        
        # Get correct private key for network (multitenancy)
        if is_testnet:
            hl_private_key = hl_creds.get("hl_testnet_private_key") or hl_creds.get("hl_private_key")
        else:
            hl_private_key = hl_creds.get("hl_mainnet_private_key") or hl_creds.get("hl_private_key")
        
        if not hl_private_key:
            await q.edit_message_text(
                f"‚ùå HyperLiquid {'Testnet' if is_testnet else 'Mainnet'} not configured.",
                parse_mode="Markdown"
            )
            return
        
        adapter = None
        try:
            adapter = HLAdapter(
                private_key=hl_private_key,
                testnet=is_testnet
                # vault_address auto-discovered via initialize()
            )
            result = await adapter.fetch_positions()
            
            if result.get("success"):
                positions = result.get("data", [])
                if not positions:
                    text = "üì≠ No open positions."
                else:
                    lines = ["üìà *Positions*\n"]
                    for pos in positions[:5]:
                        symbol = pos.get("symbol", "?")
                        side = "üü¢" if pos.get("side") == "Buy" else "üî¥"
                        pnl = float(pos.get("unrealized_pnl", 0))
                        lines.append(f"{side} {symbol}: ${pnl:+,.2f}")
                    text = "\n".join(lines)
                
                await q.edit_message_text(
                    text,
                    parse_mode="Markdown",
                    reply_markup=InlineKeyboardMarkup([
                        [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="hl:menu")]
                    ])
                )
            else:
                await q.edit_message_text(f"‚ùå Error: {result.get('error')}")
        except Exception as e:
            await q.edit_message_text(f"‚ùå Error: {str(e)}")
        finally:
            if adapter:
                await adapter.close()
    
    elif data == "hl:switch":
        current = get_exchange_type(uid)
        new_exchange = "hyperliquid" if current == "bybit" else "bybit"
        set_exchange_type(uid, new_exchange)
        
        await q.edit_message_text(
            f"‚úÖ Switched to *{new_exchange.upper()}*",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="hl:menu")]
            ])
        )
    
    elif data == "hl:network":
        hl_creds = get_hl_credentials(uid)
        current_testnet = hl_creds.get("hl_testnet", False)
        new_testnet = not current_testnet
        
        # With new multitenancy architecture, we just toggle the hl_testnet flag
        # Each network has its own credentials stored separately
        from core.db_postgres import get_conn
        with get_conn() as conn:
            conn.execute("""
                UPDATE users SET hl_testnet = ? WHERE user_id = ?
            """, (new_testnet, uid))
            conn.commit()
        db.invalidate_user_cache(uid)
        
        network = "Testnet" if new_testnet else "Mainnet"
        await q.edit_message_text(
            f"‚úÖ Switched to *{network}*",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚¨ÖÔ∏è Back", callback_data="hl:menu")]
            ])
        )
    
    elif data == "hl:disconnect":
        await q.edit_message_text(
            "‚ö†Ô∏è *Disconnect HyperLiquid?*\n\n"
            "This will remove your private key and switch back to Bybit.",
            parse_mode="Markdown",
            reply_markup=InlineKeyboardMarkup([
                [InlineKeyboardButton("‚úÖ Yes, Disconnect", callback_data="hl:confirm_disconnect")],
                [InlineKeyboardButton("‚ùå Cancel", callback_data="hl:menu")]
            ])
        )
    
    elif data == "hl:confirm_disconnect":
        clear_hl_credentials(uid)
        set_exchange_type(uid, "bybit")
        await q.edit_message_text(
            "‚úÖ HyperLiquid disconnected.\nSwitched to Bybit.",
            parse_mode="Markdown"
        )
    
    elif data == "hl:menu":
        # Re-show main menu
        hl_creds = get_hl_credentials(uid)
        is_configured = bool(hl_creds.get("hl_private_key"))
        exchange = get_exchange_type(uid)
        network = "Testnet" if hl_creds.get("hl_testnet") else "Mainnet"
        
        if is_configured:
            addr = hl_creds.get("hl_address", "")[:10] + "..." if hl_creds.get("hl_address") else "N/A"
            buttons = [
                [InlineKeyboardButton("üí∞ Balance", callback_data="hl:balance"),
                 InlineKeyboardButton("üìà Positions", callback_data="hl:positions")],
                [InlineKeyboardButton("üîÑ Switch to HL" if exchange == "bybit" else "üîÑ Switch to Bybit", 
                                    callback_data="hl:switch")],
                [InlineKeyboardButton("üåê Testnet" if not hl_creds.get("hl_testnet") else "üåê Mainnet",
                                    callback_data="hl:network")],
                [InlineKeyboardButton("‚ùå Disconnect", callback_data="hl:disconnect")],
            ]
            await q.edit_message_text(
                f"üîó *HyperLiquid DEX*\n\n"
                f"üìä *Status:* ‚úÖ Connected\n"
                f"üåê *Network:* {network}\n"
                f"üëõ *Wallet:* `{addr}`\n"
                f"üîÑ *Active:* {exchange.upper()}",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup(buttons)
            )
        else:
            await q.edit_message_text(
                "üîó *HyperLiquid DEX*\n\nNot connected.",
                parse_mode="Markdown",
                reply_markup=InlineKeyboardMarkup([
                    [InlineKeyboardButton("üåê Mainnet", callback_data="hl:mainnet"),
                     InlineKeyboardButton("üß™ Testnet", callback_data="hl:testnet")],
                ])
            )
    
    elif data == "hl:setkey":
        hl_creds = get_hl_credentials(uid)
        is_testnet = hl_creds.get("hl_testnet", False)
        _hl_awaiting_input[uid] = {"step": "private_key", "testnet": is_testnet}
        network = "Testnet" if is_testnet else "Mainnet"
        await q.edit_message_text(
            f"üî∑ *Update HyperLiquid {network} (Step 1/2)*\n\n"
            "*Step 1:* Send your *API Wallet Private Key*\n\n"
            "üí° *How to get it:*\n"
            "1. Go to app.hyperliquid.xyz/API\n"
            "2. Create an API Wallet (give it a name)\n"
            "3. Click 'Generate' to create private key\n"
            "4. Copy the private key and send it here\n\n"
            "Send /cancel to abort.",
            parse_mode="Markdown"
        )


async def handle_hl_strategy_param(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> bool:
    """Handle HL strategy parameter input. Returns True if handled."""
    uid = update.effective_user.id
    
    if uid not in _awaiting_hl_param:
        return False
    
    # Get translations
    cfg = get_user_config(uid)
    lang = cfg.get("lang", DEFAULT_LANG)
    t = LANGS.get(lang, LANGS[DEFAULT_LANG])
    
    text = update.message.text.strip()
    
    # Cancel
    if text.lower() == "/cancel":
        del _awaiting_hl_param[uid]
        await update.message.reply_text(t.get("cancelled", "‚ùå Cancelled."))
        return True
    
    try:
        value = float(text)
    except ValueError:
        await update.message.reply_text(t.get("invalid_number", "‚ùå Please enter a valid number."))
        return True
    
    info = _awaiting_hl_param[uid]
    strategy = info["strategy"]
    param = info["param"]
    
    # Import MAX_ENTRY_PERCENT for validation
    from coin_params import MAX_ENTRY_PERCENT
    
    # Validate ranges
    if param == "hl_percent" and (value <= 0 or value > MAX_ENTRY_PERCENT):
        await update.message.reply_text(t.get("entry_pct_range_error", f"‚ùå Entry % must be between 0.1 and {MAX_ENTRY_PERCENT}% (risk management limit)."))
        return True
    if param in ["hl_sl_percent", "hl_tp_percent"] and (value <= 0 or value > 500):
        await update.message.reply_text(t.get("sl_tp_range_error", "‚ùå SL/TP % must be between 0.1 and 500."))
        return True
    if param == "hl_leverage" and (value < 1 or value > 100):
        await update.message.reply_text(t.get("leverage_range_error", "‚ùå Leverage must be between 1 and 100."))
        return True
    
    # Save the value
    if param == "hl_leverage":
        value = int(value)
    db.set_hl_strategy_setting(uid, strategy, param, value)
    
    del _awaiting_hl_param[uid]
    
    strat_name = STRATEGY_NAMES_MAP.get(strategy, strategy.upper())
    param_labels = {
        "hl_percent": "Entry %",
        "hl_sl_percent": "Stop-Loss %", 
        "hl_tp_percent": "Take-Profit %",
        "hl_leverage": "Leverage"
    }
    param_label = param_labels.get(param, param)
    
    cfg = get_user_config(uid)
    lang = cfg.get("lang", DEFAULT_LANG)
    t = LANGS.get(lang, LANGS[DEFAULT_LANG])
    
    await update.message.reply_text(
        f"‚úÖ {strat_name} HyperLiquid {param_label} set to {value}",
        reply_markup=get_hl_strategy_keyboard(strategy, t, uid=uid)
    )
    return True


async def handle_hl_private_key(update: Update, ctx: ContextTypes.DEFAULT_TYPE) -> bool:
    """Handle 2-step HyperLiquid setup input. Returns True if handled."""
    uid = update.effective_user.id
    
    # Check if user is in HL setup flow
    if uid not in _hl_awaiting_input:
        return False
    
    state = _hl_awaiting_input[uid]
    step = state.get("step")
    
    if not step:
        return False
    
    # Get translations
    cfg = get_user_config(uid)
    lang = cfg.get("lang", DEFAULT_LANG)
    t = LANGS.get(lang, LANGS[DEFAULT_LANG])
    
    text = update.message.text.strip()
    
    # Cancel
    if text.lower() == "/cancel":
        del _hl_awaiting_input[uid]
        await update.message.reply_text(t.get("hl_setup_cancelled", "‚ùå HyperLiquid setup cancelled."))
        return True
    
    testnet = state.get("testnet", False)
    network = "üß™ Testnet" if testnet else "üåê Mainnet"
    
    # ==========================
    # STEP 1: API Wallet Private Key
    # ==========================
    if step == "private_key":
        key = text.replace("0x", "").strip()
        
        # Check if user sent wallet address instead of private key
        if len(key) == 40:
            await update.message.reply_text(
                "‚ùå *This looks like a wallet address, not a private key!*\n\n"
                "‚Ä¢ Wallet address: 40 characters (what you sent)\n"
                "‚Ä¢ Private key: 64 characters (what we need)\n\n"
                "Go to app.hyperliquid.xyz/API and click 'Generate' to create API wallet.\n\n"
                "Try again or send /cancel to abort.",
                parse_mode="Markdown"
            )
            return True
        
        if len(key) != 64 or not all(c in "0123456789abcdefABCDEF" for c in key):
            await update.message.reply_text(
                f"‚ùå *Invalid private key format*\n\n"
                f"You sent: {len(key)} characters\n"
                f"Expected: 64 hex characters\n\n"
                "Private key should look like:\n"
                "`47b6e4448f97b26f...40e5981a`\n\n"
                "Try again or send /cancel to abort.",
                parse_mode="Markdown"
            )
            return True
        
        # Validate key by deriving address
        try:
            from eth_account import Account
            account = Account.from_key("0x" + key)
            api_wallet_address = account.address
        except Exception as e:
            await update.message.reply_text(
                f"‚ùå *Invalid private key*: {str(e)[:50]}\n\n"
                "Try again or send /cancel to abort.",
                parse_mode="Markdown"
            )
            return True
        
        # Delete the message containing the private key for security
        try:
            await update.message.delete()
        except Exception:
            pass
        
        # Move to step 2 - ask for main wallet address
        _hl_awaiting_input[uid] = {
            "step": "wallet_address",
            "testnet": testnet,
            "private_key": "0x" + key,
            "api_wallet": api_wallet_address
        }
        
        await update.message.reply_text(
            f"‚úÖ *Step 1 Complete!*\n\n"
            f"API Wallet: `{api_wallet_address[:10]}...{api_wallet_address[-6:]}`\n\n"
            f"‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ‚îÅ\n\n"
            f"*Step 2/2:* Send your *Main Wallet Address*\n\n"
            f"üí° *How to find it:*\n"
            f"‚Ä¢ Look at top-right corner on app.hyperliquid.xyz\n"
            f"‚Ä¢ Click on your wallet address (0x...)\n"
            f"‚Ä¢ Copy the full address\n\n"
            f"‚ö†Ô∏è This is where your funds are - NOT the API wallet!\n\n"
            f"Send /cancel to abort.",
            parse_mode="Markdown"
        )
        return True
    
    # ==========================
    # STEP 2: Main Wallet Address
    # ==========================
    elif step == "wallet_address":
        address = text.strip()
        
        # Clean up address
        if not address.startswith("0x"):
            address = "0x" + address
        
        # Validate address format (42 chars: 0x + 40 hex)
        addr_hex = address[2:] if address.startswith("0x") else address
        if len(addr_hex) != 40 or not all(c in "0123456789abcdefABCDEF" for c in addr_hex):
            await update.message.reply_text(
                f"‚ùå *Invalid wallet address format*\n\n"
                f"Expected: 42 characters starting with 0x\n"
                f"Example: `0xF38498bFec6DCD4A27809e5d70A8989Df73d0C6c`\n\n"
                "Try again or send /cancel to abort.",
                parse_mode="Markdown"
            )
            return True
        
        # Get saved private key from step 1
        private_key = state.get("private_key")
        api_wallet = state.get("api_wallet")
        
        if not private_key:
            del _hl_awaiting_input[uid]
            await update.message.reply_text("‚ùå Session expired. Please start setup again.")
            return True
        
        # Save credentials with proper multitenancy field names
        account_type = "testnet" if testnet else "mainnet"
        if testnet:
            creds = {
                "hl_testnet_private_key": private_key,
                "hl_testnet_wallet_address": address,
                "hl_testnet": True,
                "account_type": "testnet"
            }
        else:
            creds = {
                "hl_mainnet_private_key": private_key,
                "hl_mainnet_wallet_address": address,
                "hl_testnet": False,
                "account_type": "mainnet"
            }
        set_hl_credentials(uid, creds=creds)
        logger.info(f"[{uid}] HyperLiquid {account_type} credentials saved: wallet={address[:10]}...")
        
        # Enable HL for user
        set_hl_enabled(uid, True)
        
        # Switch to HyperLiquid as active exchange
        set_exchange_type(uid, "hyperliquid")
        
        # Clear state
        del _hl_awaiting_input[uid]
        
        await update.message.reply_text(
            f"‚úÖ *HyperLiquid Setup Complete!* {network}\n\n"
            f"*Main Wallet:* `{address[:10]}...{address[-6:]}`\n"
            f"*API Wallet:* `{api_wallet[:10]}...{api_wallet[-6:]}`\n\n"
            f"‚ö†Ô∏è *IMPORTANT: Approve API Wallet*\n"
            f"Go to app.hyperliquid.xyz ‚Üí API ‚Üí Click your API Wallet ‚Üí *Approve Agent*\n\n"
            f"This allows the API Wallet to trade on behalf of your Main Wallet.",
            parse_mode="Markdown"
        )
        
        # Update main menu keyboard to show HyperLiquid
        await ctx.bot.send_message(
            chat_id=uid,
            text="üî∑ *HyperLiquid mode activated!*\n\nUse the updated menu below.",
            parse_mode="Markdown",
            reply_markup=main_menu_keyboard(ctx, user_id=uid)
        )
        return True
    
    return False


@with_texts
@log_calls
async def on_menu_main_cb(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
    """Handle 'Back' button that returns to main menu.
    
    This handler processes callback_data="menu:main" which is used throughout
    the bot for returning to the main menu from various submenus.
    
    IMPORTANT: main_menu_keyboard returns ReplyKeyboardMarkup (not Inline),
    so we need to DELETE the inline message and SEND a new message.
    """
    q = update.callback_query
    await q.answer()
    uid = update.effective_user.id
    t = ctx.t
    
    # Get user's current exchange and account info for the welcome message
    exchange = db.get_exchange_type(uid) or "bybit"
    trading_mode = get_trading_mode(uid)
    
    # Prepare the welcome text
    wave = t.get('wave', 'üëã')
    title = t.get('title', 'Enliko Trading Bot')
    
    # Build main menu message
    welcome_text = f"{wave} <b>{title}</b>\n\n"
    
    if exchange == "hyperliquid":
        network = "Testnet" if trading_mode in ("testnet", "demo") else "Mainnet"
        welcome_text += f"üî∑ <b>HyperLiquid</b> ({network})\n"
    else:
        mode_display = {
            "demo": "üéÆ Demo",
            "real": "üíµ Real",
            "both": "üîÄ Demo + Real"
        }.get(trading_mode, trading_mode)
        welcome_text += f"üü† <b>Bybit</b> ({mode_display})\n"
    
    welcome_text += t.get('main_menu_hint', '\nSelect an option from the menu below:')
    
    # Delete inline message first
    try:
        await q.message.delete()
    except Exception:
        pass
    
    # Send new message with ReplyKeyboardMarkup
    try:
        await ctx.bot.send_message(
            chat_id=uid,
            text=welcome_text,
            parse_mode="HTML",
            reply_markup=main_menu_keyboard(ctx, user_id=uid)
        )
    except Exception as e:
        logger.error(f"[{uid}] Failed to send menu:main message: {e}")


async def _shutdown(app: Application):
    task = app.bot_data.get("monitor_task")
    if isinstance(task, asyncio.Task) and not task.done():
        task.cancel()
        with contextlib.suppress(asyncio.CancelledError):
            await task

    global _session
    if _session is not None:
        await _session.close()
        _session = None

def main():
    db.init_db()
    try:
        set_user_field(ADMIN_ID, "is_allowed", 1)
        set_user_field(ADMIN_ID, "is_banned", 0)
    except Exception as e:
        logger.warning(f"Failed to ensure admin allowed: {e}")

    if not BOT_TOKEN:
        raise RuntimeError("TELEGRAM_TOKEN not set in the environment")
    request = HTTPXRequest(connect_timeout=10.0, read_timeout=30.0)

    app = (
        ApplicationBuilder()
        .token(BOT_TOKEN)
        .request(request)
        .post_init(start_monitoring)   
        .build()
    )
    
    # Initialize notification service
    try:
        global notification_service
        notification_service = init_notification_service(app.bot, db)
        logger.info("Notification service initialized successfully")
    except Exception as e:
        logger.error(f"Failed to initialize notification service: {e}")
    
    # Initialize error monitor with bot instance
    error_monitor.set_bot(app.bot)
    logger.info("Error monitor initialized")
    
    # DEBUG: Log ALL callback queries using TypeHandler (doesn't consume the update)
    from telegram.ext import TypeHandler
    
    async def debug_all_updates(update: Update, ctx: ContextTypes.DEFAULT_TYPE):
        if update.callback_query:
            data = update.callback_query.data
            uid = update.effective_user.id if update.effective_user else 0
            logger.info(f"[DEBUG-CALLBACK] uid={uid} callback_data={data}")
    
    app.add_handler(TypeHandler(Update, debug_all_updates), group=-100)  # Runs first, doesn't block
    
    # Menu handlers
    app.add_handler(CallbackQueryHandler(on_menu_main_cb, pattern=r"^menu:main$"))
    
    app.add_handler(CallbackQueryHandler(on_coin_group_cb, pattern=r"^coins:"))
    app.add_handler(CallbackQueryHandler(on_positions_cb, pattern=r"^pos:"))
    app.add_handler(CallbackQueryHandler(on_stats_callback, pattern=r"^stats:"))
    app.add_handler(CallbackQueryHandler(on_trades_callback, pattern=r"^trades:"))
    app.add_handler(CallbackQueryHandler(handle_balance_callback, pattern=r"^balance:"))
    app.add_handler(CallbackQueryHandler(handle_positions_callback, pattern=r"^positions:"))
    app.add_handler(CallbackQueryHandler(handle_orders_callback, pattern=r"^orders:"))
    app.add_handler(CommandHandler("start",        cmd_start))
    app.add_handler(CommandHandler("account",      cmd_account))
    app.add_handler(CommandHandler("openorders",   cmd_openorders))
    app.add_handler(CommandHandler("positions",    cmd_positions))
    app.add_handler(CommandHandler("openpositions", cmd_open_positions))
    app.add_handler(CommandHandler("stats",        cmd_trade_stats))
    app.add_handler(CommandHandler("sync_history", cmd_sync_history))  # Sync trade history from API
    app.add_handler(CommandHandler("select_coins", cmd_select_coins))
    app.add_handler(CommandHandler("set_percent",  cmd_set_percent))
    app.add_handler(CommandHandler("toggle_limit", cmd_toggle_limit))
    app.add_handler(CommandHandler("toggle_oi",    cmd_toggle_oi))
    app.add_handler(CommandHandler("toggle_rsi_bb",cmd_toggle_rsi_bb))
    app.add_handler(CommandHandler("market",       cmd_market))
    app.add_handler(CommandHandler("show_config",  cmd_show_config))
    app.add_handler(CommandHandler("indicators",   cmd_indicators))
    app.add_handler(CommandHandler("support",      cmd_support))
    app.add_handler(CommandHandler("app_login",    cmd_app_login))  # Login to iOS/Android app
    app.add_handler(CommandHandler("admin",        cmd_admin))
    
    # Subscription handlers
    app.add_handler(CommandHandler("subscribe",    cmd_subscribe))
    app.add_handler(CallbackQueryHandler(on_subscribe_cb, pattern=r"^sub:"))
    app.add_handler(CallbackQueryHandler(on_admin_license_cb, pattern=r"^adm_lic:"))
    app.add_handler(CallbackQueryHandler(on_admin_payment_cb, pattern=r"^adm_pay:"))
    app.add_handler(PreCheckoutQueryHandler(on_pre_checkout_query))
    app.add_handler(MessageHandler(filters.SUCCESSFUL_PAYMENT, on_successful_payment))
    
    # ELC Wallet handlers
    app.add_handler(CommandHandler("wallet",       cmd_wallet))
    app.add_handler(CallbackQueryHandler(on_wallet_cb, pattern=r"^wallet:"))
    
    # Sovereign Owner (Monetary Authority) handlers
    app.add_handler(CommandHandler("sovereign",    cmd_sovereign))
    app.add_handler(CallbackQueryHandler(on_sovereign_cb, pattern=r"^sovereign:"))

    app.add_handler(CallbackQueryHandler(on_moderate_cb, pattern=r"^mod:(approve|ban):\d+$"))
    app.add_handler(CallbackQueryHandler(on_admin_cb,    pattern=r"^admin:"))
    app.add_handler(CommandHandler("lang",               cmd_lang))
    app.add_handler(CallbackQueryHandler(on_setlang_cb,  pattern=r"^setlang:"))
    app.add_handler(CallbackQueryHandler(on_api_settings_cb, pattern=r"^api:"))
    app.add_handler(CallbackQueryHandler(on_spot_settings_cb, pattern=r"^spot:"))
    app.add_handler(CommandHandler("approve",            cmd_approve))
    app.add_handler(CommandHandler("ban",                cmd_ban))
    app.add_handler(CommandHandler("whoami",             whoami))

    # HyperLiquid DEX commands
    app.add_handler(CommandHandler("hl",                 cmd_hyperliquid))
    app.add_handler(CommandHandler("hyperliquid",        cmd_hyperliquid))
    app.add_handler(CommandHandler("hl_balance",         cmd_hl_balance))
    app.add_handler(CommandHandler("hl_positions",       cmd_hl_positions))
    app.add_handler(CommandHandler("hl_switch",          cmd_hl_switch))
    app.add_handler(CommandHandler("hl_clear",           cmd_hl_clear))
    app.add_handler(CallbackQueryHandler(on_hl_callback, pattern=r"^hl:"))
    app.add_handler(CallbackQueryHandler(on_hl_balance_callback, pattern=r"^hl_bal:"))
    app.add_handler(CallbackQueryHandler(on_hl_positions_callback, pattern=r"^hl_pos:"))
    app.add_handler(CallbackQueryHandler(on_hl_orders_callback, pattern=r"^hl_ord:"))
    app.add_handler(CallbackQueryHandler(on_hl_history_callback, pattern=r"^hl_hist:"))
    app.add_handler(CallbackQueryHandler(on_hl_close_callback, pattern=r"^hl_close:"))
    app.add_handler(CallbackQueryHandler(on_deep_loss_callback, pattern=r"^deep_loss:"))
    app.add_handler(CallbackQueryHandler(on_exchange_callback, pattern=r"^exchange:"))
    app.add_handler(CallbackQueryHandler(on_bybit_callback, pattern=r"^bybit:"))
    app.add_handler(CallbackQueryHandler(on_hl_api_callback, pattern=r"^hl_api:"))

    app.add_handler(CommandHandler("terms",              cmd_terms))
    app.add_handler(CommandHandler("strategy_settings",  cmd_strategy_settings))
    app.add_handler(CallbackQueryHandler(on_terms_cb,    pattern=r"^terms:(accept|decline)$"))
    app.add_handler(CallbackQueryHandler(on_disclaimer_cb, pattern=r"^disclaimer:(accept|decline)$"))
    app.add_handler(CallbackQueryHandler(on_twofa_cb,    pattern=r"^twofa_(approve|deny):"))
    app.add_handler(CallbackQueryHandler(on_2fa_app_login_cb, pattern=r"^2fa_(confirm|reject):"))
    app.add_handler(CallbackQueryHandler(on_users_cb,    pattern=r"^users:"))
    app.add_handler(CallbackQueryHandler(callback_strategy_settings, pattern=r"^(noop|strat_set:|strat_toggle:|strat_param:|strat_reset:|strat_dir_toggle:|strat_side:|strat_side_toggle:|strat_side_order_type:|strat_side_dca_toggle:|strat_side_coins:|strat_side_coins_set:|strat_side_be:|strat_side_ptp:|dca_param:|dca_toggle|strat_order_type:|strat_coins:|strat_coins_set:|scryptomera_dir:|scryptomera_side:|scalper_dir:|scalper_side:|fibonacci_dir:|elcaro_dir:|oi_dir:|rsi_bb_dir:|strat_atr_toggle:|strat_side_atr_toggle:|strat_mode:|strat_mode_cycle:|global_param:|global_atr:|global_ladder:|global_be:|strat_hl:|hl_strat:|rsi_bb_side:|elcaro_side:|fibonacci_side:|oi_side:|manual_side:)"))

    try:
        manual_labels = {texts["button_manual_order"] for texts in LANGS.values() if "button_manual_order" in texts}
        manual_pattern = r"^(" + "|".join(re.escape(lbl) for lbl in sorted(manual_labels, key=len, reverse=True)) + r")$" \
            if manual_labels else r"^\b$"  
    except Exception as e:
        logger.error(f"Failed to build manual order regex: {e}")
        manual_pattern = r"^\b$"

    try:
        cancel_labels = {texts["button_cancel_order"] for texts in LANGS.values() if "button_cancel_order" in texts}
        cancel_pattern = r"^(" + "|".join(re.escape(lbl) for lbl in sorted(cancel_labels, key=len, reverse=True)) + r")$" \
            if cancel_labels else r"^\b$"
    except Exception as e:
        logger.error(f"Failed to build cancel order regex: {e}")
        cancel_pattern = r"^\b$"
 
    conv = ConversationHandler(
        entry_points=[
            MessageHandler(filters.Regex(manual_pattern), cmd_manual_order),
        ],
        states={
            ORDER_TYPE:   [CallbackQueryHandler(on_order_type_cb, pattern=r"^order_type:")],
            ORDER_PARAMS: [MessageHandler(filters.TEXT & ~filters.COMMAND, manual_order_text)],
        },
        fallbacks=[
            MessageHandler(filters.Regex(cancel_pattern), cancel_order),
        ],
        allow_reentry=False,
        per_message=False,
        per_chat=True,   
        per_user=True  
    )
    app.add_handler(conv)

    if SIGNAL_CHANNEL_IDS:
        app.add_handler(
            MessageHandler(
                filters.Chat(chat_id=SIGNAL_CHANNEL_IDS)
                & (filters.TEXT | filters.CAPTION)
                & filters.ChatType.CHANNEL,
                on_channel_post,
            )
        )
    app.add_handler(MessageHandler(filters.TEXT & ~filters.COMMAND, text_handler))

    logger.info("üöÄ Bot starting, SIGNAL_CHANNEL_IDS=%s", SIGNAL_CHANNEL_IDS)
    app.add_error_handler(on_error)

    try:
        app.run_polling(allowed_updates=["message", "channel_post", "callback_query"])
    except (KeyboardInterrupt, SystemExit):
        logger.info("Received shutdown signal")
    finally:
        # run_polling() already handles shutdown/stop/close internally
        # We only need to clean up our own resources (aiohttp session)
        logger.info("Shutting down application and HTTP session")
        if _session and not _session.closed:
            try:
                # Try to close aiohttp session if event loop is still available
                loop = asyncio.get_event_loop()
                if not loop.is_closed():
                    loop.run_until_complete(_session.close())
                    logger.info("AIOHTTP session closed")
            except Exception as e:
                logger.debug(f"AIOHTTP close during shutdown: {e}")
        logger.info("Shutdown complete")

if __name__ == '__main__':
    main()
