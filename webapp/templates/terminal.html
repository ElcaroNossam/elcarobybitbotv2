<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, user-scalable=yes">
    <meta name="mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-capable" content="yes">
    <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
    <meta name="theme-color" content="#0a0a0a">
    <title>Enliko Trading Terminal v2.0 - Professional Trading</title>
    
    <!-- Favicon -->
    <link rel="icon" type="image/svg+xml" href="/static/images/favicon.svg">
    <link rel="apple-touch-icon" href="/static/images/favicon.svg">
    
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&family=JetBrains+Mono:wght@400;500&display=swap" rel="stylesheet">
    <link href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.5.1/css/all.min.css" rel="stylesheet">
    <link href="/static/css/terminal-advanced.css" rel="stylesheet">
    
    <!-- Mobile Responsive CSS -->
    <link rel="stylesheet" href="/static/css/mobile.css">
    
    <!-- i18n -->
    <script src="/static/i18n/translations.js"></script>
    <script src="/static/i18n/lang-switcher.js"></script>
    
    <script src="https://s3.tradingview.com/tv.js"></script>
    <!-- Beautiful Modal Dialogs -->
    <script src="/static/js/modal-dialogs.js"></script>
    
    <!-- Unified CSS Design System -->
    <link rel="stylesheet" href="/static/css/base.css">
    <link rel="stylesheet" href="/static/css/terminal-layout.css">
    
    <!-- Core JS Library -->
    <script src="/static/js/core.js"></script>
</head>
<body>
    <div class="bg-pattern"></div>
    
    <div class="terminal-layout">
        <!-- Ticker Tape -->
        <div class="ticker-tape">
            <div class="ticker-track" id="tickerTrack"></div>
        </div>
        
        <!-- Header -->
        <header class="header">
            <div class="header-left">
                <a href="/dashboard" class="logo">
                    <div class="logo-icon"><i class="fas fa-rocket"></i></div>
                    <span>Enliko</span>
                </a>
                <div class="symbol-selector" onclick="openSymbolModal()">
                    <div class="symbol-info">
                        <span class="symbol-name" id="symbolName">BTCUSDT</span>
                        <span class="symbol-pair">Perpetual</span>
                    </div>
                    <span class="symbol-price" id="symbolPrice">$97,542.30</span>
                    <span class="symbol-change positive" id="symbolChange">+2.34%</span>
                    <i class="fas fa-chevron-down" style="color: var(--text-muted); margin-left: 8px;"></i>
                </div>
            </div>
            <div class="header-center">
                <div class="market-stat">
                    <span class="market-stat-label">24h High</span>
                    <span class="market-stat-value" id="high24h">$98,200.00</span>
                </div>
                <div class="market-stat">
                    <span class="market-stat-label">24h Low</span>
                    <span class="market-stat-value" id="low24h">$94,100.00</span>
                </div>
                <div class="market-stat">
                    <span class="market-stat-label">24h Volume</span>
                    <span class="market-stat-value" id="volume24h">$2.4B</span>
                </div>
                <div class="market-stat">
                    <span class="market-stat-label">Funding</span>
                    <span class="market-stat-value" id="fundingRate" style="color: var(--green);">+0.0100%</span>
                </div>
            </div>
            <div class="header-right">
                <div class="account-selector">
                    <select class="exchange-select" id="exchangeSelect" onchange="changeExchange()">
                        <option value="bybit">Bybit</option>
                        <option value="hyperliquid">HyperLiquid</option>
                    </select>
                    <select class="account-select" id="accountSelect" onchange="changeAccountType()">
                        <option value="demo">Demo</option>
                        <option value="real">Real</option>
                    </select>
                    <span class="demo-badge" id="accountBadge">DEMO</span>
                    <button class="wallet-connect-btn" onclick="connectWallet()" title="Connect MetaMask Wallet">
                        <i class="fab fa-ethereum"></i>
                        <span id="walletBtnText">Connect Wallet</span>
                    </button>
                </div>
                <div class="ws-status">
                    <span class="ws-dot" id="wsStatus"></span>
                    <span id="wsStatusText">Connecting...</span>
                </div>
                
                <!-- Language Selector -->
                <div class="lang-selector" id="langSelector">
                    <button class="lang-btn" onclick="toggleLangMenu()" title="Language">
                        <span id="currentLangFlag">üá∫üá∏</span>
                    </button>
                    <div class="lang-menu" id="langMenu">
                        <div class="lang-item active" data-lang="en" onclick="setLanguage('en')">
                            <span class="flag">üá∫üá∏</span>
                            <span class="lang-name">English</span>
                        </div>
                        <div class="lang-item" data-lang="ru" onclick="setLanguage('ru')">
                            <span class="flag">üá∑üá∫</span>
                            <span class="lang-name">–†—É—Å—Å–∫–∏–π</span>
                        </div>
                        <div class="lang-item" data-lang="uk" onclick="setLanguage('uk')">
                            <span class="flag">üá∫üá¶</span>
                            <span class="lang-name">–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞</span>
                        </div>
                        <div class="lang-item" data-lang="zh" onclick="setLanguage('zh')">
                            <span class="flag">üá®üá≥</span>
                            <span class="lang-name">‰∏≠Êñá</span>
                        </div>
                        <div class="lang-item" data-lang="es" onclick="setLanguage('es')">
                            <span class="flag">üá™üá∏</span>
                            <span class="lang-name">Espa√±ol</span>
                        </div>
                        <div class="lang-item" data-lang="de" onclick="setLanguage('de')">
                            <span class="flag">üá©üá™</span>
                            <span class="lang-name">Deutsch</span>
                        </div>
                        <div class="lang-item" data-lang="fr" onclick="setLanguage('fr')">
                            <span class="flag">üá´üá∑</span>
                            <span class="lang-name">Fran√ßais</span>
                        </div>
                        <div class="lang-item" data-lang="it" onclick="setLanguage('it')">
                            <span class="flag">üáÆüáπ</span>
                            <span class="lang-name">Italiano</span>
                        </div>
                        <div class="lang-item" data-lang="ja" onclick="setLanguage('ja')">
                            <span class="flag">üáØüáµ</span>
                            <span class="lang-name">Êó•Êú¨Ë™û</span>
                        </div>
                        <div class="lang-item" data-lang="ar" onclick="setLanguage('ar')">
                            <span class="flag">üá∏üá¶</span>
                            <span class="lang-name">ÿßŸÑÿπÿ±ÿ®Ÿäÿ©</span>
                        </div>
                        <div class="lang-item" data-lang="he" onclick="setLanguage('he')">
                            <span class="flag">üáÆüá±</span>
                            <span class="lang-name">◊¢◊ë◊®◊ô◊™</span>
                        </div>
                        <div class="lang-item" data-lang="pl" onclick="setLanguage('pl')">
                            <span class="flag">üáµüá±</span>
                            <span class="lang-name">Polski</span>
                        </div>
                    </div>
                </div>
                
                <!-- Theme Switcher -->
                <div class="theme-switcher" id="themeSwitcher">
                    <button class="theme-btn" onclick="toggleThemeMenu()" title="Theme">
                        <i class="fas fa-moon" id="themeIcon"></i>
                    </button>
                    <div class="theme-menu" id="themeMenu">
                        <div class="theme-option active" data-theme="dark" onclick="setTheme('dark')">
                            <i class="fas fa-moon"></i>
                            <span>Dark</span>
                        </div>
                        <div class="theme-option" data-theme="light" onclick="setTheme('light')">
                            <i class="fas fa-sun"></i>
                            <span>Light</span>
                        </div>
                        <div class="theme-option" data-theme="system" onclick="setTheme('system')">
                            <i class="fas fa-desktop"></i>
                            <span>System</span>
                        </div>
                    </div>
                </div>
                
                <a href="/backtest" class="header-icon-btn" title="Strategy Backtester"><i class="fas fa-chart-line"></i></a>
                <a href="/screener" class="header-icon-btn" title="Market Screener"><i class="fas fa-th"></i></a>
                <a href="/dashboard" class="header-icon-btn" title="Dashboard"><i class="fas fa-tachometer-alt"></i></a>
                <a href="/settings" class="header-icon-btn" title="Settings"><i class="fas fa-cog"></i></a>
            </div>
        </header>
        
        <!-- Mobile Sidebar Toggle Button -->
        <button class="sidebar-toggle" aria-label="Toggle sidebar" style="display: none;">
            <i class="fas fa-bars"></i>
        </button>
        
        <!-- Left Panel - Order Book -->
        <aside class="left-panel">
            <div class="panel-tabs">
                <div class="panel-tab active" data-tab="orderbook">Order Book</div>
                <div class="panel-tab" data-tab="trades">Trades</div>
            </div>
            <div class="orderbook" id="orderbookPanel">
                <div class="orderbook-controls">
                    <div class="orderbook-grouping">
                        <button class="group-btn active" data-group="0.01">0.01</button>
                        <button class="group-btn" data-group="0.1">0.1</button>
                        <button class="group-btn" data-group="1">1</button>
                        <button class="group-btn" data-group="10">10</button>
                    </div>
                    <div class="orderbook-view-btns">
                        <button class="view-btn active" data-view="both" title="Both"><i class="fas fa-bars"></i></button>
                        <button class="view-btn" data-view="bids" title="Bids only"><i class="fas fa-arrow-up" style="color: var(--green);"></i></button>
                        <button class="view-btn" data-view="asks" title="Asks only"><i class="fas fa-arrow-down" style="color: var(--red);"></i></button>
                    </div>
                </div>
                
                <!-- Imbalance Indicator -->
                <div class="imbalance-indicator" id="imbalanceIndicator">
                    <div class="imbalance-bar">
                        <div class="imbalance-fill" style="width: 50%; background: var(--text-muted);"></div>
                    </div>
                    <span class="imbalance-label" style="color: var(--text-muted);">Neutral (0%)</span>
                </div>
                
                <div class="orderbook-header">
                    <span>Price (USDT)</span>
                    <span style="text-align: center;">Size</span>
                    <span style="text-align: right;">Total</span>
                </div>
                <div class="orderbook-asks" id="asks"></div>
                <div class="orderbook-spread">
                    <div class="spread-price up" id="lastPrice">97,542.30 <i class="fas fa-arrow-up"></i></div>
                    <div class="spread-info">
                        <span>Spread: <span id="spreadValue">$12.50</span></span>
                        <span id="spreadPercent">0.01%</span>
                    </div>
                </div>
                <div class="orderbook-bids" id="bids"></div>
            </div>
            <div class="recent-trades" id="tradesPanel">
                <div class="trades-header">
                    <span>Price</span>
                    <span style="text-align: center;">Size</span>
                    <span style="text-align: right;">Time</span>
                </div>
                <div id="tradesList"></div>
            </div>
        </aside>
        
        <!-- Chart -->
        <main class="chart-area">
            <div id="tradingview_chart"></div>
            
            <!-- Trade History Toggle Button -->
            <button class="trade-history-toggle" onclick="toggleTradeHistory()">
                üìä Trade History
            </button>
            
            <!-- Trade History Panel -->
            <div id="tradeHistoryPanel" class="trade-history-panel">
                <div class="trade-history-header">
                    <h3>üìä Trade History</h3>
                    <button class="trade-history-close" onclick="toggleTradeHistory()">√ó</button>
                </div>
                <div class="trade-history-list" id="tradeHistoryList">
                    <div style="padding: 20px; text-align: center; color: var(--text-muted);">
                        Loading trades...
                    </div>
                </div>
            </div>
        </main>
        
        <!-- Right Panel - Order Form -->
        <aside class="right-panel">
            <div class="balance-bar">
                <div class="balance-item">
                    <span class="balance-label">Available</span>
                    <span class="balance-value" id="availableBalance">$10,000.00</span>
                </div>
                <div class="balance-item">
                    <span class="balance-label">Equity</span>
                    <span class="balance-value" id="equity">$12,450.00</span>
                </div>
                <div class="balance-item">
                    <span class="balance-label">Unrealized</span>
                    <span class="balance-value positive" id="unrealizedPnl">+$450.00</span>
                </div>
            </div>
            
            <div class="order-form">
                <!-- Margin Mode & Leverage -->
                <div class="margin-mode-row">
                    <div class="margin-mode-btns">
                        <button class="margin-mode-btn cross active" data-mode="cross">Cross</button>
                        <button class="margin-mode-btn" data-mode="isolated">Isolated</button>
                    </div>
                    <div class="leverage-quick" id="leverageQuick" onclick="openLeverageModal()">10x</div>
                </div>
                
                <div class="order-type-tabs">
                    <div class="order-type-tab active" data-type="limit">Limit</div>
                    <div class="order-type-tab" data-type="market">Market</div>
                    <div class="order-type-tab" data-type="stop">Stop</div>
                    <div class="order-type-tab" data-type="stopLimit">Stop Limit</div>
                </div>
                
                <div class="side-toggle">
                    <div class="side-btn buy active" data-side="buy">
                        <i class="fas fa-arrow-up"></i> Long
                    </div>
                    <div class="side-btn sell" data-side="sell">
                        <i class="fas fa-arrow-down"></i> Short
                    </div>
                </div>
                
                <!-- Advanced Options -->
                <div class="order-options">
                    <label class="order-option">
                        <input type="checkbox" id="reduceOnly"> Reduce Only
                    </label>
                    <label class="order-option">
                        <input type="checkbox" id="postOnly"> Post Only
                    </label>
                    <label class="order-option" id="tifOption">
                        <select id="tifSelect" style="background: var(--bg-card); border: 1px solid var(--border); border-radius: 4px; padding: 2px 6px; font-size: 0.7rem; color: var(--text-primary); color-scheme: dark;">
                            <option value="GTC">GTC</option>
                            <option value="IOC">IOC</option>
                            <option value="FOK">FOK</option>
                        </select>
                    </label>
                </div>
                
                <div class="leverage-slider">
                    <div class="leverage-header">
                        <span class="form-label">Leverage</span>
                        <span class="leverage-value" id="leverageValue">10x</span>
                    </div>
                    <input type="range" class="slider" id="leverageSlider" min="1" max="100" value="10">
                    <div class="leverage-marks">
                        <span onclick="setLeverage(1)">1x</span>
                        <span onclick="setLeverage(5)">5x</span>
                        <span onclick="setLeverage(10)">10x</span>
                        <span onclick="setLeverage(25)">25x</span>
                        <span onclick="setLeverage(50)">50x</span>
                        <span onclick="setLeverage(100)">100x</span>
                    </div>
                </div>
                
                <div class="form-group" id="priceGroup">
                    <div class="form-label">
                        <span>Price</span>
                        <span id="markPrice">Mark: $97,540.00</span>
                    </div>
                    <div class="form-input-wrap">
                        <input type="number" class="form-input" id="priceInput" placeholder="0.00" step="0.01">
                        <span class="form-suffix">USDT</span>
                    </div>
                </div>
                
                <div class="form-group">
                    <div class="form-label">
                        <span>Size</span>
                        <span id="maxSize">Max: 0.1024 BTC</span>
                    </div>
                    <div class="form-input-wrap">
                        <input type="number" class="form-input" id="sizeInput" placeholder="0.00" step="0.001">
                        <span class="form-suffix" id="sizeSymbol">BTC</span>
                    </div>
                </div>
                
                <div class="percent-btns">
                    <div class="percent-btn" onclick="setPercent(25)">25%</div>
                    <div class="percent-btn" onclick="setPercent(50)">50%</div>
                    <div class="percent-btn" onclick="setPercent(75)">75%</div>
                    <div class="percent-btn" onclick="setPercent(100)">100%</div>
                </div>
                
                <div class="tp-sl-section">
                    <div class="tp-sl-header">
                        <div class="tp-sl-toggle">
                            <div class="toggle-switch" id="tpslToggle" onclick="toggleTPSL()"></div>
                            <span>TP/SL</span>
                        </div>
                        <div class="tp-sl-mode" id="tpslMode" style="display: none;">
                            <button class="group-btn active" data-mode="price" onclick="setTPSLMode('price')">Price</button>
                            <button class="group-btn" data-mode="percent" onclick="setTPSLMode('percent')">%</button>
                            <button class="group-btn" data-mode="roe" onclick="setTPSLMode('roe')">ROE%</button>
                        </div>
                    </div>
                    <div class="tp-sl-inputs" id="tpslInputs" style="display: none;">
                        <div>
                            <div class="form-label" style="color: var(--green);">
                                Take Profit
                                <span id="tpRoe" style="font-family: var(--font-mono);">+0%</span>
                            </div>
                            <div class="form-input-wrap">
                                <input type="number" class="form-input" id="tpInput" placeholder="0.00" oninput="calcTPSLRoe()">
                                <span class="form-suffix" id="tpSuffix">USDT</span>
                            </div>
                        </div>
                        <div>
                            <div class="form-label" style="color: var(--red);">
                                Stop Loss
                                <span id="slRoe" style="font-family: var(--font-mono);">-0%</span>
                            </div>
                            <div class="form-input-wrap">
                                <input type="number" class="form-input" id="slInput" placeholder="0.00" oninput="calcTPSLRoe()">
                                <span class="form-suffix" id="slSuffix">USDT</span>
                            </div>
                        </div>
                        
                        <!-- Strategy Selector & Presets -->
                        <div class="strategy-tpsl-section" style="grid-column: 1/-1; margin-top: 8px;">
                            <div class="form-label" style="font-size: 0.7rem; margin-bottom: 4px;">
                                <i class="fas fa-robot" style="color: var(--accent);"></i> Apply from Strategy
                            </div>
                            <div class="strategy-selector-row" style="display: flex; gap: 4px; flex-wrap: wrap;">
                                <button class="strategy-btn" data-strategy="global" onclick="applyStrategySettings('global')" title="Global Settings">
                                    <i class="fas fa-globe"></i> Global
                                </button>
                                <button class="strategy-btn" data-strategy="scryptomera" onclick="applyStrategySettings('scryptomera')" title="Scryptomera">
                                    üì∞ Scrypto
                                </button>
                                <button class="strategy-btn" data-strategy="scalper" onclick="applyStrategySettings('scalper')" title="Scalper">
                                    ‚ö° Scalper
                                </button>
                                <button class="strategy-btn" data-strategy="enliko" onclick="applyStrategySettings('enliko')" title="Enliko">
                                    ü§ñ Enliko
                                </button>
                                <button class="strategy-btn" data-strategy="wyckoff" onclick="applyStrategySettings('wyckoff')" title="Wyckoff">
                                    üìä Wyckoff
                                </button>
                            </div>
                        </div>
                        
                        <!-- Quick TP/SL Presets -->
                        <div style="grid-column: 1/-1; margin-top: 8px;">
                            <div class="form-label" style="font-size: 0.7rem; margin-bottom: 4px;">Quick Presets</div>
                            <div style="display: flex; gap: 4px;">
                                <button class="tpsl-preset-btn conservative" onclick="setTPSLPreset(5, 2)" title="TP 5%, SL 2%">
                                    üõ°Ô∏è Safe
                                </button>
                                <button class="tpsl-preset-btn normal" onclick="setTPSLPreset(8, 3)" title="TP 8%, SL 3%">
                                    ‚öñÔ∏è Normal
                                </button>
                                <button class="tpsl-preset-btn aggressive" onclick="setTPSLPreset(15, 5)" title="TP 15%, SL 5%">
                                    üî• Agro
                                </button>
                            </div>
                        </div>
                        
                        <!-- ATR Toggle -->
                        <div style="grid-column: 1/-1; margin-top: 8px;">
                            <label class="order-option" style="display: flex; align-items: center; gap: 6px;">
                                <input type="checkbox" id="useAtrToggle" onchange="toggleATRMode()">
                                <span style="font-size: 0.75rem;">
                                    <i class="fas fa-chart-line" style="color: var(--accent);"></i>
                                    Use ATR-based trailing SL (dynamic)
                                </span>
                            </label>
                            <div id="atrSettings" style="display: none; margin-top: 6px; padding: 8px; background: rgba(255,255,255,0.03); border-radius: 6px;">
                                <div style="display: grid; grid-template-columns: 1fr 1fr 1fr; gap: 6px;">
                                    <div class="form-group" style="margin: 0;">
                                        <div class="form-label" style="font-size: 0.65rem;">ATR Periods</div>
                                        <input type="number" class="form-input" id="atrPeriods" value="14" min="5" max="50" style="font-size: 0.75rem; padding: 4px 6px;">
                                    </div>
                                    <div class="form-group" style="margin: 0;">
                                        <div class="form-label" style="font-size: 0.65rem;">ATR Mult</div>
                                        <input type="number" class="form-input" id="atrMultiplier" value="1.5" min="0.5" max="5" step="0.1" style="font-size: 0.75rem; padding: 4px 6px;">
                                    </div>
                                    <div class="form-group" style="margin: 0;">
                                        <div class="form-label" style="font-size: 0.65rem;">Trigger %</div>
                                        <input type="number" class="form-input" id="atrTrigger" value="2" min="0.5" max="10" step="0.5" style="font-size: 0.75rem; padding: 4px 6px;">
                                    </div>
                                </div>
                            </div>
                        </div>
                        
                        <div style="grid-column: 1/-1; display: flex; gap: 4px; margin-top: 4px;">
                            <button class="percent-btn" style="flex:1; font-size: 0.65rem;" onclick="setTPPercent(2)">2%</button>
                            <button class="percent-btn" style="flex:1; font-size: 0.65rem;" onclick="setTPPercent(5)">5%</button>
                            <button class="percent-btn" style="flex:1; font-size: 0.65rem;" onclick="setTPPercent(10)">10%</button>
                            <button class="percent-btn" style="flex:1; font-size: 0.65rem;" onclick="setTPPercent(25)">25%</button>
                        </div>
                    </div>
                </div>
                
                <div class="order-summary">
                    <div class="summary-row">
                        <span class="label">Order Value</span>
                        <span class="value" id="orderValue">$0.00</span>
                    </div>
                    <div class="summary-row">
                        <span class="label">Margin Required</span>
                        <span class="value" id="marginRequired">$0.00</span>
                    </div>
                    <div class="summary-row">
                        <span class="label">Est. Liq. Price</span>
                        <span class="value" id="estLiqPrice">--</span>
                    </div>
                </div>
                
                <!-- Quick Market Buttons -->
                <div class="quick-market-btns">
                    <button class="quick-btn buy" onclick="quickMarket('buy')">
                        <i class="fas fa-bolt"></i> Market Buy <kbd>B</kbd>
                    </button>
                    <button class="quick-btn sell" onclick="quickMarket('sell')">
                        <i class="fas fa-bolt"></i> Market Sell <kbd>S</kbd>
                    </button>
                </div>
                
                <button class="submit-btn buy" id="submitOrder" onclick="submitOrder()">
                    <i class="fas fa-check"></i> Open Long
                </button>
                
                <div class="keyboard-hints">
                    <span><kbd>B</kbd> Buy</span>
                    <span><kbd>S</kbd> Sell</span>
                    <span><kbd>Enter</kbd> Submit</span>
                    <span><kbd>?</kbd> Help</span>
                </div>
                
                <!-- Quick Actions Bar -->
                <div class="quick-actions-bar">
                    <div class="quick-action" onclick="toggleOneClickTrading()" id="oneClickToggle" title="One-Click Trading">
                        <i class="fas fa-bolt"></i>
                        <span>1-Click</span>
                    </div>
                    <div class="quick-action" onclick="showDCABuilder()" title="DCA Ladder">
                        <i class="fas fa-layer-group"></i>
                        <span>DCA</span>
                    </div>
                    <div class="quick-action" onclick="showRiskCalc()" title="Risk Calculator">
                        <i class="fas fa-calculator"></i>
                        <span>Risk</span>
                    </div>
                    <div class="quick-action" onclick="showShortcuts()" title="Keyboard Shortcuts">
                        <i class="fas fa-keyboard"></i>
                        <span>Keys</span>
                    </div>
                </div>
            </div>
            
            <!-- Risk Calculator Panel -->
            <div class="risk-calc-panel" id="riskCalcPanel" style="display: none;">
                <div class="risk-calc-header">
                    <h4><i class="fas fa-calculator"></i> Position Sizer</h4>
                    <button class="modal-close" onclick="hideRiskCalc()"><i class="fas fa-times"></i></button>
                </div>
                <div class="risk-presets">
                    <button class="risk-preset-btn active" onclick="setRiskPreset(0.5)">0.5%</button>
                    <button class="risk-preset-btn" onclick="setRiskPreset(1)">1%</button>
                    <button class="risk-preset-btn" onclick="setRiskPreset(2)">2%</button>
                    <button class="risk-preset-btn" onclick="setRiskPreset(5)">5%</button>
                </div>
                <div class="risk-inputs">
                    <div class="form-group">
                        <div class="form-label">Risk %</div>
                        <input type="number" class="form-input" id="riskPercent" value="1" step="0.1" min="0.1" max="100">
                    </div>
                    <div class="form-group">
                        <div class="form-label">Entry Price</div>
                        <input type="number" class="form-input" id="riskEntry" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <div class="form-label" style="color: var(--red);">Stop Loss</div>
                        <input type="number" class="form-input" id="riskSL" placeholder="0.00">
                    </div>
                    <div class="form-group">
                        <div class="form-label" style="color: var(--green);">Take Profit</div>
                        <input type="number" class="form-input" id="riskTP" placeholder="0.00">
                    </div>
                </div>
                <div id="riskResult"></div>
                <button class="dca-submit" onclick="applyRiskCalc()" style="margin-top: 10px;">
                    <i class="fas fa-check"></i> Apply to Order
                </button>
            </div>
            
            <!-- DCA Builder Panel -->
            <div class="dca-builder" id="dcaPanel" style="display: none;">
                <div class="dca-header">
                    <h4><i class="fas fa-layer-group"></i> DCA Ladder</h4>
                    <button class="modal-close" onclick="hideDCABuilder()"><i class="fas fa-times"></i></button>
                </div>
                <div class="risk-inputs">
                    <div class="form-group">
                        <div class="form-label">Total Size</div>
                        <input type="number" class="form-input" id="dcaTotalSize" value="0.1" step="0.001">
                    </div>
                    <div class="form-group">
                        <div class="form-label">Orders</div>
                        <input type="number" class="form-input" id="dcaOrderCount" value="5" min="2" max="20">
                    </div>
                    <div class="form-group">
                        <div class="form-label">Range %</div>
                        <input type="number" class="form-input" id="dcaRange" value="5" step="0.5">
                    </div>
                    <div class="form-group">
                        <div class="form-label">Distribution</div>
                        <select class="form-input" id="dcaDistribution" style="padding-right: 10px;">
                            <option value="linear">Linear</option>
                            <option value="geometric">Geometric</option>
                            <option value="fibonacci">Fibonacci</option>
                            <option value="exponential">Exponential</option>
                        </select>
                    </div>
                </div>
                <div class="dca-summary" id="dcaSummary"></div>
                <div class="dca-orders" id="dcaOrdersList"></div>
                <button class="dca-submit" onclick="placeDCALadder()">
                    <i class="fas fa-bolt"></i> Place DCA Orders
                </button>
            </div>
            
            <!-- Alerts Panel -->
            <div class="alerts-panel" id="alertsPanel">
                <div class="alerts-header">
                    <h4><i class="fas fa-bell"></i> Price Alerts</h4>
                    <button class="add-alert-btn" onclick="SmartAlerts.showAddModal()">
                        <i class="fas fa-plus"></i>
                    </button>
                </div>
                <div class="alerts-list" id="alertsList">
                    <p class="empty">No active alerts</p>
                </div>
            </div>
        </aside>
        
        <!-- Bottom Panel - Positions -->
        <section class="bottom-panel">
            <div class="bottom-tabs">
                <div class="bottom-tab active" data-panel="positions">
                    <i class="fas fa-layer-group"></i> <span data-i18n="positions">Positions</span>
                    <span class="count" id="positionsCount">0</span>
                </div>
                <div class="bottom-tab" data-panel="orders">
                    <i class="fas fa-clock"></i> <span data-i18n="orders">Open Orders</span>
                    <span class="count" id="ordersCount">0</span>
                </div>
                <div class="bottom-tab" data-panel="history">
                    <i class="fas fa-history"></i> <span data-i18n="history">Trade History</span>
                </div>
                <div class="bottom-tab-actions">
                    <button class="action-btn close" onclick="closeAllPositions()" title="Close All Positions">
                        <i class="fas fa-times-circle"></i> <span data-i18n="close_all">Close All</span>
                    </button>
                    <button class="action-btn edit" onclick="cancelAllOrders()" title="Cancel All Orders">
                        <i class="fas fa-ban"></i> <span data-i18n="cancel_all">Cancel All</span>
                    </button>
                    <button class="action-btn" onclick="loadPositions(); loadOrders(); loadBalance();" title="Refresh">
                        <i class="fas fa-sync-alt"></i>
                    </button>
                </div>
            </div>
            <div class="bottom-content">
                <div id="positionsPanel">
                    <table class="positions-table">
                        <thead>
                            <tr>
                                <th>Symbol</th>
                                <th>Side</th>
                                <th>Size</th>
                                <th>Entry Price</th>
                                <th>Mark Price</th>
                                <th>Liq. Price</th>
                                <th>TP/SL</th>
                                <th>Margin</th>
                                <th>PnL (ROE%)</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="positionsBody">
                            <tr><td colspan="10" class="empty-state"><i class="fas fa-inbox"></i><p>No open positions</p></td></tr>
                        </tbody>
                    </table>
                </div>
                <div id="ordersPanel" style="display: none;">
                    <table class="orders-table">
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>Symbol</th>
                                <th>Type</th>
                                <th>Side</th>
                                <th>Price</th>
                                <th>Size</th>
                                <th>Filled</th>
                                <th>Actions</th>
                            </tr>
                        </thead>
                        <tbody id="ordersBody">
                            <tr><td colspan="8" class="empty-state"><i class="fas fa-clock"></i><p>No open orders</p></td></tr>
                        </tbody>
                    </table>
                </div>
                <div id="historyPanel" style="display: none;">
                    <table class="history-table">
                        <thead>
                            <tr>
                                <th>Time</th>
                                <th>Symbol</th>
                                <th>Side</th>
                                <th>Price</th>
                                <th>Size</th>
                                <th>Fee</th>
                                <th>PnL</th>
                            </tr>
                        </thead>
                        <tbody id="historyBody"></tbody>
                    </table>
                </div>
            </div>
        </section>
    </div>
    
    <!-- Symbol Search Modal -->
    <div class="modal-overlay" id="symbolModal">
        <div class="modal">
            <div class="modal-header">
                <span class="modal-title">Select Symbol</span>
                <button class="modal-close" onclick="closeSymbolModal()"><i class="fas fa-times"></i></button>
            </div>
            <div class="modal-search">
                <input type="text" id="symbolSearch" placeholder="Search symbol..." oninput="filterSymbols()">
            </div>
            <div class="symbol-list" id="symbolList"></div>
        </div>
    </div>
    
    <script>
        // ========================================
        // ENSURE MODAL DIALOGS ARE AVAILABLE
        // ========================================
        // Fallback if modal-dialogs.js didn't load properly
        if (typeof showConfirm === 'undefined') {
            window.showConfirm = async (message, title, options = {}) => {
                return confirm(message.replace(/<[^>]*>/g, ''));
            };
            window.showAlert = async (message, title) => {
                alert(message.replace(/<[^>]*>/g, ''));
            };
        }
        
        // ========================================
        // AUTH HANDLING - Token from bot auto-login
        // ========================================
        (async function() {
            const params = new URLSearchParams(window.location.search);
            
            // Method 1: Direct auth_token parameter
            const authToken = params.get('auth_token');
            if (authToken) {
                localStorage.setItem('enliko_token', authToken);
                try {
                    const res = await fetch('/api/auth/me', {
                        headers: { 'Authorization': `Bearer ${authToken}` }
                    });
                    const user = await res.json();
                    if (user && user.user_id) {
                        localStorage.setItem('enliko_user_id', user.user_id.toString());
                        localStorage.setItem('enliko_user', JSON.stringify(user));
                        if (user.language) localStorage.setItem('enliko_language', user.language);
                        if (user.exchange_type) localStorage.setItem('enliko_exchange', user.exchange_type);
                    }
                } catch (err) {
                    console.error('Auth error:', err);
                }
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }
            
            // Method 2: User ID from start parameter (login via direct-login API)
            const startUserId = params.get('start');
            if (startUserId) {
                try {
                    const res = await fetch('/api/auth/direct-login', {
                        method: 'POST',
                        headers: { 'Content-Type': 'application/json' },
                        body: JSON.stringify({ user_id: parseInt(startUserId) })
                    });
                    const data = await res.json();
                    if (res.ok && data.access_token) {
                        localStorage.setItem('enliko_token', data.access_token);
                        localStorage.setItem('enliko_user_id', startUserId);
                        if (data.user) {
                            localStorage.setItem('enliko_user', JSON.stringify(data.user));
                            if (data.user.language) localStorage.setItem('enliko_language', data.user.language);
                            if (data.user.exchange_type) localStorage.setItem('enliko_exchange', data.user.exchange_type);
                        }
                    }
                } catch (err) {
                    console.error('Direct login error:', err);
                }
                window.history.replaceState({}, document.title, window.location.pathname);
                return;
            }
        })();
        
        // State
        const state = {
            symbol: 'BTCUSDT',
            side: 'buy',
            orderType: 'limit',
            leverage: 10,
            price: 0,
            size: 0,
            tpslEnabled: false,
            exchange: 'bybit',
            accountType: 'demo',
            ws: null,
            settingsWs: null,
            positions: [],
            orders: [],
            orderbookGroup: 0.01,
            orderbookView: 'both',
            recentTrades: [],
            lastPrice: 97542.30,
            marginMode: 'cross',
            // Loading states
            loading: {
                positions: false,
                orders: false,
                balance: false,
                symbols: false,
                order: false
            },
            // Error states
            errors: {
                positions: null,
                orders: null,
                balance: null,
                symbols: null
            }
        };
        
        // Loading overlay helper
        function setLoading(element, isLoading, message = 'Loading...') {
            const container = typeof element === 'string' ? document.getElementById(element) : element;
            if (!container) return;
            
            const existingOverlay = container.querySelector('.loading-overlay');
            if (isLoading && !existingOverlay) {
                const overlay = document.createElement('div');
                overlay.className = 'loading-overlay';
                overlay.innerHTML = `<div class="loading-spinner"></div><span>${message}</span>`;
                container.style.position = 'relative';
                container.appendChild(overlay);
            } else if (!isLoading && existingOverlay) {
                existingOverlay.remove();
            }
        }
        
        // Show error in table
        function showTableError(tbodyId, colspan, message) {
            const tbody = document.getElementById(tbodyId);
            if (tbody) {
                tbody.innerHTML = `<tr><td colspan="${colspan}" class="error-state"><i class="fas fa-exclamation-triangle"></i><p>${message}</p><button class="btn btn-sm btn-secondary" onclick="location.reload()">Retry</button></td></tr>`;
            }
        }
        
        const symbols = [
            { symbol: 'BTCUSDT', name: 'Bitcoin', price: 97542.30, change: 2.34 },
            { symbol: 'ETHUSDT', name: 'Ethereum', price: 3456.78, change: 1.56 },
            { symbol: 'SOLUSDT', name: 'Solana', price: 189.45, change: -0.89 },
            { symbol: 'BNBUSDT', name: 'BNB', price: 678.90, change: 0.45 },
            { symbol: 'XRPUSDT', name: 'XRP', price: 2.34, change: 3.21 },
            { symbol: 'DOGEUSDT', name: 'Dogecoin', price: 0.3456, change: -1.23 },
            { symbol: 'ADAUSDT', name: 'Cardano', price: 0.89, change: 2.10 },
            { symbol: 'AVAXUSDT', name: 'Avalanche', price: 42.56, change: 4.56 },
            { symbol: 'LINKUSDT', name: 'Chainlink', price: 23.45, change: -0.67 },
            { symbol: 'DOTUSDT', name: 'Polkadot', price: 7.89, change: 1.23 }
        ];
        
        // Initialize
        document.addEventListener('DOMContentLoaded', () => {
            // Restore account type from localStorage
            const savedAccountType = localStorage.getItem('account_type');
            if (savedAccountType && ['demo', 'real', 'testnet', 'mainnet'].includes(savedAccountType)) {
                state.accountType = savedAccountType;
                document.getElementById('accountSelect').value = savedAccountType;
                updateAccountBadge();
            }
            
            initTickerTape();
            initTradingView();
            initEventListeners();
            initOrderbook();
            loadPositions();
            loadOrders();
            loadBalance();
            connectWebSocket();
            renderSymbolList();
            
            // Auto-refresh data every 10 seconds
            setInterval(() => {
                loadPositions();
                loadOrders();
                loadBalance();
            }, 10000);
        });
        
        function initTickerTape() {
            const track = document.getElementById('tickerTrack');
            const tickerData = [
                { symbol: 'BTC', price: 97542.30, change: 2.34 },
                { symbol: 'ETH', price: 3456.78, change: 1.56 },
                { symbol: 'SOL', price: 189.45, change: -0.89 },
                { symbol: 'BNB', price: 678.90, change: 0.45 },
                { symbol: 'XRP', price: 2.34, change: 3.21 },
                { symbol: 'DOGE', price: 0.3456, change: -1.23 },
                { symbol: 'ADA', price: 0.89, change: 2.10 },
                { symbol: 'AVAX', price: 42.56, change: 4.56 },
                { symbol: 'LINK', price: 23.45, change: -0.67 },
                { symbol: 'DOT', price: 7.89, change: 1.23 },
                { symbol: 'MATIC', price: 0.78, change: -2.15 },
                { symbol: 'UNI', price: 12.34, change: 3.45 },
                { symbol: 'ATOM', price: 8.90, change: 1.78 },
                { symbol: 'LTC', price: 102.50, change: 0.89 },
                { symbol: 'FIL', price: 5.67, change: -1.34 },
            ];
            
            // Create items twice for seamless loop
            const html = [...tickerData, ...tickerData].map(t => `
                <div class="ticker-item" onclick="selectSymbol('${t.symbol}USDT')">
                    <span class="ticker-symbol">${t.symbol}/USDT</span>
                    <span class="ticker-price">$${t.price.toLocaleString()}</span>
                    <span class="ticker-change ${t.change >= 0 ? 'up' : 'down'}">${t.change >= 0 ? '+' : ''}${t.change.toFixed(2)}%</span>
                </div>
            `).join('');
            track.innerHTML = html;
        }
        
        function initTradingView() {
            if (typeof TradingView === 'undefined') return;
            new TradingView.widget({
                container_id: "tradingview_chart",
                autosize: true,
                symbol: "BINANCE:" + state.symbol,
                interval: "15",
                timezone: "Etc/UTC",
                theme: "dark",
                style: "1",
                locale: "en",
                toolbar_bg: "#0a0a0a",
                enable_publishing: false,
                hide_side_toolbar: false,
                allow_symbol_change: true,
                studies: ["RSI@tv-basicstudies", "MACD@tv-basicstudies"],
                backgroundColor: "#0a0a0a",
                gridColor: "rgba(255,255,255,0.03)"
            });
        }
        
        // Trade History Panel Functions
        let tradeHistoryVisible = false;
        
        function toggleTradeHistory() {
            const panel = document.getElementById('tradeHistoryPanel');
            tradeHistoryVisible = !tradeHistoryVisible;
            if (tradeHistoryVisible) {
                panel.classList.add('active');
                loadTradeHistory();
            } else {
                panel.classList.remove('active');
            }
        }
        
        async function loadTradeHistory() {
            const listEl = document.getElementById('tradeHistoryList');
            listEl.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted);">Loading trades...</div>';
            
            try {
                const token = localStorage.getItem('enliko_token');
                const response = await fetch(`/api/trading/chart-markers/${state.symbol}?days=30`, {
                    headers: {
                        'Authorization': `Bearer ${token}`
                    }
                });
                
                if (!response.ok) throw new Error('Failed to load trades');
                
                const data = await response.json();
                const markers = data.markers || [];
                
                if (markers.length === 0) {
                    listEl.innerHTML = '<div style="padding: 20px; text-align: center; color: var(--text-muted);">No trades found for this symbol</div>';
                    return;
                }
                
                // Sort by time descending
                markers.sort((a, b) => b.time - a.time);
                
                // Render markers
                const html = markers.map(marker => {
                    const date = new Date(marker.time * 1000).toLocaleString();
                    const typeLabels = {
                        'entry_long': '‚ñ≤ LONG Entry',
                        'entry_short': '‚ñº SHORT Entry',
                        'active_entry': '‚ö° Active Position',
                        'exit_tp': 'üéØ Take Profit',
                        'exit_sl': 'üõ°Ô∏è Stop-Loss',
                        'exit_atr_sl': 'üìâ ATR Stop',
                        'exit_trailing': 'üìà Trailing Stop',
                        'exit_manual': 'üëÜ Manual Close',
                        'exit_liq': 'üíÄ Liquidation',
                        'exit_adl': '‚ö° ADL',
                        'exit_unknown': '‚ùì Unknown',
                        'active_sl': 'üî¥ Active SL',
                        'active_tp': 'üü¢ Active TP',
                        'sl_level': 'SL Level',
                        'tp_level': 'TP Level'
                    };
                    
                    const typeLabel = typeLabels[marker.type] || marker.type;
                    const pnl = marker.pnl;
                    const pnlClass = pnl > 0 ? 'positive' : pnl < 0 ? 'negative' : '';
                    const pnlText = pnl !== undefined ? `${pnl >= 0 ? '+' : ''}${pnl.toFixed(2)}$` : '';
                    
                    // Get CSS class for border color
                    let itemClass = marker.type.replace('_', '-');
                    if (marker.isActive) itemClass = 'entry-long'; // Active positions green
                    
                    return `
                        <div class="trade-marker-item ${itemClass}">
                            <div class="trade-marker-info">
                                <span class="trade-marker-type">${typeLabel}</span>
                                <span class="trade-marker-meta">@ ${marker.price?.toFixed(6)} ‚Ä¢ ${date}</span>
                                ${marker.text ? `<span class="trade-marker-meta">${marker.text}</span>` : ''}
                            </div>
                            ${pnlText ? `<span class="trade-marker-pnl ${pnlClass}">${pnlText}</span>` : ''}
                        </div>
                    `;
                }).join('');
                
                listEl.innerHTML = html;
                
            } catch (error) {
                console.error('Failed to load trade history:', error);
                listEl.innerHTML = `<div style="padding: 20px; text-align: center; color: var(--red);">Error: ${error.message}</div>`;
            }
        }
        
        function initEventListeners() {
            // Order type tabs
            document.querySelectorAll('.order-type-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.order-type-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    state.orderType = tab.dataset.type;
                    document.getElementById('priceGroup').style.display = state.orderType === 'market' ? 'none' : 'block';
                });
            });
            
            // Side toggle
            document.querySelectorAll('.side-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    setSide(btn.dataset.side);
                });
            });
            
            // Margin mode buttons
            document.querySelectorAll('.margin-mode-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    setMarginMode(btn.dataset.mode);
                });
            });
            
            // Leverage slider
            document.getElementById('leverageSlider').addEventListener('input', (e) => {
                state.leverage = parseInt(e.target.value);
                document.getElementById('leverageValue').textContent = state.leverage + 'x';
                updateOrderSummary();
            });
            
            // Price & Size inputs
            document.getElementById('priceInput').addEventListener('input', updateOrderSummary);
            document.getElementById('sizeInput').addEventListener('input', updateOrderSummary);
            
            // Panel tabs
            document.querySelectorAll('.panel-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.panel-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById('orderbookPanel').style.display = tab.dataset.tab === 'orderbook' ? 'flex' : 'none';
                    document.getElementById('tradesPanel').classList.toggle('active', tab.dataset.tab === 'trades');
                });
            });
            
            // Orderbook grouping buttons
            document.querySelectorAll('.group-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.group-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.orderbookGroup = parseFloat(btn.dataset.group);
                    initOrderbook();
                });
            });
            
            // Orderbook view buttons
            document.querySelectorAll('.view-btn').forEach(btn => {
                btn.addEventListener('click', () => {
                    document.querySelectorAll('.view-btn').forEach(b => b.classList.remove('active'));
                    btn.classList.add('active');
                    state.orderbookView = btn.dataset.view;
                    updateOrderbookView();
                });
            });
            
            // Bottom tabs
            document.querySelectorAll('.bottom-tab').forEach(tab => {
                tab.addEventListener('click', () => {
                    document.querySelectorAll('.bottom-tab').forEach(t => t.classList.remove('active'));
                    tab.classList.add('active');
                    document.getElementById('positionsPanel').style.display = tab.dataset.panel === 'positions' ? 'block' : 'none';
                    document.getElementById('ordersPanel').style.display = tab.dataset.panel === 'orders' ? 'block' : 'none';
                    document.getElementById('historyPanel').style.display = tab.dataset.panel === 'history' ? 'block' : 'none';
                });
            });
        }
        
        function updateOrderbookView() {
            const asks = document.getElementById('asks');
            const bids = document.getElementById('bids');
            if (state.orderbookView === 'bids') {
                asks.style.display = 'none';
                bids.style.display = 'flex';
                bids.style.flex = '1';
            } else if (state.orderbookView === 'asks') {
                asks.style.display = 'flex';
                asks.style.flex = '1';
                bids.style.display = 'none';
            } else {
                asks.style.display = 'flex';
                asks.style.flex = '1';
                bids.style.display = 'flex';
                bids.style.flex = '1';
            }
        }
        
        function setLeverage(val) {
            state.leverage = val;
            document.getElementById('leverageSlider').value = val;
            document.getElementById('leverageValue').textContent = val + 'x';
            updateOrderSummary();
        }
        
        function setPercent(pct) {
            const available = parseFloat(document.getElementById('availableBalance').textContent.replace(/[$,]/g, ''));
            const price = parseFloat(document.getElementById('priceInput').value) || parseFloat(document.getElementById('symbolPrice').textContent.replace(/[$,]/g, ''));
            if (price > 0) {
                const maxSize = (available * state.leverage * (pct / 100)) / price;
                document.getElementById('sizeInput').value = maxSize.toFixed(4);
                updateOrderSummary();
            }
        }
        
        function toggleTPSL() {
            state.tpslEnabled = !state.tpslEnabled;
            document.getElementById('tpslToggle').classList.toggle('active', state.tpslEnabled);
            document.getElementById('tpslInputs').style.display = state.tpslEnabled ? 'grid' : 'none';
            document.getElementById('tpslMode').style.display = state.tpslEnabled ? 'flex' : 'none';
        }
        
        // TP/SL mode (price, percent, roe)
        let tpslMode = 'price';
        function setTPSLMode(mode) {
            tpslMode = mode;
            document.querySelectorAll('#tpslMode .group-btn').forEach(b => {
                b.classList.toggle('active', b.dataset.mode === mode);
            });
            const tpSuffix = document.getElementById('tpSuffix');
            const slSuffix = document.getElementById('slSuffix');
            if (mode === 'price') {
                tpSuffix.textContent = 'USDT';
                slSuffix.textContent = 'USDT';
            } else {
                tpSuffix.textContent = '%';
                slSuffix.textContent = '%';
            }
            calcTPSLRoe();
        }
        
        function calcTPSLRoe() {
            const entryPrice = parseFloat(document.getElementById('priceInput').value) || 0;
            const tpVal = parseFloat(document.getElementById('tpInput').value) || 0;
            const slVal = parseFloat(document.getElementById('slInput').value) || 0;
            const leverage = state.leverage || 1;
            const isBuy = state.side === 'buy';
            let tpRoe = 0, slRoe = 0;
            
            if (entryPrice > 0 && tpVal > 0) {
                if (tpslMode === 'price') {
                    const priceDiff = isBuy ? tpVal - entryPrice : entryPrice - tpVal;
                    tpRoe = (priceDiff / entryPrice) * 100 * leverage;
                } else if (tpslMode === 'percent') {
                    tpRoe = tpVal * leverage;
                } else {
                    tpRoe = tpVal;
                }
            }
            
            if (entryPrice > 0 && slVal > 0) {
                if (tpslMode === 'price') {
                    const priceDiff = isBuy ? entryPrice - slVal : slVal - entryPrice;
                    slRoe = (priceDiff / entryPrice) * 100 * leverage;
                } else if (tpslMode === 'percent') {
                    slRoe = slVal * leverage;
                } else {
                    slRoe = slVal;
                }
            }
            
            document.getElementById('tpRoe').textContent = tpRoe > 0 ? '+' + tpRoe.toFixed(1) + '%' : '+0%';
            document.getElementById('slRoe').textContent = slRoe > 0 ? '-' + slRoe.toFixed(1) + '%' : '-0%';
        }
        
        function setTPPercent(pct) {
            const entryPrice = parseFloat(document.getElementById('priceInput').value) || 0;
            if (entryPrice <= 0) return;
            const isBuy = state.side === 'buy';
            
            if (tpslMode === 'price') {
                const tpPrice = isBuy ? entryPrice * (1 + pct/100) : entryPrice * (1 - pct/100);
                const slPrice = isBuy ? entryPrice * (1 - pct/100) : entryPrice * (1 + pct/100);
                document.getElementById('tpInput').value = tpPrice.toFixed(2);
                document.getElementById('slInput').value = slPrice.toFixed(2);
            } else {
                document.getElementById('tpInput').value = pct;
                document.getElementById('slInput').value = pct;
            }
            calcTPSLRoe();
        }
        
        // ============================================================
        // STRATEGY SETTINGS & TP/SL PRESETS (NEW)
        // ============================================================
        
        // Cache for loaded strategy settings
        let strategySettings = null;
        let currentStrategy = 'global';
        
        // Load strategy settings from API
        async function loadStrategySettings() {
            try {
                const token = localStorage.getItem('enliko_token');
                if (!token) return;
                
                const params = new URLSearchParams({
                    exchange: state.exchange || 'bybit',
                    account_type: state.accountType || 'demo'
                });
                
                const res = await fetch(`/api/trading/strategy-settings?${params}`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                
                if (res.ok) {
                    strategySettings = await res.json();
                    console.log('Loaded strategy settings:', strategySettings);
                    
                    // Update ATR toggle state from global settings
                    const useAtr = strategySettings.global?.use_atr || false;
                    document.getElementById('useAtrToggle').checked = useAtr;
                    if (useAtr) {
                        document.getElementById('atrSettings').style.display = 'block';
                    }
                }
            } catch (e) {
                console.error('Failed to load strategy settings:', e);
            }
        }
        
        // Apply settings from a specific strategy
        function applyStrategySettings(strategy) {
            if (!strategySettings) {
                showNotification('Settings not loaded yet', 'warning');
                loadStrategySettings();
                return;
            }
            
            currentStrategy = strategy;
            
            // Update active button
            document.querySelectorAll('.strategy-btn').forEach(btn => {
                btn.classList.toggle('active', btn.dataset.strategy === strategy);
            });
            
            let settings;
            if (strategy === 'global') {
                settings = strategySettings.global;
            } else {
                settings = strategySettings.strategies?.[strategy];
            }
            
            if (!settings) {
                showNotification(`No settings found for ${strategy}`, 'warning');
                return;
            }
            
            // Enable TP/SL if not already enabled
            if (!state.tpslEnabled) {
                toggleTPSL();
            }
            
            // Set mode to percent for strategy-based TP/SL
            setTPSLMode('percent');
            
            // Apply TP/SL from strategy
            const tpPct = settings.tp_percent || 8;
            const slPct = settings.sl_percent || 3;
            
            document.getElementById('tpInput').value = tpPct;
            document.getElementById('slInput').value = slPct;
            
            // Apply leverage if available
            if (settings.leverage) {
                setLeverage(settings.leverage);
            }
            
            // Apply ATR settings if use_atr is enabled
            const useAtr = settings.use_atr || false;
            document.getElementById('useAtrToggle').checked = useAtr;
            toggleATRMode(false); // Don't notify
            
            if (useAtr) {
                document.getElementById('atrPeriods').value = settings.atr_periods || 14;
                document.getElementById('atrMultiplier').value = settings.atr_multiplier_sl || 1.5;
                document.getElementById('atrTrigger').value = settings.atr_trigger_pct || 2;
            }
            
            calcTPSLRoe();
            updateOrderSummary();
            
            const strategyLabel = strategy === 'global' ? 'Global' : strategy.charAt(0).toUpperCase() + strategy.slice(1);
            showNotification(`Applied ${strategyLabel}: TP ${tpPct}%, SL ${slPct}%`, 'success');
        }
        
        // Set TP/SL from preset
        function setTPSLPreset(tpPct, slPct) {
            // Enable TP/SL if not already enabled
            if (!state.tpslEnabled) {
                toggleTPSL();
            }
            
            // Set mode to percent
            setTPSLMode('percent');
            
            document.getElementById('tpInput').value = tpPct;
            document.getElementById('slInput').value = slPct;
            
            // Update active preset button
            document.querySelectorAll('.tpsl-preset-btn').forEach(btn => btn.classList.remove('active'));
            
            // Mark active based on values
            if (tpPct === 5 && slPct === 2) {
                document.querySelector('.tpsl-preset-btn.conservative')?.classList.add('active');
            } else if (tpPct === 8 && slPct === 3) {
                document.querySelector('.tpsl-preset-btn.normal')?.classList.add('active');
            } else if (tpPct === 15 && slPct === 5) {
                document.querySelector('.tpsl-preset-btn.aggressive')?.classList.add('active');
            }
            
            // Clear strategy selection
            document.querySelectorAll('.strategy-btn').forEach(btn => btn.classList.remove('active'));
            
            calcTPSLRoe();
            updateOrderSummary();
        }
        
        // Toggle ATR mode
        function toggleATRMode(notify = true) {
            const useAtr = document.getElementById('useAtrToggle').checked;
            document.getElementById('atrSettings').style.display = useAtr ? 'block' : 'none';
            
            state.useAtr = useAtr;
            
            if (useAtr && notify) {
                showNotification('ATR-based trailing SL enabled. SL will be dynamic.', 'info');
            }
        }
        
        // Save strategy settings to server
        async function saveCurrentStrategySettings() {
            if (currentStrategy === 'global') {
                showNotification('Cannot save global settings from terminal', 'warning');
                return;
            }
            
            try {
                const token = localStorage.getItem('enliko_token');
                if (!token) return;
                
                const tpPct = parseFloat(document.getElementById('tpInput').value) || 8;
                const slPct = parseFloat(document.getElementById('slInput').value) || 3;
                const useAtr = document.getElementById('useAtrToggle').checked;
                
                const body = {
                    strategy: currentStrategy,
                    tp_percent: tpPct,
                    sl_percent: slPct,
                    leverage: state.leverage,
                    use_atr: useAtr,
                    exchange: state.exchange || 'bybit',
                    account_type: state.accountType || 'demo'
                };
                
                if (useAtr) {
                    body.atr_periods = parseInt(document.getElementById('atrPeriods').value) || 14;
                    body.atr_multiplier_sl = parseFloat(document.getElementById('atrMultiplier').value) || 1.5;
                    body.atr_trigger_pct = parseFloat(document.getElementById('atrTrigger').value) || 2;
                }
                
                const res = await fetch('/api/trading/strategy-settings', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify(body)
                });
                
                const data = await res.json();
                if (data.success) {
                    showNotification(`Saved ${currentStrategy} settings`, 'success');
                    // Reload settings
                    loadStrategySettings();
                } else {
                    showNotification(data.error || 'Failed to save', 'error');
                }
            } catch (e) {
                showNotification('Error saving settings', 'error');
            }
        }
        
        // Get ATR settings for order placement
        function getATRSettingsForOrder() {
            const useAtr = document.getElementById('useAtrToggle')?.checked || false;
            if (!useAtr) return null;
            
            return {
                use_atr: true,
                atr_periods: parseInt(document.getElementById('atrPeriods')?.value) || 14,
                atr_multiplier_sl: parseFloat(document.getElementById('atrMultiplier')?.value) || 1.5,
                atr_trigger_pct: parseFloat(document.getElementById('atrTrigger')?.value) || 2.0
            };
        }
        
        // ============================================================
        
        function setSide(side) {
            state.side = side;
            document.querySelectorAll('.side-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.side-btn.${side}`)?.classList.add('active');
            updateSubmitButton();
            calcTPSLRoe();
        }
        
        function setOrderType(type) {
            state.orderType = type;
            document.querySelectorAll('.order-type-tab').forEach(t => t.classList.remove('active'));
            document.querySelector(`.order-type-tab[data-type="${type}"]`)?.classList.add('active');
            document.getElementById('priceGroup').style.display = type === 'market' ? 'none' : 'block';
            if (type === 'market') {
                document.getElementById('priceInput').value = state.lastPrice || '';
            }
        }
        
        function setMarginMode(mode) {
            state.marginMode = mode;
            document.querySelectorAll('.margin-mode-btn').forEach(b => b.classList.remove('active'));
            document.querySelector(`.margin-mode-btn[data-mode="${mode}"]`)?.classList.add('active');
        }
        
        function openLeverageModal() {
            const lev = prompt('Enter leverage (1-100):', state.leverage);
            if (lev && !isNaN(lev) && lev >= 1 && lev <= 100) {
                setLeverage(parseInt(lev));
                document.getElementById('leverageQuick').textContent = state.leverage + 'x';
            }
        }
        
        function updateSubmitButton() {
            const btn = document.getElementById('submitOrder');
            btn.className = 'submit-btn ' + state.side;
            btn.innerHTML = state.side === 'buy' 
                ? '<i class="fas fa-arrow-up"></i> Open Long' 
                : '<i class="fas fa-arrow-down"></i> Open Short';
        }
        
        function updateOrderSummary() {
            const price = parseFloat(document.getElementById('priceInput').value) || 0;
            const size = parseFloat(document.getElementById('sizeInput').value) || 0;
            const orderValue = price * size;
            const margin = orderValue / state.leverage;
            
            document.getElementById('orderValue').textContent = '$' + orderValue.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
            document.getElementById('marginRequired').textContent = '$' + margin.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
            
            if (price > 0 && size > 0) {
                const liqPrice = state.side === 'buy' 
                    ? price * (1 - 1/state.leverage * 0.9)
                    : price * (1 + 1/state.leverage * 0.9);
                document.getElementById('estLiqPrice').textContent = '$' + liqPrice.toFixed(2);
            }
        }
        
        function initOrderbook() {
            const asks = document.getElementById('asks');
            const bids = document.getElementById('bids');
            const basePrice = 97542.30;
            const grouping = state.orderbookGroup;
            
            // Generate mock orderbook with grouping
            const askLevels = [], bidLevels = [];
            let totalAskSize = 0, totalBidSize = 0;
            
            for (let i = 15; i >= 1; i--) {
                const price = Math.ceil((basePrice + i * 3 * grouping) / grouping) * grouping;
                const size = Math.random() * 3 + 0.1;
                totalAskSize += size;
                askLevels.push({ price, size, total: totalAskSize });
            }
            for (let i = 1; i <= 15; i++) {
                const price = Math.floor((basePrice - i * 3 * grouping) / grouping) * grouping;
                const size = Math.random() * 3 + 0.1;
                totalBidSize += size;
                bidLevels.push({ price, size, total: totalBidSize });
            }
            
            const maxAskTotal = totalAskSize;
            const maxBidTotal = totalBidSize;
            
            asks.innerHTML = askLevels.reverse().map(l => {
                const depth = (l.total / maxAskTotal) * 100;
                const priceStr = l.price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                return `<div class="orderbook-row ask" onclick="setPrice(${l.price})">
                    <span class="price">${priceStr}</span>
                    <span class="size">${l.size.toFixed(4)}</span>
                    <span class="total">${l.total.toFixed(2)}</span>
                    <div class="depth" style="width: ${depth}%"></div>
                </div>`;
            }).join('');
            
            bids.innerHTML = bidLevels.map(l => {
                const depth = (l.total / maxBidTotal) * 100;
                const priceStr = l.price.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                return `<div class="orderbook-row bid" onclick="setPrice(${l.price})">
                    <span class="price">${priceStr}</span>
                    <span class="size">${l.size.toFixed(4)}</span>
                    <span class="total">${l.total.toFixed(2)}</span>
                    <div class="depth" style="width: ${depth}%"></div>
                </div>`;
            }).join('');
            
            // Update spread
            const spread = askLevels[askLevels.length - 1].price - bidLevels[0].price;
            const spreadPct = (spread / basePrice * 100).toFixed(4);
            document.getElementById('spreadValue').textContent = '$' + spread.toFixed(2);
            document.getElementById('spreadPercent').textContent = spreadPct + '%';
            
            // Init recent trades
            initRecentTrades();
        }
        
        function initRecentTrades() {
            const trades = [];
            const basePrice = 97542.30;
            for (let i = 0; i < 30; i++) {
                const isBuy = Math.random() > 0.5;
                const price = basePrice + (Math.random() - 0.5) * 20;
                const size = Math.random() * 0.5 + 0.01;
                const time = new Date(Date.now() - i * 2000);
                trades.push({ isBuy, price, size, time });
            }
            state.recentTrades = trades;
            renderRecentTrades();
        }
        
        function renderRecentTrades() {
            const list = document.getElementById('tradesList');
            list.innerHTML = state.recentTrades.slice(0, 25).map(t => `
                <div class="trade-row ${t.isBuy ? 'buy' : 'sell'}">
                    <span class="price">${t.price.toFixed(2)}</span>
                    <span style="text-align: center;">${t.size.toFixed(4)}</span>
                    <span class="time">${t.time.toLocaleTimeString('en-GB', {hour: '2-digit', minute: '2-digit', second: '2-digit'})}</span>
                </div>
            `).join('');
        }
        
        function setPrice(price) {
            document.getElementById('priceInput').value = price;
            updateOrderSummary();
        }
        
        function connectWebSocket() {
            const wsStatus = document.getElementById('wsStatus');
            const wsText = document.getElementById('wsStatusText');
            
            try {
                const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
                state.ws = new WebSocket(`${proto}//${location.host}/ws/terminal`);
                
                state.ws.onopen = () => {
                    wsStatus.classList.add('connected');
                    wsText.textContent = 'Live';
                };
                
                state.ws.onclose = () => {
                    wsStatus.classList.remove('connected');
                    wsText.textContent = 'Reconnecting...';
                    setTimeout(connectWebSocket, 3000);
                };
                
                state.ws.onerror = () => state.ws.close();
                
                state.ws.onmessage = (e) => {
                    const data = JSON.parse(e.data);
                    handleWSMessage(data);
                };
            } catch (e) {
                wsText.textContent = 'Offline';
            }
        }
        
        function handleWSMessage(data) {
            if (data.type === 'ticker') {
                state.lastPrice = data.price;
                document.getElementById('symbolPrice').textContent = '$' + data.price.toLocaleString();
                document.getElementById('symbolChange').textContent = (data.change >= 0 ? '+' : '') + data.change.toFixed(2) + '%';
                document.getElementById('symbolChange').className = 'symbol-change ' + (data.change >= 0 ? 'positive' : 'negative');
                // Update last price indicator
                const lastPriceEl = document.getElementById('lastPrice');
                if (lastPriceEl) {
                    lastPriceEl.textContent = data.price.toLocaleString(undefined, {minimumFractionDigits: 2});
                }
            } else if (data.type === 'positions') {
                renderPositions(data.data);
            } else if (data.type === 'orders') {
                renderOrders(data.data);
            } else if (data.type === 'balance') {
                document.getElementById('availableBalance').textContent = '$' + data.available.toLocaleString();
                document.getElementById('equity').textContent = '$' + data.equity.toLocaleString();
            }
        }
        
        async function loadPositions() {
            const posTable = document.querySelector('.positions-table');
            try {
                state.loading.positions = true;
                state.errors.positions = null;
                setLoading(posTable, true, 'Loading positions...');
                
                const token = localStorage.getItem('enliko_token');
                if (!token) {
                    showTableError('positionsBody', 10, 'Please log in to view positions');
                    return;
                }
                
                const params = new URLSearchParams({
                    exchange: state.exchange || 'bybit',
                    account_type: state.accountType || 'demo'
                });
                
                const res = await fetch(`/api/trading/positions?${params}`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                
                if (!res.ok) {
                    const error = await res.json().catch(() => ({ detail: 'Failed to load positions' }));
                    throw new Error(error.detail || `Error ${res.status}`);
                }
                
                const data = await res.json();
                state.positions = data;
                renderPositions(data);
            } catch (e) {
                console.error('loadPositions error:', e);
                state.errors.positions = e.message;
                showTableError('positionsBody', 10, e.message);
            } finally {
                state.loading.positions = false;
                setLoading(posTable, false);
            }
        }
        
        async function loadOrders() {
            const ordersTable = document.querySelector('.orders-table');
            try {
                state.loading.orders = true;
                state.errors.orders = null;
                setLoading(ordersTable, true, 'Loading orders...');
                
                const token = localStorage.getItem('enliko_token');
                if (!token) {
                    showTableError('ordersBody', 8, 'Please log in to view orders');
                    return;
                }
                
                const params = new URLSearchParams({
                    exchange: state.exchange || 'bybit',
                    account_type: state.accountType || 'demo'
                });
                
                const res = await fetch(`/api/trading/orders?${params}`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                
                if (!res.ok) {
                    const error = await res.json().catch(() => ({ detail: 'Failed to load orders' }));
                    throw new Error(error.detail || `Error ${res.status}`);
                }
                
                const data = await res.json();
                state.orders = data;
                renderOrders(data);
            } catch (e) {
                console.error('loadOrders error:', e);
                state.errors.orders = e.message;
                showTableError('ordersBody', 8, e.message);
            } finally {
                state.loading.orders = false;
                setLoading(ordersTable, false);
            }
        }
        
        async function loadBalance() {
            const balanceCard = document.querySelector('.balance-display');
            try {
                state.loading.balance = true;
                
                const token = localStorage.getItem('enliko_token');
                if (!token) return;
                
                const params = new URLSearchParams({
                    exchange: state.exchange || 'bybit',
                    account_type: state.accountType || 'demo'
                });
                
                const res = await fetch(`/api/trading/balance?${params}`, {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                
                if (!res.ok) {
                    throw new Error('Failed to load balance');
                }
                
                const data = await res.json();
                document.getElementById('availableBalance').textContent = '$' + (data.available || 0).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                document.getElementById('equity').textContent = '$' + (data.equity || 0).toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                const pnl = data.unrealized_pnl || 0;
                const pnlEl = document.getElementById('unrealizedPnl');
                pnlEl.textContent = (pnl >= 0 ? '+' : '') + '$' + pnl.toLocaleString(undefined, {minimumFractionDigits: 2, maximumFractionDigits: 2});
                pnlEl.className = 'balance-value ' + (pnl >= 0 ? 'positive' : 'negative');
            } catch (e) {
                console.error('loadBalance error:', e);
                // Show error in balance display
                document.getElementById('availableBalance').textContent = '--';
                document.getElementById('equity').textContent = '--';
                document.getElementById('unrealizedPnl').textContent = '--';
            } finally {
                state.loading.balance = false;
            }
        }
        
        function renderPositions(positions) {
            const tbody = document.getElementById('positionsBody');
            document.getElementById('positionsCount').textContent = positions.length;
            
            if (!positions.length) {
                tbody.innerHTML = '<tr><td colspan="10" class="empty-state"><i class="fas fa-inbox"></i><p>No open positions</p></td></tr>';
                return;
            }
            
            tbody.innerHTML = positions.map(p => {
                const pnlClass = (p.pnl || 0) >= 0 ? 'positive' : 'negative';
                
                // Strategy badge
                let strategyBadge = '';
                if (p.strategy) {
                    const strategyIcons = {
                        'scryptomera': 'üì∞',
                        'scalper': '‚ö°',
                        'enliko': 'ü§ñ',
                        'wyckoff': 'üìä',
                        'manual': 'üë§'
                    };
                    const icon = strategyIcons[p.strategy] || 'üìå';
                    strategyBadge = `<span class="strategy-badge" title="${p.strategy}">${icon}</span>`;
                }
                
                // TP/SL info
                let tpslInfo = '--';
                if (p.tp_price || p.sl_price) {
                    const tpStr = p.tp_price ? `TP: $${p.tp_price.toLocaleString()}` : '';
                    const slStr = p.sl_price ? `SL: $${p.sl_price.toLocaleString()}` : '';
                    tpslInfo = `<div class="tpsl-mini">${tpStr ? `<span class="tp">${tpStr}</span>` : ''}${slStr ? `<span class="sl">${slStr}</span>` : ''}</div>`;
                }
                
                // ATR indicator
                let atrIndicator = '';
                if (p.use_atr) {
                    atrIndicator = p.atr_activated 
                        ? `<span class="atr-badge active" title="ATR Trailing Active">üìà</span>` 
                        : `<span class="atr-badge" title="ATR Trailing (pending activation)">üìâ</span>`;
                }
                
                return `<tr>
                    <td><strong>${p.symbol}</strong> ${strategyBadge} ${atrIndicator}</td>
                    <td><span class="position-side ${p.side}">${(p.side || 'buy').toUpperCase()}</span></td>
                    <td style="font-family: var(--font-mono);">${p.size || 0}</td>
                    <td style="font-family: var(--font-mono);">$${(p.entry_price || 0).toLocaleString()}</td>
                    <td style="font-family: var(--font-mono);">$${(p.mark_price || 0).toLocaleString()}</td>
                    <td style="font-family: var(--font-mono); color: var(--red);">$${p.liq_price?.toLocaleString() || '--'}</td>
                    <td>${tpslInfo}</td>
                    <td style="font-family: var(--font-mono);">$${p.margin?.toLocaleString() || '--'}</td>
                    <td class="pnl ${pnlClass}" style="font-family: var(--font-mono);">${(p.pnl || 0) >= 0 ? '+' : ''}$${(p.pnl || 0).toFixed(2)} (${(p.roe || 0) >= 0 ? '+' : ''}${(p.roe || 0).toFixed(2)}%)</td>
                    <td>
                        <button class="action-btn close" onclick="closePosition('${p.symbol}')">Close</button>
                        <button class="action-btn edit" onclick="editPosition('${p.symbol}')">TP/SL</button>
                    </td>
                </tr>`;
            }).join('');
        }
        
        function renderOrders(orders) {
            const tbody = document.getElementById('ordersBody');
            document.getElementById('ordersCount').textContent = orders.length;
            
            if (!orders.length) {
                tbody.innerHTML = '<tr><td colspan="8" class="empty-state"><i class="fas fa-clock"></i><p>No open orders</p></td></tr>';
                return;
            }
            
            tbody.innerHTML = orders.map(o => `<tr>
                <td>${new Date(o.time).toLocaleTimeString()}</td>
                <td><strong>${o.symbol}</strong></td>
                <td>${o.type}</td>
                <td><span class="position-side ${o.side}">${o.side.toUpperCase()}</span></td>
                <td style="font-family: var(--font-mono);">$${parseFloat(o.price || 0).toLocaleString()}</td>
                <td style="font-family: var(--font-mono);">${o.size}</td>
                <td>${o.filled || 0}%</td>
                <td><button class="action-btn close" onclick="cancelOrder('${o.id}', '${o.symbol}')">Cancel</button></td>
            </tr>`).join('');
        }
        
        // Quick market order with hotkey support
        function quickMarket(side) {
            state.side = side;
            state.orderType = 'market';
            updateSubmitButton();
            // Update order type UI
            document.querySelectorAll('.order-type-tab').forEach(b => {
                b.classList.toggle('active', b.dataset.type === 'market');
            });
            document.getElementById('priceGroup').style.display = 'none';
            // Set market price from current symbol price
            const currentPrice = parseFloat(document.getElementById('symbolPrice').textContent.replace(/[$,]/g, ''));
            state.lastPrice = currentPrice;
            document.getElementById('priceInput').value = currentPrice || '';
            submitOrder();
        }
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
            // Don't trigger when typing in inputs
            if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
                if (e.key === 'Escape') {
                    e.target.blur();
                }
                return;
            }
            
            switch(e.key.toLowerCase()) {
                case 'b':
                    e.preventDefault();
                    setSide('buy');
                    break;
                case 's':
                    e.preventDefault();
                    setSide('sell');
                    break;
                case 'enter':
                    e.preventDefault();
                    submitOrder();
                    break;
                case 'escape':
                    document.getElementById('sizeInput').value = '';
                    document.getElementById('priceInput').value = '';
                    break;
                case '1':
                    e.preventDefault();
                    setOrderType('limit');
                    break;
                case '2':
                    e.preventDefault();
                    setOrderType('market');
                    break;
                case '3':
                    e.preventDefault();
                    setOrderType('conditional');
                    break;
            }
        });
        
        async function submitOrder() {
            const submitBtn = document.querySelector('.submit-btn');
            const price = parseFloat(document.getElementById('priceInput').value);
            const size = parseFloat(document.getElementById('sizeInput').value);
            
            // Validation
            const errors = [];
            if (!size || size <= 0) {
                errors.push('Enter valid order size');
            }
            if (state.orderType !== 'market' && (!price || price <= 0)) {
                errors.push('Enter valid price for limit order');
            }
            if (!state.symbol) {
                errors.push('Select a trading pair');
            }
            if (!localStorage.getItem('enliko_token')) {
                showNotification('Please log in to trade', 'error');
                return;
            }
            
            if (errors.length > 0) {
                errors.forEach(e => showNotification(e, 'warning'));
                return;
            }
            
            // Get TP/SL values based on mode
            let tp = null, sl = null;
            if (state.tpslEnabled) {
                const tpVal = parseFloat(document.getElementById('tpInput').value);
                const slVal = parseFloat(document.getElementById('slInput').value);
                const entryPrice = state.orderType === 'market' ? state.lastPrice : price;
                
                if (tpslMode === 'price') {
                    tp = tpVal || null;
                    sl = slVal || null;
                } else if (tpslMode === 'percent') {
                    const isBuy = state.side === 'buy';
                    if (tpVal) tp = isBuy ? entryPrice * (1 + tpVal/100) : entryPrice * (1 - tpVal/100);
                    if (slVal) sl = isBuy ? entryPrice * (1 - slVal/100) : entryPrice * (1 + slVal/100);
                } else { // ROE mode
                    const isBuy = state.side === 'buy';
                    if (tpVal) {
                        const tpPct = tpVal / state.leverage;
                        tp = isBuy ? entryPrice * (1 + tpPct/100) : entryPrice * (1 - tpPct/100);
                    }
                    if (slVal) {
                        const slPct = slVal / state.leverage;
                        sl = isBuy ? entryPrice * (1 - slPct/100) : entryPrice * (1 + slPct/100);
                    }
                }
                
                // Validate TP/SL logic
                if (tp && sl) {
                    const isBuy = state.side === 'buy';
                    const entryPrice = state.orderType === 'market' ? state.lastPrice : price;
                    if (isBuy && (tp <= entryPrice || sl >= entryPrice)) {
                        showNotification('For LONG: TP must be above entry, SL below', 'warning');
                    } else if (!isBuy && (tp >= entryPrice || sl <= entryPrice)) {
                        showNotification('For SHORT: TP must be below entry, SL above', 'warning');
                    }
                }
            }
            
            const order = {
                symbol: state.symbol,
                side: state.side,
                type: state.orderType,
                price: state.orderType === 'market' ? null : price,
                size: size,
                leverage: state.leverage,
                tp: tp,
                sl: sl,
                exchange: state.exchange || 'bybit',
                account_type: state.accountType || 'demo',
                reduceOnly: document.getElementById('reduceOnly')?.checked || false,
                postOnly: document.getElementById('postOnly')?.checked || false,
                timeInForce: document.getElementById('tifSelect')?.value || 'GTC',
                // NEW: Strategy and ATR settings
                strategy: currentStrategy !== 'global' ? currentStrategy : null,
                use_atr: document.getElementById('useAtrToggle')?.checked || false,
                atr_periods: parseInt(document.getElementById('atrPeriods')?.value) || 14,
                atr_multiplier_sl: parseFloat(document.getElementById('atrMultiplier')?.value) || 1.5,
                atr_trigger_pct: parseFloat(document.getElementById('atrTrigger')?.value) || 2.0
            };
            
            try {
                state.loading.order = true;
                if (submitBtn) submitBtn.classList.add('btn-loading');
                
                const token = localStorage.getItem('enliko_token');
                const res = await fetch('/api/trading/order', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token 
                    },
                    body: JSON.stringify(order)
                });
                
                const data = await res.json();
                if (data.success || res.ok) {
                    showNotification(`${state.side.toUpperCase()} ${state.symbol} order placed!`, 'success');
                    document.getElementById('sizeInput').value = '';
                    loadPositions();
                    loadOrders();
                } else {
                    showNotification(data.error || data.detail || 'Order failed', 'error');
                }
            } catch (e) {
                console.error('Order error:', e);
                showNotification('Failed to place order: ' + e.message, 'error');
            } finally {
                state.loading.order = false;
                if (submitBtn) submitBtn.classList.remove('btn-loading');
            }
        }
        
        async function closePosition(symbol) {
            const confirmed = await showConfirm(
                `–í—ã —É–≤–µ—Ä–µ–Ω—ã —á—Ç–æ —Ö–æ—Ç–∏—Ç–µ –∑–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é <strong>${symbol}</strong>?`,
                '–ó–∞–∫—Ä—ã—Ç—å –ø–æ–∑–∏—Ü–∏—é',
                { type: 'warning', confirmText: '–ó–∞–∫—Ä—ã—Ç—å', cancelText: '–û—Ç–º–µ–Ω–∞' }
            );
            if (!confirmed) return;
            
            try {
                const token = localStorage.getItem('enliko_token');
                const res = await fetch('/api/trading/close', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token 
                    },
                    body: JSON.stringify({ 
                        symbol,
                        exchange: state.exchange || 'bybit',
                        account_type: state.accountType || 'demo'
                    })
                });
                
                const data = await res.json();
                if (data.success) {
                    showNotification('Position closed', 'success');
                    loadPositions();
                } else {
                    showNotification(data.error || 'Failed to close', 'error');
                }
            } catch (e) {
                showNotification('Error closing position', 'error');
            }
        }
        
        async function editPosition(symbol) {
            const tp = prompt('Enter Take Profit price (leave empty to skip):');
            const sl = prompt('Enter Stop Loss price (leave empty to skip):');
            
            if (!tp && !sl) return;
            
            try {
                const token = localStorage.getItem('enliko_token');
                const res = await fetch('/api/trading/modify-tpsl', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token 
                    },
                    body: JSON.stringify({ 
                        symbol,
                        take_profit: tp ? parseFloat(tp) : null,
                        stop_loss: sl ? parseFloat(sl) : null,
                        exchange: state.exchange || 'bybit',
                        account_type: state.accountType || 'demo'
                    })
                });
                
                const data = await res.json();
                if (data.success) {
                    showNotification('TP/SL updated', 'success');
                    loadPositions();
                } else {
                    showNotification(data.error || 'Failed to update TP/SL', 'error');
                }
            } catch (e) {
                showNotification('Error updating TP/SL', 'error');
            }
        }
        
        async function cancelOrder(orderId, symbol) {
            const confirmed = await showConfirm(
                '–í—ã –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω–æ —Ö–æ—Ç–∏—Ç–µ –æ—Ç–º–µ–Ω–∏—Ç—å —ç—Ç–æ—Ç –æ—Ä–¥–µ—Ä?',
                '–û—Ç–º–µ–Ω–∏—Ç—å –æ—Ä–¥–µ—Ä',
                { type: 'warning', confirmText: '–û—Ç–º–µ–Ω–∏—Ç—å', cancelText: '–ù–∞–∑–∞–¥' }
            );
            if (!confirmed) return;
            
            try {
                const token = localStorage.getItem('enliko_token');
                const res = await fetch('/api/trading/order', {
                    method: 'DELETE',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token 
                    },
                    body: JSON.stringify({ 
                        symbol: symbol,
                        order_id: orderId,
                        exchange: state.exchange || 'bybit',
                        account_type: state.accountType || 'demo'
                    })
                });
                
                const data = await res.json();
                if (data.success) {
                    showNotification('Order cancelled', 'success');
                    loadOrders();
                } else {
                    showNotification(data.error || 'Failed to cancel order', 'error');
                }
            } catch (e) {
                showNotification('Error cancelling order', 'error');
            }
        }
        
        async function closeAllPositions() {
            const count = state.positions?.length || 0;
            if (count === 0) {
                showNotification('No open positions', 'info');
                return;
            }
            const confirmed = await showConfirm(
                `<strong>–í–ù–ò–ú–ê–ù–ò–ï!</strong><br>–ë—É–¥—É—Ç –∑–∞–∫—Ä—ã—Ç—ã <strong>–í–°–ï ${count} –ø–æ–∑–∏—Ü–∏–π</strong>.<br>–≠—Ç–æ –¥–µ–π—Å—Ç–≤–∏–µ –Ω–µ–ª—å–∑—è –æ—Ç–º–µ–Ω–∏—Ç—å!`,
                '–ó–∞–∫—Ä—ã—Ç—å –≤—Å–µ –ø–æ–∑–∏—Ü–∏–∏',
                { type: 'danger', danger: true, confirmText: '–ó–∞–∫—Ä—ã—Ç—å –≤—Å—ë', cancelText: '–û—Ç–º–µ–Ω–∞' }
            );
            if (!confirmed) return;
            
            try {
                const token = localStorage.getItem('enliko_token');
                const res = await fetch('/api/trading/close-all', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token 
                    },
                    body: JSON.stringify({
                        exchange: state.exchange || 'bybit',
                        account_type: state.accountType || 'demo'
                    })
                });
                
                const data = await res.json();
                if (data.success) {
                    showNotification(`Closed ${data.closed || count} positions`, 'success');
                    loadPositions();
                    loadBalance();
                } else {
                    showNotification(data.error || 'Failed to close all positions', 'error');
                }
            } catch (e) {
                showNotification('Error closing positions', 'error');
            }
        }
        
        async function cancelAllOrders() {
            const count = state.orders?.length || 0;
            if (count === 0) {
                showNotification('No open orders', 'info');
                return;
            }
            const confirmed = await showConfirm(
                `–û—Ç–º–µ–Ω–∏—Ç—å <strong>–í–°–ï ${count} –æ—Ä–¥–µ—Ä–æ–≤</strong>?`,
                '–û—Ç–º–µ–Ω–∏—Ç—å –≤—Å–µ –æ—Ä–¥–µ—Ä–∞',
                { type: 'warning', confirmText: '–û—Ç–º–µ–Ω–∏—Ç—å –≤—Å—ë', cancelText: '–ù–∞–∑–∞–¥' }
            );
            if (!confirmed) return;
            
            try {
                const token = localStorage.getItem('enliko_token');
                const params = new URLSearchParams({
                    exchange: state.exchange || 'bybit',
                    account_type: state.accountType || 'demo'
                });
                
                const res = await fetch(`/api/trading/cancel-all-orders?${params}`, {
                    method: 'POST',
                    headers: { 
                        'Authorization': 'Bearer ' + token 
                    }
                });
                
                const data = await res.json();
                if (data.success) {
                    showNotification(`Cancelled ${data.cancelled || count} orders`, 'success');
                    loadOrders();
                } else {
                    showNotification(data.error || 'Failed to cancel orders', 'error');
                }
            } catch (e) {
                showNotification('Error cancelling orders', 'error');
            }
        }
        
        // Notification system with stacking
        const notifications = [];
        function showNotification(msg, type = 'info', duration = 3500) {
            // Create container if not exists
            let container = document.getElementById('notificationContainer');
            if (!container) {
                container = document.createElement('div');
                container.id = 'notificationContainer';
                container.style.cssText = 'position: fixed; top: 80px; right: 20px; z-index: 10000; display: flex; flex-direction: column; gap: 10px;';
                document.body.appendChild(container);
            }
            
            const n = document.createElement('div');
            const icons = { success: 'check-circle', error: 'exclamation-circle', warning: 'exclamation-triangle', info: 'info-circle' };
            const colors = { success: 'var(--green)', error: 'var(--red)', warning: '#f59e0b', info: 'var(--accent)' };
            
            n.className = 'notification notification-' + type;
            n.style.cssText = `padding: 14px 20px; border-radius: 12px; background: ${colors[type] || colors.info}; 
                color: white; font-weight: 500; box-shadow: 0 8px 32px rgba(0,0,0,0.3); display: flex; align-items: center; gap: 10px;
                animation: slideIn 0.3s ease; cursor: pointer;`;
            n.innerHTML = `<i class="fas fa-${icons[type] || icons.info}"></i><span>${msg}</span>`;
            n.onclick = () => dismissNotification(n);
            
            container.appendChild(n);
            notifications.push(n);
            
            // Auto dismiss
            setTimeout(() => dismissNotification(n), duration);
        }
        
        function dismissNotification(n) {
            if (!n || !n.parentNode) return;
            n.style.animation = 'slideOut 0.2s ease';
            setTimeout(() => {
                n.remove();
                const idx = notifications.indexOf(n);
                if (idx > -1) notifications.splice(idx, 1);
            }, 200);
        }
        
        // Symbol Modal
        function openSymbolModal() {
            document.getElementById('symbolModal').classList.add('active');
            document.getElementById('symbolSearch').focus();
            // Load fresh symbols from API
            fetchSymbolsFromAPI();
        }
        
        function closeSymbolModal() {
            document.getElementById('symbolModal').classList.remove('active');
        }
        
        let liveSymbols = symbols; // Will be updated with API data
        
        async function fetchSymbolsFromAPI(query = '') {
            const list = document.getElementById('symbolList');
            try {
                state.loading.symbols = true;
                list.innerHTML = '<div class="loading-overlay"><div class="loading-spinner"></div><span>Loading symbols...</span></div>';
                
                const params = new URLSearchParams({ limit: '50' });
                if (query) params.append('query', query);
                
                const res = await fetch(`/api/trading/symbols?${params}`);
                if (res.ok) {
                    const data = await res.json();
                    if (data.symbols && data.symbols.length > 0) {
                        liveSymbols = data.symbols.map(s => ({
                            symbol: s.symbol,
                            name: s.base,
                            price: s.price || 0,
                            change: s.change_24h || 0,
                            volume: s.volume_formatted || 'N/A',
                            funding: s.funding_rate ? (s.funding_rate * 100).toFixed(4) + '%' : null
                        }));
                        renderSymbolList();
                    }
                }
            } catch (e) {
                console.log('Symbol fetch error:', e);
                list.innerHTML = '<div class="error-state"><i class="fas fa-exclamation-triangle"></i><p>Failed to load symbols</p></div>';
            } finally {
                state.loading.symbols = false;
            }
        }
        
        function formatVolume(vol) {
            if (!vol || isNaN(vol)) return 'N/A';
            if (vol >= 1e9) return (vol / 1e9).toFixed(2) + 'B';
            if (vol >= 1e6) return (vol / 1e6).toFixed(2) + 'M';
            if (vol >= 1e3) return (vol / 1e3).toFixed(1) + 'K';
            return vol.toFixed(0);
        }
        
        function renderSymbolList(filter = '') {
            const list = document.getElementById('symbolList');
            const sourceSymbols = liveSymbols.length > 0 ? liveSymbols : symbols;
            const filtered = sourceSymbols.filter(s => 
                s.symbol.toLowerCase().includes(filter.toLowerCase()) || 
                s.name.toLowerCase().includes(filter.toLowerCase())
            );
            
            if (!filtered.length) {
                list.innerHTML = '<div class="empty-state"><i class="fas fa-search"></i><p>No symbols found</p></div>';
                return;
            }
            
            list.innerHTML = filtered.map(s => `
                <div class="symbol-item" onclick="selectSymbol('${s.symbol}')">
                    <div class="symbol-item-info">
                        <div class="symbol-item-icon">${s.symbol.slice(0,2)}</div>
                        <div>
                            <div class="symbol-item-name">${s.symbol.replace('USDT', '')}</div>
                            <div class="symbol-item-full">${s.name} Perpetual</div>
                        </div>
                    </div>
                    <div class="symbol-item-stats">
                        <div class="symbol-item-price">
                            <div class="price">$${parseFloat(s.price || 0).toLocaleString(undefined, {maximumFractionDigits: 6})}</div>
                            <div class="change ${s.change >= 0 ? 'positive' : 'negative'}">${s.change >= 0 ? '+' : ''}${(s.change || 0).toFixed(2)}%</div>
                        </div>
                        <div class="symbol-item-volume">
                            <div class="volume-label">Vol 24h</div>
                            <div class="volume-value">${s.volume || 'N/A'}</div>
                        </div>
                    </div>
                </div>
            `).join('');
        }
        
        function filterSymbols() {
            renderSymbolList(document.getElementById('symbolSearch').value);
        }
        
        function selectSymbol(symbol) {
            state.symbol = symbol;
            const s = symbols.find(x => x.symbol === symbol);
            document.getElementById('symbolName').textContent = symbol;
            document.getElementById('symbolPrice').textContent = '$' + s.price.toLocaleString();
            document.getElementById('symbolChange').textContent = (s.change >= 0 ? '+' : '') + s.change.toFixed(2) + '%';
            document.getElementById('symbolChange').className = 'symbol-change ' + (s.change >= 0 ? 'positive' : 'negative');
            document.getElementById('sizeSymbol').textContent = symbol.replace('USDT', '');
            closeSymbolModal();
            initTradingView();
            
            // Refresh trade history if panel is open
            if (tradeHistoryVisible) {
                loadTradeHistory();
            }
        }
        
        // Close modal on outside click
        document.getElementById('symbolModal').addEventListener('click', (e) => {
            if (e.target.classList.contains('modal-overlay')) closeSymbolModal();
        });
        
        // ============================================================
        // ADVANCED TERMINAL FEATURES INTEGRATION
        // ============================================================
        
        // Initialize Risk Calculator
        function initRiskCalculator() {
            const panel = document.getElementById('riskCalcPanel');
            if (!panel) return;
            
            RiskCalculator.state.accountBalance = parseFloat(
                document.getElementById('availableBalance')?.textContent.replace(/[$,]/g, '') || 10000
            );
            RiskCalculator.state.leverage = state.leverage;
            
            // Update on input changes
            ['riskEntry', 'riskSL', 'riskTP', 'riskPercent'].forEach(id => {
                const el = document.getElementById(id);
                if (el) {
                    el.addEventListener('input', () => {
                        RiskCalculator.state.entryPrice = parseFloat(document.getElementById('riskEntry')?.value) || 0;
                        RiskCalculator.state.stopLoss = parseFloat(document.getElementById('riskSL')?.value) || 0;
                        RiskCalculator.state.riskPercent = parseFloat(document.getElementById('riskPercent')?.value) || 1;
                        
                        const tp = parseFloat(document.getElementById('riskTP')?.value);
                        const result = tp ? RiskCalculator.setRiskReward(tp) : RiskCalculator.calculate();
                        
                        if (result) {
                            document.getElementById('riskResult').innerHTML = RiskCalculator.render();
                        }
                    });
                }
            });
        }
        
        // Initialize DCA Builder
        function initDCABuilder() {
            const panel = document.getElementById('dcaPanel');
            if (!panel) return;
            
            DCABuilder.state.entryPrice = state.lastPrice;
            DCABuilder.state.side = state.side;
        }
        
        // Enhanced orderbook with real data
        async function fetchRealOrderbook() {
            try {
                const res = await fetch(`/api/trading/orderbook/${state.symbol}?depth=25`);
                if (res.ok) {
                    const data = await res.json();
                    if (!data.error) {
                        updateOrderbookUI(data);
                    }
                }
            } catch (e) {
                console.log('Orderbook fetch error:', e);
            }
        }
        
        // Cache for orderbook to prevent unnecessary DOM updates
        let lastOrderbookHash = '';
        
        function updateOrderbookUI(data) {
            const asksEl = document.getElementById('asks');
            const bidsEl = document.getElementById('bids');
            if (!asksEl || !bidsEl) return;
            
            // Skip if data hasn't changed (reduces flickering)
            const currentHash = JSON.stringify(data.asks.slice(0, 10)) + JSON.stringify(data.bids.slice(0, 10));
            if (currentHash === lastOrderbookHash) return;
            lastOrderbookHash = currentHash;
            
            // Use requestAnimationFrame for smoother rendering
            requestAnimationFrame(() => {
                // Update heatmap analysis
                OrderbookHeatmap.update(data.asks, data.bids);
                
                // Render asks (reversed for display)
                asksEl.innerHTML = data.asks.slice().reverse().map(([price, size, total, depth]) => {
                    const heatColor = OrderbookHeatmap.getHeatColor(size, 'ask');
                    const isWhale = size > OrderbookHeatmap.state.maxSize * 0.3;
                    return `<div class="orderbook-row ask ${isWhale ? 'whale' : ''}" onclick="setPrice(${price})" style="--heat-color: ${heatColor};">
                        <span class="price">${price.toLocaleString(undefined, {minimumFractionDigits: 2})}</span>
                        <span class="size ${isWhale ? 'highlight' : ''}">${size.toFixed(4)}</span>
                        <span class="total">${total.toFixed(2)}</span>
                        <div class="depth" style="width: ${depth}%;"></div>
                        ${isWhale ? '<i class="fas fa-fish whale-icon"></i>' : ''}
                    </div>`;
                }).join('');
                
                // Render bids
                bidsEl.innerHTML = data.bids.map(([price, size, total, depth]) => {
                    const heatColor = OrderbookHeatmap.getHeatColor(size, 'bid');
                    const isWhale = size > OrderbookHeatmap.state.maxSize * 0.3;
                    return `<div class="orderbook-row bid ${isWhale ? 'whale' : ''}" onclick="setPrice(${price})" style="--heat-color: ${heatColor};">
                        <span class="price">${price.toLocaleString(undefined, {minimumFractionDigits: 2})}</span>
                        <span class="size ${isWhale ? 'highlight' : ''}">${size.toFixed(4)}</span>
                        <span class="total">${total.toFixed(2)}</span>
                        <div class="depth" style="width: ${depth}%;"></div>
                        ${isWhale ? '<i class="fas fa-fish whale-icon"></i>' : ''}
                    </div>`;
                }).join('');
                
                // Update spread
                if (data.asks.length && data.bids.length) {
                    document.getElementById('spreadValue').textContent = '$' + data.spread.toFixed(2);
                    document.getElementById('spreadPercent').textContent = data.spread_percent.toFixed(4) + '%';
                    
                    // Update imbalance indicator
                    const imbalanceEl = document.getElementById('imbalanceIndicator');
                    if (imbalanceEl) {
                        const color = data.imbalance > 10 ? 'var(--green)' : data.imbalance < -10 ? 'var(--red)' : 'var(--text-muted)';
                        const label = data.imbalance > 10 ? 'Bullish' : data.imbalance < -10 ? 'Bearish' : 'Neutral';
                        imbalanceEl.innerHTML = `
                            <div class="imbalance-bar"><div class="imbalance-fill" style="width: ${50 + data.imbalance/2}%; background: ${color};"></div></div>
                            <span class="imbalance-label" style="color: ${color};">${label} (${data.imbalance.toFixed(1)}%)</span>
                        `;
                    }
                }
            });
        }
        
        // One-Click Trading toggle
        function toggleOneClickTrading() {
            if (OneClickTrading.state.enabled) {
                OneClickTrading.disable();
                document.getElementById('oneClickToggle')?.classList.remove('active');
            } else {
                OneClickTrading.enable();
                document.getElementById('oneClickToggle')?.classList.add('active');
            }
        }
        
        // Show keyboard shortcuts
        function showShortcuts() {
            Shortcuts.showHelp();
        }
        
        // Enhanced WebSocket connection with orderbook streaming
        function connectAdvancedWebSocket() {
            const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
            const userId = localStorage.getItem('enliko_user_id') || 0;
            
            const ws = new WebSocket(`${proto}//${location.host}/ws/terminal/${userId}`);
            
            ws.onopen = () => {
                console.log('Advanced WS connected');
                // Subscribe to orderbook updates
                ws.send(JSON.stringify({
                    type: 'subscribe_orderbook',
                    symbol: state.symbol
                }));
            };
            
            ws.onmessage = (e) => {
                try {
                    const data = JSON.parse(e.data);
                    
                    switch (data.type) {
                        case 'orderbook':
                            updateOrderbookUI(data);
                            break;
                        case 'trades':
                            updateRecentTrades(data.trades);
                            break;
                        case 'price_update':
                            updatePriceDisplay(data.data);
                            break;
                        case 'signal':
                            handleSignal(data.data);
                            break;
                        case 'positions':
                            renderPositions(data.data);
                            break;
                    }
                } catch (err) {
                    console.log('WS message error:', err);
                }
            };
            
            ws.onclose = () => {
                setTimeout(connectAdvancedWebSocket, 5000);
            };
            
            return ws;
        }
        
        function updateRecentTrades(trades) {
            const list = document.getElementById('tradesList');
            if (!list) return;
            
            const newTrades = trades.map(t => ({
                isBuy: t.side === 'Buy',
                price: t.price,
                size: t.size,
                time: new Date(t.time)
            }));
            
            state.recentTrades = [...newTrades, ...state.recentTrades].slice(0, 50);
            renderRecentTrades();
        }
        
        function updatePriceDisplay(data) {
            if (data.price) {
                state.lastPrice = data.price;
                document.getElementById('symbolPrice').textContent = '$' + data.price.toLocaleString();
            }
            if (data.change24h !== undefined) {
                const changeEl = document.getElementById('symbolChange');
                changeEl.textContent = (data.change24h >= 0 ? '+' : '') + data.change24h.toFixed(2) + '%';
                changeEl.className = 'symbol-change ' + (data.change24h >= 0 ? 'positive' : 'negative');
            }
        }
        
        function handleSignal(signal) {
            // Add to signal feed
            const feed = document.getElementById('signalFeed');
            if (feed) {
                const item = document.createElement('div');
                item.className = `signal-item ${signal.side.toLowerCase()}`;
                item.innerHTML = `
                    <div class="signal-info">
                        <span class="signal-strategy">${signal.strategy}</span>
                        <span class="signal-reason">${signal.reason}</span>
                    </div>
                    <span class="signal-confidence ${signal.confidence >= 0.75 ? 'high' : 'medium'}">
                        ${(signal.confidence * 100).toFixed(0)}%
                    </span>
                `;
                feed.insertBefore(item, feed.firstChild);
                
                // Keep only last 10 signals
                while (feed.children.length > 10) {
                    feed.removeChild(feed.lastChild);
                }
            }
            
            // Show notification
            Notifications.show(
                `${signal.strategy}: ${signal.side.toUpperCase()} ${signal.symbol}`,
                signal.side.toLowerCase() === 'buy' ? 'success' : 'warning',
                5000
            );
        }
        
        // ============================================================
        // PANEL TOGGLE FUNCTIONS
        // ============================================================
        
        function showRiskCalc() {
            document.getElementById('riskCalcPanel').style.display = 'block';
            document.getElementById('dcaPanel').style.display = 'none';
            // Pre-fill with current price
            document.getElementById('riskEntry').value = state.lastPrice || '';
        }
        
        function hideRiskCalc() {
            document.getElementById('riskCalcPanel').style.display = 'none';
        }
        
        function showDCABuilder() {
            document.getElementById('dcaPanel').style.display = 'block';
            document.getElementById('riskCalcPanel').style.display = 'none';
            updateDCAPreview();
        }
        
        function hideDCABuilder() {
            document.getElementById('dcaPanel').style.display = 'none';
        }
        
        function setRiskPreset(percent) {
            document.getElementById('riskPercent').value = percent;
            document.querySelectorAll('.risk-preset-btn').forEach(btn => {
                btn.classList.toggle('active', parseFloat(btn.textContent) === percent);
            });
            // Trigger recalculation
            document.getElementById('riskPercent').dispatchEvent(new Event('input'));
        }
        
        function applyRiskCalc() {
            const result = RiskCalculator.calculate();
            if (result) {
                document.getElementById('sizeInput').value = result.positionSize.toFixed(4);
                document.getElementById('priceInput').value = RiskCalculator.state.entryPrice;
                
                // Set TP/SL if calculated
                if (document.getElementById('riskSL').value) {
                    state.tpslEnabled = true;
                    document.getElementById('tpslToggle').classList.add('active');
                    document.getElementById('tpslInputs').style.display = 'grid';
                    document.getElementById('slInput').value = document.getElementById('riskSL').value;
                }
                if (document.getElementById('riskTP').value) {
                    document.getElementById('tpInput').value = document.getElementById('riskTP').value;
                }
                
                hideRiskCalc();
                updateOrderSummary();
                Notifications.show('Position size applied from Risk Calculator', 'success');
            }
        }
        
        // ============================================================
        // DCA BUILDER FUNCTIONS
        // ============================================================
        
        function updateDCAPreview() {
            const totalSize = parseFloat(document.getElementById('dcaTotalSize').value) || 0.1;
            const orderCount = parseInt(document.getElementById('dcaOrderCount').value) || 5;
            const range = parseFloat(document.getElementById('dcaRange').value) || 5;
            const distribution = document.getElementById('dcaDistribution').value;
            const entryPrice = state.lastPrice || 0;
            
            if (!entryPrice) return;
            
            // Calculate weights
            const weights = {
                linear: Array(orderCount).fill(1),
                geometric: Array.from({length: orderCount}, (_, i) => Math.pow(1.5, i)),
                fibonacci: (() => { let f = [1, 1]; for(let i = 2; i < orderCount; i++) f.push(f[i-1]+f[i-2]); return f.slice(0, orderCount); })(),
                exponential: Array.from({length: orderCount}, (_, i) => Math.pow(2, i))
            }[distribution] || Array(orderCount).fill(1);
            
            const totalWeight = weights.reduce((a, b) => a + b, 0);
            const priceStep = (entryPrice * range / 100) / (orderCount - 1);
            const isBuy = state.side === 'buy';
            
            const orders = [];
            let totalValue = 0;
            
            for (let i = 0; i < orderCount; i++) {
                const size = totalSize * (weights[i] / totalWeight);
                const price = isBuy ? entryPrice - (priceStep * i) : entryPrice + (priceStep * i);
                const value = price * size;
                totalValue += value;
                
                orders.push({
                    index: i + 1,
                    price: price.toFixed(2),
                    size: size.toFixed(4),
                    pct: ((price - entryPrice) / entryPrice * 100).toFixed(2)
                });
            }
            
            // Calculate average entry
            const avgEntry = totalValue / totalSize;
            
            // Update summary
            document.getElementById('dcaSummary').innerHTML = `
                <div class="dca-stat">
                    <span>Avg Entry</span>
                    <strong>$${avgEntry.toFixed(2)}</strong>
                </div>
                <div class="dca-stat">
                    <span>Total Value</span>
                    <strong>$${totalValue.toFixed(2)}</strong>
                </div>
                <div class="dca-stat">
                    <span>Range</span>
                    <strong>${range}%</strong>
                </div>
            `;
            
            // Update orders list
            document.getElementById('dcaOrdersList').innerHTML = orders.map(o => `
                <div class="dca-order ${state.side}">
                    <span class="order-num">#${o.index}</span>
                    <span class="order-price">$${parseFloat(o.price).toLocaleString()}</span>
                    <span class="order-size">${o.size}</span>
                    <span class="order-pct">${o.pct}%</span>
                </div>
            `).join('');
        }
        
        async function placeDCALadder() {
            const totalSize = parseFloat(document.getElementById('dcaTotalSize').value) || 0.1;
            const orderCount = parseInt(document.getElementById('dcaOrderCount').value) || 5;
            const range = parseFloat(document.getElementById('dcaRange').value) || 5;
            const distribution = document.getElementById('dcaDistribution').value;
            
            if (!state.lastPrice) {
                Notifications.show('Price not available', 'error');
                return;
            }
            
            try {
                const token = localStorage.getItem('enliko_token');
                const res = await fetch('/api/trading/dca-ladder', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token
                    },
                    body: JSON.stringify({
                        symbol: state.symbol,
                        side: state.side,
                        total_size: totalSize,
                        order_count: orderCount,
                        price_range_percent: range,
                        distribution: distribution,
                        entry_price: state.lastPrice,
                        exchange: state.exchange || 'bybit',
                        account_type: document.getElementById('accountSelect')?.value || 'demo',
                        leverage: state.leverage
                    })
                });
                
                const data = await res.json();
                if (data.success) {
                    Notifications.show(`Placed ${data.placed}/${data.total} DCA orders`, 'success');
                    hideDCABuilder();
                    loadPositions();
                } else {
                    Notifications.show(data.error || 'Failed to place DCA orders', 'error');
                }
            } catch (e) {
                Notifications.show('Error placing DCA orders', 'error');
            }
        }
        
        // Add event listeners for DCA inputs
        ['dcaTotalSize', 'dcaOrderCount', 'dcaRange', 'dcaDistribution'].forEach(id => {
            const el = document.getElementById(id);
            if (el) {
                el.addEventListener('input', updateDCAPreview);
                el.addEventListener('change', updateDCAPreview);
            }
        });
        
        // ============================================================
        // ALERTS PANEL UPDATE
        // ============================================================
        
        function updateAlertsPanel() {
            const list = document.getElementById('alertsList');
            if (!list || typeof SmartAlerts === 'undefined') return;
            
            const activeAlerts = SmartAlerts.alerts.filter(a => a.active);
            
            if (activeAlerts.length === 0) {
                list.innerHTML = '<p class="empty">No active alerts</p>';
                return;
            }
            
            list.innerHTML = activeAlerts.map(a => `
                <div class="alert-item">
                    <div class="alert-info">
                        <span class="alert-symbol">${a.symbol}</span>
                        <span class="alert-condition">${a.condition} $${a.value.toLocaleString()}</span>
                    </div>
                    <button class="alert-remove" onclick="SmartAlerts.remove(${a.id}); updateAlertsPanel();">
                        <i class="fas fa-times"></i>
                    </button>
                </div>
            `).join('');
        }
        
        // Initialize advanced features on load
        document.addEventListener('DOMContentLoaded', () => {
            // Load user settings from server
            loadUserSettings();
            
            // Load strategy settings for TP/SL presets
            loadStrategySettings();
            
            // Connect to Settings Sync WebSocket
            connectSettingsSyncWebSocket();
            
            // Load advanced JS module
            const script = document.createElement('script');
            script.src = '/static/js/terminal-advanced.js';
            script.onload = () => {
                initRiskCalculator();
                initDCABuilder();
                SmartAlerts.load();
                PositionAnalytics.fetchStats();
                updateAlertsPanel();
                
                // Start real orderbook polling (optimized: 4s interval to reduce flickering)
                setInterval(fetchRealOrderbook, 4000);
                
                // Periodic alerts panel update
                setInterval(updateAlertsPanel, 5000);
            };
            document.body.appendChild(script);
            
            // Request notification permission
            if ('Notification' in window && Notification.permission === 'default') {
                Notification.requestPermission();
            }
        });
        
        // ============================================================
        // EXCHANGE & ACCOUNT SWITCHING
        // ============================================================
        
        async function loadUserSettings() {
            try {
                const token = localStorage.getItem('enliko_token');
                if (!token) return;
                
                const res = await fetch('/api/users/me', {
                    headers: { 'Authorization': 'Bearer ' + token }
                });
                
                if (res.ok) {
                    const data = await res.json();
                    if (data.user) {
                        // Set exchange and account type from user settings
                        state.exchange = data.user.exchange_type || 'bybit';
                        state.accountType = data.user.trading_mode || 'demo';
                        state.leverage = data.user.leverage || 10;
                        
                        // Update UI
                        document.getElementById('exchangeSelect').value = state.exchange;
                        document.getElementById('accountSelect').value = state.accountType;
                        updateAccountBadge();
                        updateExchangeUI();
                        setLeverage(state.leverage);
                    }
                }
            } catch (e) {
                console.error('Failed to load user settings:', e);
            }
        }
        
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        // WALLET CONNECTION (MetaMask/Web3)
        // ‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê‚ïê
        
        let walletConnected = false;
        let walletAddress = null;
        
        async function connectWallet() {
            if (typeof window.ethereum === 'undefined') {
                showNotification('Please install MetaMask extension', 'error');
                window.open('https://metamask.io/download/', '_blank');
                return;
            }
            
            try {
                const accounts = await window.ethereum.request({ method: 'eth_requestAccounts' });
                walletAddress = accounts[0];
                walletConnected = true;
                
                // Update UI
                const walletBtn = document.getElementById('walletBtnText');
                if (walletBtn) {
                    walletBtn.textContent = walletAddress.slice(0, 6) + '...' + walletAddress.slice(-4);
                }
                
                // Save to backend
                const response = await fetch('/api/web3/connect', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json',
                        'Authorization': `Bearer ${localStorage.getItem('enliko_token') || ''}`
                    },
                    body: JSON.stringify({ address: walletAddress })
                });
                
                if (response.ok) {
                    showNotification('Wallet connected successfully!', 'success');
                } else {
                    showNotification('Failed to save wallet connection', 'warning');
                }
                
                // Listen for account changes
                window.ethereum.on('accountsChanged', handleAccountsChanged);
                window.ethereum.on('chainChanged', () => window.location.reload());
                
            } catch (error) {
                console.error('Wallet connection error:', error);
                showNotification('Failed to connect wallet: ' + error.message, 'error');
            }
        }
        
        function handleAccountsChanged(accounts) {
            if (accounts.length === 0) {
                walletConnected = false;
                walletAddress = null;
                document.getElementById('walletBtnText').textContent = 'Connect Wallet';
                showNotification('Wallet disconnected', 'info');
            } else {
                walletAddress = accounts[0];
                document.getElementById('walletBtnText').textContent = 
                    walletAddress.slice(0, 6) + '...' + walletAddress.slice(-4);
            }
        }
        
        // Check if wallet already connected on page load
        async function checkWalletConnection() {
            if (typeof window.ethereum !== 'undefined') {
                try {
                    const accounts = await window.ethereum.request({ method: 'eth_accounts' });
                    if (accounts.length > 0) {
                        walletAddress = accounts[0];
                        walletConnected = true;
                        document.getElementById('walletBtnText').textContent = 
                            walletAddress.slice(0, 6) + '...' + walletAddress.slice(-4);
                    }
                } catch (error) {
                    console.error('Check wallet error:', error);
                }
            }
        }
        
        async function changeExchange() {
            const newExchange = document.getElementById('exchangeSelect').value;
            if (newExchange === state.exchange) return;
            
            const prevExchange = state.exchange;
            state.exchange = newExchange;
            
            try {
                const token = localStorage.getItem('enliko_token');
                const res = await fetch('/api/users/exchange', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token 
                    },
                    body: JSON.stringify({ 
                        exchange: newExchange,
                        reconnect: true
                    })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showNotification(`Switched to ${newExchange.toUpperCase()}`, 'success');
                    updateExchangeUI();
                    updateAccountTypeOptions();
                    
                    // Reconnect WebSocket for new exchange
                    reconnectWebSockets();
                    
                    // Reload positions for new exchange
                    loadPositions();
                    
                    // Update balance display
                    if (data.balance) {
                        document.getElementById('availableBalance').textContent = '$' + data.balance.available.toLocaleString();
                        document.getElementById('equity').textContent = '$' + data.balance.equity.toLocaleString();
                    }
                } else {
                    // Revert on failure
                    state.exchange = prevExchange;
                    document.getElementById('exchangeSelect').value = prevExchange;
                    showNotification(data.error || 'Failed to switch exchange', 'error');
                }
            } catch (e) {
                state.exchange = prevExchange;
                document.getElementById('exchangeSelect').value = prevExchange;
                showNotification('Connection error', 'error');
            }
        }
        
        async function changeAccountType() {
            const newAccountType = document.getElementById('accountSelect').value;
            if (newAccountType === state.accountType) return;
            
            const prevAccountType = state.accountType;
            state.accountType = newAccountType;
            
            // Save to localStorage for persistence across pages
            localStorage.setItem('account_type', newAccountType);
            
            try {
                const token = localStorage.getItem('enliko_token');
                const res = await fetch('/api/users/switch-account-type', {
                    method: 'POST',
                    headers: { 
                        'Content-Type': 'application/json',
                        'Authorization': 'Bearer ' + token 
                    },
                    body: JSON.stringify({ 
                        account_type: newAccountType,
                        exchange: state.exchange
                    })
                });
                
                const data = await res.json();
                
                if (data.success) {
                    showNotification(`Switched to ${newAccountType.toUpperCase()}`, 'success');
                    updateAccountBadge();
                    
                    // Reload positions for new account type
                    loadPositions();
                    
                    // Reload strategy settings for new account type
                    loadStrategySettings();
                    
                    // Update balance
                    if (data.balance) {
                        document.getElementById('availableBalance').textContent = '$' + data.balance.available.toLocaleString();
                        document.getElementById('equity').textContent = '$' + data.balance.equity.toLocaleString();
                    }
                } else {
                    state.accountType = prevAccountType;
                    document.getElementById('accountSelect').value = prevAccountType;
                    showNotification(data.error || 'Failed to switch account', 'error');
                }
            } catch (e) {
                state.accountType = prevAccountType;
                document.getElementById('accountSelect').value = prevAccountType;
                showNotification('Connection error', 'error');
            }
        }
        
        function updateAccountBadge() {
            const badge = document.getElementById('accountBadge');
            if (state.accountType === 'demo' || state.accountType === 'testnet') {
                badge.className = 'demo-badge';
                badge.textContent = 'DEMO';
            } else {
                badge.className = 'real-badge';
                badge.textContent = 'REAL';
            }
        }
        
        function updateAccountTypeOptions() {
            const select = document.getElementById('accountSelect');
            select.innerHTML = '';
            
            if (state.exchange === 'bybit') {
                select.innerHTML = `
                    <option value="demo">Demo</option>
                    <option value="real">Real</option>
                `;
            } else if (state.exchange === 'hyperliquid') {
                select.innerHTML = `
                    <option value="testnet">Testnet</option>
                    <option value="mainnet">Mainnet</option>
                `;
            }
            
            // Set current value
            if (state.exchange === 'hyperliquid') {
                state.accountType = state.accountType === 'demo' ? 'testnet' : 
                                    state.accountType === 'real' ? 'mainnet' : state.accountType;
            } else {
                state.accountType = state.accountType === 'testnet' ? 'demo' : 
                                    state.accountType === 'mainnet' ? 'real' : state.accountType;
            }
            
            select.value = state.accountType;
            updateAccountBadge();
        }
        
        function updateExchangeUI() {
            const exchangeBadge = document.querySelector('.exchange-select');
            const logo = document.querySelector('.logo-icon');
            
            // Update exchange-specific styling
            document.body.setAttribute('data-exchange', state.exchange);
            
            if (state.exchange === 'hyperliquid') {
                // HyperLiquid specific features
                document.querySelectorAll('.bybit-only').forEach(el => el.style.display = 'none');
                document.querySelectorAll('.hl-only').forEach(el => el.style.display = '');
                
                // Update max leverage for HyperLiquid
                const slider = document.getElementById('leverageSlider');
                slider.max = 50; // HyperLiquid max
                if (state.leverage > 50) setLeverage(50);
                
                // Update leverage marks
                const marks = document.querySelector('.leverage-marks');
                if (marks) {
                    marks.innerHTML = `
                        <span onclick="setLeverage(1)">1x</span>
                        <span onclick="setLeverage(5)">5x</span>
                        <span onclick="setLeverage(10)">10x</span>
                        <span onclick="setLeverage(20)">20x</span>
                        <span onclick="setLeverage(50)">50x</span>
                    `;
                }
                
                // HyperLiquid doesn't have margin mode selection
                document.querySelector('.margin-mode-row')?.classList.add('hl-hidden');
                
            } else {
                // Bybit specific features
                document.querySelectorAll('.bybit-only').forEach(el => el.style.display = '');
                document.querySelectorAll('.hl-only').forEach(el => el.style.display = 'none');
                
                // Restore max leverage for Bybit
                const slider = document.getElementById('leverageSlider');
                slider.max = 100;
                
                // Restore leverage marks
                const marks = document.querySelector('.leverage-marks');
                if (marks) {
                    marks.innerHTML = `
                        <span onclick="setLeverage(1)">1x</span>
                        <span onclick="setLeverage(5)">5x</span>
                        <span onclick="setLeverage(10)">10x</span>
                        <span onclick="setLeverage(25)">25x</span>
                        <span onclick="setLeverage(50)">50x</span>
                        <span onclick="setLeverage(100)">100x</span>
                    `;
                }
                
                document.querySelector('.margin-mode-row')?.classList.remove('hl-hidden');
            }
            
            // Update TradingView chart symbol prefix
            initTradingView();
        }
        
        function reconnectWebSockets() {
            // Close existing connections
            if (state.ws) {
                state.ws.close();
            }
            
            // Reconnect with new exchange context
            setTimeout(() => {
                connectWebSocket();
                connectAdvancedWebSocket();
            }, 500);
        }
        
        // ============================================================
        // SETTINGS SYNC WEBSOCKET
        // ============================================================
        
        function connectSettingsSyncWebSocket() {
            let userId = localStorage.getItem('enliko_user_id');
            
            // Fallback: try to get from enliko_user object
            if (!userId) {
                try {
                    const userObj = JSON.parse(localStorage.getItem('enliko_user') || '{}');
                    if (userObj.user_id) {
                        userId = userObj.user_id.toString();
                        localStorage.setItem('enliko_user_id', userId);
                    }
                } catch (e) {}
            }
            
            if (!userId) {
                console.log('No user_id for settings sync, will retry after auth');
                return;
            }
            
            const proto = location.protocol === 'https:' ? 'wss:' : 'ws:';
            
            try {
                state.settingsWs = new WebSocket(`${proto}//${location.host}/ws/settings-sync/${userId}`);
                
                state.settingsWs.onopen = () => {
                    console.log('Settings sync connected');
                    // Request current settings
                    state.settingsWs.send(JSON.stringify({ type: 'get_settings' }));
                };
                
                state.settingsWs.onmessage = (e) => {
                    try {
                        const data = JSON.parse(e.data);
                        handleSettingsSyncMessage(data);
                    } catch (err) {
                        console.log('Settings sync parse error:', err);
                    }
                };
                
                state.settingsWs.onclose = () => {
                    console.log('Settings sync disconnected, reconnecting...');
                    setTimeout(connectSettingsSyncWebSocket, 5000);
                };
                
                state.settingsWs.onerror = () => {
                    state.settingsWs.close();
                };
            } catch (e) {
                console.error('Failed to connect settings sync:', e);
            }
        }
        
        function handleSettingsSyncMessage(data) {
            switch (data.type) {
                case 'exchange_switched':
                    // Another device switched exchange
                    if (data.exchange !== state.exchange) {
                        state.exchange = data.exchange;
                        document.getElementById('exchangeSelect').value = data.exchange;
                        updateExchangeUI();
                        updateAccountTypeOptions();
                        showNotification(`Exchange switched to ${data.exchange.toUpperCase()} from another device`, 'info');
                        reconnectWebSockets();
                        loadPositions();
                    }
                    break;
                    
                case 'settings_changed':
                    // Settings updated from another source
                    if (data.settings) {
                        if (data.settings.leverage && data.settings.leverage !== state.leverage) {
                            setLeverage(data.settings.leverage);
                        }
                        if (data.settings.trading_mode && data.settings.trading_mode !== state.accountType) {
                            state.accountType = data.settings.trading_mode;
                            document.getElementById('accountSelect').value = state.accountType;
                            updateAccountBadge();
                        }
                    }
                    break;
                    
                case 'strategy_deployed':
                    // Strategy was deployed from backtest
                    showNotification(`Strategy "${data.strategy_name}" deployed! Parameters applied.`, 'success');
                    if (data.params) {
                        // Apply strategy parameters
                        if (data.params.leverage) setLeverage(data.params.leverage);
                        if (data.params.tp_percent) {
                            document.getElementById('tpInput').value = data.params.tp_percent;
                        }
                        if (data.params.sl_percent) {
                            document.getElementById('slInput').value = data.params.sl_percent;
                        }
                    }
                    break;
                    
                case 'preset_loaded':
                    // User loaded a preset from marketplace
                    showNotification(`Preset "${data.preset_name}" loaded`, 'success');
                    loadUserSettings(); // Reload all settings
                    break;
                    
                case 'credentials_updated':
                    // API credentials were updated
                    showNotification('API credentials updated, reconnecting...', 'info');
                    reconnectWebSockets();
                    loadPositions();
                    break;
                    
                case 'current_settings':
                    // Initial settings load
                    if (data.settings) {
                        state.exchange = data.settings.exchange_type || 'bybit';
                        state.accountType = data.settings.trading_mode || 'demo';
                        state.leverage = data.settings.leverage || 10;
                        
                        document.getElementById('exchangeSelect').value = state.exchange;
                        updateAccountTypeOptions();
                        setLeverage(state.leverage);
                        updateExchangeUI();
                    }
                    break;
            }
        }
        
        // Notify settings changes to sync
        function notifySettingsChange(changeType, data) {
            if (state.settingsWs && state.settingsWs.readyState === WebSocket.OPEN) {
                state.settingsWs.send(JSON.stringify({
                    type: 'update_setting',
                    change_type: changeType,
                    data: data
                }));
            }
        }
        
        // ===== Language & Theme Management =====
        
        const LANGUAGES = {
            'en': { flag: 'üá∫üá∏', name: 'English' },
            'ru': { flag: 'üá∑üá∫', name: '–†—É—Å—Å–∫–∏–π' },
            'uk': { flag: 'üá∫üá¶', name: '–£–∫—Ä–∞—ó–Ω—Å—å–∫–∞' },
            'zh': { flag: 'üá®üá≥', name: '‰∏≠Êñá' },
            'es': { flag: 'üá™üá∏', name: 'Espa√±ol' },
            'de': { flag: 'üá©üá™', name: 'Deutsch' },
            'fr': { flag: 'üá´üá∑', name: 'Fran√ßais' },
            'it': { flag: 'üáÆüáπ', name: 'Italiano' },
            'ja': { flag: 'üáØüáµ', name: 'Êó•Êú¨Ë™û' },
            'ar': { flag: 'üá∏üá¶', name: 'ÿßŸÑÿπÿ±ÿ®Ÿäÿ©' },
            'he': { flag: 'üáÆüá±', name: '◊¢◊ë◊®◊ô◊™' },
            'pl': { flag: 'üáµüá±', name: 'Polski' }
        };
        
        function toggleLangMenu() {
            const menu = document.getElementById('langMenu');
            const themeMenu = document.getElementById('themeMenu');
            
            // Close theme menu if open
            if (themeMenu.classList.contains('show')) {
                themeMenu.classList.remove('show');
            }
            
            menu.classList.toggle('show');
        }
        
        function toggleThemeMenu() {
            const menu = document.getElementById('themeMenu');
            const langMenu = document.getElementById('langMenu');
            
            // Close lang menu if open
            if (langMenu.classList.contains('show')) {
                langMenu.classList.remove('show');
            }
            
            menu.classList.toggle('show');
        }
        
        function setLanguage(lang) {
            const langData = LANGUAGES[lang];
            if (!langData) return;
            
            // Update flag icon
            document.getElementById('currentLangFlag').textContent = langData.flag;
            
            // Update active state in menu
            document.querySelectorAll('.lang-item').forEach(item => {
                item.classList.remove('active');
                if (item.dataset.lang === lang) {
                    item.classList.add('active');
                }
            });
            
            // Save to localStorage
            localStorage.setItem('enliko_language', lang);
            
            // Close menu
            document.getElementById('langMenu').classList.remove('show');
            
            // Show notification
            showNotification(`Language changed to ${langData.name}`, 'info');
            
            // Apply translations (if available)
            applyTranslations(lang);
        }
        
        function applyTranslations(lang) {
            // This would load translations from server or use bundled translations
            // For now, just reload page with new language preference
            // Future: fetch('/api/translations/' + lang).then(...)
        }
        
        function setTheme(theme) {
            const html = document.documentElement;
            const icon = document.getElementById('themeIcon');
            
            // Remove any existing theme
            html.removeAttribute('data-theme');
            
            if (theme === 'light') {
                html.setAttribute('data-theme', 'light');
                icon.className = 'fas fa-sun';
            } else if (theme === 'system') {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                if (!prefersDark) {
                    html.setAttribute('data-theme', 'light');
                }
                icon.className = 'fas fa-desktop';
            } else {
                // dark theme (default)
                icon.className = 'fas fa-moon';
            }
            
            // Update active state in menu
            document.querySelectorAll('.theme-option').forEach(option => {
                option.classList.remove('active');
                if (option.dataset.theme === theme) {
                    option.classList.add('active');
                }
            });
            
            // Save to localStorage
            localStorage.setItem('enliko_theme', theme);
            
            // Close menu
            document.getElementById('themeMenu').classList.remove('show');
            
            showNotification(`Theme: ${theme.charAt(0).toUpperCase() + theme.slice(1)}`, 'info');
        }
        
        // Initialize language and theme from localStorage
        function initLanguageAndTheme() {
            // Language
            const savedLang = localStorage.getItem('enliko_language') || 'en';
            const langData = LANGUAGES[savedLang];
            if (langData) {
                document.getElementById('currentLangFlag').textContent = langData.flag;
                document.querySelectorAll('.lang-item').forEach(item => {
                    item.classList.remove('active');
                    if (item.dataset.lang === savedLang) {
                        item.classList.add('active');
                    }
                });
            }
            
            // Theme
            const savedTheme = localStorage.getItem('enliko_theme') || 'dark';
            const html = document.documentElement;
            const icon = document.getElementById('themeIcon');
            
            if (savedTheme === 'light') {
                html.setAttribute('data-theme', 'light');
                icon.className = 'fas fa-sun';
            } else if (savedTheme === 'system') {
                const prefersDark = window.matchMedia('(prefers-color-scheme: dark)').matches;
                if (!prefersDark) {
                    html.setAttribute('data-theme', 'light');
                }
                icon.className = 'fas fa-desktop';
            } else {
                icon.className = 'fas fa-moon';
            }
            
            document.querySelectorAll('.theme-option').forEach(option => {
                option.classList.remove('active');
                if (option.dataset.theme === savedTheme) {
                    option.classList.add('active');
                }
            });
        }
        
        // Close dropdowns when clicking outside
        document.addEventListener('click', function(e) {
            const langSelector = document.getElementById('langSelector');
            const themeSwitcher = document.getElementById('themeSwitcher');
            
            if (langSelector && !langSelector.contains(e.target)) {
                document.getElementById('langMenu').classList.remove('show');
            }
            
            if (themeSwitcher && !themeSwitcher.contains(e.target)) {
                document.getElementById('themeMenu').classList.remove('show');
            }
        });
        
        // Listen for system theme changes
        window.matchMedia('(prefers-color-scheme: dark)').addEventListener('change', (e) => {
            const savedTheme = localStorage.getItem('enliko_theme');
            if (savedTheme === 'system') {
                const html = document.documentElement;
                if (e.matches) {
                    html.removeAttribute('data-theme');
                } else {
                    html.setAttribute('data-theme', 'light');
                }
            }
        });
        
        // Initialize on DOM ready
        document.addEventListener('DOMContentLoaded', function() {
            initLanguageAndTheme();
            checkWalletConnection(); // Check if wallet is already connected
        });
    </script>
    
    <!-- Mobile Navigation & Utilities -->
    <script src="/static/js/mobile-navigation.js"></script>
</body>
</html>