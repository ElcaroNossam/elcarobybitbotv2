"""
Telegram Authentication API
============================
Handles authentication via Telegram Login Widget and deep links.
Allows iOS/Android/WebApp users to login with their Telegram account.

Flow:
1. User clicks "Login with Telegram" in app
2. App opens Telegram Login Widget or deep link
3. Telegram returns auth data (id, first_name, username, hash)
4. This API verifies the hash using BOT_TOKEN
5. Returns JWT token linked to user's Telegram account

For existing bot users: instant login (they already have user_id in DB)
For new users: creates account with Telegram credentials
"""
import os
import hmac
import hashlib
import logging
import time
import json
import jwt
from typing import Optional
from datetime import datetime

from fastapi import APIRouter, HTTPException, Request, Header
from pydantic import BaseModel

import sys
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
import db
from webapp.api.auth import create_token
from core.db_postgres import execute, execute_one

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/auth/telegram", tags=["telegram-auth"])

# Load .env here to ensure environment variables are available
try:
    from dotenv import load_dotenv
    load_dotenv()
except ImportError:
    pass

# Get bot token for hash verification
BOT_TOKEN = os.getenv("TG_BOT_TOKEN") or os.getenv("BOT_TOKEN") or os.getenv("TELEGRAM_TOKEN") or ""
SECRET_KEY = os.getenv("JWT_SECRET", os.getenv("SECRET_KEY", "enliko-secret-key-2026"))


# =============================================================================
# MODELS
# =============================================================================

class TelegramAuthData(BaseModel):
    """Data received from Telegram Login Widget."""
    id: int  # Telegram user ID
    first_name: str
    last_name: Optional[str] = None
    username: Optional[str] = None
    photo_url: Optional[str] = None
    auth_date: int  # Unix timestamp
    hash: str  # HMAC-SHA256 verification hash


class TelegramLinkRequest(BaseModel):
    """Request to link Telegram to existing email account."""
    telegram_data: TelegramAuthData
    current_token: str  # JWT token of logged-in email user


class TelegramDeepLinkRequest(BaseModel):
    """Request from bot-generated deep link."""
    token: str  # One-time token generated by bot
    telegram_id: int


class Request2FAByUsername(BaseModel):
    """Request 2FA login via Telegram username."""
    username: str  # Telegram username (with or without @)


class Check2FARequest(BaseModel):
    """Check 2FA confirmation status."""
    request_id: str


# =============================================================================
# HASH VERIFICATION
# =============================================================================

def verify_telegram_auth(data: TelegramAuthData) -> bool:
    """
    Verify Telegram Login Widget data authenticity.
    
    According to Telegram docs:
    1. Create data-check-string by sorting all fields alphabetically
    2. Generate secret_key = SHA256(BOT_TOKEN)
    3. hash = HMAC-SHA256(secret_key, data-check-string)
    4. Compare with received hash
    """
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN not configured for Telegram auth verification")
        return False
    
    # Check auth_date freshness (max 1 hour old)
    if time.time() - data.auth_date > 3600:
        logger.warning(f"Telegram auth data too old: {data.auth_date}")
        return False
    
    # Build data-check-string (sorted alphabetically, excluding hash)
    data_dict = {
        "id": data.id,
        "first_name": data.first_name,
        "auth_date": data.auth_date,
    }
    if data.last_name:
        data_dict["last_name"] = data.last_name
    if data.username:
        data_dict["username"] = data.username
    if data.photo_url:
        data_dict["photo_url"] = data.photo_url
    
    # Sort and create check string
    check_string = "\n".join(
        f"{k}={v}" for k, v in sorted(data_dict.items())
    )
    
    # Generate secret key from bot token
    secret_key = hashlib.sha256(BOT_TOKEN.encode()).digest()
    
    # Calculate expected hash
    expected_hash = hmac.new(
        secret_key,
        check_string.encode(),
        hashlib.sha256
    ).hexdigest()
    
    # Compare (constant-time)
    return hmac.compare_digest(expected_hash, data.hash)


# =============================================================================
# ENDPOINTS
# =============================================================================

@router.post("/login")
async def telegram_login(data: TelegramAuthData, request: Request):
    """
    Authenticate user via Telegram Login Widget.
    
    For existing bot users: returns JWT token immediately
    For new users: creates account and returns JWT token
    For linked accounts: finds user via telegram_user_mapping
    
    This is the primary way for Telegram bot users to access iOS/Android apps.
    """
    # Verify Telegram data authenticity
    if not verify_telegram_auth(data):
        raise HTTPException(
            status_code=401,
            detail="Invalid Telegram authentication data"
        )
    
    telegram_id = data.id
    
    # Check if user exists in main users table
    from core.db_postgres import execute_one, get_pool
    import psycopg2.extras
    
    # First check: direct telegram_id as user_id (native Telegram users)
    user = execute_one(
        "SELECT user_id, is_allowed, is_banned, email, first_name, auth_provider FROM users WHERE user_id = %s",
        (telegram_id,)
    )
    
    # Second check: linked account via telegram_user_mapping (email users who linked Telegram)
    if not user:
        mapping = execute_one(
            "SELECT user_id FROM telegram_user_mapping WHERE telegram_id = %s",
            (telegram_id,)
        )
        if mapping:
            user = execute_one(
                "SELECT user_id, is_allowed, is_banned, email, first_name, auth_provider FROM users WHERE user_id = %s",
                (mapping["user_id"],)
            )
    
    if user and user.get("is_banned"):
        raise HTTPException(status_code=403, detail="Account is banned")
    
    # Create or update user
    pool = get_pool()
    pg_conn = pool.getconn()
    try:
        with pg_conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
            if user:
                # Update existing user with Telegram info
                cur.execute("""
                    UPDATE users SET
                        telegram_username = %s,
                        first_name = COALESCE(first_name, %s),
                        last_name = COALESCE(last_name, %s),
                        last_login = NOW(),
                        auth_provider = CASE 
                            WHEN email IS NOT NULL THEN 'both'
                            ELSE 'telegram'
                        END
                    WHERE user_id = %s
                    RETURNING user_id, email, first_name, is_allowed, auth_provider
                """, (
                    data.username,
                    data.first_name,
                    data.last_name,
                    telegram_id
                ))
                updated_user = cur.fetchone()
                pg_conn.commit()
                
                user_for_token = dict(updated_user) if updated_user else user
            else:
                # Create new user from Telegram login
                cur.execute("""
                    INSERT INTO users (
                        user_id, first_name, last_name, telegram_username,
                        is_allowed, auth_provider, lang, created_at
                    ) VALUES (%s, %s, %s, %s, 1, 'telegram', 'en', NOW())
                    ON CONFLICT (user_id) DO UPDATE SET
                        telegram_username = EXCLUDED.telegram_username,
                        last_login = NOW()
                    RETURNING user_id, first_name, is_allowed, auth_provider
                """, (
                    telegram_id,
                    data.first_name,
                    data.last_name,
                    data.username
                ))
                new_user = cur.fetchone()
                pg_conn.commit()
                
                user_for_token = dict(new_user) if new_user else {"user_id": telegram_id}
                logger.info(f"Created new user from Telegram login: {telegram_id} (@{data.username})")
    finally:
        pool.putconn(pg_conn)
    
    # Generate JWT token
    is_admin = telegram_id == 511692487  # ADMIN_ID from coin_params
    token, refresh_token = create_token(telegram_id, is_admin=is_admin)
    
    logger.info(f"Telegram login successful: {telegram_id} (@{data.username})")
    
    return {
        "success": True,
        "token": token,
        "refresh_token": refresh_token,
        "user_id": telegram_id,
        "user": {
            "id": telegram_id,
            "user_id": telegram_id,
            "telegram_id": telegram_id,
            "telegram_username": data.username,
            "email": user_for_token.get("email"),
            "name": data.first_name + (f" {data.last_name}" if data.last_name else ""),
            "first_name": data.first_name,
            "last_name": data.last_name,
            "is_admin": is_admin,
            "is_allowed": bool(user_for_token.get("is_allowed", 1)),
            "auth_provider": user_for_token.get("auth_provider", "telegram"),
        }
    }


@router.post("/link")
async def link_telegram_to_email(data: TelegramLinkRequest, request: Request):
    """
    Link Telegram account to existing email account.
    
    Allows email-registered users to add Telegram login option.
    After linking, user can login with either method.
    """
    # Verify current JWT token
    from webapp.api.auth import decode_token
    
    try:
        payload = decode_token(data.current_token)
        current_user_id = int(payload.get("sub"))
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    # Verify Telegram data
    if not verify_telegram_auth(data.telegram_data):
        raise HTTPException(status_code=401, detail="Invalid Telegram authentication")
    
    telegram_id = data.telegram_data.id
    
    # Check if Telegram account is already linked to another user
    from core.db_postgres import execute_one, get_pool
    import psycopg2.extras
    
    existing_tg_user = execute_one(
        "SELECT user_id FROM users WHERE user_id = %s AND user_id != %s",
        (telegram_id, current_user_id)
    )
    
    if existing_tg_user:
        raise HTTPException(
            status_code=400,
            detail="This Telegram account is already linked to another user. Please use Telegram login instead."
        )
    
    # Link accounts by merging:
    # - Keep email user's data (they registered first via email)
    # - Add Telegram credentials
    # - If telegram_id differs from current_user_id, we need to migrate data
    
    pool = get_pool()
    pg_conn = pool.getconn()
    try:
        with pg_conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
            # Update email user with Telegram link
            # Store telegram_id and telegram_username in users table
            cur.execute("""
                UPDATE users SET
                    telegram_id = %s,
                    telegram_username = %s,
                    auth_provider = 'both',
                    updated_at = NOW()
                WHERE user_id = %s
                RETURNING user_id, email, first_name, telegram_username, telegram_id
            """, (
                telegram_id,
                data.telegram_data.username,
                current_user_id
            ))
            linked_user = cur.fetchone()
            
            # Also store in telegram_user_mapping for fast lookup by telegram_id
            cur.execute("""
                INSERT INTO telegram_user_mapping (telegram_id, user_id)
                VALUES (%s, %s)
                ON CONFLICT (telegram_id) DO UPDATE SET user_id = EXCLUDED.user_id
            """, (telegram_id, current_user_id))
            
            pg_conn.commit()
    finally:
        pool.putconn(pg_conn)
    
    logger.info(f"Linked Telegram @{data.telegram_data.username} to user {current_user_id}")
    
    return {
        "success": True,
        "message": "Telegram account linked successfully",
        "user": dict(linked_user) if linked_user else None
    }


@router.get("/widget-params")
async def get_telegram_widget_params():
    """
    Get parameters for Telegram Login Widget.
    
    Returns bot username and callback URL for widget configuration.
    Used by WebApp to render Telegram Login button.
    """
    bot_username = os.getenv("BOT_USERNAME", "EnlikoBot")
    callback_url = os.getenv("WEBAPP_URL", "https://enliko.com") + "/auth/telegram/callback"
    
    return {
        "bot_username": bot_username,
        "callback_url": callback_url,
        "request_access": "write"  # Request write access for notifications
    }


@router.post("/deep-link")
async def verify_deep_link(data: TelegramDeepLinkRequest):
    """
    Verify deep link token generated by Telegram bot.
    
    Flow:
    1. User requests login link in bot: /login_app
    2. Bot generates one-time token and sends deep link
    3. App opens link and calls this endpoint
    4. We verify token and return JWT
    
    This is an alternative to Telegram Login Widget for native apps.
    """
    from core.redis_client import get_redis
    
    redis = await get_redis()
    
    # Token key pattern: app_login:{token}
    token_key = f"app_login:{data.token}"
    stored_data = await redis.get(token_key)
    
    if not stored_data:
        raise HTTPException(status_code=401, detail="Invalid or expired login token")
    
    import json
    token_data = json.loads(stored_data)
    
    # Verify telegram_id matches
    if token_data.get("telegram_id") != data.telegram_id:
        raise HTTPException(status_code=401, detail="Token mismatch")
    
    # Delete token (one-time use)
    await redis.delete(token_key)
    
    telegram_id = data.telegram_id
    
    # Get user data
    from core.db_postgres import execute_one
    user = execute_one(
        "SELECT user_id, first_name, email, is_allowed, auth_provider FROM users WHERE user_id = %s",
        (telegram_id,)
    )
    
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Generate JWT
    is_admin = telegram_id == 511692487
    token, refresh_token = create_token(telegram_id, is_admin=is_admin)
    
    logger.info(f"Deep link login successful: {telegram_id}")
    
    return {
        "success": True,
        "token": token,
        "refresh_token": refresh_token,
        "user_id": telegram_id,
        "user": {
            "id": telegram_id,
            "user_id": telegram_id,
            "email": user.get("email"),
            "name": user.get("first_name"),
            "is_allowed": bool(user.get("is_allowed", 0)),
            "auth_provider": user.get("auth_provider", "telegram"),
        }
    }


# =============================================================================
# EMAIL LINKING (for Telegram users)
# =============================================================================

class LinkEmailRequest(BaseModel):
    """Request to link email to Telegram account."""
    email: str
    password: str  # New password for email login


@router.post("/link-email")
async def link_email_to_telegram(data: LinkEmailRequest, request: Request):
    """
    Link email to existing Telegram account.
    
    Allows Telegram users (from bot) to add email login option.
    After linking, user can login with either method.
    
    Requires: Authorization header with valid JWT token
    """
    from webapp.api.auth import decode_token, get_authorization_header
    import bcrypt
    
    # Get and verify JWT token
    auth_header = request.headers.get("Authorization", "")
    if not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing authorization token")
    
    token = auth_header.replace("Bearer ", "")
    try:
        payload = decode_token(token)
        current_user_id = int(payload.get("sub"))
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    # Validate email format
    import re
    if not re.match(r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$", data.email):
        raise HTTPException(status_code=400, detail="Invalid email format")
    
    # Validate password (consistent with email_auth.py - 8 chars minimum)
    if len(data.password) < 8:
        raise HTTPException(status_code=400, detail="Password must be at least 8 characters")
    
    from core.db_postgres import execute_one, get_pool
    import psycopg2.extras
    
    # Check if email is already used
    existing_email = execute_one(
        "SELECT user_id FROM users WHERE email = %s AND user_id != %s",
        (data.email.lower(), current_user_id)
    )
    
    if existing_email:
        raise HTTPException(
            status_code=400,
            detail="This email is already linked to another account"
        )
    
    # Hash password
    salt = bcrypt.gensalt()
    password_hash = bcrypt.hashpw(data.password.encode(), salt).decode()
    
    pool = get_pool()
    pg_conn = pool.getconn()
    try:
        with pg_conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
            # Update Telegram user with email credentials
            cur.execute("""
                UPDATE users SET
                    email = %s,
                    password_hash = %s,
                    password_salt = %s,
                    email_verified = TRUE,
                    auth_provider = 'both',
                    updated_at = NOW()
                WHERE user_id = %s
                RETURNING user_id, email, first_name, telegram_username, telegram_id
            """, (
                data.email.lower(),
                password_hash,
                salt.decode(),
                current_user_id
            ))
            linked_user = cur.fetchone()
            pg_conn.commit()
            
            if not linked_user:
                raise HTTPException(status_code=404, detail="User not found")
    finally:
        pool.putconn(pg_conn)
    
    logger.info(f"Linked email {data.email} to Telegram user {current_user_id}")
    
    return {
        "success": True,
        "message": "Email linked successfully",
        "user": {
            "user_id": current_user_id,
            "email": data.email.lower(),
            "telegram_username": linked_user.get("telegram_username"),
            "auth_provider": "both"
        }
    }


@router.get("/linked-accounts")
async def get_linked_accounts(request: Request):
    """
    Get all linked accounts for current user.
    
    Returns information about email and Telegram linking status.
    """
    from webapp.api.auth import decode_token
    
    auth_header = request.headers.get("Authorization", "")
    if not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing authorization token")
    
    token = auth_header.replace("Bearer ", "")
    try:
        payload = decode_token(token)
        user_id = int(payload.get("sub"))
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    from core.db_postgres import execute_one
    
    user = execute_one("""
        SELECT 
            user_id, email, email_verified, telegram_id, telegram_username,
            auth_provider, first_name, last_name, created_at
        FROM users WHERE user_id = %s
    """, (user_id,))
    
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Determine what accounts are linked
    has_email = bool(user.get("email"))
    has_telegram = user.get("telegram_id") is not None or user.get("user_id", 0) > 0
    
    return {
        "user_id": user_id,
        "email": {
            "linked": has_email,
            "address": user.get("email"),
            "verified": bool(user.get("email_verified"))
        },
        "telegram": {
            "linked": has_telegram,
            "id": user.get("telegram_id") or (user_id if user_id > 0 else None),
            "username": user.get("telegram_username")
        },
        "auth_provider": user.get("auth_provider", "unknown"),
        "name": f"{user.get('first_name', '')} {user.get('last_name', '')}".strip(),
        "created_at": user.get("created_at").isoformat() if user.get("created_at") else None
    }


# ==============================================================================
# Complete Telegram Linking (from iOS/Android app flow)
# ==============================================================================
@router.post("/complete-link")
async def complete_telegram_link(
    request: Request,
    authorization: str = Header(...)
):
    """
    Complete Telegram account linking from app.
    
    Flow:
    1. User clicks "Link Telegram" in iOS/Android app
    2. Opens t.me/EnlikoBot?start=link_app
    3. Bot generates token and shows "Complete Linking" button
    4. User clicks button ‚Üí arrives at /auth/telegram/complete-link?token=XXX
    5. This endpoint links Telegram to their email account
    
    Body: { "token": "link_token_from_bot" }
    """
    try:
        # Get user from JWT
        token = authorization.replace("Bearer ", "").strip()
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        user_id = payload.get("sub")  # JWT uses 'sub' for user_id
        if user_id:
            user_id = int(user_id)
        
        if not user_id:
            raise HTTPException(status_code=401, detail="Invalid token")
        
        # Get token from body
        body = await request.json()
        link_token = body.get("token")
        
        if not link_token:
            raise HTTPException(status_code=400, detail="Missing link token")
        
        # Verify token in Redis
        from core.redis_client import get_redis
        redis = get_redis()
        token_data_raw = await redis.get(f"tg_link_token:{link_token}")
        
        if not token_data_raw:
            raise HTTPException(status_code=400, detail="Link token expired or invalid")
        
        import json
        token_data = json.loads(token_data_raw)
        telegram_id = token_data.get("telegram_id")
        telegram_username = token_data.get("telegram_username", "")
        telegram_first_name = token_data.get("telegram_first_name", "")
        telegram_last_name = token_data.get("telegram_last_name", "")
        
        if not telegram_id:
            raise HTTPException(status_code=400, detail="Invalid token data")
        
        # Delete token (one-time use)
        await redis.delete(f"tg_link_token:{link_token}")
        
        # Check if this Telegram ID is already linked to another account
        existing = execute_one("""
            SELECT user_id FROM telegram_user_mapping WHERE telegram_id = %s
        """, (telegram_id,))
        
        if existing and existing.get("user_id") != user_id:
            raise HTTPException(
                status_code=409,
                detail="This Telegram account is already linked to another user"
            )
        
        # Update user with Telegram info
        execute("""
            UPDATE users SET
                telegram_id = %s,
                telegram_username = %s,
                first_name = COALESCE(NULLIF(first_name, ''), %s),
                last_name = COALESCE(NULLIF(last_name, ''), %s),
                auth_provider = CASE 
                    WHEN auth_provider = 'email' THEN 'both'
                    ELSE auth_provider
                END,
                updated_at = NOW()
            WHERE user_id = %s
        """, (telegram_id, telegram_username, telegram_first_name, telegram_last_name, user_id))
        
        # Add to mapping table
        execute("""
            INSERT INTO telegram_user_mapping (telegram_id, user_id, created_at)
            VALUES (%s, %s, NOW())
            ON CONFLICT (telegram_id) DO UPDATE SET user_id = EXCLUDED.user_id
        """, (telegram_id, user_id))
        
        logger.info(f"Successfully linked Telegram {telegram_id} (@{telegram_username}) to user {user_id}")
        
        return {
            "success": True,
            "message": "Telegram account linked successfully",
            "telegram": {
                "id": telegram_id,
                "username": telegram_username
            }
        }
        
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid or expired token")
    except Exception as e:
        logger.exception(f"Failed to complete Telegram link: {e}")
        raise HTTPException(status_code=500, detail=str(e))


# ==============================================================================
# 2FA Login via Telegram Username (Simple Auth Flow)
# ==============================================================================

@router.post("/request-2fa")
async def request_2fa_login(data: Request2FAByUsername):
    """
    Request 2FA login via Telegram username.
    
    Flow:
    1. User enters @username in iOS/Android/WebApp
    2. This endpoint finds user by username and sends 2FA confirmation to their Telegram
    3. User confirms in Telegram bot
    4. App polls /check-2fa to get JWT token
    
    Returns:
        request_id: ID for polling confirmation status
    """
    import secrets
    
    # Clean username (remove @ if present)
    username = data.username.strip().lstrip('@').lower()
    
    if not username or len(username) < 2:
        raise HTTPException(status_code=400, detail="Invalid username")
    
    # Find user by Telegram username
    user = execute_one("""
        SELECT user_id, telegram_username, telegram_id, first_name, is_allowed
        FROM users 
        WHERE LOWER(telegram_username) = %s OR LOWER(telegram_username) = %s
        LIMIT 1
    """, (username, f"@{username}"))
    
    if not user:
        raise HTTPException(
            status_code=404, 
            detail="User not found. Please start the bot first: t.me/EnlikoBot"
        )
    
    telegram_id = user.get("telegram_id") or user.get("user_id")
    if not telegram_id or telegram_id <= 0:
        raise HTTPException(
            status_code=400,
            detail="Could not find your Telegram ID. Please use the bot once: t.me/EnlikoBot"
        )
    
    # Generate request_id
    request_id = secrets.token_urlsafe(24)
    
    # Store request in Redis with 5 min TTL
    try:
        from core.redis_client import get_redis
        redis_client = await get_redis()
        request_data = json.dumps({
            "telegram_id": telegram_id,
            "username": username,
            "status": "pending",  # pending, approved, rejected
            "created_at": datetime.now().isoformat()
        })
        await redis_client.set(f"2fa_login:{request_id}", request_data, ttl=300)
    except Exception as e:
        logger.error(f"Redis error in request-2fa: {e}")
        # Fallback: store in database
        try:
            execute("""
                INSERT INTO login_2fa_requests (request_id, telegram_id, username, status, expires_at)
                VALUES (%s, %s, %s, 'pending', NOW() + INTERVAL '5 minutes')
            """, (request_id, telegram_id, username))
        except Exception as db_e:
            logger.error(f"DB error in request-2fa: {db_e}")
            raise HTTPException(status_code=500, detail="Failed to create login request")
    
    # Send confirmation request to Telegram bot
    try:
        import aiohttp
        bot_token = BOT_TOKEN
        if not bot_token:
            raise HTTPException(status_code=500, detail="Bot not configured")
        
        # Create inline keyboard with Confirm/Reject buttons
        keyboard = {
            "inline_keyboard": [
                [
                    {"text": "‚úÖ –ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å –≤—Ö–æ–¥", "callback_data": f"2fa_confirm:{request_id}"},
                    {"text": "‚ùå –û—Ç–∫–ª–æ–Ω–∏—Ç—å", "callback_data": f"2fa_reject:{request_id}"}
                ]
            ]
        }
        
        message_text = """üîê <b>–ó–∞–ø—Ä–æ—Å –Ω–∞ –≤—Ö–æ–¥ –≤ –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ</b>

–ö—Ç–æ-—Ç–æ –ø—ã—Ç–∞–µ—Ç—Å—è –≤–æ–π—Ç–∏ –≤ –≤–∞—à –∞–∫–∫–∞—É–Ω—Ç —á–µ—Ä–µ–∑ iOS/Android/Web –ø—Ä–∏–ª–æ–∂–µ–Ω–∏–µ.

–ï—Å–ª–∏ —ç—Ç–æ –≤—ã, –Ω–∞–∂–º–∏—Ç–µ "–ü–æ–¥—Ç–≤–µ—Ä–¥–∏—Ç—å".
–ï—Å–ª–∏ –Ω–µ—Ç ‚Äî –Ω–∞–∂–º–∏—Ç–µ "–û—Ç–∫–ª–æ–Ω–∏—Ç—å".

‚è± –ó–∞–ø—Ä–æ—Å –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª–µ–Ω 5 –º–∏–Ω—É—Ç."""

        async with aiohttp.ClientSession() as session:
            async with session.post(
                f"https://api.telegram.org/bot{bot_token}/sendMessage",
                json={
                    "chat_id": telegram_id,
                    "text": message_text,
                    "parse_mode": "HTML",
                    "reply_markup": keyboard
                },
                timeout=aiohttp.ClientTimeout(total=10)
            ) as resp:
                result = await resp.json()
                if not result.get("ok"):
                    logger.error(f"Failed to send 2FA message: {result}")
                    # User might have blocked the bot
                    raise HTTPException(
                        status_code=400,
                        detail="Could not send confirmation. Make sure you haven't blocked the bot."
                    )
    except aiohttp.ClientError as e:
        logger.error(f"Telegram API error: {e}")
        raise HTTPException(status_code=500, detail="Failed to send confirmation request")
    
    logger.info(f"2FA login requested for @{username} (ID: {telegram_id}), request_id: {request_id}")
    
    return {
        "success": True,
        "request_id": request_id,
        "message": "Confirmation request sent to your Telegram"
    }


@router.get("/check-2fa/{request_id}")
async def check_2fa_status(request_id: str):
    """
    Check 2FA confirmation status.
    
    App polls this endpoint every 2-3 seconds to check if user confirmed.
    
    Returns:
        status: pending | approved | rejected | expired
        token: JWT token if approved
    """
    # Try Redis first
    request_data = None
    try:
        from core.redis_client import get_redis
        redis_client = await get_redis()
        raw_data = await redis_client.get(f"2fa_login:{request_id}")
        if raw_data:
            request_data = json.loads(raw_data)
    except Exception as e:
        logger.warning(f"Redis error in check-2fa: {e}")
    
    # Fallback to database
    if not request_data:
        try:
            db_row = execute_one("""
                SELECT telegram_id, username, status, expires_at
                FROM login_2fa_requests
                WHERE request_id = %s AND expires_at > NOW()
            """, (request_id,))
            if db_row:
                request_data = {
                    "telegram_id": db_row["telegram_id"],
                    "username": db_row["username"],
                    "status": db_row["status"]
                }
        except Exception as db_e:
            logger.warning(f"DB error in check-2fa: {db_e}")
    
    if not request_data:
        return {
            "status": "expired",
            "message": "Request not found or expired"
        }
    
    status = request_data.get("status", "pending")
    
    if status == "pending":
        return {
            "status": "pending",
            "message": "Waiting for confirmation in Telegram"
        }
    
    if status == "rejected":
        return {
            "status": "rejected",
            "message": "Login was rejected"
        }
    
    if status == "approved":
        telegram_id = request_data.get("telegram_id")
        
        # Get user from DB
        user = execute_one("""
            SELECT user_id, email, first_name, is_allowed, auth_provider, telegram_username
            FROM users WHERE user_id = %s OR telegram_id = %s
        """, (telegram_id, telegram_id))
        
        if not user:
            return {
                "status": "error",
                "message": "User not found"
            }
        
        # Generate JWT token
        is_admin = telegram_id == 511692487
        token, refresh_token = create_token(telegram_id, is_admin=is_admin)
        
        # Clean up request from Redis
        try:
            from core.redis_client import get_redis
            redis_client = await get_redis()
            await redis_client.delete(f"2fa_login:{request_id}")
        except:
            pass
        
        # Clean up from database
        try:
            execute("DELETE FROM login_2fa_requests WHERE request_id = %s", (request_id,))
        except:
            pass
        
        logger.info(f"2FA login approved for telegram_id={telegram_id}")
        
        return {
            "status": "approved",
            "token": token,
            "refresh_token": refresh_token,
            "user": {
                "id": telegram_id,
                "user_id": telegram_id,
                "email": user.get("email"),
                "name": user.get("first_name"),
                "username": user.get("telegram_username"),
                "is_allowed": bool(user.get("is_allowed", 0)),
                "auth_provider": user.get("auth_provider", "telegram"),
            }
        }
    
    return {
        "status": "error",
        "message": "Unknown status"
    }


@router.post("/update-2fa-status")
async def update_2fa_status(request_id: str, status: str):
    """
    Internal endpoint called by bot to update 2FA status.
    
    Status can be: approved or rejected
    """
    if status not in ("approved", "rejected"):
        raise HTTPException(status_code=400, detail="Invalid status")
    
    # Update in Redis
    updated = False
    try:
        from core.redis_client import get_redis
        redis_client = await get_redis()
        raw_data = await redis_client.get(f"2fa_login:{request_id}")
        if raw_data:
            request_data = json.loads(raw_data)
            request_data["status"] = status
            await redis_client.set(f"2fa_login:{request_id}", json.dumps(request_data), ttl=60)  # Keep for 1 min after approval
            updated = True
    except Exception as e:
        logger.warning(f"Redis error updating 2FA status: {e}")
    
    # Also update database fallback
    try:
        execute("""
            UPDATE login_2fa_requests SET status = %s WHERE request_id = %s
        """, (status, request_id))
        updated = True
    except Exception as e:
        logger.warning(f"DB error updating 2FA status: {e}")
    
    if not updated:
        raise HTTPException(status_code=404, detail="Request not found")
    
    logger.info(f"2FA status updated: request_id={request_id}, status={status}")
    
    return {"success": True, "status": status}

