"""
Telegram Authentication API
============================
Handles authentication via Telegram Login Widget and deep links.
Allows iOS/Android/WebApp users to login with their Telegram account.

Flow:
1. User clicks "Login with Telegram" in app
2. App opens Telegram Login Widget or deep link
3. Telegram returns auth data (id, first_name, username, hash)
4. This API verifies the hash using BOT_TOKEN
5. Returns JWT token linked to user's Telegram account

For existing bot users: instant login (they already have user_id in DB)
For new users: creates account with Telegram credentials
"""
import os
import hmac
import hashlib
import logging
import time
import json
import jwt
from typing import Optional
from datetime import datetime

from fastapi import APIRouter, HTTPException, Request, Header
from pydantic import BaseModel

import sys
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
import db
from webapp.api.auth import create_token
from core.db_postgres import execute, execute_one

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/auth/telegram", tags=["telegram-auth"])

# Get bot token for hash verification
BOT_TOKEN = os.getenv("TG_BOT_TOKEN") or os.getenv("BOT_TOKEN") or ""
SECRET_KEY = os.getenv("JWT_SECRET", os.getenv("SECRET_KEY", "enliko-secret-key-2026"))


# =============================================================================
# MODELS
# =============================================================================

class TelegramAuthData(BaseModel):
    """Data received from Telegram Login Widget."""
    id: int  # Telegram user ID
    first_name: str
    last_name: Optional[str] = None
    username: Optional[str] = None
    photo_url: Optional[str] = None
    auth_date: int  # Unix timestamp
    hash: str  # HMAC-SHA256 verification hash


class TelegramLinkRequest(BaseModel):
    """Request to link Telegram to existing email account."""
    telegram_data: TelegramAuthData
    current_token: str  # JWT token of logged-in email user


class TelegramDeepLinkRequest(BaseModel):
    """Request from bot-generated deep link."""
    token: str  # One-time token generated by bot
    telegram_id: int


# =============================================================================
# HASH VERIFICATION
# =============================================================================

def verify_telegram_auth(data: TelegramAuthData) -> bool:
    """
    Verify Telegram Login Widget data authenticity.
    
    According to Telegram docs:
    1. Create data-check-string by sorting all fields alphabetically
    2. Generate secret_key = SHA256(BOT_TOKEN)
    3. hash = HMAC-SHA256(secret_key, data-check-string)
    4. Compare with received hash
    """
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN not configured for Telegram auth verification")
        return False
    
    # Check auth_date freshness (max 1 hour old)
    if time.time() - data.auth_date > 3600:
        logger.warning(f"Telegram auth data too old: {data.auth_date}")
        return False
    
    # Build data-check-string (sorted alphabetically, excluding hash)
    data_dict = {
        "id": data.id,
        "first_name": data.first_name,
        "auth_date": data.auth_date,
    }
    if data.last_name:
        data_dict["last_name"] = data.last_name
    if data.username:
        data_dict["username"] = data.username
    if data.photo_url:
        data_dict["photo_url"] = data.photo_url
    
    # Sort and create check string
    check_string = "\n".join(
        f"{k}={v}" for k, v in sorted(data_dict.items())
    )
    
    # Generate secret key from bot token
    secret_key = hashlib.sha256(BOT_TOKEN.encode()).digest()
    
    # Calculate expected hash
    expected_hash = hmac.new(
        secret_key,
        check_string.encode(),
        hashlib.sha256
    ).hexdigest()
    
    # Compare (constant-time)
    return hmac.compare_digest(expected_hash, data.hash)


# =============================================================================
# ENDPOINTS
# =============================================================================

@router.post("/login")
async def telegram_login(data: TelegramAuthData, request: Request):
    """
    Authenticate user via Telegram Login Widget.
    
    For existing bot users: returns JWT token immediately
    For new users: creates account and returns JWT token
    For linked accounts: finds user via telegram_user_mapping
    
    This is the primary way for Telegram bot users to access iOS/Android apps.
    """
    # Verify Telegram data authenticity
    if not verify_telegram_auth(data):
        raise HTTPException(
            status_code=401,
            detail="Invalid Telegram authentication data"
        )
    
    telegram_id = data.id
    
    # Check if user exists in main users table
    from core.db_postgres import execute_one, get_pool
    import psycopg2.extras
    
    # First check: direct telegram_id as user_id (native Telegram users)
    user = execute_one(
        "SELECT user_id, is_allowed, is_banned, email, first_name, auth_provider FROM users WHERE user_id = %s",
        (telegram_id,)
    )
    
    # Second check: linked account via telegram_user_mapping (email users who linked Telegram)
    if not user:
        mapping = execute_one(
            "SELECT user_id FROM telegram_user_mapping WHERE telegram_id = %s",
            (telegram_id,)
        )
        if mapping:
            user = execute_one(
                "SELECT user_id, is_allowed, is_banned, email, first_name, auth_provider FROM users WHERE user_id = %s",
                (mapping["user_id"],)
            )
    
    if user and user.get("is_banned"):
        raise HTTPException(status_code=403, detail="Account is banned")
    
    # Create or update user
    pool = get_pool()
    pg_conn = pool.getconn()
    try:
        with pg_conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
            if user:
                # Update existing user with Telegram info
                cur.execute("""
                    UPDATE users SET
                        telegram_username = %s,
                        first_name = COALESCE(first_name, %s),
                        last_name = COALESCE(last_name, %s),
                        last_login = NOW(),
                        auth_provider = CASE 
                            WHEN email IS NOT NULL THEN 'both'
                            ELSE 'telegram'
                        END
                    WHERE user_id = %s
                    RETURNING user_id, email, first_name, is_allowed, auth_provider
                """, (
                    data.username,
                    data.first_name,
                    data.last_name,
                    telegram_id
                ))
                updated_user = cur.fetchone()
                pg_conn.commit()
                
                user_for_token = dict(updated_user) if updated_user else user
            else:
                # Create new user from Telegram login
                cur.execute("""
                    INSERT INTO users (
                        user_id, first_name, last_name, telegram_username,
                        is_allowed, auth_provider, lang, created_at
                    ) VALUES (%s, %s, %s, %s, 1, 'telegram', 'en', NOW())
                    ON CONFLICT (user_id) DO UPDATE SET
                        telegram_username = EXCLUDED.telegram_username,
                        last_login = NOW()
                    RETURNING user_id, first_name, is_allowed, auth_provider
                """, (
                    telegram_id,
                    data.first_name,
                    data.last_name,
                    data.username
                ))
                new_user = cur.fetchone()
                pg_conn.commit()
                
                user_for_token = dict(new_user) if new_user else {"user_id": telegram_id}
                logger.info(f"Created new user from Telegram login: {telegram_id} (@{data.username})")
    finally:
        pool.putconn(pg_conn)
    
    # Generate JWT token
    is_admin = telegram_id == 511692487  # ADMIN_ID from coin_params
    token, refresh_token = create_token(telegram_id, is_admin=is_admin)
    
    logger.info(f"Telegram login successful: {telegram_id} (@{data.username})")
    
    return {
        "success": True,
        "token": token,
        "refresh_token": refresh_token,
        "user_id": telegram_id,
        "user": {
            "id": telegram_id,
            "user_id": telegram_id,
            "telegram_id": telegram_id,
            "telegram_username": data.username,
            "email": user_for_token.get("email"),
            "name": data.first_name + (f" {data.last_name}" if data.last_name else ""),
            "first_name": data.first_name,
            "last_name": data.last_name,
            "is_admin": is_admin,
            "is_allowed": bool(user_for_token.get("is_allowed", 1)),
            "auth_provider": user_for_token.get("auth_provider", "telegram"),
        }
    }


@router.post("/link")
async def link_telegram_to_email(data: TelegramLinkRequest, request: Request):
    """
    Link Telegram account to existing email account.
    
    Allows email-registered users to add Telegram login option.
    After linking, user can login with either method.
    """
    # Verify current JWT token
    from webapp.api.auth import decode_token
    
    try:
        payload = decode_token(data.current_token)
        current_user_id = int(payload.get("sub"))
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    # Verify Telegram data
    if not verify_telegram_auth(data.telegram_data):
        raise HTTPException(status_code=401, detail="Invalid Telegram authentication")
    
    telegram_id = data.telegram_data.id
    
    # Check if Telegram account is already linked to another user
    from core.db_postgres import execute_one, get_pool
    import psycopg2.extras
    
    existing_tg_user = execute_one(
        "SELECT user_id FROM users WHERE user_id = %s AND user_id != %s",
        (telegram_id, current_user_id)
    )
    
    if existing_tg_user:
        raise HTTPException(
            status_code=400,
            detail="This Telegram account is already linked to another user. Please use Telegram login instead."
        )
    
    # Link accounts by merging:
    # - Keep email user's data (they registered first via email)
    # - Add Telegram credentials
    # - If telegram_id differs from current_user_id, we need to migrate data
    
    pool = get_pool()
    pg_conn = pool.getconn()
    try:
        with pg_conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
            # Update email user with Telegram link
            # Store telegram_id and telegram_username in users table
            cur.execute("""
                UPDATE users SET
                    telegram_id = %s,
                    telegram_username = %s,
                    auth_provider = 'both',
                    updated_at = NOW()
                WHERE user_id = %s
                RETURNING user_id, email, first_name, telegram_username, telegram_id
            """, (
                telegram_id,
                data.telegram_data.username,
                current_user_id
            ))
            linked_user = cur.fetchone()
            
            # Also store in telegram_user_mapping for fast lookup by telegram_id
            cur.execute("""
                INSERT INTO telegram_user_mapping (telegram_id, user_id)
                VALUES (%s, %s)
                ON CONFLICT (telegram_id) DO UPDATE SET user_id = EXCLUDED.user_id
            """, (telegram_id, current_user_id))
            
            pg_conn.commit()
    finally:
        pool.putconn(pg_conn)
    
    logger.info(f"Linked Telegram @{data.telegram_data.username} to user {current_user_id}")
    
    return {
        "success": True,
        "message": "Telegram account linked successfully",
        "user": dict(linked_user) if linked_user else None
    }


@router.get("/widget-params")
async def get_telegram_widget_params():
    """
    Get parameters for Telegram Login Widget.
    
    Returns bot username and callback URL for widget configuration.
    Used by WebApp to render Telegram Login button.
    """
    bot_username = os.getenv("BOT_USERNAME", "EnlikoBot")
    callback_url = os.getenv("WEBAPP_URL", "https://enliko.com") + "/auth/telegram/callback"
    
    return {
        "bot_username": bot_username,
        "callback_url": callback_url,
        "request_access": "write"  # Request write access for notifications
    }


@router.post("/deep-link")
async def verify_deep_link(data: TelegramDeepLinkRequest):
    """
    Verify deep link token generated by Telegram bot.
    
    Flow:
    1. User requests login link in bot: /login_app
    2. Bot generates one-time token and sends deep link
    3. App opens link and calls this endpoint
    4. We verify token and return JWT
    
    This is an alternative to Telegram Login Widget for native apps.
    """
    from core.redis_client import get_redis
    
    redis = await get_redis()
    
    # Token key pattern: app_login:{token}
    token_key = f"app_login:{data.token}"
    stored_data = await redis.get(token_key)
    
    if not stored_data:
        raise HTTPException(status_code=401, detail="Invalid or expired login token")
    
    import json
    token_data = json.loads(stored_data)
    
    # Verify telegram_id matches
    if token_data.get("telegram_id") != data.telegram_id:
        raise HTTPException(status_code=401, detail="Token mismatch")
    
    # Delete token (one-time use)
    await redis.delete(token_key)
    
    telegram_id = data.telegram_id
    
    # Get user data
    from core.db_postgres import execute_one
    user = execute_one(
        "SELECT user_id, first_name, email, is_allowed, auth_provider FROM users WHERE user_id = %s",
        (telegram_id,)
    )
    
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Generate JWT
    is_admin = telegram_id == 511692487
    token, refresh_token = create_token(telegram_id, is_admin=is_admin)
    
    logger.info(f"Deep link login successful: {telegram_id}")
    
    return {
        "success": True,
        "token": token,
        "refresh_token": refresh_token,
        "user_id": telegram_id,
        "user": {
            "id": telegram_id,
            "user_id": telegram_id,
            "email": user.get("email"),
            "name": user.get("first_name"),
            "is_allowed": bool(user.get("is_allowed", 0)),
            "auth_provider": user.get("auth_provider", "telegram"),
        }
    }


# =============================================================================
# EMAIL LINKING (for Telegram users)
# =============================================================================

class LinkEmailRequest(BaseModel):
    """Request to link email to Telegram account."""
    email: str
    password: str  # New password for email login


@router.post("/link-email")
async def link_email_to_telegram(data: LinkEmailRequest, request: Request):
    """
    Link email to existing Telegram account.
    
    Allows Telegram users (from bot) to add email login option.
    After linking, user can login with either method.
    
    Requires: Authorization header with valid JWT token
    """
    from webapp.api.auth import decode_token, get_authorization_header
    import bcrypt
    
    # Get and verify JWT token
    auth_header = request.headers.get("Authorization", "")
    if not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing authorization token")
    
    token = auth_header.replace("Bearer ", "")
    try:
        payload = decode_token(token)
        current_user_id = int(payload.get("sub"))
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    # Validate email format
    import re
    if not re.match(r"^[a-zA-Z0-9_.+-]+@[a-zA-Z0-9-]+\.[a-zA-Z0-9-.]+$", data.email):
        raise HTTPException(status_code=400, detail="Invalid email format")
    
    # Validate password
    if len(data.password) < 6:
        raise HTTPException(status_code=400, detail="Password must be at least 6 characters")
    
    from core.db_postgres import execute_one, get_pool
    import psycopg2.extras
    
    # Check if email is already used
    existing_email = execute_one(
        "SELECT user_id FROM users WHERE email = %s AND user_id != %s",
        (data.email.lower(), current_user_id)
    )
    
    if existing_email:
        raise HTTPException(
            status_code=400,
            detail="This email is already linked to another account"
        )
    
    # Hash password
    salt = bcrypt.gensalt()
    password_hash = bcrypt.hashpw(data.password.encode(), salt).decode()
    
    pool = get_pool()
    pg_conn = pool.getconn()
    try:
        with pg_conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
            # Update Telegram user with email credentials
            cur.execute("""
                UPDATE users SET
                    email = %s,
                    password_hash = %s,
                    password_salt = %s,
                    email_verified = TRUE,
                    auth_provider = 'both',
                    updated_at = NOW()
                WHERE user_id = %s
                RETURNING user_id, email, first_name, telegram_username, telegram_id
            """, (
                data.email.lower(),
                password_hash,
                salt.decode(),
                current_user_id
            ))
            linked_user = cur.fetchone()
            pg_conn.commit()
            
            if not linked_user:
                raise HTTPException(status_code=404, detail="User not found")
    finally:
        pool.putconn(pg_conn)
    
    logger.info(f"Linked email {data.email} to Telegram user {current_user_id}")
    
    return {
        "success": True,
        "message": "Email linked successfully",
        "user": {
            "user_id": current_user_id,
            "email": data.email.lower(),
            "telegram_username": linked_user.get("telegram_username"),
            "auth_provider": "both"
        }
    }


@router.get("/linked-accounts")
async def get_linked_accounts(request: Request):
    """
    Get all linked accounts for current user.
    
    Returns information about email and Telegram linking status.
    """
    from webapp.api.auth import decode_token
    
    auth_header = request.headers.get("Authorization", "")
    if not auth_header.startswith("Bearer "):
        raise HTTPException(status_code=401, detail="Missing authorization token")
    
    token = auth_header.replace("Bearer ", "")
    try:
        payload = decode_token(token)
        user_id = int(payload.get("sub"))
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    from core.db_postgres import execute_one
    
    user = execute_one("""
        SELECT 
            user_id, email, email_verified, telegram_id, telegram_username,
            auth_provider, first_name, last_name, created_at
        FROM users WHERE user_id = %s
    """, (user_id,))
    
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Determine what accounts are linked
    has_email = bool(user.get("email"))
    has_telegram = user.get("telegram_id") is not None or user.get("user_id", 0) > 0
    
    return {
        "user_id": user_id,
        "email": {
            "linked": has_email,
            "address": user.get("email"),
            "verified": bool(user.get("email_verified"))
        },
        "telegram": {
            "linked": has_telegram,
            "id": user.get("telegram_id") or (user_id if user_id > 0 else None),
            "username": user.get("telegram_username")
        },
        "auth_provider": user.get("auth_provider", "unknown"),
        "name": f"{user.get('first_name', '')} {user.get('last_name', '')}".strip(),
        "created_at": user.get("created_at").isoformat() if user.get("created_at") else None
    }


# ==============================================================================
# Complete Telegram Linking (from iOS/Android app flow)
# ==============================================================================
@router.post("/complete-link")
async def complete_telegram_link(
    request: Request,
    authorization: str = Header(...)
):
    """
    Complete Telegram account linking from app.
    
    Flow:
    1. User clicks "Link Telegram" in iOS/Android app
    2. Opens t.me/EnlikoBot?start=link_app
    3. Bot generates token and shows "Complete Linking" button
    4. User clicks button â†’ arrives at /auth/telegram/complete-link?token=XXX
    5. This endpoint links Telegram to their email account
    
    Body: { "token": "link_token_from_bot" }
    """
    try:
        # Get user from JWT
        token = authorization.replace("Bearer ", "").strip()
        payload = jwt.decode(token, SECRET_KEY, algorithms=["HS256"])
        user_id = payload.get("user_id")
        
        if not user_id:
            raise HTTPException(status_code=401, detail="Invalid token")
        
        # Get token from body
        body = await request.json()
        link_token = body.get("token")
        
        if not link_token:
            raise HTTPException(status_code=400, detail="Missing link token")
        
        # Verify token in Redis
        from core.redis_client import get_redis
        redis = get_redis()
        token_data_raw = await redis.get(f"tg_link_token:{link_token}")
        
        if not token_data_raw:
            raise HTTPException(status_code=400, detail="Link token expired or invalid")
        
        import json
        token_data = json.loads(token_data_raw)
        telegram_id = token_data.get("telegram_id")
        telegram_username = token_data.get("telegram_username", "")
        telegram_first_name = token_data.get("telegram_first_name", "")
        telegram_last_name = token_data.get("telegram_last_name", "")
        
        if not telegram_id:
            raise HTTPException(status_code=400, detail="Invalid token data")
        
        # Delete token (one-time use)
        await redis.delete(f"tg_link_token:{link_token}")
        
        # Check if this Telegram ID is already linked to another account
        existing = execute_one("""
            SELECT user_id FROM telegram_user_mapping WHERE telegram_id = %s
        """, (telegram_id,))
        
        if existing and existing.get("user_id") != user_id:
            raise HTTPException(
                status_code=409,
                detail="This Telegram account is already linked to another user"
            )
        
        # Update user with Telegram info
        execute("""
            UPDATE users SET
                telegram_id = %s,
                telegram_username = %s,
                first_name = COALESCE(NULLIF(first_name, ''), %s),
                last_name = COALESCE(NULLIF(last_name, ''), %s),
                auth_provider = CASE 
                    WHEN auth_provider = 'email' THEN 'both'
                    ELSE auth_provider
                END,
                updated_at = NOW()
            WHERE user_id = %s
        """, (telegram_id, telegram_username, telegram_first_name, telegram_last_name, user_id))
        
        # Add to mapping table
        execute("""
            INSERT INTO telegram_user_mapping (telegram_id, user_id, created_at)
            VALUES (%s, %s, NOW())
            ON CONFLICT (telegram_id) DO UPDATE SET user_id = EXCLUDED.user_id
        """, (telegram_id, user_id))
        
        logger.info(f"Successfully linked Telegram {telegram_id} (@{telegram_username}) to user {user_id}")
        
        return {
            "success": True,
            "message": "Telegram account linked successfully",
            "telegram": {
                "id": telegram_id,
                "username": telegram_username
            }
        }
        
    except jwt.PyJWTError:
        raise HTTPException(status_code=401, detail="Invalid or expired token")
    except Exception as e:
        logger.exception(f"Failed to complete Telegram link: {e}")
        raise HTTPException(status_code=500, detail=str(e))
