"""
Telegram Authentication API
============================
Handles authentication via Telegram Login Widget and deep links.
Allows iOS/Android/WebApp users to login with their Telegram account.

Flow:
1. User clicks "Login with Telegram" in app
2. App opens Telegram Login Widget or deep link
3. Telegram returns auth data (id, first_name, username, hash)
4. This API verifies the hash using BOT_TOKEN
5. Returns JWT token linked to user's Telegram account

For existing bot users: instant login (they already have user_id in DB)
For new users: creates account with Telegram credentials
"""
import os
import hmac
import hashlib
import logging
import time
from typing import Optional
from datetime import datetime

from fastapi import APIRouter, HTTPException, Request
from pydantic import BaseModel

import sys
sys.path.insert(0, os.path.dirname(os.path.dirname(os.path.dirname(__file__))))
import db
from webapp.api.auth import create_token

logger = logging.getLogger(__name__)

router = APIRouter(prefix="/auth/telegram", tags=["telegram-auth"])

# Get bot token for hash verification
BOT_TOKEN = os.getenv("TG_BOT_TOKEN") or os.getenv("BOT_TOKEN") or ""


# =============================================================================
# MODELS
# =============================================================================

class TelegramAuthData(BaseModel):
    """Data received from Telegram Login Widget."""
    id: int  # Telegram user ID
    first_name: str
    last_name: Optional[str] = None
    username: Optional[str] = None
    photo_url: Optional[str] = None
    auth_date: int  # Unix timestamp
    hash: str  # HMAC-SHA256 verification hash


class TelegramLinkRequest(BaseModel):
    """Request to link Telegram to existing email account."""
    telegram_data: TelegramAuthData
    current_token: str  # JWT token of logged-in email user


class TelegramDeepLinkRequest(BaseModel):
    """Request from bot-generated deep link."""
    token: str  # One-time token generated by bot
    telegram_id: int


# =============================================================================
# HASH VERIFICATION
# =============================================================================

def verify_telegram_auth(data: TelegramAuthData) -> bool:
    """
    Verify Telegram Login Widget data authenticity.
    
    According to Telegram docs:
    1. Create data-check-string by sorting all fields alphabetically
    2. Generate secret_key = SHA256(BOT_TOKEN)
    3. hash = HMAC-SHA256(secret_key, data-check-string)
    4. Compare with received hash
    """
    if not BOT_TOKEN:
        logger.error("BOT_TOKEN not configured for Telegram auth verification")
        return False
    
    # Check auth_date freshness (max 1 hour old)
    if time.time() - data.auth_date > 3600:
        logger.warning(f"Telegram auth data too old: {data.auth_date}")
        return False
    
    # Build data-check-string (sorted alphabetically, excluding hash)
    data_dict = {
        "id": data.id,
        "first_name": data.first_name,
        "auth_date": data.auth_date,
    }
    if data.last_name:
        data_dict["last_name"] = data.last_name
    if data.username:
        data_dict["username"] = data.username
    if data.photo_url:
        data_dict["photo_url"] = data.photo_url
    
    # Sort and create check string
    check_string = "\n".join(
        f"{k}={v}" for k, v in sorted(data_dict.items())
    )
    
    # Generate secret key from bot token
    secret_key = hashlib.sha256(BOT_TOKEN.encode()).digest()
    
    # Calculate expected hash
    expected_hash = hmac.new(
        secret_key,
        check_string.encode(),
        hashlib.sha256
    ).hexdigest()
    
    # Compare (constant-time)
    return hmac.compare_digest(expected_hash, data.hash)


# =============================================================================
# ENDPOINTS
# =============================================================================

@router.post("/login")
async def telegram_login(data: TelegramAuthData, request: Request):
    """
    Authenticate user via Telegram Login Widget.
    
    For existing bot users: returns JWT token immediately
    For new users: creates account and returns JWT token
    For linked accounts: finds user via telegram_user_mapping
    
    This is the primary way for Telegram bot users to access iOS/Android apps.
    """
    # Verify Telegram data authenticity
    if not verify_telegram_auth(data):
        raise HTTPException(
            status_code=401,
            detail="Invalid Telegram authentication data"
        )
    
    telegram_id = data.id
    
    # Check if user exists in main users table
    from core.db_postgres import execute_one, get_pool
    import psycopg2.extras
    
    # First check: direct telegram_id as user_id (native Telegram users)
    user = execute_one(
        "SELECT user_id, is_allowed, is_banned, email, first_name, auth_provider FROM users WHERE user_id = %s",
        (telegram_id,)
    )
    
    # Second check: linked account via telegram_user_mapping (email users who linked Telegram)
    if not user:
        mapping = execute_one(
            "SELECT user_id FROM telegram_user_mapping WHERE telegram_id = %s",
            (telegram_id,)
        )
        if mapping:
            user = execute_one(
                "SELECT user_id, is_allowed, is_banned, email, first_name, auth_provider FROM users WHERE user_id = %s",
                (mapping["user_id"],)
            )
    
    if user and user.get("is_banned"):
        raise HTTPException(status_code=403, detail="Account is banned")
    
    # Create or update user
    pool = get_pool()
    pg_conn = pool.getconn()
    try:
        with pg_conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
            if user:
                # Update existing user with Telegram info
                cur.execute("""
                    UPDATE users SET
                        telegram_username = %s,
                        first_name = COALESCE(first_name, %s),
                        last_name = COALESCE(last_name, %s),
                        last_login = NOW(),
                        auth_provider = CASE 
                            WHEN email IS NOT NULL THEN 'both'
                            ELSE 'telegram'
                        END
                    WHERE user_id = %s
                    RETURNING user_id, email, first_name, is_allowed, auth_provider
                """, (
                    data.username,
                    data.first_name,
                    data.last_name,
                    telegram_id
                ))
                updated_user = cur.fetchone()
                pg_conn.commit()
                
                user_for_token = dict(updated_user) if updated_user else user
            else:
                # Create new user from Telegram login
                cur.execute("""
                    INSERT INTO users (
                        user_id, first_name, last_name, telegram_username,
                        is_allowed, auth_provider, lang, created_at
                    ) VALUES (%s, %s, %s, %s, 1, 'telegram', 'en', NOW())
                    ON CONFLICT (user_id) DO UPDATE SET
                        telegram_username = EXCLUDED.telegram_username,
                        last_login = NOW()
                    RETURNING user_id, first_name, is_allowed, auth_provider
                """, (
                    telegram_id,
                    data.first_name,
                    data.last_name,
                    data.username
                ))
                new_user = cur.fetchone()
                pg_conn.commit()
                
                user_for_token = dict(new_user) if new_user else {"user_id": telegram_id}
                logger.info(f"Created new user from Telegram login: {telegram_id} (@{data.username})")
    finally:
        pool.putconn(pg_conn)
    
    # Generate JWT token
    is_admin = telegram_id == 511692487  # ADMIN_ID from coin_params
    token, refresh_token = create_token(telegram_id, is_admin=is_admin)
    
    logger.info(f"Telegram login successful: {telegram_id} (@{data.username})")
    
    return {
        "success": True,
        "token": token,
        "refresh_token": refresh_token,
        "user_id": telegram_id,
        "user": {
            "id": telegram_id,
            "user_id": telegram_id,
            "telegram_id": telegram_id,
            "telegram_username": data.username,
            "email": user_for_token.get("email"),
            "name": data.first_name + (f" {data.last_name}" if data.last_name else ""),
            "first_name": data.first_name,
            "last_name": data.last_name,
            "is_admin": is_admin,
            "is_allowed": bool(user_for_token.get("is_allowed", 1)),
            "auth_provider": user_for_token.get("auth_provider", "telegram"),
        }
    }


@router.post("/link")
async def link_telegram_to_email(data: TelegramLinkRequest, request: Request):
    """
    Link Telegram account to existing email account.
    
    Allows email-registered users to add Telegram login option.
    After linking, user can login with either method.
    """
    # Verify current JWT token
    from webapp.api.auth import decode_token
    
    try:
        payload = decode_token(data.current_token)
        current_user_id = int(payload.get("sub"))
    except Exception as e:
        raise HTTPException(status_code=401, detail="Invalid token")
    
    # Verify Telegram data
    if not verify_telegram_auth(data.telegram_data):
        raise HTTPException(status_code=401, detail="Invalid Telegram authentication")
    
    telegram_id = data.telegram_data.id
    
    # Check if Telegram account is already linked to another user
    from core.db_postgres import execute_one, get_pool
    import psycopg2.extras
    
    existing_tg_user = execute_one(
        "SELECT user_id FROM users WHERE user_id = %s AND user_id != %s",
        (telegram_id, current_user_id)
    )
    
    if existing_tg_user:
        raise HTTPException(
            status_code=400,
            detail="This Telegram account is already linked to another user. Please use Telegram login instead."
        )
    
    # Link accounts by merging:
    # - Keep email user's data (they registered first via email)
    # - Add Telegram credentials
    # - If telegram_id differs from current_user_id, we need to migrate data
    
    pool = get_pool()
    pg_conn = pool.getconn()
    try:
        with pg_conn.cursor(cursor_factory=psycopg2.extras.RealDictCursor) as cur:
            # Update email user with Telegram link
            # Note: user_id stays the same (email-generated negative ID)
            # We just add telegram credentials for alternative login
            cur.execute("""
                UPDATE users SET
                    telegram_username = %s,
                    auth_provider = 'both',
                    updated_at = NOW()
                WHERE user_id = %s
                RETURNING user_id, email, first_name, telegram_username
            """, (
                data.telegram_data.username,
                current_user_id
            ))
            linked_user = cur.fetchone()
            
            # Also store the telegram_id mapping for future telegram logins
            # We need a mapping table: telegram_id -> user_id
            cur.execute("""
                CREATE TABLE IF NOT EXISTS telegram_user_mapping (
                    telegram_id BIGINT PRIMARY KEY,
                    user_id BIGINT NOT NULL REFERENCES users(user_id),
                    linked_at TIMESTAMP DEFAULT NOW()
                )
            """)
            
            cur.execute("""
                INSERT INTO telegram_user_mapping (telegram_id, user_id)
                VALUES (%s, %s)
                ON CONFLICT (telegram_id) DO UPDATE SET user_id = EXCLUDED.user_id
            """, (telegram_id, current_user_id))
            
            pg_conn.commit()
    finally:
        pool.putconn(pg_conn)
    
    logger.info(f"Linked Telegram @{data.telegram_data.username} to user {current_user_id}")
    
    return {
        "success": True,
        "message": "Telegram account linked successfully",
        "user": dict(linked_user) if linked_user else None
    }


@router.get("/widget-params")
async def get_telegram_widget_params():
    """
    Get parameters for Telegram Login Widget.
    
    Returns bot username and callback URL for widget configuration.
    Used by WebApp to render Telegram Login button.
    """
    bot_username = os.getenv("BOT_USERNAME", "EnlikoBot")
    callback_url = os.getenv("WEBAPP_URL", "https://enliko.com") + "/auth/telegram/callback"
    
    return {
        "bot_username": bot_username,
        "callback_url": callback_url,
        "request_access": "write"  # Request write access for notifications
    }


@router.post("/deep-link")
async def verify_deep_link(data: TelegramDeepLinkRequest):
    """
    Verify deep link token generated by Telegram bot.
    
    Flow:
    1. User requests login link in bot: /login_app
    2. Bot generates one-time token and sends deep link
    3. App opens link and calls this endpoint
    4. We verify token and return JWT
    
    This is an alternative to Telegram Login Widget for native apps.
    """
    from core.redis_client import get_redis
    
    redis = await get_redis()
    
    # Token key pattern: app_login:{token}
    token_key = f"app_login:{data.token}"
    stored_data = await redis.get(token_key)
    
    if not stored_data:
        raise HTTPException(status_code=401, detail="Invalid or expired login token")
    
    import json
    token_data = json.loads(stored_data)
    
    # Verify telegram_id matches
    if token_data.get("telegram_id") != data.telegram_id:
        raise HTTPException(status_code=401, detail="Token mismatch")
    
    # Delete token (one-time use)
    await redis.delete(token_key)
    
    telegram_id = data.telegram_id
    
    # Get user data
    from core.db_postgres import execute_one
    user = execute_one(
        "SELECT user_id, first_name, email, is_allowed, auth_provider FROM users WHERE user_id = %s",
        (telegram_id,)
    )
    
    if not user:
        raise HTTPException(status_code=404, detail="User not found")
    
    # Generate JWT
    is_admin = telegram_id == 511692487
    token, refresh_token = create_token(telegram_id, is_admin=is_admin)
    
    logger.info(f"Deep link login successful: {telegram_id}")
    
    return {
        "success": True,
        "token": token,
        "refresh_token": refresh_token,
        "user_id": telegram_id,
        "user": {
            "id": telegram_id,
            "user_id": telegram_id,
            "email": user.get("email"),
            "name": user.get("first_name"),
            "is_allowed": bool(user.get("is_allowed", 0)),
            "auth_provider": user.get("auth_provider", "telegram"),
        }
    }
